<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-19T02:24:20.767Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Bean @Autowired 与 JSR-250 @Resource</title>
    <link href="http://example.com/2022/07/19/Spring-Core/Spring-Core-@Resource-%E4%B8%8E-@Autowired/"/>
    <id>http://example.com/2022/07/19/Spring-Core/Spring-Core-@Resource-%E4%B8%8E-@Autowired/</id>
    <published>2022-07-19T01:11:46.000Z</published>
    <updated>2022-07-19T02:24:20.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean-Autowired-与-JSR-250-Resource"><a href="#Spring-Bean-Autowired-与-JSR-250-Resource" class="headerlink" title="Spring Bean @Autowired 与 JSR-250 @Resource"></a>Spring Bean @Autowired 与 JSR-250 @Resource</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>由 Spring 提供的注解，依赖注入的过程由 <code>AutowiredAnnotationBeanPostProcessor</code> 执行。</p><p>通常这一步骤发生在 <code>populateBean</code> 流程之中，使用特定的 <code>InstantiationAwareBeanPostProcessor</code> 进行属性注入</p><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p>由 JSR-250 中提供的注解，依赖注入的过程由 <code>CommonAnnotationBeanPostProcessor</code> 执行。</p><p>通常这一步骤发生在 <code>populateBean</code> 流程之中，使用特定的 <code>InstantiationAwareBeanPostProcessor</code> 进行属性注入</p><ol><li>如果 <code>@Resource</code> 指定了 <code>name</code>，则按照 <code>name</code> 查找 Bean，找到则注入；找不到抛出异常</li><li>如果 <code>@Resource</code> 没有指定 <code>name</code>，通过 Java 反射得到 <code>Field</code> 属性 <code>name</code>，找不到则按照类型匹配</li></ol><blockquote><p>由于显式指定了 <code>@Resource</code> 的 <code>name</code>，因此在找不到的情况下必须抛出异常，这可能是人为的疏漏；如果没有指定 <code>name</code>，那么容器会智能地按照属性名、类型地顺序依次寻找。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">autowireResource</span><span class="params">(BeanFactory factory, LookupElement element, <span class="meta">@Nullable</span> String requestingBeanName)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchBeanDefinitionException &#123;</span><br><span class="line"></span><br><span class="line">    Object resource;</span><br><span class="line">    Set&lt;String&gt; autowiredBeanNames;</span><br><span class="line">    <span class="comment">// 此处的 element.name 以及在构造器中赋值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> element.name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">        <span class="type">AutowireCapableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (AutowireCapableBeanFactory) factory;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> element.getDependencyDescriptor();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.fallbackToDefaultTypeMatch &amp;&amp; element.isDefaultName &amp;&amp; !factory.containsBean(name)) &#123;</span><br><span class="line">            autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">            resource = beanFactory.resolveDependency(descriptor, requestingBeanName, autowiredBeanNames, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (resource == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(element.getLookupType(), <span class="string">&quot;No resolvable resource object&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resource = beanFactory.resolveBeanByName(name, descriptor);</span><br><span class="line">            autowiredBeanNames = Collections.singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        resource = factory.getBean(name, element.lookupType);</span><br><span class="line">        autowiredBeanNames = Collections.singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">        <span class="type">ConfigurableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (ConfigurableBeanFactory) factory;</span><br><span class="line">        <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestingBeanName != <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(autowiredBeanName)) &#123;</span><br><span class="line">                beanFactory.registerDependentBean(autowiredBeanName, requestingBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Bean-Autowired-与-JSR-250-Resource&quot;&gt;&lt;a href=&quot;#Spring-Bean-Autowired-与-JSR-250-Resource&quot; class=&quot;headerlink&quot; title=&quot;Spring Bean </summary>
      
    
    
    
    
    <category term="Spring Bean" scheme="http://example.com/tags/Spring-Bean/"/>
    
  </entry>
  
  <entry>
    <title>Android 笔记</title>
    <link href="http://example.com/2022/07/18/Android/Android-%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/07/18/Android/Android-%E7%AC%94%E8%AE%B0/</id>
    <published>2022-07-18T14:56:44.000Z</published>
    <updated>2022-07-18T14:57:07.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h1><h1 id="Activities"><a href="#Activities" class="headerlink" title="Activities"></a>Activities</h1><h2 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h2><h3 id="创建一个-fragment"><a href="#创建一个-fragment" class="headerlink" title="创建一个 fragment"></a>创建一个 fragment</h3><p>一个 fragment 表示某个 activity 中用户接口的一个模块化部分。一个 fragment 有它自己的生命周期，接受它自己的输入事件，并且你可以在activity 运行时添加或移除 fragment。</p><h4 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h4><p>fragments 需要 AndroidX fragment 库的依赖。为此，你需要添加 Google Maven 仓库到你的项目 build.grade 文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了将 AndroidX Fragment 库包含到你的项目，需要在你的 App 的 build.gradle 文件添加如下依赖：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def fragment_version = &quot;<span class="number">1.3</span>.<span class="number">5</span>&quot;</span><br><span class="line"></span><br><span class="line">    // Java language implementation</span><br><span class="line">    implementation &quot;androidx<span class="selector-class">.fragment</span>:fragment:$fragment_version<span class="string">&quot;</span></span><br><span class="line"><span class="string">    // Kotlin</span></span><br><span class="line"><span class="string">    implementation &quot;</span>androidx.fragment:fragment-ktx:$fragment_version<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="创建一个-fragment-类"><a href="#创建一个-fragment-类" class="headerlink" title="创建一个 fragment 类"></a>创建一个 fragment 类</h4><p>为了创建一个 fragment，需要继承 AndroidX 的 <code>Fragment</code> 类，并覆盖它的方法，类似你创建一个 <code>Activity</code> 类。为了创建一个定义了自己的布局的最小 fragment，需要为基本构造器提供 fragment 的布局资源。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleFragment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_fragment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Fragment 库还提供了更多专业的 fragment 基类：</p><ul><li><p>DialogFragment<br>显示悬浮对话框，使用此类创建一个对话框是一个对于使用 Activity  dialog helper 方法的好的替代方案，因为 fragment 会自动处理对话框的创建和清理。详细信息参考 DialogFragment。</p></li><li><p>PreferenceFragmentCompat<br>显示作为列表的 Preference 对象的层次结构。你可以使用<br>PreferenceFragmentCompat 来为你的 App 创建一个设置屏幕。</p></li></ul><h4 id="添加一个-fragment-到-activity"><a href="#添加一个-fragment-到-activity" class="headerlink" title="添加一个 fragment 到 activity"></a>添加一个 fragment 到 activity</h4><p>通常，你的 fragment 必须嵌入在 AndroidX <code>FragmentActivity</code> 中，用以贡献一部分 UI 到 activity 布局。<code>FragmentActivity</code> 是 <code>AppCompatActivity</code> 基类，因此如果你已经在你的 App 中为 AppCompatActivity 提供了向后兼容性，那么你不必改变你的 activity 基类。</p><p>你可以通过两种方式添加 fragment：</p><ul><li>在 activity 的布局文件中定义片段</li><li>在 activity 布局文件定义 fragment 容器，后面通过程序添加到 activity。</li></ul><p>在任何一种情况下，你都需要添加一个 <code>FragmentContainerView</code>，定义了 fragment 应该放在 activity 试图层次结构中的位置。</p><p>强烈建议：使用 Fragment 作为 fragment 的容器，因为 <code>FragmentContainerView</code> 包含了其他 View Group（如 FrameLayout）没有提供的修复程序。</p><h5 id="通过-XML-添加-fragment"><a href="#通过-XML-添加-fragment" class="headerlink" title="通过 XML 添加 fragment"></a>通过 XML 添加 fragment</h5><p>为了声明将 fragment 添加到你的 activity 布局 XML，你需要添加一个 <code>FragmentContainerView</code> 元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/example_activity.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_container_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.example.ExampleFragment&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>Android:name 指定要实例化的 fragment 类名。当 activity 布局填充时，指定的 fragment 会实例化，当新实例化 fragment 时，onInflate() 会被调用，并且会创建一个 <code>FragmentTransaction</code> 去将 fragment 添加到 <code>FragmentManager</code>。</p><h5 id="程序化添加-fragment"><a href="#程序化添加-fragment" class="headerlink" title="程序化添加 fragment"></a>程序化添加 fragment</h5><p>为了程序化添加 fragment 到 activity，布局应该引入 <code>FragmentContainerView</code> 作为 fragment 容器，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/example_activity.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_container_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>与 XML 方式不同，android:name 属性并未使用，因此不会自动实例化特定 fragment。相反，使用 FragmentTransaction 来实例化 fragment 并将其添加到 activity 的布局中。</p><p>当你的 activity 在运行时，你可以制造 fragment transaction 例如添加、删除或者替换 fragment。在 <code>FragmentActivity</code> 中，你可以获得 <code>FragmentManager</code> 的实例，你可以通过它创建 <code>FragmentTransaction</code>。 在 activity 的 onCreate() 方法中，你可以使用 FragmentTransaction.add() 实例化你的 fragment，传递参数 ViewGroup ID 和 fragment Class，然后提交事务，如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleActivity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">            getSupportFragmentManager().beginTransaction()</span><br><span class="line">                .setReorderingAllowed(<span class="literal">true</span>)</span><br><span class="line">                .add(R.id.fragment_container_view, ExampleFragment.class, <span class="literal">null</span>)</span><br><span class="line">                .commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：当执行一个 FragmentTransaction 时，你应该总是使用 setReorderingAllowed(true)。更多信息参考官网。</p></blockquote><p>在前面的例子中，请注意，只有在 savedInstanceState 为 null 时，才会创建 fragment 事务。这是为了确保仅仅当 activity 第一次创建的时候，fragment 才会添加一次。发生配置更改或者 activity recreate，savedInstanceState 不再为 null，并且不需要再添加一次 fragment，因为 fragment 可以自动从 savedInstanceState 恢复。</p><p>如果你的 fragment 需要一些初始化数据，你可以通过在调用 FragmentTransaction.add() 时提供一个 Bundle，如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleActivity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">            bundle.putInt(<span class="string">&quot;some_int&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            getSupportFragmentManager().beginTransaction()</span><br><span class="line">                .setReorderingAllowed(<span class="literal">true</span>)</span><br><span class="line">                .add(R.id.fragment_container_view, ExampleFragment.class, bundle)</span><br><span class="line">                .commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 fragment 中，你可以通过调用 <code>requireArguments()</code> 来获取参数 Bundle，并且可以使用适合的 getter 方法来获取每个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleFragment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">someInt</span> <span class="operator">=</span> requireArguments().getInt(<span class="string">&quot;some_int&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &#x27;com<span class="selector-class">.squareup</span><span class="selector-class">.okhttp3</span>:okhttp:<span class="number">4.9</span>.<span class="number">0</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;清单文件&quot;&gt;&lt;a href=&quot;#清单文件&quot; class=&quot;headerlink&quot; title=&quot;清单文件&quot;&gt;&lt;/a&gt;清单文件&lt;/h1&gt;&lt;h1 id=&quot;Activities&quot;&gt;&lt;a href=&quot;#Activities&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="Android 笔记" scheme="http://example.com/categories/Android-%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Android 笔记" scheme="http://example.com/tags/Android-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>向 Activity 添加 Fragment</title>
    <link href="http://example.com/2022/07/18/Android/%E5%90%91-Activity-%E6%B7%BB%E5%8A%A0-Fragment/"/>
    <id>http://example.com/2022/07/18/Android/%E5%90%91-Activity-%E6%B7%BB%E5%8A%A0-Fragment/</id>
    <published>2022-07-18T14:32:36.000Z</published>
    <updated>2022-07-18T14:40:50.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="向-Activity-添加-Fragment"><a href="#向-Activity-添加-Fragment" class="headerlink" title="向 Activity 添加 Fragment"></a>向 Activity 添加 Fragment</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>在 Activity 的布局文件内声明片段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.news.ArticleListFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/list&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.news.ArticleReaderFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/viewer&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;fragment&gt;</code> 的 android:name 属性指定要在布局中进行实例化的 Fragment 类。</p><p>创建 activity 布局时，系统会将每个 fragment 实例化，并调用 OnCreateView() 方法，以检索每个片段的布局。系统会返回插入 fragment 后的 View。</p><blockquote><p>注意：每个片段都需要唯一标识符，重启 Activity 时，系统可使用该标识符来恢复片段（您也可以使用该标识符来捕获片段，从而执行某些事务，如将其移除）。可以通过两种方式为片段提供 ID：</p></blockquote><p>为 android:id 属性提供唯一 ID。<br>为 android:tag 属性提供唯一字符串。</p><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>在 activity 运行期间，可以随时将片段添加到 activity 布局中，只需指定 fragment 放入哪个 ViewGroup。</p><p>在 activity 中执行片段事务（如添加、移除或替换片段），必须使用 FragmentTransaction API。</p><p>可以从 FragmentActivity 获取一个FragmentTransaction实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FragmentManager</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> getSupportFragmentManager();</span><br><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">fragmentTransaction</span> <span class="operator">=</span> fragmentManager.beginTransaction();</span><br></pre></td></tr></table></figure><p>然后，使用 add() 方法添加片段，指定要添加的片段以及插入哪个视图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExampleFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleFragment</span>();</span><br><span class="line">fragmentTransaction.add(R.id.fragment_container, fragment);</span><br><span class="line">fragmentTransaction.commit();</span><br></pre></td></tr></table></figure><p>一旦通过 FragmentTransaction 做出了更改，就必须调用 commit() 以使更改生效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;向-Activity-添加-Fragment&quot;&gt;&lt;a href=&quot;#向-Activity-添加-Fragment&quot; class=&quot;headerlink&quot; title=&quot;向 Activity 添加 Fragment&quot;&gt;&lt;/a&gt;向 Activity 添加 Fragme</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>简历</title>
    <link href="http://example.com/2022/07/18/%E7%AE%80%E5%8E%86/"/>
    <id>http://example.com/2022/07/18/%E7%AE%80%E5%8E%86/</id>
    <published>2022-07-18T09:04:36.000Z</published>
    <updated>2022-07-18T09:38:10.766Z</updated>
    
    <content type="html"><![CDATA[<p>知识：</p><p><strong>PHP</strong> <strong>Java</strong> JavaScript HTML CSS <strong>MySQL</strong> <strong>Redis</strong> <strong>Nginx</strong> XML Json Node.js Vue 企业微信自建 企业微信代开发</p><p>云尚作业统计模块</p><p>空中课堂一期大屏统计模块</p><p>实验竞赛统计模块</p><p>腾讯云云点播、对象存储、拓课云、推流直播等服务对接</p><p>2020 年</p><p>负责积分系统；</p><p>负责江苏名师空中课堂教师成长备课模块的数据库设计，发起备课，备课查询，备课详情、备课内容讨论；</p><p>负责江苏名师空中课堂题库模块的题库上传，批量上传，基础教学数据查询；</p><p>负责江苏名师空中课堂资源中心的数据库设计，资源统计，旧数据表迁移等；</p><p>2021年 </p><p>负责江苏名师一期空中课堂大屏接口，统计缓存各维度数据；</p><p>负责企微自建应用云上家长课堂接口；</p><p>负责校园安全系统学生、教师考勤，功能室管理、护导管理功能，后期独立负责维护后续问题，自行搭建维护了一个基于 vue element admin 后台框架的前端项目，便于管理多个学校设备，用于状态查看，设备信息导入等；</p><p>负责企微应用数据打卡设计、接口编写；</p><p>负责企微应用鼓 e 小视频设计、编码;</p><p>负责梁溪名师在线的团队在线校验；</p><p>负责企微应用行走日记的设计、编码；</p><p>负责企微应用学生点名设计、编码；</p><p>负责鼓楼云尚作业的分组功能、作业数据统计功能、自动化批改脚本、学生作业报告、学生错题统计；</p><p>负责企微应用校长信箱设计、编码；</p><p>负责南京师范大学附属中学树人学校、力人初中的招生系统编码；</p><p>负责南京实验幼儿园招生系统；</p><p>负责五塘、宝善、金达、滨江、鼓楼第二实验幼儿园联合招生系统；</p><p>负责鼓楼一中心学校招生系统；</p><p>负责江苏名师空中课堂苏 e 优课的证书方法与缓存，以及后续证书问题的更进；</p><p>负责省机关幼儿园家校助理团的设计、编码 8.1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;知识：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PHP&lt;/strong&gt; &lt;strong&gt;Java&lt;/strong&gt; JavaScript HTML CSS &lt;strong&gt;MySQL&lt;/strong&gt; &lt;strong&gt;Redis&lt;/strong&gt; &lt;strong&gt;Nginx&lt;/st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AES 加密算法</title>
    <link href="http://example.com/2022/07/18/Security/AES-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/07/18/Security/AES-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2022-07-18T04:31:01.000Z</published>
    <updated>2022-07-18T07:48:36.966Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AES-加密算法"><a href="#AES-加密算法" class="headerlink" title="AES 加密算法"></a>AES 加密算法</h1><h2 id="密钥扩展算法"><a href="#密钥扩展算法" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h2><img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/crypto/AES%E5%AF%86%E9%92%A5%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95.drawio.svg"><p>步骤说明：</p><ol><li><p>将密钥 key 按左图的格式，从上到下，从左到右排列，每一列 4 个字节，其中 $k_n$ 表示 1 个字节。</p><blockquote><p>AES 支持密钥长度为 16、24、32 字节，因此可能的列数是 4、6、8</p></blockquote></li><li><p>将每一列的 4 字节从上到下拼接成 32 bit，记为 $W_t$</p></li></ol><blockquote><p>根据密钥长度不同，列数是 4、6、8，因此 $W$ 每一行的长度是 4、6、8</p></blockquote><ol start="3"><li>依次求解 $W_t$，$t$ 的范围是 $[4,43]$（因为已经得到 $[0,3]$ 的值），规则如下：<br>若 $t%4&#x3D;0$，则：<br>$$w[t]&#x3D;w[t-4]⊕g(w[t-1])$$<br>否则：<br>$$w[t]&#x3D;w[t-4]⊕w[t-1]；$$</li></ol><p>g 函数的流程如下：</p><ol><li>将 $W_t$ 循环左移 8 bit（即 1 字节）</li><li>对每个字节做 S 盒置换</li><li>将每个字节与 32 bit 常量$(RC[t&#x2F;4],0,0,0)$进行异或。</li></ol><blockquote><p>$RC$ 是一个一维数组，其所需长度随着 AES 算法密钥的长度变化，</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/luop/p/4334160.html">https://www.cnblogs.com/luop/p/4334160.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AES-加密算法&quot;&gt;&lt;a href=&quot;#AES-加密算法&quot; class=&quot;headerlink&quot; title=&quot;AES 加密算法&quot;&gt;&lt;/a&gt;AES 加密算法&lt;/h1&gt;&lt;h2 id=&quot;密钥扩展算法&quot;&gt;&lt;a href=&quot;#密钥扩展算法&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据文档生成器 screw</title>
    <link href="http://example.com/2022/07/18/Tool/%E6%95%B0%E6%8D%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8-screw/"/>
    <id>http://example.com/2022/07/18/Tool/%E6%95%B0%E6%8D%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8-screw/</id>
    <published>2022-07-18T00:59:38.000Z</published>
    <updated>2022-07-18T01:02:45.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据文档生成器-screw"><a href="#数据文档生成器-screw" class="headerlink" title="数据文档生成器 screw"></a>数据文档生成器 screw</h1><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://github.com/yihr/screw">https://github.com/yihr/screw</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247490367&idx=4&sn=33457d828191fc8717bf90e29d02aa5b&chksm=fbb292c1ccc51bd776a938e2a0aca306363c8ea526362c83a1ed0e7d2522d136a5482f529481&mpshare=1&scene=1&srcid=08075ho06D4MoWdvYI6HZGn2&sharer_sharetime=1596771975108&sharer_shareid=00de337ccf971170dff621a18a7fdda8&key=bbcde1cc2908d6bbca75f9126db113cba3e65212579f0c49d238ed98e48a07667ecea3754647040875027233e7254e03354cbcb58a82ff9c1b4f865e3e510b1759f8f013ff094835f46a0f3809a473f4&ascene=1&uin=MjE2Mjg4NzYz&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=A98TRXcX38ZaCSWR2WlBPus=&pass_ticket=/q1C0cKlfjbdKpTIM9MtXaZTfIIIRMMDAPgn/J8FuXo=">参考文章</a></p><h2 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.smallbun.screw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>screw-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JUnit-生成"><a href="#JUnit-生成" class="headerlink" title="JUnit 生成"></a>JUnit 生成</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBDocument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成文件配置</span></span><br><span class="line">        <span class="type">EngineConfig</span> <span class="variable">engineConfig</span> <span class="operator">=</span> EngineConfig.builder()</span><br><span class="line">            <span class="comment">/* 生成文件路径，本地路径 */</span></span><br><span class="line">            .fileOutputDir(<span class="string">&quot;D:/&quot;</span>)</span><br><span class="line">            <span class="comment">/* 是否打开输出的目录 */</span></span><br><span class="line">            .openOutputDir(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">/* 文件类型 */</span></span><br><span class="line">            .fileType(EngineFileType.HTML)</span><br><span class="line">            <span class="comment">/* 生成模板实现 */</span></span><br><span class="line">            .produceType(EngineTemplateType.freemarker)</span><br><span class="line">            .build();</span><br><span class="line">        <span class="comment">// 生成文档配置（包含以下自定义版本号、描述等配置连接）</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> Configuration.builder()</span><br><span class="line">            .version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;数据库文档&quot;</span>)</span><br><span class="line">            .dataSource(dataSource)</span><br><span class="line">            .engineConfig(engineConfig)</span><br><span class="line">            .produceConfig(getProcessConfig())</span><br><span class="line">            .build();</span><br><span class="line">        <span class="comment">// 执行生成</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DocumentationExecute</span>(config).execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置想要生成的表 + 配置想要忽略的表</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProcessConfig <span class="title function_">getProcessConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessConfig.builder()</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据文档生成器-screw&quot;&gt;&lt;a href=&quot;#数据文档生成器-screw&quot; class=&quot;headerlink&quot; title=&quot;数据文档生成器 screw&quot;&gt;&lt;/a&gt;数据文档生成器 screw&lt;/h1&gt;&lt;h2 id=&quot;相关链接&quot;&gt;&lt;a href=&quot;#相关链接&quot;</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="screw" scheme="http://example.com/tags/screw/"/>
    
  </entry>
  
  <entry>
    <title>Vue 打包部署脚本</title>
    <link href="http://example.com/2022/07/18/Vue/Vue-%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/"/>
    <id>http://example.com/2022/07/18/Vue/Vue-%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</id>
    <published>2022-07-18T00:50:05.000Z</published>
    <updated>2022-07-18T00:51:22.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-打包部署脚本"><a href="#Vue-打包部署脚本" class="headerlink" title="Vue 打包部署脚本"></a>Vue 打包部署脚本</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev scp2 cross-env ora@4.1.1 chalk</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> scpClient = <span class="built_in">require</span>(<span class="string">&#x27;scp2&#x27;</span>);      <span class="comment">// 基于ssh2的纯javascript安全复制程序</span></span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">&#x27;ora&#x27;</span>);             <span class="comment">// 一个优雅的 Node.js 终端加载动画效果</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>);         <span class="comment">// 字体颜色插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spinner = <span class="title function_">ora</span>(<span class="string">&#x27;正在发布到 &#x27;</span> + process.<span class="property">env</span>.<span class="property">NODE_ENV</span> + <span class="string">&#x27; 服务器...\n&#x27;</span>);</span><br><span class="line">spinner.<span class="title function_">start</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_LIST</span> = &#123;</span><br><span class="line">    <span class="string">&#x27;development&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>,            <span class="comment">// ip</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">22</span>,                       <span class="comment">// 端口</span></span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>,               <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span>,                <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/opt/www&#x27;</span>                <span class="comment">// 发布至静态服务器的项目路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;production&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>,      <span class="comment">// ip</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">22</span>,                       <span class="comment">// 端口</span></span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>,               <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span>,                <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/opt/www&#x27;</span>                <span class="comment">// 发布至静态服务器的项目路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是公钥认证在这里创建私钥文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;C:\\Users\\Administrator\\.ssh\\id_rsa&#x27;</span></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFileSync</span>(path).<span class="title function_">toString</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="variable constant_">SERVER_LIST</span>[process.<span class="property">env</span>.<span class="property">NODE_ENV</span>];</span><br><span class="line">scpClient.<span class="title function_">scp</span>(</span><br><span class="line">    <span class="string">&#x27;dist/&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">host</span>: server.<span class="property">hostname</span>,</span><br><span class="line">        <span class="attr">port</span>: server.<span class="property">port</span>,</span><br><span class="line">        <span class="attr">username</span>: server.<span class="property">username</span>,</span><br><span class="line">        <span class="attr">password</span>: server.<span class="property">password</span>,</span><br><span class="line">        privateKey,</span><br><span class="line">        <span class="attr">path</span>: server.<span class="property">path</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        spinner.<span class="title function_">stop</span>();</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">red</span>(<span class="string">&#x27;发布失败.\n&#x27;</span>));</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">green</span>(<span class="string">&#x27;Success! 成功发布到&#x27;</span> + process.<span class="property">env</span>.<span class="property">NODE_ENV</span> + <span class="string">&#x27;服务器! \n&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>package.json</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">  <span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;npm run build &amp;&amp; cross-env NODE_ENV=development node ./deploy&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue-打包部署脚本&quot;&gt;&lt;a href=&quot;#Vue-打包部署脚本&quot; class=&quot;headerlink&quot; title=&quot;Vue 打包部署脚本&quot;&gt;&lt;/a&gt;Vue 打包部署脚本&lt;/h1&gt;&lt;h2 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;head</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Config</title>
    <link href="http://example.com/2022/07/17/Spring-Cloud/Spring-Cloud-Config/"/>
    <id>http://example.com/2022/07/17/Spring-Cloud/Spring-Cloud-Config/</id>
    <published>2022-07-17T13:34:41.000Z</published>
    <updated>2022-07-18T14:24:55.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/">Spring Cloud Config</a></h1><h2 id="1-Quick-Start"><a href="#1-Quick-Start" class="headerlink" title="1. Quick Start"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_quick_start">1. Quick Start</a></h2><blockquote><p>该章是官网的一个体验案例</p></blockquote><p>首先，启动服务，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> spring-cloud-config-server</span><br><span class="line">$ ../mvnw spring-boot:run</span><br></pre></td></tr></table></figure><p>服务是一个 Spring Boot 程序，你也可以从 IDE 运行。</p><p>接下来，试验一下客户端，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/foo/development</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;master&quot;</span>,<span class="string">&quot;propertySources&quot;</span>:[</span><br><span class="line">  &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;https://github.com/scratches/config-repo/foo-development.properties&quot;</span>,<span class="string">&quot;source&quot;</span>:&#123;<span class="string">&quot;bar&quot;</span>:<span class="string">&quot;spam&quot;</span>&#125;&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;https://github.com/scratches/config-repo/foo.properties&quot;</span>,<span class="string">&quot;source&quot;</span>:&#123;<span class="string">&quot;foo&quot;</span>:<span class="string">&quot;bar&quot;</span>&#125;&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure><p>定位属性资源的默认策略是去克隆一个 git 存储库（位于 <code>spring.cloud.config.server.git.uri</code>），并使用它去实例化一个迷你的 <code>SpringApplication</code>。</p><p>HTTP 服务以下格式的资源：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure><h3 id="1-1-Client-Side-Usage"><a href="#1-1-Client-Side-Usage" class="headerlink" title="1.1. Client Side Usage"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_client_side_usage">1.1. Client Side Usage</a></h3><p>为了在应用程序中使用这些功能，你可以将其构建为依赖于 <code>spring-cloud-config-client</code> 的Spring Boot 项目。最简便的方法是使用 Spring Boot 启动器 <code>org.springframework.cloud:spring-cloud-starter-config</code>。对于 maven 用户以及 Gradle 和 Spring CLI 用户的 Spring IO 版本管理属性文件，也有一个父 POM 和 BOM（spring-cloud-starter-parent）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在，你可以创建一个标准的 Spring Boot 应用，就像下面的 HTTP 服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个 HTTP 服务启动的时候，它会从默认的监听于本地端口 8888 配置服务（如果启动了）获取外部配置。如果想修改默认行为，你可以修改 bootstrap.properties 中的配置服务的位置，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.config.uri: http://myconfigserver.com</span><br></pre></td></tr></table></figure><p>默认地，如果应用名称没有设置，则会使用 <code>application</code>。如果要修改默认行为，可以使用 <code>spring.application.name</code> 进行修改：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name:</span> <span class="string">myapp</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>设置属性 <code>$&#123;spring.application.name&#125;</code> 不要使用保留字 <code>application-</code> 作为应用名前缀，防止无法解析出正确的资源。</li></ul></blockquote><h2 id="2-Spring-Cloud-Config-Server"><a href="#2-Spring-Cloud-Config-Server" class="headerlink" title="2. Spring Cloud Config Server"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_spring_cloud_config_server">2. Spring Cloud Config Server</a></h2><p>Spring Cloud Config Server 提供了一个用于外部配置的 HTTP 资源 API。通过使用 <code>@EnableConfigServer</code> 注解，服务就能嵌入到 Spring Boot 应用中。因此，下面的应用就是一个配置服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigServer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(ConfigServer.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和所有的 Spring Boot 应用一样，它默认运行在 8080 端口，但你可以将其切换到约定好的 8888 端口。最简单的方式是，通过配置 <code>spring.config.name=configserver</code> 来启动应用，这同时也设置了默认的存储库类型。</p><blockquote><p>注意，这种配置方式的依据是 Config Server jar 包下的 configserver.yml 文件。实际并没有作用，引用的是 github 上面的样本地址。</p></blockquote><p>另一种方式是使用你自己的 <code>application.properties</code>，如下所示：</p><p><strong>application.properties</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring.cloud.config.server.git.uri:</span> <span class="string">file://$&#123;user.home&#125;/config-repo</span></span><br></pre></td></tr></table></figure><p>在这里，<code>$&#123;user.home&#125;/config-repo</code> 是一个包含 YAML 以及属性文件的 git 存储库。</p><blockquote><p>在 Windows 上，如果 git 存储库是一个绝对驱动的前缀，你需要再加一个 “&#x2F;“，例如：<code>file:///$&#123;user.home&#125;/config-repo)</code></p></blockquote><h3 id="2-1-Environment-Repository"><a href="#2-1-Environment-Repository" class="headerlink" title="2.1. Environment Repository"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_environment_repository">2.1. Environment Repository</a></h3><p>在什么地方存储配置服务的配置数据？管理此行为的策略是 <code>EnvironmentRepository</code>，服务 <code>Environment</code> 对象。这个 <code>Environment</code> 是 Spring Environment 的浅拷贝（包括 <code>propertySources</code> 作为主要功能）。<code>Environment</code> 资源是三个变量的参数化：</p><ul><li><code>&#123;application&#125;</code>，映射到 <code>spring.application.name</code></li><li><code>&#123;profile&#125;</code>，在客户端映射到 <code>spring.profiles.active</code></li><li><code>&#123;label&#125;</code></li></ul><p>存储库的实现通常表现得像一个 Spring Boot 程序，它从 <code>spring.config.name</code> 等于 <code>&#123;application&#125;</code> 以及 <code>spring.profiles.active</code> 等于 <code>&#123;profiles&#125;</code> 中加载配置文件。配置文件的优先规则也与常规的 Spring Boot 程序相同：激活的配置文件优先于默认值，如果又多个配置文件，则选择最后一个（类似向 Map 添加条目）。</p><p>如果存储库是基于文件的，那么服务器将从 application.yml 和 foo.yml 中创建一个 <code>Environment</code>。如果 YAML 文件在它们内部有指向 Spring 配置文件的文档，那么会使用更高的优先级。如果有特定的配置 YAML 文件，那么这些文件也以比默认值更高的优先级而使用。高优先级转换为在 <code>Environment</code> 中提前列出的 <code>PropertySource</code>。</p><h4 id="2-1-1-Git-Backend"><a href="#2-1-1-Git-Backend" class="headerlink" title="2.1.1. Git Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_git_backend">2.1.1. Git Backend</a></h4><p>默认的 <code>EnvironmentRepository</code> 的实现使用 Git 后端，这对于管理升级和物理环境，以及对于跟踪变化非常方便。要更改存储库的位置，你可以在 Config Server（例如在 <code>application.yml</code> 中）中设置 <code>spring.cloud.config.server.git.uri</code> 配置属性。如果你用一个 <code>file:</code> 前缀进行设置，则应从本地存储库工作，以便于你可以在没有服务器的情况下快速启动。但是，在这种情况下，服务直接在本地存储库上操作而无需克隆（无论是否是裸仓库都无关紧要，因为 Config Server 永远不会更改 “remote” 存储库）。为了扩展 Config Server 并使其高度可用，你需要将所有服务实例指向相同的存储库，因此只有共享文件系统才能起作用。甚至在这种情况下，最好将 <code>ssh:</code> 协议用于共享文件系统存储库，以便于服务可以克隆它，并将本地工作副本作为缓存。</p><h5 id="Skipping-SSL-Certificate-Validation"><a href="#Skipping-SSL-Certificate-Validation" class="headerlink" title="Skipping SSL Certificate Validation"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_skipping_ssl_certificate_validation">Skipping SSL Certificate Validation</a></h5><p>通过将 <code>git.skipSslValidation</code> 属性设置为 <code>true</code>（默认为 <code>false</code>），可以禁用配置服务器对 Git 服务器的 SSSL 证书校验：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://example.com/my/repo</span></span><br><span class="line">          <span class="attr">skipSslValidation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h5 id="Setting-HTTP-Connection-Timeout"><a href="#Setting-HTTP-Connection-Timeout" class="headerlink" title="Setting HTTP Connection Timeout"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_setting_http_connection_timeout">Setting HTTP Connection Timeout</a></h5><h4 id="2-1-3-File-System-Backend"><a href="#2-1-3-File-System-Backend" class="headerlink" title="2.1.3. File System Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_file_system_backend">2.1.3. File System Backend</a></h4><p>Config Server 中拥有一个 <code>native</code> profile，该配置不使用 Git，而是从本地类路径或者文件系加载配置文件。为了使用本地配置，以 <code>spring.profiles.active=native</code> 启动 Config Server。</p><p>搜索路径可以包含占位符 <code>&#123;application&#125;</code>, <code>&#123;profile&#125;</code>, <code>&#123;label&#125;</code>。通过这种方式，你可以在路径中分离目录并选择一个对你有意义的策略。</p><p>如果你没有在搜索路径中使用占位符，存储库还会将 <code>&#123;label&#125;</code> 参数追加到存储路径末尾，因此属性文件会从每个搜索路径，以及有一个 label 后缀的子目录去加载。因此，没有占位符的默认行为与在搜索路径末尾添加 <code>/&#123;label&#125;/</code> 相同。举个例子，<code>file:/tmp/config</code> 与 <code>file:/tmp/config,file:/tmp/config/&#123;label&#125;</code> 相同。这个行为可以通过设置 <code>spring.cloud.config.server.native.addLabelLocations=false</code> 从而禁用。</p><blockquote><ul><li>默认添加 label 后缀的行为很单纯，例如，你设置了 <code>spring.cloud.config.server.native.search-locations=file:///f:/profiles/application</code>，同时 label 参数为 dev，那么还会搜索的路径就是 <code>file:///f:/profiles/applicationdev</code>，并不会帮你自动添加路径分隔符 <code>/</code>，至少在 2.2.8.RELEASE 测试是如此。</li></ul></blockquote><h4 id="2-1-6-Sharing-Configuration-With-All-Applications"><a href="#2-1-6-Sharing-Configuration-With-All-Applications" class="headerlink" title="2.1.6. Sharing Configuration With All Applications"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_sharing_configuration_with_all_applications">2.1.6. Sharing Configuration With All Applications</a></h4><h5 id="2-1-6-1-File-Based-Repositories"><a href="#2-1-6-1-File-Based-Repositories" class="headerlink" title="2.1.6.1. File Based Repositories"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#spring-cloud-config-server-file-based-repositories">2.1.6.1. File Based Repositories</a></h5><p>使用基于文件的存储库，在所有客户端应用之间共享文件名为 <code>application*</code> 的资源（<code>application.properties</code>, <code>application.yml</code>, <code>application-*.properties</code> 等）。你可以使用具有这些文件名的资源来进行全局默认配置，并且根据需要让它们被应用特定的文件覆盖。</p><p>属性覆盖功能也可以用于设置全局默认，应用程序允许在本地覆盖它们。</p><blockquote><p>使用 native 配置文件（本地文件系统后端），你应该使用不属于服务自己的配置的指定搜索路径。否则，位于默认搜索路径中的 <code>application*</code> 资源会被移除，因为它们是服务的一部分。</p></blockquote><h4 id="2-1-7-JDBC-Backend"><a href="#2-1-7-JDBC-Backend" class="headerlink" title="2.1.7. JDBC Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_jdbc_backend">2.1.7. JDBC Backend</a></h4><p>Spring Cloud Config 服务支持 JDBC 作为配置属性的后端。你可以通过添加 <code>spring-jdbc</code> 到类路径，并使用 <code>jdbc</code> 配置，或者添加 <code>JdbcEnvironmentRepository</code> 该 bean 来启用此功能。</p><p>你可以通过设置 <code>spring.cloud.config.server.jdbc.enabled=false</code> 来禁用 <code>JdbcEnvironmentRepository</code> 的自动配置。</p><blockquote><p>至少 Spring Cloud Config 2.2.8.RELEASE 开始支持 enabled 属性</p></blockquote><p>数据库需要有一个名为 <code>PROPERTIES</code> 的表，列为 <code>APPLICATION</code>, <code>PROFILE</code>, <code>LABEL</code>, <code>KEY</code>, <code>VALUE</code>。所有的字段都是 Java 的 String 类型，因此你可以定义为 <code>VARCHAR</code>。属性值表现与它们来自 Spring Boot 属性文件 <code>&#123;application&#125;-&#123;profile&#125;.properties</code> 相同，包括所有的编码与解码，这些稍后会进行处理（即不会直接再存储库实现中）。</p><blockquote><p>默认的 SQL 为 <code>SELECT KEY, VALUE from PROPERTIES where APPLICATION=? and PROFILE=? and LABEL=?</code>，但这对于 MySQL 并不管用，因为 KEY 为关键字，应当被反引号包裹，否则在执行过程中报错。</p></blockquote><h4 id="2-1-8-Redis-Backend"><a href="#2-1-8-Redis-Backend" class="headerlink" title="2.1.8. Redis Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_redis_backend">2.1.8. Redis Backend</a></h4><h4 id="2-1-11-Composite-Environment-Repositories"><a href="#2-1-11-Composite-Environment-Repositories" class="headerlink" title="2.1.11 Composite Environment Repositories"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#composite-environment-repositories">2.1.11 Composite Environment Repositories</a></h4><p>从多个环境存储库提取配置数据。</p><h3 id="2-2-Health-Indicator"><a href="#2-2-Health-Indicator" class="headerlink" title="2.2.  Health Indicator"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_health_indicator">2.2.  Health Indicator</a></h3><p>配置服务器附带一个健康指示器，用于检查配置的 <code>EnvironmentRepository</code> 是否正常工作。默认地，它会请求 <code>EnvironmentRepository</code> 一个名为 <code>app</code> 的应用，<code>default</code> 的配置，由 <code>EnvironmentRepository</code> 实现提供的默认标签。</p><p>通过 <code>health.config.enabled=false</code>，你可以禁用健康指示器。</p><h3 id="2-3-Security"><a href="#2-3-Security" class="headerlink" title="2.3. Security"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_security">2.3. Security</a></h3><p>你可以以任何对你有意义的方法保护 Config Server（从物理网络安全到 OAuth2 持票人令牌），Spring Security 和 Spring Boot 提供了许多安全性的功能。</p><p>为了使用默认的 Spring Boot 配置 HTTP Basic 安全，需要包含 Spring Security 到类路径。默认具有一个名为 <code>user</code> 的用户名和随机生成的密码。实践中，随机密码并没有太大用处，推荐配置密码并加密。</p><blockquote><ul><li>需要包含 <code>spring-boot-starter-security</code> 依赖，以使用 Spring 的自动配置化的 HTTP Basic 安全</li><li>通过设置 <code>spring.security.user.password</code> 配置密码</li><li>客户端注意设置用户名和密码</li></ul></blockquote><h3 id="2-4-Encryption-and-Decryption"><a href="#2-4-Encryption-and-Decryption" class="headerlink" title="2.4. Encryption and Decryption"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_encryption_and_decryption">2.4. Encryption and Decryption</a></h3><blockquote><p>为了使用加密和解密功能，旧版本 JDK 需要下载完全的 <a href="https://www.oracle.com/java/technologies/javase-jce-all-downloads.html">JCD</a></p></blockquote><p>如果远程属性资源包含加密内容（以 <code>&#123;cipher&#125;</code> 开头），则先解密再通过 HTTP 发送。该设置的优点是：当属性值 “静止” 时，不需要以纯文本方式展示。如果值无法被解密，将会从属性源中删除它，并添加一个额外的有相同键的属性，但是具有 <code>invalid</code> 前缀，值意味着不适用。这主要是为了加密文本用作密码，有可能意外泄漏。</p><h3 id="2-5-Key-Management"><a href="#2-5-Key-Management" class="headerlink" title="2.5. Key Management"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_key_management">2.5. Key Management</a></h3><p>Config Server 可以使用对称加密或者非对称加密（RSA 密钥对）。选择不对称加密在安全性方面更优越，但使用对称密钥通常更方便，因为它是在 <code>bootstrap.properties</code> 中配置的单个属性值。</p><p>要配置对称密钥，你需要设置 <code>encryt.key</code> 为密钥字符串（或者使用 <code>ENCRYPT_KEY</code> 环境变量，可以脱离纯文本配置文件）。</p><h3 id="2-6-Creating-a-Key-Store-for-Testing"><a href="#2-6-Creating-a-Key-Store-for-Testing" class="headerlink" title="2.6. Creating a Key Store for Testing"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_creating_a_key_store_for_testing">2.6. Creating a Key Store for Testing</a></h3><p>使用 JDK 自带的 <code>keytool</code> 工具创建密钥库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ keytool -genkeypair -<span class="built_in">alias</span> mytestkey -keyalg RSA \</span><br><span class="line">  -dname <span class="string">&quot;CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US&quot;</span> \</span><br><span class="line">  -keypass changeme -keystore server.jks -storepass letmein</span><br></pre></td></tr></table></figure><p>将生成的 <code>server.jks</code> 文件放到类路径下，然后在 <code>bootstrap.yml</code> 进行配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">keyStore:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:/server.jks</span> <span class="comment"># keystore 文件存储路径</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">letmein</span> <span class="comment"># storepass 密钥仓库</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">mytestkey</span> <span class="comment"># 密钥对别名</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">changeme</span> <span class="comment"># keypass 用来保护所生成密钥对中的私钥</span></span><br></pre></td></tr></table></figure><h3 id="2-7-Using-Multiple-Keys-and-Key-Rotation"><a href="#2-7-Using-Multiple-Keys-and-Key-Rotation" class="headerlink" title="2.7. Using Multiple Keys and Key Rotation"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_using_multiple_keys_and_key_rotation">2.7. Using Multiple Keys and Key Rotation</a></h3><h3 id="2-8-Serving-Encrypted-Properties"><a href="#2-8-Serving-Encrypted-Properties" class="headerlink" title="2.8. Serving Encrypted Properties"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_serving_encrypted_properties">2.8. Serving Encrypted Properties</a></h3><p>有时候，你往客户端自行解密配置，而不是在配置中心解密完毕再传送过来。在这种情况下，如果你提供了 <code>encrypt.*</code> 相关配置来定位 key，你还是可以具有 <code>/encrypt</code> 和 <code>/decrypt</code> 端点，但是你需要在 <code>boostrap.[yml|properties]</code> 设置 <code>spring.cloud.config.server.encrypt.enabled=false</code> 来显式关闭传出属性的解密功能。如果你不关心端点，那么如果你没有配置 key 或者 enabled 标志，就能起作用了。</p><h2 id="3-Serving-Alternative-Formats"><a href="#3-Serving-Alternative-Formats" class="headerlink" title="3. Serving Alternative Formats"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_serving_alternative_formats">3. Serving Alternative Formats</a></h2><p>来自环境端点的默认 JSON 格式是完美被 Spring 应用消费的，因为它直接映射到 <code>Environment</code> 抽象上。如果你愿意，你也可以通过增加一个后缀（”.yml”, “.yaml” 或者 “.properties”）以 YAML 或者 Java 属性消费相同的数据。这对于那些不关心 JSON 端点的结构，或者额外元数据的应用来消费是非常有用的（例如，未使用 Spring 的应用可能会受益于此方法的简单性）。</p><h2 id="4-Serving-Plain-Text"><a href="#4-Serving-Plain-Text" class="headerlink" title="4. Serving Plain Text"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_serving_plain_text">4. Serving Plain Text</a></h2><p>不使用 <code>Environment</code> 抽象，你的应用可能需要对其环境量身定制的通用普通文本配置文件。Config Server 通过一个位于 <code>/&#123;application&#125;/&#123;profile&#125;/&#123;label&#125;/&#123;path&#125;</code> 的额外端点提供这些，其中，<code>application</code>，<code>profile</code>，<code>label</code> 与常规的环境端点有相同含义，但是 <code>path</code> 是一个文件名的路径（例如 log.xml）。此端点的源文件以与环境端点相同的方式定位。相同的搜索路径被用于 properties 和 YAML 文件。但是，仅返回第一个被匹配的资源，而不是聚合所有资源。</p><p>在资源被定位之后，以常规格式的占位符（<code>$&#123;...&#125;</code>）会被使用提供的 application name，profile，label 解析。以这种方式，资源端点与环境端点紧密集成。</p><h2 id="5-Embedding-the-Config-Server"><a href="#5-Embedding-the-Config-Server" class="headerlink" title="5. Embedding the Config Server"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_embedding_the_config_server">5. Embedding the Config Server</a></h2><p>配置服务最好以独立应用运行。但是，如果你需要，你也可以将其嵌入到另一个应用中。使用 <code>@EnableConfigServer</code> 注解，一个可选的属性 <code>spring.cloud.config.server.bootstrap</code> 在这种情况下是有用的。这是一个标记，指示该服务是否应该从它自己的远程存储库配置自己。默认地，该标记是关闭的，因为它可以延迟启动。但是，当嵌入另一个应用中时，将与任何其他应用程序以一样的方式启动是有意义的。将 <code>spring.cloud.config.server.bootstrap</code> 设置为 <code>true</code> 时，还必须使用符合环境存储库配置。</p><h2 id="6-Push-Notifications-and-Spring-Cloud-Bus"><a href="#6-Push-Notifications-and-Spring-Cloud-Bus" class="headerlink" title="6. Push Notifications and Spring Cloud Bus"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_push_notifications_and_spring_cloud_bus">6. Push Notifications and Spring Cloud Bus</a></h2><p>许多源代码存储库提供者（如 Github，Gitlab，Gitea, Gitee, Gogs, 或者 Bitbucket）通过 webhook 通知你存储库中的更改。你可以通过提供者的用户接口以一个 URL 和一组你感兴趣的事件配置 webhook。如果你添加了 <code>spring-cloud-config-monitor</code> 依赖，并且在你的配置中心激活了 Spring Cloud Bus，那么 <code>/monitor</code> 端点会被启用。</p><p>当 webhook 被激活时，配置服务会针对它认为可能已经更改的应用程序发送 <code>RefreshRemoteApplicationEvent</code> 。变更检测是策略化的。但是，默认地，它会寻找与应用程序名称匹配的文件中地变更。</p><h2 id="7-Spring-Cloud-Config-Client"><a href="#7-Spring-Cloud-Config-Client" class="headerlink" title="7. Spring Cloud Config Client"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_spring_cloud_config_client">7. Spring Cloud Config Client</a></h2><p>Spring Boot 应用可以立即使用 Spring Config 服务。</p><h3 id="7-1-Config-First-Bootstrap"><a href="#7-1-Config-First-Bootstrap" class="headerlink" title="7.1. Config First Bootstrap"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#config-first-bootstrap">7.1. Config First Bootstrap</a></h3><p>类路径上拥有 Spring Cloud Config Client 的应用程序，默认的行为是：当配置客户端启动时，它会绑定到 Config Server（通过 <code>spring.cloud.config.uri</code> 引导配置属性），并使用远程属性源初始化 Spring 的 <code>Environment</code>。</p><p>此行为的最终结果是，所有希望消费 Config Server 的客户端需要一个 <code>bootstrap.yml</code>，其中需要在 <code>spring.cloud.config.uri</code> 中配置好服务地址（默认是 <code>http://localhost:8888</code>）。</p><h3 id="7-2-Discovery-First-Bootstrap"><a href="#7-2-Discovery-First-Bootstrap" class="headerlink" title="7.2. Discovery First Bootstrap"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#discovery-first-bootstrap">7.2. Discovery First Bootstrap</a></h3><h3 id="7-3-Config-Client-Fail-Fast"><a href="#7-3-Config-Client-Fail-Fast" class="headerlink" title="7.3. Config Client Fail Fast"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#config-client-fail-fast">7.3. Config Client Fail Fast</a></h3><h3 id="7-4-Config-Client-Retry"><a href="#7-4-Config-Client-Retry" class="headerlink" title="7.4. Config Client Retry"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#config-client-retry">7.4. Config Client Retry</a></h3><h3 id="7-5-Locating-Remote-Configuration-Resources"><a href="#7-5-Locating-Remote-Configuration-Resources" class="headerlink" title="7.5. Locating Remote Configuration Resources"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_locating_remote_configuration_resources">7.5. Locating Remote Configuration Resources</a></h3><p>Config Service 从 <code>/&#123;application&#125;/&#123;profile&#125;/&#123;label&#125;</code> 供应属性源，在客户端应用中<strong>默认</strong>的绑定如下：</p><ul><li>“application”&#x3D;<code>$&#123;spring.application.name&#125;</code></li><li>“profile”&#x3D;<code>$&#123;spring.profiles.active&#125;</code></li><li>“label”&#x3D;”master”</li></ul><p>你可以通过设置 <code>spring.cloud.config.*</code> 来覆盖它们（此处 <code>*</code> 表示 <code>name</code>, <code>profile</code>, <code>label</code>）。</p><p><code>label</code> 对于回滚到之前的配置版本比较有用，使用默认的 Config Server 实现，它可以是 git label，分支名，commit ID。</p><p><code>label</code> 也可以用逗号分隔的列表表示，在这种情况下，列表中的项目会逐个尝试，直至成功（即只有一个有效）。当工作在功能分支上时，此行为可能比较有用，例如，你可能希望将 <code>label</code> 与你的分支对齐，但使其可选，在这种情况下，你可以使用 <code>spring.cloud.config.label=myfeature,develop</code>。</p><h3 id="7-6-Specifying-Multiple-Urls-for-the-Config-Server"><a href="#7-6-Specifying-Multiple-Urls-for-the-Config-Server" class="headerlink" title="7.6. Specifying Multiple Urls for the Config Server"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_specifying_multiple_urls_for_the_config_server">7.6. Specifying Multiple Urls for the Config Server</a></h3><h3 id="7-7-Configuring-Timeouts"><a href="#7-7-Configuring-Timeouts" class="headerlink" title="7.7. Configuring Timeouts"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_configuring_timeouts">7.7. Configuring Timeouts</a></h3><p>配置超时阈值：</p><ul><li>读取超时：<code>spring.cloud.config.request-read-timeout</code></li><li>连接超时：<code>spring.cloud.config.request-connect-timeout</code></li></ul><h3 id="7-8-Security"><a href="#7-8-Security" class="headerlink" title="7.8. Security"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_security_2">7.8. Security</a></h3><p>如果你使用 HTTP Basic 安全验证，客户端需要知晓密码（如果不是默认的，还需要用户名）。你可以通过配置服务的 URI 指定用户名和密码，或者通过 <code>username</code> 和 <code>password</code> 属性：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">     <span class="attr">uri:</span> <span class="string">https://user:secret@myconfig.mycompany.com</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">     <span class="attr">uri:</span> <span class="string">https://myconfig.mycompany.com</span></span><br><span class="line">     <span class="attr">username:</span> <span class="string">user</span></span><br><span class="line">     <span class="attr">password:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure><blockquote><p><code>spring.cloud.config.username</code> 和 <code>spring.cloud.config.password</code> 会覆盖 URI 里的值</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Cloud-Config&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Config&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Config&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.spring.</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring Cloud" scheme="http://example.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2022/07/16/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/07/16/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-07-16T08:01:03.000Z</published>
    <updated>2022-07-16T09:34:40.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Proxy-模式"><a href="#Proxy-模式" class="headerlink" title="Proxy 模式"></a>Proxy 模式</h2><h3 id="Proxy-模式中的角色"><a href="#Proxy-模式中的角色" class="headerlink" title="Proxy 模式中的角色"></a>Proxy 模式中的角色</h3><p>在 Proxy 模式中一般有以下角色：</p><ul><li>Subject（主体）</li></ul><p>Subject 定义了使 Proxy 和 RealSubject 之间具有一致性的接口。</p><ul><li>Proxy（代理人）</li></ul><p>Proxy 会尽量处理来自外界的请求。当自己不能处理时，才会将工作交给 RealSubject。Proxy 也要实现 Subject 定义的接口。</p><ul><li>RealSubject（实际主体）</li></ul><p>RealSubject 会在 Proxy 无法胜任工作时出场。它也会实现 Subject 接口。</p><p>下面这段示例程序实现了一个 “带有名字的打印机”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPrinterName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getPrinterName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String string)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Printer</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        heavyJob(<span class="string">&quot;正在生成 Printer 示例 (&quot;</span> + name + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrinterName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrinterName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;===&quot;</span>);</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heavyJob</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrinterProxy</span> <span class="keyword">implements</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Printer real;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrinterProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrinterProxy</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrinterName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.real != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.real.setPrinterName(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrinterName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensure();</span><br><span class="line">        real.print(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.real == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.real == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.real = <span class="keyword">new</span> <span class="title class_">Printer</span>(<span class="built_in">this</span>.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Proxy-模式变体"><a href="#Proxy-模式变体" class="headerlink" title="Proxy 模式变体"></a>Proxy 模式变体</h3><ul><li><p>Virtual Proxy（虚拟代理）<br>Virtual Proxy 就是上面呈现的 Proxy 模式。当真正需要 RealSubject 时，才生成和初始化实例。</p></li><li><p>Remote Proxy（远程代理）<br>Remote Proxy 可以让我们不必在意 RealSubject 是否在远程网络上，透明地使用它的功能。Java 的 RMI（Remote Method Invocation：远程方法调用）就相当于 Remote Proxy。</p></li><li><p>Access Proxy<br>Access Proxy 用于限制 RealSubject 的功能访问。例如，这种代理只允许访问特定的方法，当访问其他方法时则报错。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h1&gt;&lt;h2 id=&quot;Proxy-模式&quot;&gt;&lt;a href=&quot;#Proxy-模式&quot; class=&quot;headerlink&quot; title=&quot;P</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 构造 Mapper Proxy 原理</title>
    <link href="http://example.com/2022/07/16/MyBatis/MyBatis-%E6%9E%84%E9%80%A0-Mapper-Proxy-%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/07/16/MyBatis/MyBatis-%E6%9E%84%E9%80%A0-Mapper-Proxy-%E5%8E%9F%E7%90%86/</id>
    <published>2022-07-16T00:10:44.000Z</published>
    <updated>2022-07-16T23:17:23.005Z</updated>
    
    <content type="html"><![CDATA[<p>在 MyBatis 应用中，我们定义的 <code>Mapper</code> 接口，最终都会转换为 JDK 动态代理对象 <code>Proxy</code>。</p><p>假设有 UserMapper.xml：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure><p>在 MyBatis 的框架中，提供了 <code>SqlSession</code> 的默认实现类 <code>DefaultSqlSession</code>，关注其实现方法 <code>getMapper()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultSqlSession.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.getMapper(type, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法 getMapper 内部调用了属性 <code>Configuration</code> 的 getMapper 方法，将代码细节委托给 <code>Configuration</code> 实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Configuration.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Configuration</code> 内部的实现是将 getMapper 的细节委托给 <code>MapperRegistry</code> 实现，顾名思义，Mapper 注册表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperRegistry.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保该类型被识别</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 <code>MapperRegistry</code> 的实现可以知道，其内部维护了一个 <code>knownMappers</code> 结构，用于进行 <code>Mapper</code> 接口到 <code>MapperProxyFactory</code> 的映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><code>MapperProxyFactory</code>，由类名可以知道这是一个批量生产 MapperProxy 的工厂类，关注其如何生产 MapperProxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperProxyFactory.java</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 InvocationHandler</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 JDK 动态代理的方法创建代理类</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，创建了一个 <code>MapperProxy</code>，这是一个由 MyBatis 提供的 <code>InvocationHandler</code> 的实现类，然后将其传递给 <code>Proxy.newProxyInstance</code> 方法创建 Proxy 并返回。</p><blockquote><p>从名字上看，MapperProxyFactory 似乎是生产 MapperProxy 的工厂，但在过程中，MapperProxy 只是扮演了代理类的 Handler 角色，MapperProxyFactory 真正生产的应该是代理类。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 MyBatis 应用中，我们定义的 &lt;code&gt;Mapper&lt;/code&gt; 接口，最终都会转换为 JDK 动态代理对象 &lt;code&gt;Proxy&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;假设有 UserMapper.xml：&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 官方文档翻译笔记</title>
    <link href="http://example.com/2022/07/15/MyBatis/MyBatis-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/07/15/MyBatis/MyBatis-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E7%AC%94%E8%AE%B0/</id>
    <published>2022-07-15T10:08:57.000Z</published>
    <updated>2022-07-15T10:12:41.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><a href="https://mybatis.org/mybatis-3/">MyBatis</a></h1><hr><h2 id="1-Getting-started"><a href="#1-Getting-started" class="headerlink" title="1. Getting started"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Getting_started">1. Getting started</a></h2><h3 id="1-1-Installation"><a href="#1-1-Installation" class="headerlink" title="1.1. Installation"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Installation">1.1. Installation</a></h3><p>进行最基本的 MyBatis 应用开发需要导入的依赖，最新版本可以参考<a href="https://github.com/mybatis/mybatis-3/releases">github</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Building-SqlSessionFactory-from-XML"><a href="#1-2-Building-SqlSessionFactory-from-XML" class="headerlink" title="1.2. Building SqlSessionFactory from XML"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Building_SqlSessionFactory_from_XML">1.2. Building SqlSessionFactory from XML</a></h3><p>从 XML 构建 SqlSessionFactory。所有 mybatis 应用程序围绕 <code>SqlSessionFactory</code> 实例。可以通过 <code>SqlSessionFactoryBuilder</code> 获取到 <code>SqlSessionFactory</code> 实例。<code>SqlSessionFactoryBuilder</code> 可以从以下几个来源进行构建：</p><ul><li>Mybatis configuration xml</li><li>Configuration object</li></ul><p>从 XML 文件构建 <code>SqlSessionFactory</code> 实例，建议使用<strong>类路径资源</strong>，但实际上也可以使用 InputStream。</p><p><strong>mybatis-config.xml</strong> 可以参考<a href="https://mybatis.org/mybatis-3/getting-started.html">官网</a></p><h3 id="1-3-Building-SqlSessionFactory-without-XML"><a href="#1-3-Building-SqlSessionFactory-without-XML" class="headerlink" title="1.3. Building SqlSessionFactory without XML"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Building_SqlSessionFactory_without_XML">1.3. Building SqlSessionFactory without XML</a></h3><p>可以参考官网的案例。但是，并不支持这种做法，因为高级映射仍然需要 XML 的支持。</p><h3 id="1-4-Acquiring-a-SqlSession-from-SqlSessionFactory"><a href="#1-4-Acquiring-a-SqlSession-from-SqlSessionFactory" class="headerlink" title="1.4. Acquiring a SqlSession from SqlSessionFactory"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Acquiring_a_SqlSession_from_SqlSessionFactory">1.4. Acquiring a SqlSession from SqlSessionFactory</a></h3><p>通过以下代码可以创建一个 Session（注意关闭）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure><h3 id="1-5-Exploring-Mapped-SQL-Statements"><a href="#1-5-Exploring-Mapped-SQL-Statements" class="headerlink" title="1.5. Exploring Mapped SQL Statements"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Exploring_Mapped_SQL_Statements">1.5. Exploring Mapped SQL Statements</a></h3><p>语句可以由 XML 或者 Annotation 定义。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述例子，在命名空间 <code>org.mybatis.example.BlogMapper</code> 中，定义了名为 <code>selectBlog</code> 的映射语句，允许你通过完全限定名称 <code>org.mybatis.example.BlogMapper.selectBlog</code> 来调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure><p>这与在完全限定的 Java 类上调用一个方法是非常类似的，这也是如此设计的原因。使用与映射的 select 语句在名称，参数，返回类型相匹配的方法，可以直接映射到与命名空间名称相同的 Mapper 类。这允许你简单地将方法调用在映射器接口上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure><p>第二种方法有很多优势。首先，它不依赖字符串，更安全。其次，如果你的 IDE 由代码补全，可以利用它跳转到你映射的 SQL 语句。</p><p><strong>Namespaces</strong><br>以前版本的 MyBatis 命名空间是可选的，现在强制需要命名空间，具有隔离语句的目的。</p><p>命名空间让接口进行绑定，并且，即使你现在并不认为你会使用，你也应该遵循这种实践，防止你改变想法。一旦使用命名空间，把它放到正确的 Java 包命名空间下能清理你的代码，并且长期内提高 MyBatis 的可用性</p><p>对于简单的语句，可以使用注解方式定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">  Blog <span class="title function_">selectBlog</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不过，对于复杂的语句，建议使用 XML 方式定义，否则显得混乱。</p></blockquote><h2 id="2-Configuration-XML"><a href="#2-Configuration-XML" class="headerlink" title="2. Configuration XML"></a><a href="https://mybatis.org/mybatis-3/configuration.html">2. Configuration XML</a></h2><h3 id="2-1-properties"><a href="#2-1-properties" class="headerlink" title="2.1. properties"></a><a href="https://mybatis.org/mybatis-3/configuration.html#properties">2.1. properties</a></h3><p><code>&lt;properties&gt;</code> 除了支持嵌入内置属性，还支持引入外部 Java 属性文件，只需通过 resource 或者 url 属性设置即可。resource 是以类路径为基础路径的相对路径，url 为标准的路径位置，如 file:&#x2F;&#x2F;&#x2F;。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意点</strong> </p><ul><li>resource 和 url 不可以同时设置，否则抛出异常。</li><li>如果配置了相同的属性，则后面的会覆盖前面的；如果是分散在属性文件和子元素属性中，那么由于属性文件后加载，因此属性文件会覆盖子元素属性。</li><li><code>&lt;properties&gt;</code> 标签必需位于 <code>configuration</code> 子元素第一个</li></ul><p>属性配置完，可以在配置文件中使用属性，以替代需要动态配置的值。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性的来源也可以是由程序传递给 SqlSessionFactoryBuilder.build() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, props);</span><br><span class="line"><span class="comment">// ... or ...</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>.build(reader, environment, props);</span><br></pre></td></tr></table></figure><h3 id="2-2-settings"><a href="#2-2-settings" class="headerlink" title="2.2. settings"></a><a href="https://mybatis.org/mybatis-3/configuration.html#settings">2.2. settings</a></h3><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">有效值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">cacheEnabled</td><td align="left">全局启用或禁用此配置下任何映射器中的任何缓存</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">lazyLoadingEnabled</td><td align="left">全局懒加载。该值可以被 <code>fetchType</code> 取代。</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">aggressiveLazyLoading</td><td align="left">启用后，任何方法调用都会加载对象的延迟属性。否则，每个属性按需加载。具体见 <code>lazyLoadTriggerMethods</code></td><td align="left"></td><td align="left">false (true in ≤3.4.1)</td></tr><tr><td align="left">useColumnLabel</td><td align="left">使用列标签而不是列名。不同的驱动表现不同。</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">mapUnderscoreToCamelCase</td><td align="left">下划线到驼峰转换</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">autoMappingBehavior</td><td align="left">是否自动映射，Spring MyBatis 默认为 PARTIAL，注意。</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">defaultExecutorType</td><td align="left">配置默认的执行器。SIMPLE REUSE BATCH</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">localCacheScope</td><td align="left">本地缓存的作用域</td><td align="left">SESSION | STATEMENT</td><td align="left">SESSION</td></tr><tr><td align="left">logImpl</td><td align="left">指定 MyBatis 应该使用的日志实现。如果未设置，则自动发现。</td><td align="left">SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</td><td align="left">Not set</td></tr></tbody></table><h3 id="2-3-typeAliases"><a href="#2-3-typeAliases" class="headerlink" title="2.3. typeAliases"></a><a href="https://mybatis.org/mybatis-3/configuration.html#typeAliases">2.3. typeAliases</a></h3><p>别名是 Java 类型的短名称，可以简单地减少完全限定类名的冗余输入。支持 <code>&lt;typeAlias&gt;</code> 和 <code>&lt;package&gt;</code> 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定 MyBatis 搜索 bean 的包，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在包中的<strong>所有 bean</strong>，都会使用 bean 的小写非限定类名作为别名。其中，<code>domain.blog.Author</code> 将被注册为 <code>author</code>。特殊地，如果发现 @Alias 注解，则其值将用作别名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有许多内置的 Java 类型的别名。它们都是大小写不敏感的。具体参见类 <code>TypeAliasRegistry</code></p><h3 id="2-4-typeHandlers"><a href="#2-4-typeHandlers" class="headerlink" title="2.4. typeHandlers"></a><a href="https://mybatis.org/mybatis-3/configuration.html#typeHandlers">2.4. typeHandlers</a></h3><p>typeHandler 用于两个地方：</p><ul><li>当 MyBatis 在 PreparedStatement 设置参数时。参见 <code>DefaultParameterHandler</code></li><li>从 ResultSet 检索值。参见 <code>DefaultResultSetHandler</code></li></ul><blockquote><p>自从  3.4.5, MyBatis 默认支持 JSR-310 (Date and Time API)</p></blockquote><p>在 MyBatis 中，存在一个 <code>TypeHandlerRegistry</code> 组件，其维护了一个 Map 结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>该 Map 的 key 是 <code>java.lang.reflect.Type</code> 类型对象，value 又是一个 Map（称为 sub map），通常用于传入一个 Class 对象，得到 Jdbc 类型支持的类型处理器，sub map 通常还会存储一个 key 为 null 的键值对，用于匹配默认的处理器。</p><blockquote><p>typeHandlers 几乎很少自己定义扩展，但少部分情况还是比较有效的，例如：不涉及查询的一对多关系、setString 的乱码问题。</p></blockquote><h3 id="2-5-Handling-Enums"><a href="#2-5-Handling-Enums" class="headerlink" title="2.5. Handling Enums"></a><a href="https://mybatis.org/mybatis-3/configuration.html#Handling_Enums">2.5. Handling Enums</a></h3><h3 id="2-6-objectFactory"><a href="#2-6-objectFactory" class="headerlink" title="2.6. objectFactory"></a><a href="https://mybatis.org/mybatis-3/configuration.html#objectFactory">2.6. objectFactory</a></h3><p>使用 ObjectFactory 进行创建结果对象的新实例。不仅支持无参构造器的创建，也支持有参构造器创建。</p><h3 id="2-7-plugins"><a href="#2-7-plugins" class="headerlink" title="2.7. plugins"></a><a href="https://mybatis.org/mybatis-3/configuration.html#plugins">2.7. plugins</a></h3><h3 id="2-8-environments"><a href="#2-8-environments" class="headerlink" title="2.8. environments"></a><a href="https://mybatis.org/mybatis-3/configuration.html#environments">2.8. environments</a></h3><p>MyBatis 可以配置多个环境。这有助于你以任何原因将 SQL 映射到不同的数据库。例如，你可能对于开发，测试和生产环境由不同的配置。或者，你可能有多个表结构相同的生产数据库，并且你希望为两者使用相同的 SQL 映射。</p><p><strong>注意</strong> 尽管你可以配置多个环境，但是你只可以为每个 SqlSessionFactory 选择一个。因此，如果要连接到多个数据库，则需要为每个数据库创建一个 SqlSessionFactory。</p><ul><li><strong>每个数据库一个 SqlSessionFactory 实例</strong></li></ul><p>传递给 build() 方法参数 environment 可以指定环境，否则使用 default 环境。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment, properties);</span><br></pre></td></tr></table></figure><p><strong>transactionManager</strong></p><p>MyBatis 包含了两种事务管理器，JDBC | MANAGED</p><p><strong>dataSource</strong></p><p>dataSource 元素使用标准 JDBC DataSource 接口配置 JDBC Connection 对象。</p><p>大多数 MyBatis 应用程序将根据示例中配置 dataSource。但是，它不是必需的。但是，要促进懒加载，数据源是需要的。</p><p>有三种内置的数据源类型，UNPOOLED | POOLED | JNDI</p><p><strong>UNPOOLED</strong> 每次请求时，数据源都是简单地打开和关闭一个链接。虽然它有点慢，但是对于不需要立即可用连接地简单应用来说，是个不错地选择。不同的数据库也不同，因此对于一些池化不太重要的数据库，该配置会是比较理想的。UNPOOLED 数据源具有以下属性需要配置：</p><ul><li><code>driver</code> </li><li><code>url</code></li><li><code>username</code></li><li><code>password</code></li><li><code>defaultTransactionIsolationLevel</code> 连接的默认事务隔离级别</li><li><code>defaultNetworkTimeout</code> 默认网络超时值，以等待数据库操作完成，单位毫秒</li></ul><p><strong>POOLED</strong> DataSource 池化 JDBC Connection 对象，以避免创建新连接实例所需要的初始化和认证时间。这是一种当前 web 应用中流行的方式，可以获得最快的响应。</p><p>除了上面的（UNPOOLED）属性之外，还有许多属性可用于配置 POOLED 数据源：</p><ul><li><code>poolMaximumActiveConnections</code></li><li><code>poolMaximumIdleConnections</code></li><li><code>poolMaximumCheckoutTime</code></li><li><code>poolTimeToWait</code></li><li><code>poolMaximumLocalBadConnectionTolerance</code></li><li><code>poolPingQuery</code> ping 查询被发送到数据库以验证连接处于良好的工作状态，并且已准备好接受请求。默认值：”NO PING QUERY SET”，这回引起大多数数据库驱动以错误信息产生失败。</li><li><code>poolPingEnabled</code> 开启或禁用 ping 查询。如果开启，你必须用一个有效的 SQL 语句（最好很快）设置 <code>poolPingQuery</code> 属性。默认：false</li><li><code>poolPingConnectionsNotUsedFor</code></li></ul><p><strong>JNDI</strong> 此 DataSource 的实现旨在与容器（如 EJB 或者应用服务器）一起使用，该数据源可以配置内部或外部数据源，并且在 JNDI 上下文中对其进行引用。该数据源配置只需要两个属性：</p><ul><li>initial_context</li><li>data_source</li></ul><h3 id="2-9-databaseIdProvider"><a href="#2-9-databaseIdProvider" class="headerlink" title="2.9. databaseIdProvider"></a><a href="https://mybatis.org/mybatis-3/configuration.html#databaseIdProvider">2.9. databaseIdProvider</a></h3><h3 id="2-10-mappers"><a href="#2-10-mappers" class="headerlink" title="2.10. mappers"></a><a href="https://mybatis.org/mybatis-3/configuration.html#mappers">2.10. mappers</a></h3><p>定义映射的 SQL 语句，首先，我们需要告诉 MyBatis 在哪里找到他们，你可以使用：</p><ul><li>类路径相对资源引用</li><li>完全限定 url 引用，包括 <code>file:///</code></li><li>类名</li><li>包名</li></ul><h4 id="方式1-类路径相对资源引用"><a href="#方式1-类路径相对资源引用" class="headerlink" title="方式1 类路径相对资源引用"></a>方式1 类路径相对资源引用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方式2-完全限定-url-引用"><a href="#方式2-完全限定-url-引用" class="headerlink" title="方式2 完全限定 url 引用"></a>方式2 完全限定 url 引用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方式3-类名"><a href="#方式3-类名" class="headerlink" title="方式3 类名"></a>方式3 类名</h4><p>注册的配置结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注册源码分析</strong></p><p>依靠组件 <code>MapperRegistry</code> 进行注册。不需要尝试配置两个一样的类，否则你会得到异常。</p><p>依靠 <code>MapperAnnotationBuilder</code> 解析注解。注解解析部分，通过反射 Class.getMethod() 获取到接口所有的方法。</p><p>MapperAnnotationBuilder 会委派内部的 MapperBuilderAssistant 进行语句添加，还会缓存到 MapperBuilderAssistant  中</p><h4 id="方式4-包名"><a href="#方式4-包名" class="headerlink" title="方式4 包名"></a>方式4 包名</h4><p>注册该包下所有接口为 mapper</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>你在指定非 package 的配置时，只能配置 url，name，resource 之一的属性，否则你会得到异常。</p><h2 id="3-Mapper-XML-Files"><a href="#3-Mapper-XML-Files" class="headerlink" title="3. Mapper XML Files"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#">3. Mapper XML Files</a></h2><h3 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1. select"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#select">3.1. select</a></h3><p>对于形如 <code>#&#123;id&#125;</code> 这样的标记，这告诉 MyBatis 需要创建一个 PreparedStatement 的参数。使用 JDBC，这样的参数会在 SQL 中识别为 “?”，传递给 PreparedStatement。</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">在该 namesapce 下的唯一标识符，可以用于引用该语句，即 Statement ID。</td></tr><tr><td align="left">parameterType</td><td align="left">将传递到此语句的参数的完全限定类名或别名。可选，因为 MyBatis 可以通过传递给语句的实际参数得到 <code>TypeHandler</code></td></tr><tr><td align="left">resultType</td><td align="left">从此语句返回的预期类型的完全限定类名或别名。在集合的情况下，这应该是集合包含的类型，而不是集合类型。使用 <code>resultType</code> 或者 <code>resultMap</code>，不可以都用。</td></tr><tr><td align="left">resultMap</td><td align="left">外部 <code>resultMap</code> 的引用。使用 <code>resultMap</code> 或者 <code>resultType</code>，不可以都用。</td></tr><tr><td align="left">flushCache</td><td align="left">设置为 true 将导致当调用此语句时会刷新 Local 和 2 级缓存。对于 select 默认是 false</td></tr><tr><td align="left">useCache</td><td align="left">设置为 true 将导致该语句的结果缓存在 2 级缓存。对于 select 语句默认为: <code>true</code></td></tr><tr><td align="left">timeout</td><td align="left">驱动等待数据库返回数据，在抛出异常之前的超时时间，默认 <code>unset</code>（驱动决定）</td></tr><tr><td align="left">fetchSize</td><td align="left"></td></tr><tr><td align="left">statementType</td><td align="left">可选值：STATEMENT, PREPARED, CALLABLE。默认值：PREPARED</td></tr><tr><td align="left">resultSetType</td><td align="left"></td></tr><tr><td align="left">databaseId</td><td align="left"></td></tr><tr><td align="left">resultOrdered</td><td align="left"></td></tr><tr><td align="left">resultSets</td><td align="left"></td></tr></tbody></table><h3 id="3-2-insert-update-and-delete"><a href="#3-2-insert-update-and-delete" class="headerlink" title="3.2. insert, update and delete"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#insert.2C_update_and_delete">3.2. insert, update and delete</a></h3><p>MyBatis 加载 Mapper 的时候会将读取到的语句信息都存储到 Configuration 的属性 <code>mappedStatements</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, MappedStatement&gt; mappedStatements;</span><br></pre></td></tr></table></figure><p>其中，<code>MappedStatement</code> 又能够获取 <code>BoundSql</code></p><h3 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h3><ul><li>collection</li></ul><p>支持分步查询和关联查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.cannedbread.dictionary.pojo.domain.DictionaryTypeDO&quot;</span> <span class="attr">id</span>=<span class="string">&quot;doctionaryType&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;t_type&quot;</span> <span class="attr">property</span>=<span class="string">&quot;type&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;t_description&quot;</span> <span class="attr">property</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;dictionaryTypeList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.cannedbread.dictionary.pojo.domain.DictionaryValueDO&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;v_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;v_label&quot;</span> <span class="attr">property</span>=<span class="string">&quot;label&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;v_value&quot;</span> <span class="attr">property</span>=<span class="string">&quot;value&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-Parameters"><a href="#3-3-Parameters" class="headerlink" title="3.3. Parameters"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Parameters">3.3. Parameters</a></h3><p>参数，指传递给语句的参数。参数可以认为有 2 种：</p><ul><li><p>简易（原始）数据类型。 Integer、String 等没有属性的值。</p></li><li><p>复合数据类型。可以理解为是由简易数据类型组合而成的类。</p></li></ul><p>通常，我们使用 <code>#&#123;id&#125;</code> 这种方式引用参数。但是，参数可以更具体地引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;property,javaType=<span class="type">int</span>,jdbcType:NUMBERIC&#125;</span><br></pre></td></tr></table></figure><p><code>javaType</code> 基本可以总是从参数对象中确定，除非该对象是 <code>HashMap</code>，那么需要显式指定 <code>javaType</code> 确保使用正确的 TypeHandler。</p><ul><li>传入 List</li></ul><p>引用名称必须为 <code>list</code>，获取长度：<code>list.size</code>，获取第 n 个元素：list[n]</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;list != null and list.size != 0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span>&gt;</span>#&#123;item&#125;<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>传入多个值</li></ul><p>多个参数会封装成 Map，key 为 param1, param2, …</p><p>引用方式：<code>#&#123;param1&#125;</code>、<code>#&#123;param2.password&#125;</code></p><ul><li>传入 Map</li></ul><p>对 XML 中映射的语句进行解析之后，能够得到一个 <code>List&lt;ParameterMapping&gt;</code>，其中收集所有 <code>#&#123;&#125;</code> 占位符。</p><p>这些结构之后会传递给 <code>StatementHandler</code>，通常是 <code>PreparedStatementHandler</code>，之后通过 handler 进行参数设置。</p><h3 id="3-4-Result-Maps"><a href="#3-4-Result-Maps" class="headerlink" title="3.4. Result Maps"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Result_Maps">3.4. Result Maps</a></h3><p>对于如下映射语句例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根据 <code>resultType</code> 属性所指定的，这样的语句会简单地将所有地列自动映射到 <code>HashMap</code> 的 key 上。但是，在大多数场景下，<code>HashMap</code>并不是一个好的领域模型。应用程序更有可能使用 Java Bean 或者 POJO。考虑如下的 Java Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String hashedPassword;</span><br><span class="line">  <span class="comment">// Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 Java Bean 规范，上面的类有 3 个属性：id, username, hashedPassword。这些与 SELECT 语句中的列名<strong>完全匹配</strong>。这样，Java Bean 可以像 HashMap 一样，简单地映射到 ResultSet。</p><p>在这些情况下，MyBatis 自动在幕后创建 ResultMap 以将列名基于名称地自动映射到 Java Bean 的属性。</p><p><strong>列名与属性名不匹配的情况如何处理 ?</strong></p><ul><li>标准 SQL 语法，SELECT 语句别名</li><li>使用自定义 <code>&lt;Result Map&gt;</code></li></ul><h4 id="3-4-1-Advanced-Result-Maps"><a href="#3-4-1-Advanced-Result-Maps" class="headerlink" title="3.4.1. Advanced Result Maps"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Advanced_Result_Maps">3.4.1. Advanced Result Maps</a></h4><p>Result Map 是 MyBatis 强大的工具，可以自由映射结果。</p><h4 id="3-4-2-resultMap"><a href="#3-4-2-resultMap" class="headerlink" title="3.4.2. resultMap"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#resultMap">3.4.2. resultMap</a></h4><p><code>&lt;resultMap&gt;</code> 元素的概览：</p><ul><li><code>&lt;constructor&gt;</code> 用于在实例化时将结果注入类的构造函数<ul><li><code>idArg</code> ID 参数，标识 ID 将有助于提升整体性能</li><li><code>arg</code> 普通结果参数注入</li></ul></li><li><code>&lt;id&gt;</code> 一个 ID 结果，标识 ID 将会提高整体性能</li><li><code>&lt;result&gt;</code> 普通结果参数</li><li><code>&lt;association&gt;</code> 复合类型关联，许多结果会汇总到该类型<ul><li>嵌套结果映射 - association 本身就是 <code>resultMap</code>，或者可以引用其他的 <code>resultMap</code></li></ul></li><li><code>&lt;collection&gt;</code> 复合类型的集合<ul><li>嵌套结果映射 - collection 本身就是 <code>resultMap</code>，或者可以引用其他的 <code>resultMap</code></li></ul></li><li><code>&lt;discriminator&gt;</code> 使用结果的值来确定要使用的 <code>resultMap</code></li></ul><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">当前命名空间下引用此 result map 的唯一标识符</td></tr><tr><td align="left">type</td><td align="left">Java 的完全限定名，或者别名</td></tr><tr><td align="left">autoMapping</td><td align="left">如果存在该属性，MyBatis 会为该 result map 启用或禁用自动映射</td></tr></tbody></table><h4 id="3-4-3-id-amp-result"><a href="#3-4-3-id-amp-result" class="headerlink" title="3.4.3. id &amp; result"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#id_.26_result">3.4.3. id &amp; result</a></h4><p>id 和 result 都可以映射一个列的值到一个简单数据类型的字段（String,int,double,Date,…）</p><h4 id="association"><a href="#association" class="headerlink" title="association"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#association">association</a></h4><p>association 元素处理 “has-one” 类型关系。例如，一个博客有一个作者。<code>&lt;association&gt;</code> 映射像其他 <code>&lt;result&gt;</code> 一样工作。你可以指定 <code>property</code>, <code>javaType</code>, <code>jdbcType</code>, <code>typeHandler</code>。</p><p>association 不同之处在于，你需要告诉 MyBatis 如何加载关联数据，支持 2 种方式：</p><ul><li>Nested Select：嵌套查询，或者嵌套子查询。通过执行另一个映射 SQL 语句返回所需的<strong>复合类型</strong>。</li><li>Nested Results：嵌套结果。通过使用嵌套的结果映射来处理 join 结果的重复子集。</li></ul><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">property</td><td align="left">字段或属性。如果给定名称存在 Java Bean 匹配的属性，则会使用。否则，MyBatis 会寻找给定名称的字段。</td></tr><tr><td align="left">javaType</td><td align="left">完全限定的 Java 类名（或者 alias）。如果你映射到 Java Bean，MyBatis 会弄清楚类型。如果你映射到 HashMap，你需要指定 javaType 以确保所需的行为。</td></tr><tr><td align="left">jdbcType</td><td align="left"></td></tr><tr><td align="left">typeHandler</td><td align="left"></td></tr></tbody></table><h4 id="Nested-Select-for-Association"><a href="#Nested-Select-for-Association" class="headerlink" title="Nested Select for Association"></a>Nested Select for Association</h4><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">将要传递给嵌套语句的列名或者别名。<strong>可以确定唯一一条记录。</strong><br>注意：为了处理复合键，可以使用语法 <code>column=&quot;prop1=col1,prop2=col2&quot;</code> 指定多个列名传递给嵌套的 select 语句</td></tr><tr><td align="left">select</td><td align="left">映射语句的 ID，将会加载需要的复杂类型</td></tr><tr><td align="left">fetchType</td><td align="left">可选。有效值是 lazy 和 eager。如果存在，它会覆盖全局配置参数 <code>lazyLoadingEnabled</code></td></tr></tbody></table><blockquote><p>嵌套 SELECT 必须确保结果集的数量小于等于 1 个，否则你会得到异常：<br>org.apache.ibatis.executor.ExecutorException: Statement returned more than one row, where no more than one was expected.</p></blockquote><p><strong>官方提示</strong> 虽然这种方式比较简单，但是，对于大量数据集或者列表性能并不好。这种问题也被称之为 “N + 1 Select 问题”。简而言之，N + 1 Select 问题是由类似如下引起的：</p><ul><li>你执行单个 SQL 检索出一个记录列表（+1）</li><li>对于每个返回的记录，你执行 select 语句来加载每个的细节（N）</li></ul><p>该问题会导致大量 SQL 执行，并不是可取的。MyBatis 可以拦截在这些查询语句，因此你可能会忽略这些语句的开销。但是，如果你加载这样的列表，然后立即迭代它访问嵌套数据，则会调用所有延迟加载，因此性能可能非常糟糕。</p><blockquote><p>这也是在开发过程中比较忌讳的，在循环体中发起 SQL 查询</p></blockquote><h4 id="Nested-Results-for-Association"><a href="#Nested-Results-for-Association" class="headerlink" title="Nested Results for Association"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Nested_Results_for_Association">Nested Results for Association</a></h4><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">resultMap</td><td align="left">ID</td></tr><tr><td align="left">columnPrefix</td><td align="left">当 join 多张表时，你往往会使用别名来避免结果重复列名。指定 <code>columnPrefix</code> 允许你在映射时添加统一的前缀</td></tr><tr><td align="left">notNullColumn</td><td align="left"></td></tr><tr><td align="left">autoMapping</td><td align="left">如果该属性存在，MyBatis 在映射该属性时，将会启用或者禁用自动映射</td></tr></tbody></table><h4 id="Multiple-ResultSets-for-Association"><a href="#Multiple-ResultSets-for-Association" class="headerlink" title="Multiple ResultSets for Association"></a>Multiple ResultSets for Association</h4><h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><ul><li>嵌套 select</li><li>使用 join + 嵌套结果</li></ul><h4 id="Nested-Select-for-Collection"><a href="#Nested-Select-for-Collection" class="headerlink" title="Nested Select for Collection"></a>Nested Select for Collection</h4><p><code>&lt;collection&gt;</code> 元素将会使用新的属性 <code>ofType</code>，该属性适用于区分 Java Bean 属性类型和 collection 包含的类型。</p><h4 id="Nested-Results-for-Collection"><a href="#Nested-Results-for-Collection" class="headerlink" title="Nested Results for Collection"></a>Nested Results for Collection</h4><p>需要注意 collection 子元素 id 的重要性。</p><h4 id="Multiple-ResultSets-for-Collection"><a href="#Multiple-ResultSets-for-Collection" class="headerlink" title="Multiple ResultSets for Collection"></a>Multiple ResultSets for Collection</h4><h4 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h4><h3 id="Auto-mapping"><a href="#Auto-mapping" class="headerlink" title="Auto-mapping"></a>Auto-mapping</h3><p>MyBatis 可以自动映射结果，你也可以自己构建 result map，你甚至可以结合两种。</p><p>通常，数据库列使用大写字母且单词之间用下划线，而 Java 属性通常遵循驼峰命名约定。可以设置 <code>mapUnderscoreToCamelCase </code> 为 true 完成自动映射。</p><p>即使存在 <code>resultMap</code>，自动映射也会发生。对于每个结果映射，在结果集中但没有进行手工映射的列，将会被自动映射，之后进行手工映射。</p><p>有 3 个映射级别：</p><ul><li><code>NONE</code> 禁用自动映射。即，只会赋值手动映射属性。</li><li><code>PARTIAL</code> 除了其中定义的嵌套结果映射，其他都会自动映射</li><li><code>FULL</code> 自动映射所有</li></ul><h2 id="3-6-cache"><a href="#3-6-cache" class="headerlink" title="3.6. cache"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#cache">3.6. cache</a></h2><p>默认地，只有 Local Cache 是启用的，用于缓存会话的数据。要启用全局二级缓存，你只需添加一行文字到你的 SQL Mapper 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>二级缓存需要配置 <code>cacheEnabled</code> 为 <code>true</code> 才会开启，一般默认是开启的，但建议显式设置。另外，使用二级缓存，还需要实体类实现 <code>Serializable</code> 接口，否则将会抛出异常。</p></blockquote><p>这个简单的语句效果如下：</p><ul><li>缓存所有映射语句文件中 SELECT 语句的结果</li><li>所有 insert, update, delete 语句将刷新缓存</li><li>缓存将使用最近最少使用（LRU）算法进行驱逐</li><li>缓存不会以基于计划的时间顺序刷新</li><li>缓存将存储 1024 个列表或对象的引用（无论方法返回什么）</li><li>缓存会被视为读&#x2F;写缓存，这意味，被检索的对象不会被共享，可以被调用者安全的修改，不会干扰其他线程可能的修改</li></ul><h3 id="Using-a-Custom-Cache"><a href="#Using-a-Custom-Cache" class="headerlink" title="Using a Custom Cache"></a>Using a Custom Cache</h3><p>实现 Cache 接口，并在 Mapper 文件中指定 type：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="cache-ref"><a href="#cache-ref" class="headerlink" title="cache-ref"></a>cache-ref</h3><p>在不同 namespace 之间共享相同的缓存配置和实例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;com.someone.application.data.SomeMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-Java-API"><a href="#5-Java-API" class="headerlink" title="5. Java API"></a><a href="https://mybatis.org/mybatis-3/java-api.html">5. Java API</a></h2><h3 id="5-2-SqlSessions"><a href="#5-2-SqlSessions" class="headerlink" title="5.2. SqlSessions"></a><a href="https://mybatis.org/mybatis-3/java-api.html#sqlSessions">5.2. SqlSessions</a></h3><p>通过 <code>SqlSession</code>，你可以执行命令，获得 Mapper，管理事务。<code>SqlSession</code> 由 <code>SqlSessionFactory</code> 创建。</p><h4 id="5-2-1-SqlSessionFactoryBuilder"><a href="#5-2-1-SqlSessionFactoryBuilder" class="headerlink" title="5.2.1. SqlSessionFactoryBuilder"></a>5.2.1. SqlSessionFactoryBuilder</h4><p><code>SqlSessionFactoryBuilder</code> 有 5 个 build() 方法，每个方法允许你从不同来源构建 <code>SqlSessionFactory</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String env, Properties props)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span></span><br></pre></td></tr></table></figure><p><code>environment</code> MyBatis 将会使用的环境，如果没有调用包含 environment 参数的方法，则使用默认环境。</p><p><code>properties</code> MyBatis 将会加载的属性，可使用 <code>$&#123;propName&#125;</code> 进行配置</p><p><strong>关于 properties 加载的顺序</strong> </p><ul><li>首先，读取 properties 元素主体中指定的属性</li><li>其次，加载于 properties 元素的 resource 类路径资源或者 url 属性指定的资源将会被读取</li><li>最后，作为方法参数传递的 properties 最后读取</li></ul><p>后加载的属性会覆盖前者</p><h4 id="5-2-2-SqlSessionFactory"><a href="#5-2-2-SqlSessionFactory" class="headerlink" title="5.2.2. SqlSessionFactory"></a>5.2.2. SqlSessionFactory</h4><p>SqlSessionFactory 有 6 种方法用于创建 SqlSession 实例。一般地，当你选择用哪个方法时，需要考虑以下事情：</p><ul><li><strong>Transaction</strong>：你是否希望为 session 使用事务范围，或者使用 auto-commit（这通常意味着数据库或 JDBC 没有事务）？</li><li><strong>Connection</strong>：从 MyBatis 配置好的数据源获取还是自己提供</li><li><strong>Execution</strong>：重用 PreparedStatement 还是批处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">()</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(Connection connection)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, <span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span></span><br><span class="line">Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>默认地，无参的 openSession() 将会创建具有如下特征的 SqlSession：</p><ul><li>启动事务，即不会 auto commit</li><li>Connection 对象从 DataSource 中获取</li><li>事务隔离级别是驱动或者数据源使用的默认值</li><li>不会重用 PreparedStatements，不会批量更新</li></ul><p>ExecutorType 参数定义了 3 个可选值：</p><ul><li>ExecutorType.SIMPLE：朴素的执行器。为每个执行语句创建一个 PreparedStatement。</li><li>ExecutorType.REUSE：这种类型会重用 PreparedStatement。</li><li>ExecutorType.BATCH：批量更新，同时，如果执行语句之间有 SELECT 语句，也会在必要的地方划清。</li></ul><h4 id="5-2-3-SqlSession"><a href="#5-2-3-SqlSession" class="headerlink" title="5.2.3. SqlSession"></a><a href="https://mybatis.org/mybatis-3/java-api.html#SqlSession">5.2.3. SqlSession</a></h4><h5 id="5-2-3-1-Statement-Execution-Methods"><a href="#5-2-3-1-Statement-Execution-Methods" class="headerlink" title="5.2.3.1. Statement Execution Methods"></a><a href="https://mybatis.org/mybatis-3/java-api.html#Statement_Execution_Methods">5.2.3.1. Statement Execution Methods</a></h5><p>SqlSession 具有许多方法，用于执行 SQL 映射文件中定义的 SELECT, INSERT, UPDATE, DELETE 语句。每个方法都有一个 <code>statement</code> 参数（Statement ID），并且可以有 parameter 参数，参数可以是原始类型（自动装箱），或者 Java Bean，POJO，Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement)</span>;</span><br><span class="line">&lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement)</span>;</span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement)</span>;</span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line">&lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, String mapKey)</span>;</span><br><span class="line">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span>;</span><br><span class="line">&lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, ResultHandler handler)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, Object parameter, ResultHandler handler)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span></span><br></pre></td></tr></table></figure><blockquote><ul><li><code>selectOne</code> 和 <code>selectList</code> 不同点在于， <code>selectOne</code> 必须返回一个对象或者 null（没有对象）。如果超过一个对象，则抛出异常。</li></ul></blockquote><p>如果你不知道有多少对象，使用 <code>selectList</code> 总是安全的。</p><p>如果你想检查对象是否存在，你最好返回一个计数值（0 或 1）。</p><p><code>selectMap</code> 是一个特殊的情况，它会基于结果中的某个属性，将结果列表转换为一个 Map。</p><p>因为不是所有方法都需要参数，因此这些方法都有一个无参数的重载方法。</p><p><code>insert</code>, <code>update</code>, <code>delete</code> 的返回值表示的是影响行数。</p><p>有几种高级的 <code>select</code> 方法，它们允许你限制要返回的行范围，或者提供自定义的结果处理逻辑（ResultHandler），通常用于非常大的数据集（MySQL 几乎不使用）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span><br><span class="line">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowbounds)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span> <span class="params">(String statement, Object parameter, ResultHandler&lt;T&gt; handler)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler)</span></span><br></pre></td></tr></table></figure><p><code>RowBounds</code> 参数会让 MyBatis 跳过指定的记录数，同时限制要返回的记录数。</p><blockquote><ul><li>在这里，不同的驱动能够获得不同的效率。为了最佳性能，需要使用结果集类型为 <code>SCROLL_SENSITIVE </code> 或者 <code>SCROLL_INSENSITIVE </code></li></ul></blockquote><p><code>ResultHandler</code> 参数允许你按照你的方式处理每一行。你可以把它添加到 List，创建一个 Map，Set，或者抛出买个结果，而只保留计算的计算的总数。你可以使用 ResultHandler 做任何事情，这就是 MyBatis 内部使用来构造结果集列表的。</p><p>ResultHandler 接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResultHandler</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(ResultContext&lt;? extends T&gt; context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ResultContext</code> 参数用于访问结果对象本身，这是被创建的结果对象的数量计数，以及你可以使用 <code>stop()</code> 方法停止 MyBatis 加载更多结果。</p><p>使用 <code>ResultHandler</code> 有两点你应该了解：</p><ul><li>使用 <code>ResultHandler</code> 调用的方法种的数据不会被缓存</li><li>当使用高级 <code>resultMap</code> 时，MyBatis 有可能需要多行来构建 1 个对象。如果使用 <code>ResultHandler</code>，可能会给你一个关联或者集合未被填充的对象。</li></ul><h5 id="Local-Cache"><a href="#Local-Cache" class="headerlink" title="Local Cache"></a><a href="https://mybatis.org/mybatis-3/java-api.html#Local_Cache">Local Cache</a></h5><p>MyBatis 使用了 2 个缓存，Local Cache 和 二级缓存。</p><p>每次 MyBatis 创建新的会话时，也会创建一个 Local Cache 附加到会话中。在<strong>本次会话</strong>中执行的任何查询都将存储在本地缓存中，因此具有相同输入参数的相同查询，以后都不会查询数据库。当 update, commit, rollback 和 close 时，Local Cache 会清除。</p><h6 id="1-Local-Cache-原理-👇"><a href="#1-Local-Cache-原理-👇" class="headerlink" title="1. Local Cache 原理 👇"></a>1. Local Cache 原理 👇</h6><p>一般地，执行查询方法的时候都是调用 BaseExecutor 的 query() 方法，其方法内部会先考虑是否从 Local Cache 中获取数据，如果不从缓存中获取，则调用内部的 doQuery() 方法</p><h6 id="Local-Cache-的-Key-🐱"><a href="#Local-Cache-的-Key-🐱" class="headerlink" title="Local Cache 的 Key 🐱"></a>Local Cache 的 Key 🐱</h6><p>org.apache.ibatis.cache.CacheKey 是 Local Cache 的 key</p><h6 id="何时可能会失效-Local-Cache（失效）？-🐌"><a href="#何时可能会失效-Local-Cache（失效）？-🐌" class="headerlink" title="何时可能会失效 Local Cache（失效）？ 🐌"></a>何时可能会失效 Local Cache（失效）？ 🐌</h6><ul><li>不同的会话</li></ul><p>不同的 Session 本身不共享 Local Cache。我并不认为这是失效的原因。这反而是一种使用错误的方式。</p><ul><li>执行 update 操作</li></ul><p>如果执行了更新操作会清空 Local Cache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>手动调用 DefaultSqlSession.clearCache()</li></ul><p>底层会调用 executor 的 clearLocalCache() 方法</p><ul><li><p>设置了语句属性 <code>flushCache</code> 为 <code>true</code>，缓存全清</p></li><li><p>设置 flushCacheRequired</p></li><li><p>配置 localCacheScope 为 STATEMENT</p></li><li><p>commit 和 rollback</p></li></ul><h5 id="Ensuring-that-SqlSession-is-Closed"><a href="#Ensuring-that-SqlSession-is-Closed" class="headerlink" title="Ensuring that SqlSession is Closed"></a>Ensuring that SqlSession is Closed</h5><p>你必须确保关闭所有你打开的会话。推荐方式是使用 try 包裹资源。</p><h5 id="Using-Mappers"><a href="#Using-Mappers" class="headerlink" title="Using Mappers"></a>Using Mappers</h5><h5 id="Mapper-Annotations"><a href="#Mapper-Annotations" class="headerlink" title="Mapper Annotations"></a>Mapper Annotations</h5><table><thead><tr><th align="left">注解</th><th align="left">目标</th><th align="left">XML 等价物</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">@CacheNamespace</td><td align="left">Class</td><td align="left"><code>&lt;cache&gt;</code></td><td align="left">为给定的命名空间配置缓存</td></tr><tr><td align="left">@CacheNamespaceRef</td><td align="left">Class</td><td align="left"><code>&lt;cacheRef&gt;</code></td><td align="left">引用其他命名空间的缓存。注意：xml mapper 文件声明的缓存是隔离的</td></tr><tr><td align="left">@MapKey</td><td align="left">Method</td><td align="left"></td><td align="left">用于返回类型是 Map 的方法。基于对象的属性将结果 List 转换为 Map。注解的属性 <code>value</code> 作为 Map 的 key</td></tr></tbody></table><h1 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a><a href="https://mp.baomidou.com/">MyBatisPlus</a></h1><hr><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.cannedbread.dictionary.mapper&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><hr><ul><li>PageHelper</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用方法：<br>(1) PageHelper.start()，传入 pageNum 当前页码，pageSize 每页显示数目。<br>(2) 调用 Mapper 方法查询<br>(3) 使用 pageInfo 构造器传入查询结果集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PageInfo&lt;ProjectArea&gt; <span class="title function_">listPageByExample</span><span class="params">(<span class="type">int</span> pageNum, <span class="type">int</span> pageSize, ProjectArea example)</span> &#123;</span><br><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">List&lt;ProjectArea&gt; result = projectAreaMapper.selectList(example);</span><br><span class="line">PageInfo&lt;ProjectArea&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(result);</span><br><span class="line"><span class="keyword">return</span> pageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="各种-Logger"><a href="#各种-Logger" class="headerlink" title="各种 Logger"></a>各种 Logger</h2><ul><li>PreparedStatementLogger</li><li>ConnectionLogger</li></ul><h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><h3 id="PreparedStatementHandler"><a href="#PreparedStatementHandler" class="headerlink" title="PreparedStatementHandler"></a>PreparedStatementHandler</h3><p>执行 SQL 的时候会将 statement 强制转换为 PreparedStatement 类型，并进行执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">ps.execute();</span><br><span class="line"><span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SqlSource"><a href="#SqlSource" class="headerlink" title="SqlSource"></a>SqlSource</h2><ul><li>RawSqlSource</li><li>DynamicSqlSource</li><li>StaticSqlSource，生成 BoundSQL</li></ul><h3 id="RawSqlSource"><a href="#RawSqlSource" class="headerlink" title="RawSqlSource"></a>RawSqlSource</h3><p>RawSqlSource 拥有一个 SqlSource 的属性，它是 StaticSqlSource：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RawSqlSource</span> <span class="keyword">implements</span> <span class="title class_">SqlSource</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlSource sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何判断一个 SqlNode 是否是动态的 ?</strong></p><ul><li>如果是纯文本节点，且存在 <code>$&#123;&#125;</code>，认为是动态</li><li>如果是元素节点，则一定是动态</li></ul><p>具体代码见 XMLScriptBuilder.parseDynamicTags &gt; TextSqlNode.isDynamic</p><p><strong>为什么 RawSqlSource、DynamicSqlSource 不直接生成 BoundSQL，反而通过   StaticSqlSource 生成?</strong></p><p>设计的问题</p><p>DynamicSqlSource 解析是对 SqlNode 的解析，其中会存储根节点 rootSqlNode，节点可以认为是类似 DOM 的节点。</p><p><code>rootSqlNode.apply(context);</code> 即遍历 SqlNode 树进行解析，最终生成 context。</p><h2 id="SqlNode"><a href="#SqlNode" class="headerlink" title="SqlNode"></a>SqlNode</h2><ul><li>MixedSqlNode</li></ul><p>SQL 语法树从结构来看是树形，但是 MyBatis 会将同一层的所有节点用 MixedSqlNode 包装，因此，从节点的角度看，是一个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    contents.forEach(node -&gt; node.apply(context));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>StaticTextSqlNode 静态文本</p></li><li><p>TextSqlNode 包含了表达式的文本，如：select * from ${table}</p></li><li><p>IfSqlNode</p></li></ul><p>计算表达式的值，如果为 true，则继续解析，一般 if 表达式下面就是静态文本了，所以大部分情况则是直接追加 SQL</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">        contents.apply(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ForEachNode</li></ul><p>解析完毕之后会生成特定的序列，其中每个每个</p><p>该解析一定会添加 open 与 close，所以如果在拼接 in 语句的时候没有元素，可能导致 SQL 错误</p><ul><li>TrimSqlNode</li></ul><p>从进入该节点开始，将会使用 <code>FilteredDynamicContext</code> 包装原来的 context，之后的结果会缓存在 <code>FilteredDynamicContext</code> 的 <code>sqlBuffer</code> 中，直至该节点解析完毕，最后使用 filteredDynamicContext.applyAll() 真正进行应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    TrimSqlNode.<span class="type">FilteredDynamicContext</span> <span class="variable">filteredDynamicContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrimSqlNode</span>.FilteredDynamicContext(context);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> contents.apply(filteredDynamicContext);</span><br><span class="line">    filteredDynamicContext.applyAll();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么加这一个缓存 ?</strong></p><p>如果直接追加 SQL 到最终的结果上，最后还需要做一步 trim，此时已经不方便 trim 了。</p><ul><li>WhereSqlNode</li></ul><p>将会删除特定的前缀，并追加前缀 WHERE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; prefixList = Arrays.asList(<span class="string">&quot;AND &quot;</span>,<span class="string">&quot;OR &quot;</span>,<span class="string">&quot;AND\n&quot;</span>, <span class="string">&quot;OR\n&quot;</span>, <span class="string">&quot;AND\r&quot;</span>, <span class="string">&quot;OR\r&quot;</span>, <span class="string">&quot;AND\t&quot;</span>, <span class="string">&quot;OR\t&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhereSqlNode</span> <span class="keyword">extends</span> <span class="title class_">TrimSqlNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">WhereSqlNode</span><span class="params">(Configuration configuration, SqlNode contents)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(configuration, contents, <span class="string">&quot;WHERE&quot;</span>, prefixList, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rootSqlNode-apply-context"><a href="#rootSqlNode-apply-context" class="headerlink" title="rootSqlNode.apply(context)"></a>rootSqlNode.apply(context)</h2><h2 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h2><p>MapperProxy 是 MyBatis 中 InvacationHandler 的实现类。其中，包含一个 SqlSessionTemplate，SqlSessionTemplate 内部又包含一个 DefaultSqlSession </p><p><strong>为什么 SqlSessionTemplate 又使用代理对象 sqlSessionProxy 去执行方法？</strong></p><p>为了实现拦截操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; SqlSession.class &#125;, <span class="keyword">new</span> <span class="title class_">SqlSessionInterceptor</span>());</span><br></pre></td></tr></table></figure><h2 id="CachingExecutor-的执行"><a href="#CachingExecutor-的执行" class="headerlink" title="CachingExecutor 的执行"></a>CachingExecutor 的执行</h2><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>(1) 获得 BoundSql</p><p>BoundSql </p><p>(2) 创建缓存 key</p><p>创建是由 BaseExecutor 完成的，其中影响因素有：</p><ul><li>MappedStatement.id，即方法全限定名</li><li>rowBounds.offset</li><li>rowBounds.limit</li><li>boundSql.sql</li><li>parameterMappings 的参数值</li><li>parameterMappings.environment.id</li></ul><p>(3) flushCacheIfRequired<br>(4) 使用代理 Executor 执行查询</p><h2 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h2><h3 id="queryFromDatabase"><a href="#queryFromDatabase" class="headerlink" title="queryFromDatabase"></a>queryFromDatabase</h3><p>(1) 获取 Configuration<br>(2) 创建 StatementHandler<br>(3) prepareStatement<br>(4) StatementHandler.query</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MyBatis&quot;&gt;&lt;a href=&quot;#MyBatis&quot; class=&quot;headerlink&quot; title=&quot;MyBatis&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://mybatis.org/mybatis-3/&quot;&gt;MyBatis&lt;/a&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;h2</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 整合 MyBatis 启动原理</title>
    <link href="http://example.com/2022/07/15/Spring-Boot/Spring-Boot-%E6%95%B4%E5%90%88-MyBatis-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/07/15/Spring-Boot/Spring-Boot-%E6%95%B4%E5%90%88-MyBatis-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</id>
    <published>2022-07-15T08:54:14.000Z</published>
    <updated>2022-07-16T14:32:07.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-整合-MyBatis-启动原理"><a href="#Spring-Boot-整合-MyBatis-启动原理" class="headerlink" title="Spring Boot 整合 MyBatis 启动原理"></a>Spring Boot 整合 MyBatis 启动原理</h1><p>MyBatis 整合 Spring Boot 需要解决的是如何将自己创建的代理对象（<code>java.lang.reflect.Proxy</code>）交给 Spring 容器管理，这与将一个类（Class）交给 Spring 管理有所不同。</p><blockquote><p>将对象交给 Spring 容器管理，我们可以选择注入 Bean Definition，然后让 Spring 完成对象构造、配置、初始化等操作，然后放到 <code>singletonObjects</code> 单例池中，也可以选择直接放到单例池中，也就是不构造 Bean Definition，也不会存在于 <code>beanDefinitionMap</code>，这就是下面提及的 <code>SingletonBeanRegistry.registerSingleton</code> 方式</p></blockquote><p>将自定义的对象交给 Spring 容器管理，一般考虑的方式是：</p><ul><li>@Bean</li><li>factory method</li><li>SingletonBeanRegistry.registerSingleton</li><li>FactoryBean</li></ul><p>对于 <code>@Bean</code> 方式，我们可以使用这种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserMapper <span class="title function_">videoMapper</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到 MapperRegistry.knownMappers，否则 SqlSession.getMapper 会抛出异常</span></span><br><span class="line">    sqlSession.getConfiguration().addMapper(UserMapper.class);</span><br><span class="line">    <span class="keyword">return</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方式的确可行，但是我们每定义一个 Mapper 就需要写一个 <code>@Bean</code> 方法，还是比较麻烦的。</p><p>factory method 注入的方式与 <code>@Bean</code> 大同小异。</p><p>MyBatis 整合进 Spring 选择的是 <code>FactoryBean</code> 方式，通过向容器注入 <code>FactoryBean</code> 这种特殊的 Bean Definitnion，进而注入 <code>Mapper</code></p><p>比较朴素的想法是，对于每个 <code>Mapper</code> 我们都为它定义一个 <code>FactoryBean</code>，但是这样工作量太大，MyBatis 通过动态 Class 实现了只需要一个 <code>MapperFactoryBean</code> 就可以构造出不同的 <code>Mapper</code> 实例</p><blockquote><p>底层对应 <code>MapperFactoryBean</code> 的属性 <code>mapperInterface</code>，表示不同的 <code>Mapper</code> 接口的 <code>Class</code> 对象</p></blockquote><p>在使用 Spring 整合 MyBatis 的时候，通常会使用如下配置，这也是官网 <a href="http://mybatis.org/spring/getting-started.html">Getting Started</a> 提供的案例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.spring.sample.mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MyBatis Spring Boot Starter 为了解决上述这种按需配置 <code>MapperFactoryBean</code> 的繁琐步骤，引入了 Spring 类路径扫描机制。</p><h2 id="Spring-Boot-加载-Mapper"><a href="#Spring-Boot-加载-Mapper" class="headerlink" title="Spring Boot 加载 Mapper"></a>Spring Boot 加载 Mapper</h2><ol><li>Spring Boot 启动过程中，会调用 <code>AbstractApplicationContext</code> 的 <code>refresh</code> 方法，其中一个过程是 <code>invokeBeanFactoryPostProcessors</code>，它会调用 <code>ConfigurationClassPostProcessor</code> 后置处理器加载具有 <code>@Configuration</code> 注解的 Bean。</li><li><code>ConfigurationClassPostProcessor</code> 关注的是 <code>@Configuration</code> 类型的 Bean，它会判断该 Bean 是否包含 <code>@Import</code> 注解。假设我们将 <code>@MapperScan</code> 添加在主启动类上（一般是具有 <code>@SpringBootApplication</code> 注解），那么将会读取主启动类注解，发现具有 <code>@MapperScan</code>，而 <code>@MapperScan</code> 嵌套了 <code>@Import</code> 注解，value 为 <code>MapperScannerRegistrar.class</code>，因此，将会构造<code>MapperScannerRegistrar</code> Bean Definition 进入 Spring 容器</li></ol><p>当 <code>@Configuration</code> 类解析完毕加载到容器后，就会执行 <code>load</code> 方法，用于加载这些 <code>@Configuration</code> 类相关的 Bean、Resource 等（如 <code>@Import</code>, <code>@ImportResource</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses)</span><br></pre></td></tr></table></figure><p>当 <code>load</code> 完毕，此时 <code>MapperScannerRegistrar</code> 已经加载到 Spring 容器，而且 <code>load</code> 会主动触发 <code>MapperScannerRegistrar</code> 的回调方法 <code>registerBeanDefinitions</code>。</p><p><code>MapperScannerRegistrar</code> 是 <code>ImportBeanDefinitionRegistrars</code> 的子类，其关键方法 <code>registerBeanDefinitions</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得 @MapperScan 的全部属性</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">mapperScanAttrs</span> <span class="operator">=</span> AnnotationAttributes</span><br><span class="line">        .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    <span class="keyword">if</span> (mapperScanAttrs != <span class="literal">null</span>) &#123;</span><br><span class="line">        registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,</span><br><span class="line">            generateBaseBeanName(importingClassMetadata, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在底层构造了一个 <code>MapperScannerConfigurer</code> Bean Definitnion，并注册到容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造 MapperScannerConfigurer Bean Definition</span></span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;processPropertyPlaceHolders&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass = annoAttrs.getClass(<span class="string">&quot;annotationClass&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;annotationClass&quot;</span>, annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">&quot;markerInterface&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;markerInterface&quot;</span>, markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; generatorClass = annoAttrs.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;nameGenerator&quot;</span>, BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">MapperFactoryBean</span>&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">&quot;factoryBean&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;mapperFactoryBeanClass&quot;</span>, mapperFactoryBeanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlSessionTemplateRef</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;sqlSessionTemplateRef&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(sqlSessionTemplateRef)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;sqlSessionTemplateBeanName&quot;</span>, annoAttrs.getString(<span class="string">&quot;sqlSessionTemplateRef&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlSessionFactoryRef</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;sqlSessionFactoryRef&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(sqlSessionFactoryRef)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span>, annoAttrs.getString(<span class="string">&quot;sqlSessionFactoryRef&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集 basePackage</span></span><br><span class="line">    List&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    basePackages.addAll(</span><br><span class="line">        Arrays.stream(annoAttrs.getStringArray(<span class="string">&quot;value&quot;</span>)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(<span class="string">&quot;basePackages&quot;</span>)).filter(StringUtils::hasText)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)).map(ClassUtils::getPackageName)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">        basePackages.add(getDefaultBasePackage(annoMeta));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">lazyInitialization</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;lazyInitialization&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;lazyInitialization&quot;</span>, lazyInitialization);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultScope</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;defaultScope&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!AbstractBeanDefinition.SCOPE_DEFAULT.equals(defaultScope)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;defaultScope&quot;</span>, defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 basePackage 属性，用逗号(,)分隔</span></span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;basePackage&quot;</span>, StringUtils.collectionToCommaDelimitedString(basePackages));</span><br><span class="line"></span><br><span class="line">    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MapperScannerConfigurer</code> 是 <code>BeanDefinitionRegistryPostProcessor</code> 的实现类，也就说其调用时机在 refresh 方法的 <code>invokeBeanFactoryPostProcessors</code> 中，它执行了类路径扫描，并注册了相关的 Mapper，关键方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">        processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建扫描器</span></span><br><span class="line">    <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">    scanner.setAddToConfig(<span class="built_in">this</span>.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(<span class="built_in">this</span>.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(<span class="built_in">this</span>.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(<span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(<span class="built_in">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(<span class="built_in">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(<span class="built_in">this</span>.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">        scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(defaultScope)) &#123;</span><br><span class="line">        scanner.setDefaultScope(defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将之前用逗号(,)分隔的 basePackage 字符串分解成 String[]</span></span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassPathBeanDefinitionScanner</code> 的 scan 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">beanCountAtScanStart</span> <span class="operator">=</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line">    doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassPathBeanDefinitionScanner</code> 的 doScan 方法如下，它返回扫描到的所有 <code>BeanDefinitionHolder</code> 的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">                definitionHolder =</span><br><span class="line">                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis 覆盖了原来的 <code>doScan</code> 方法，因为我们不能把扫描到的 <code>Mapper</code> 接口交给 Spring 容器，否则后续的实例化将无法进行。因此，MyBatis 在调用 <code>super.doScan()</code> 方法得到扫描到的 <code>Set&lt;BeanDefinitionHolder&gt;</code> 之后又进行后置处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 Spring 内置提供的 doScan 方法</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">            + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 后置处理</span></span><br><span class="line">        processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MyBatis 的 <code>ClassPathMapperScanner</code> 后置处理方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> &#123; AbstractBeanDefinition definition;</span><br><span class="line">    <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry();</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">        definition = (AbstractBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">scopedProxy</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ScopedProxyFactoryBean.class.getName().equals(definition.getBeanClassName())) &#123;</span><br><span class="line">            definition = (AbstractBeanDefinition) Optional</span><br><span class="line">                .ofNullable(((RootBeanDefinition) definition).getDecoratedDefinition())</span><br><span class="line">                .map(BeanDefinitionHolder::getBeanDefinition).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;The target bean definition of scoped proxy bean not found. Root bean definition[&quot;</span> + holder + <span class="string">&quot;]&quot;</span>));</span><br><span class="line">            scopedProxy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扫描到的 Mapper 接口，因此这里获取到的应该是形如 UserMapper 之类的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> definition.getBeanClassName();</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Creating MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + beanClassName</span><br><span class="line">            + <span class="string">&quot;&#x27; mapperInterface&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mapper 接口是 Bean 原始的类型，但是实际类型是 MapperFactoryBean</span></span><br><span class="line">        <span class="comment">// 将原始类型（Mapper）作为构造器参数传入</span></span><br><span class="line">        definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <span class="comment">// issue #59</span></span><br><span class="line">        <span class="comment">// 将 BeanClass 强制修改为 MapperFactoryBean 类型</span></span><br><span class="line">        definition.setBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line"></span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;addToConfig&quot;</span>, <span class="built_in">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attribute for MockitoPostProcessor</span></span><br><span class="line">        <span class="comment">// https://github.com/mybatis/spring-boot-starter/issues/475</span></span><br><span class="line">        definition.setAttribute(FACTORY_BEAN_OBJECT_TYPE, beanClassName);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">explicitFactoryUsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">            LOGGER.warn(</span><br><span class="line">                () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">            LOGGER.warn(</span><br><span class="line">                () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        definition.setLazyInit(lazyInitialization);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (scopedProxy) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ConfigurableBeanFactory.SCOPE_SINGLETON.equals(definition.getScope()) &amp;&amp; defaultScope != <span class="literal">null</span>) &#123;</span><br><span class="line">        definition.setScope(defaultScope);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!definition.isSingleton()) &#123;</span><br><span class="line">        <span class="type">BeanDefinitionHolder</span> <span class="variable">proxyHolder</span> <span class="operator">=</span> ScopedProxyUtils.createScopedProxy(holder, registry, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (registry.containsBeanDefinition(proxyHolder.getBeanName())) &#123;</span><br><span class="line">            registry.removeBeanDefinition(proxyHolder.getBeanName());</span><br><span class="line">        &#125;</span><br><span class="line">        registry.registerBeanDefinition(proxyHolder.getBeanName(), proxyHolder.getBeanDefinition());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Boot-整合-MyBatis-启动原理&quot;&gt;&lt;a href=&quot;#Spring-Boot-整合-MyBatis-启动原理&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 整合 MyBatis 启动原理&quot;&gt;&lt;/a&gt;Sprin</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="MyBatis" scheme="http://example.com/tags/MyBatis/"/>
    
    <category term="Spring Boot" scheme="http://example.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Gateway</title>
    <link href="http://example.com/2022/07/15/Spring-Cloud/Spring-Cloud-Gateway/"/>
    <id>http://example.com/2022/07/15/Spring-Cloud/Spring-Cloud-Gateway/</id>
    <published>2022-07-15T08:28:39.000Z</published>
    <updated>2022-07-15T08:46:32.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/">Spring Cloud Gateway</a></h1><h2 id="1-How-to-Include-Spring-Cloud-Gateway"><a href="#1-How-to-Include-Spring-Cloud-Gateway" class="headerlink" title="1. How to Include Spring Cloud Gateway"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gateway-starter">1. How to Include Spring Cloud Gateway</a></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你包含了 starter，但是你不想启用网关，则可以设置 <code>spring.cloud.gateway.enabled=false</code></p><h2 id="2-Glossary"><a href="#2-Glossary" class="headerlink" title="2. Glossary"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#glossary">2. Glossary</a></h2><ul><li><strong>Route</strong>: 网关的基本构建。它由 ID，目标 URI，谓词集合，以及过滤器集合定义。如果聚合谓词为 true，则匹配路由。</li><li><strong>Predicate</strong>: 这是 Java 8 Function Predicate。输入类型是 <code>Spring Framework ServerWebExchange</code>。这使你可以匹配来自 HTTP 请求中的任何东西，例如 Header 或者参数。</li><li><strong>Filter</strong>: 这些是一些 <code>GatewayFilter</code> 实例，它们由特定的工厂构建出来。在这里，你可以在发送下游请求之前或之后修改请求和响应。</li></ul><h2 id="4-Configuring-Route-Predicate-Factories-and-Gateway-Filter-Factories"><a href="#4-Configuring-Route-Predicate-Factories-and-Gateway-Filter-Factories" class="headerlink" title="4. Configuring Route Predicate Factories and Gateway Filter Factories"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#configuring-route-predicate-factories-and-gateway-filter-factories">4. Configuring Route Predicate Factories and Gateway Filter Factories</a></h2><p>配置谓词和过滤器有两种方式：快捷方式和完全扩展参数。下面大多数示例都是用快捷方式。</p><h3 id="4-1-Shortcut-Configuration"><a href="#4-1-Shortcut-Configuration" class="headerlink" title="4.1. Shortcut Configuration"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#shortcut-configuration">4.1. Shortcut Configuration</a></h3><p>快捷方式配置由过滤器名称识别，跟着一个等号（<code>=</code>），后面跟着由逗号（<code>,</code>）分割的参数值。</p><p><strong>application.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=mycookie,mycookievalue</span></span><br></pre></td></tr></table></figure><p>上面的样例定义了具有两个参数的 <code>Cookie</code> 路由谓词工厂，参数分别是，cookie name <code>mycookie</code>，以及要匹配 <code>mycookievalue</code> 的值。</p><h1 id="5-Route-Predicate-Factories"><a href="#5-Route-Predicate-Factories" class="headerlink" title="5. Route Predicate Factories"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gateway-request-predicates-factories">5. Route Predicate Factories</a></h1><p>Spring Cloud Gateway 包含许多内置的路由谓词工厂，所有这些谓词匹配不同的 HTTP 请求属性</p><h2 id="5-1-The-After-Route-Predicate-Factory"><a href="#5-1-The-After-Route-Predicate-Factory" class="headerlink" title="5.1. The After Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-after-route-predicate-factory">5.1. The After Route Predicate Factory</a></h2><p><code>After</code> 路由谓词工厂携带一个参数，即一个 <code>datetime</code>（其实是 Java 的 <code>ZonedDateTime</code>）。该谓词匹配发生在指定时间之后的请求。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">After=2021-06-03T10:00:00.000+08:00</span></span><br></pre></td></tr></table></figure><h2 id="5-2-The-Before-Route-Predicate-Factory"><a href="#5-2-The-Before-Route-Predicate-Factory" class="headerlink" title="5.2. The Before Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-before-route-predicate-factory">5.2. The Before Route Predicate Factory</a></h2><p><code>Before</code> 路由谓词工厂携带一个参数，即一个 <code>datetime</code>（其实是 Java 的 <code>ZonedDateTime</code>）。该谓词匹配发生在指定时间之前的请求。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Before=2021-06-03T10:00:00.000+08:00</span></span><br></pre></td></tr></table></figure><h2 id="5-3-The-Between-Route-Predicate-Factory"><a href="#5-3-The-Between-Route-Predicate-Factory" class="headerlink" title="5.3. The Between Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-between-route-predicate-factory">5.3. The Between Route Predicate Factory</a></h2><p><code>Between</code> 路由谓词工厂携带两个参数，<code>datetime1</code> 和 <code>datetime2</code>，他们都是 Java 的 <code>ZonedDateTime</code> 对象。该谓词匹配发生在 <code>datetime1</code> 之后，以及 <code>datetime2</code> 之前的请求。<code>datetime2</code> 参数必须在 <code>datetime1</code> 之后。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017-01-21T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure><h2 id="5-4-The-Cookie-Route-Predicate-Factory"><a href="#5-4-The-Cookie-Route-Predicate-Factory" class="headerlink" title="5.4. The Cookie Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-cookie-route-predicate-factory">5.4. The Cookie Route Predicate Factory</a></h2><p><code>Cookie</code> 路由谓词工厂携带两个参数，<code>name</code> 和 <code>regexp</code>（本质是 Java 的正则表达式）。该谓词匹配具有给定名称，并且值匹配正则表达式的 cookie。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Cookie=x-token,</span> <span class="string">\w+</span></span><br></pre></td></tr></table></figure><h2 id="5-5-The-Header-Route-Predicate-Factory"><a href="#5-5-The-Header-Route-Predicate-Factory" class="headerlink" title="5.5. The Header Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-header-route-predicate-factory">5.5. The Header Route Predicate Factory</a></h2><p><code>Header</code> 路由谓词工厂携带两个参数，<code>name</code> 和 <code>regexp</code>（本质是 Java 的正则表达式）。该谓词匹配具有给定名称，并且值匹配正则表达式的 header。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><h2 id="5-6-The-Host-Route-Predicate-Factory"><a href="#5-6-The-Host-Route-Predicate-Factory" class="headerlink" title="5.6. The Host Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-host-route-predicate-factory">5.6. The Host Route Predicate Factory</a></h2><p><code>Header</code> 路由谓词工厂携带一个参数：主机名 <code>patterns</code> 列表。模式是一种 Ant 风格的带有 <code>.</code> 作为分隔符的模式。该谓词匹配模式中的的 <code>Host</code> 头部。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><blockquote><p>消息头部的字段名是大小写不敏感的，也就是头部 X-Request-Id，也可以传递 x-request-id<br>RFC 2616 <a href="https://www.rfc-editor.org/rfc/inline-errata/rfc2616.html%EF%BC%8C%E6%9F%A5%E8%AF%A2">https://www.rfc-editor.org/rfc/inline-errata/rfc2616.html，查询</a> (“:”) 关键字附近文字可以找到：Field names are case-insensitive.</p></blockquote><h2 id="5-7-The-Method-Route-Predicate-Factory"><a href="#5-7-The-Method-Route-Predicate-Factory" class="headerlink" title="5.7. The Method Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-method-route-predicate-factory">5.7. The Method Route Predicate Factory</a></h2><p><code>Method</code> 路由谓词工厂携带一个参数 <code>methods</code>，该参数是一个或者多个参数：待匹配的 HTTP 方法。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure><h2 id="5-8-The-Path-Route-Predicate-Factory"><a href="#5-8-The-Path-Route-Predicate-Factory" class="headerlink" title="5.8. The Path Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-path-route-predicate-factory">5.8. The Path Route Predicate Factory</a></h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/echo/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5-9-The-Query-Route-Predicate-Factory"><a href="#5-9-The-Query-Route-Predicate-Factory" class="headerlink" title="5.9. The Query Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-query-route-predicate-factory">5.9. The Query Route Predicate Factory</a></h2><p><code>Query</code> 路由谓词工厂携带两个参数，一个必需的 <code>param</code> 和一个可选的 <code>regexp</code>（本质是 Java 的正则表达式）。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=id</span></span><br></pre></td></tr></table></figure><h2 id="5-10-The-RemoteAddr-Route-Predicate-Factory"><a href="#5-10-The-RemoteAddr-Route-Predicate-Factory" class="headerlink" title="5.10. The RemoteAddr Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-remoteaddr-route-predicate-factory">5.10. The RemoteAddr Route Predicate Factory</a></h2><p><code>RemoteAddr</code> 路由谓词工厂携带一个 <code>sources</code> 列表，这是 CIDR 符号字符串，例如 <code>192.168.0.1/16</code>，此处 <code>192.168.0.1</code> 是 IP 地址，16 是子网掩码。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.0.187/24</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Cloud-Gateway&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Gateway&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Gateway&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.spri</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring Cloud" scheme="http://example.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix 配置实践</title>
    <link href="http://example.com/2022/07/15/Hystrix-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2022/07/15/Hystrix-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-07-15T03:50:30.000Z</published>
    <updated>2022-07-15T03:50:37.080Z</updated>
    
    <content type="html"><![CDATA[<p>涉及到断路器的参数（HystrixCommandProperties）：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">circuitBreaker.enabled</td><td align="left">是否开启断路器</td><td align="left">true</td></tr><tr><td align="left">circuitBreaker.requestVolumeThreshold</td><td align="left">请求总数阈值。这意味着，如果 hystrix 命令在休眠窗口期间调用次数不足 20 次，即使请求都失败，断路器也不会打开</td><td align="left">20</td></tr><tr><td align="left">circuitBreaker.sleepWindowInMilliseconds</td><td align="left">休眠窗口</td><td align="left">5000</td></tr><tr><td align="left">circuitBreaker.errorThresholdPercentage</td><td align="left">错误阈值。当请求总数在休眠窗口内超过了阈值，断路器就会打开。</td><td align="left">50</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;涉及到断路器的参数（HystrixCommandProperties）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;参数&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;描述&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;默认值&lt;/th&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Shiro Subject login 流程分析</title>
    <link href="http://example.com/2022/07/14/Shiro/Shiro-Subject-login-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/07/14/Shiro/Shiro-Subject-login-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2022-07-14T07:23:58.000Z</published>
    <updated>2022-07-14T08:12:58.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Subject-login-流程分析"><a href="#Subject-login-流程分析" class="headerlink" title="Subject login 流程分析"></a>Subject login 流程分析</h1><p>通常，在执行登录之前，我们必须拥有一个 <code>Subject</code> 对象，可能是从 <code>SecurityUtils</code> 类中获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure><p>Shiro 框架中 <code>Subject</code> 实现类 <code>DelegatingSubject</code>，顾名思义，委托中的 <code>Subject</code>，该类本身不做 login 操作，而是将 login 操作委托给 <code>SecurityManager</code></p><p>Subject.login() 的方法声明如下，需要传入一个 <code>AuthenticationToken</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">login</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException;</span><br></pre></td></tr></table></figure><p>具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    clearRunAsIdentitiesInternal();</span><br><span class="line">    <span class="comment">// 委托给 SecurityManager 执行</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> securityManager.login(<span class="built_in">this</span>, token);</span><br><span class="line"></span><br><span class="line">    PrincipalCollection principals;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subject <span class="keyword">instanceof</span> DelegatingSubject) &#123;</span><br><span class="line">        <span class="type">DelegatingSubject</span> <span class="variable">delegating</span> <span class="operator">=</span> (DelegatingSubject) subject;</span><br><span class="line">        <span class="comment">//we have to do this in case there are assumed identities - we don&#x27;t want to lose the &#x27;real&#x27; principals:</span></span><br><span class="line">        principals = delegating.principals;</span><br><span class="line">        host = delegating.host;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        principals = subject.getPrincipals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (principals == <span class="literal">null</span> || principals.isEmpty()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Principals returned from securityManager.login( token ) returned a null or &quot;</span> +</span><br><span class="line">                <span class="string">&quot;empty value.  This value must be non null and populated with one or more elements.&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.principals = principals;</span><br><span class="line">    <span class="built_in">this</span>.authenticated = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (token <span class="keyword">instanceof</span> HostAuthenticationToken) &#123;</span><br><span class="line">        host = ((HostAuthenticationToken) token).getHost();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (host != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> subject.getSession(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = decorate(session);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DefaultSecurityManager</code> 的 login 方法如下，其中 authenticate 是执行认证的关键方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Subject <span class="title function_">login</span><span class="params">(Subject subject, AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    AuthenticationInfo info;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        info = authenticate(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onFailedLogin(token, ae, subject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;onFailedLogin method threw an &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;exception.  Logging and propagating original AuthenticationException.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ae; <span class="comment">//propagate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">loggedIn</span> <span class="operator">=</span> createSubject(token, info, subject);</span><br><span class="line"></span><br><span class="line">    onSuccessfulLogin(token, info, loggedIn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loggedIn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SecurityManager</code> 将认证的方法委托给了内部认证器 <code>Authenticator</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AuthenticationInfo <span class="title function_">authenticate</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.authenticator.authenticate(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractAuthenticator</code> 认证方法 <code>authenticate()</code> 代码如下，其中 <code>doAuthenticate()</code> 是认证的关键方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AuthenticationInfo <span class="title function_">authenticate</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Method argument (authentication token) cannot be null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.trace(<span class="string">&quot;Authentication attempt received for token [&#123;&#125;]&quot;</span>, token);</span><br><span class="line"></span><br><span class="line">    AuthenticationInfo info;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        info = doAuthenticate(token);</span><br><span class="line">        <span class="keyword">if</span> (info == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;No account information found for authentication token [&quot;</span> + token + <span class="string">&quot;] by this &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Authenticator instance.  Please check that it is configured correctly.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="type">AuthenticationException</span> <span class="variable">ae</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">            ae = (AuthenticationException) t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ae == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more</span></span><br><span class="line">            <span class="comment">//severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Authentication failed for token submission [&quot;</span> + token + <span class="string">&quot;].  Possible unexpected &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;error? (Typical or expected login exceptions should extend from AuthenticationException).&quot;</span>;</span><br><span class="line">            ae = <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(msg, t);</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled())</span><br><span class="line">                log.warn(msg, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notifyFailure(token, ae);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to send notification for failed authentication attempt - listener error?.  &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Please check your AuthenticationListener implementation(s).  Logging sending exception &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;and propagating original AuthenticationException instead...&quot;</span>;</span><br><span class="line">                log.warn(msg, t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> ae;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;Authentication successful for token [&#123;&#125;].  Returned account [&#123;&#125;]&quot;</span>, token, info);</span><br><span class="line"></span><br><span class="line">    notifySuccess(token, info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，我们可以认为 Shiro 框架中的认证器就是 <code>ModularRealmAuthenticator</code>，因为没有其他实现类了，其 <code>doAuthenticate()</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doAuthenticate</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    assertRealmsConfigured();</span><br><span class="line">    Collection&lt;Realm&gt; realms = getRealms();</span><br><span class="line">    <span class="keyword">if</span> (realms.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有 1 个 Realm</span></span><br><span class="line">        <span class="keyword">return</span> doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 具有多个 Realm</span></span><br><span class="line">        <span class="keyword">return</span> doMultiRealmAuthentication(realms, authenticationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果配置了多个 <code>Realm</code>，会使用到认证策略 <code>AuthenticationStrategy</code>，认证策略也有很多种，其中的 <code>AllSuccessfulStrategy</code> 要求所有的 <code>Realm</code> 都必须认证成功，并且会合并所有的 <code>AuthenticationInfo</code> 中的 <code>PrincipalCollection</code> 形成 <code>MutablePrincipalCollection</code>，凭证 <code>credential</code> 也会合并为集合。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Subject-login-流程分析&quot;&gt;&lt;a href=&quot;#Subject-login-流程分析&quot; class=&quot;headerlink&quot; title=&quot;Subject login 流程分析&quot;&gt;&lt;/a&gt;Subject login 流程分析&lt;/h1&gt;&lt;p&gt;通常，在执行</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Shiro" scheme="http://example.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Shiro FilterChainDefinitionMap 注册原理</title>
    <link href="http://example.com/2022/07/14/Shiro/Shiro-FilterChainDefinitionMap-%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/07/14/Shiro/Shiro-FilterChainDefinitionMap-%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</id>
    <published>2022-07-14T06:28:34.000Z</published>
    <updated>2022-07-14T07:14:29.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shiro-FilterChainDefinitionMap-注册原理"><a href="#Shiro-FilterChainDefinitionMap-注册原理" class="headerlink" title="Shiro FilterChainDefinitionMap 注册原理"></a>Shiro FilterChainDefinitionMap 注册原理</h1><p>在进行 <code>FilterChainDefinitionMap</code> 配置的时候，需要准备两个字符串，分别称之为 <code>antPath</code> 和 <code>definition</code>。以如下的配置为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultShiroFilterChainDefinition</span> <span class="variable">chainDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShiroFilterChainDefinition</span>();</span><br><span class="line">chainDefinition.addPathDefinition(<span class="string">&quot;/url&quot;</span>, <span class="string">&quot;authc, roles[admin,user], perms[file:edit]&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>第一个字符串可以认为是路径（可以包含通配符），第二个字符串是过滤器链定义</p></blockquote><p>对于 <code>FilterChainDefinitionMap</code> 中每个 filter Chain Definition 的处理都是在 <code>DefaultFilterChainManager</code> 进行的，主要关注如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处的 chainName 就是 antPath </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createChain</span><span class="params">(String chainName, String chainDefinition)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(chainName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;chainName cannot be null or empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(chainDefinition)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;chainDefinition cannot be null or empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Creating chain [&quot;</span> + chainName + <span class="string">&quot;] with global filters &quot;</span> + globalFilterNames + <span class="string">&quot; and from String definition [&quot;</span> + chainDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先以此添加全局 filter，比如 InvalidRequestFilter</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(globalFilterNames)) &#123;</span><br><span class="line">        globalFilterNames.stream().forEach(filterName -&gt; addToChain(chainName, filterName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对值进行标记解析，以获得最后特定于过滤器的配置项</span></span><br><span class="line">    <span class="comment">// 这里以半角逗号(,) 作为分隔符，忽略两边空白符</span></span><br><span class="line">    <span class="comment">// 例如对于值：</span></span><br><span class="line">    <span class="comment">//     &quot;authc, roles[admin,user], perms[file:edit]&quot;</span></span><br><span class="line">    <span class="comment">// 最终的标记数组为：</span></span><br><span class="line">    <span class="comment">//     &#123; &quot;authc&quot;, &quot;roles[admin,user]&quot;, &quot;perms[file:edit]&quot; &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    String[] filterTokens = splitChainDefinition(chainDefinition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个标记都是特定于每个过滤器的</span></span><br><span class="line">    <span class="comment">// 即，这些配置可能是过滤器约定好的，你需要熟悉这些用法</span></span><br><span class="line">    <span class="comment">// 譬如 roles[admin,user] 括号 [] 之间代表着角色</span></span><br><span class="line">    <span class="comment">//      perms[file:edit] 括号 [] 之间代表权限，权限又用 : 隔开，前者表示操作对象，后者表示操作类型</span></span><br><span class="line">    <span class="comment">// 剥离 name，提取括号 [] 之间的特定于过滤器的配置</span></span><br><span class="line">    <span class="keyword">for</span> (String token : filterTokens) &#123;</span><br><span class="line">        <span class="comment">// 一定是一个包含 2 个元素的数组，第一个是 filter name，第二个 config 可能是 null</span></span><br><span class="line">        <span class="comment">// [ &quot;authc&quot;, null ]</span></span><br><span class="line">        <span class="comment">// [ &quot;roles&quot;, &quot;admin,user&quot; ]</span></span><br><span class="line">        <span class="comment">// [ &quot;perms&quot;, &quot;file:edit&quot; ]</span></span><br><span class="line">        String[] nameConfigPair = toNameConfigPair(token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在，我们拥有过滤器名称，路径，以及特定于路径的配置（可能是 null，也就是没有配置）</span></span><br><span class="line">        addToChain(chainName, nameConfigPair[<span class="number">0</span>], nameConfigPair[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToChain</span><span class="params">(String chainName, String filterName, String chainSpecificFilterConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(chainName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;chainName cannot be null or empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> getFilter(filterName);</span><br><span class="line">    <span class="keyword">if</span> (filter == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;There is no filter with name &#x27;&quot;</span> + filterName +</span><br><span class="line">                <span class="string">&quot;&#x27; to apply to chain [&quot;</span> + chainName + <span class="string">&quot;] in the pool of available Filters.  Ensure a &quot;</span> +</span><br><span class="line">                <span class="string">&quot;filter with that name/path has first been registered with the addFilter method(s).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里主要就是把配置字符串，如：admin,user 按照半角逗号（,）分割</span></span><br><span class="line">    <span class="comment">// 将得到的 chainName 和 [admin, user] 放入过滤器中  Map&lt;String, Object&gt; appliedPaths 结构中</span></span><br><span class="line">    <span class="comment">// 之所以这样做，是因为对于不同的路径，可能会配置同一个过滤器的不同过滤规则</span></span><br><span class="line">    <span class="comment">// 比如： 学校列表学校管理员与区级管理员可访问，区列表仅区级管理员访问</span></span><br><span class="line">    <span class="comment">//      /school/list  roles[school_admin, area_admin]</span></span><br><span class="line">    <span class="comment">//      /area/list    roles[area_admin]</span></span><br><span class="line">    applyChainConfig(chainName, filter, chainSpecificFilterConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensureChain 顾名思义，表示确保 chain 存在，如果不存在就新建一个</span></span><br><span class="line">    <span class="type">NamedFilterList</span> <span class="variable">chain</span> <span class="operator">=</span> ensureChain(chainName);</span><br><span class="line">    chain.add(filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shiro-FilterChainDefinitionMap-注册原理&quot;&gt;&lt;a href=&quot;#Shiro-FilterChainDefinitionMap-注册原理&quot; class=&quot;headerlink&quot; title=&quot;Shiro FilterChainDefin</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Shiro" scheme="http://example.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Shiro DefaultFilter 使用笔记</title>
    <link href="http://example.com/2022/07/14/Shiro/Shiro-DefaultFilter-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/07/14/Shiro/Shiro-DefaultFilter-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2022-07-14T03:17:34.000Z</published>
    <updated>2022-07-14T09:30:23.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shiro-DefaultFilter-使用笔记"><a href="#Shiro-DefaultFilter-使用笔记" class="headerlink" title="Shiro DefaultFilter 使用笔记"></a>Shiro DefaultFilter 使用笔记</h1><h2 id="anon"><a href="#anon" class="headerlink" title="anon"></a>anon</h2><p>AnonymousFilter</p><p>匿名过滤器，请求 <code>onPreHandle()</code> 直接通过。</p><h2 id="authc"><a href="#authc" class="headerlink" title="authc"></a>authc</h2><p>FormAuthenticationFilter</p><p>onAccessDenied 方法分 loginUrl 处理和非 loginUrl 处理：<br>(1) 当请求是 loginUrl 时，其中又根据是否为 POST 请求判断是否是 login 页面请求还是，login 提交。<br>(2) 当请求是非 loginUrl 时，向 session 存储了一个属性 shiroSavedRequest， 然后跳转到登录页面。</p><h2 id="authcBasic"><a href="#authcBasic" class="headerlink" title="authcBasic"></a>authcBasic</h2><p>BasicHttpAuthenticationFilter</p><p>onAccessDenied 逻辑：</p><ol><li>通过请求头 Authorization 判断是否为 login 请求，如果是，执行 executeLogin 逻辑，获取 username, password 构造 AuthenticationToken 进行 Realm 认证。</li><li>如果不是 login 请求，或者登录失败，发送质询</li></ol><h2 id="invalidRequest"><a href="#invalidRequest" class="headerlink" title="invalidRequest"></a>invalidRequest</h2><p>InvalidRequestFilter</p><p>默认全局过滤器，过滤一些非法请求</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Shiro-DefaultFilter-使用笔记&quot;&gt;&lt;a href=&quot;#Shiro-DefaultFilter-使用笔记&quot; class=&quot;headerlink&quot; title=&quot;Shiro DefaultFilter 使用笔记&quot;&gt;&lt;/a&gt;Shiro DefaultF</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Shiro" scheme="http://example.com/tags/Shiro/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud OpenFeign</title>
    <link href="http://example.com/2022/07/13/Spring-Cloud/Spring-Cloud-OpenFeign/"/>
    <id>http://example.com/2022/07/13/Spring-Cloud/Spring-Cloud-OpenFeign/</id>
    <published>2022-07-12T16:35:38.000Z</published>
    <updated>2022-07-15T03:37:33.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h1><h2 id="1-Declarative-REST-Client-Feign"><a href="#1-Declarative-REST-Client-Feign" class="headerlink" title="1. Declarative REST Client: Feign"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign">1. Declarative REST Client: Feign</a></h2><p>Feign 是一个声明式 Web 服务客户端。它使得编写 Web 服务客户端更容易。使用 Feign 创建一个接口并注解它。它具有可插入的注解支持，包括 Feign 注解和 JAX-RS 注解。Feign 还支持可插拔的编码器和解码器。Spring Cloud 增加了对 Spring MVC 注解的支持，以及支持使用 Spring Web 中默认项相同的 <code>HttpMessageConverters</code>。Spring Cloud 集成了 Ribbon 以及 Eureka，Spring Cloud CiruitBreaker，以及 Spring Cloud LoadBalancer，以便在使用 Feign 时提供负载均衡的 HTTP 客户端。</p><h3 id="1-1-How-to-Include-Feign"><a href="#1-1-How-to-Include-Feign" class="headerlink" title="1.1. How to Include Feign"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#netflix-feign-starter">1.1. How to Include Feign</a></h3><p>要在项目中包含 Feign，请使用 group 为 <code>org.springframework.cloud</code>，artifact id 为 <code>spring-cloud-starter-openfeign</code> 的 starter。有关使用当前 Spring Cloud Release Train 设置你的构建系统的详情，参见 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</a></p><p>示例 Spring Boot 应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StoreClient.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;stores&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StoreClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)</span></span><br><span class="line">    List&lt;Store&gt; <span class="title function_">getStores</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)</span></span><br><span class="line">    Page&lt;Store&gt; <span class="title function_">getStores</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.POST, value = &quot;/stores/&#123;storeId&#125;&quot;, consumes = &quot;application/json&quot;)</span></span><br><span class="line">    Store <span class="title function_">update</span><span class="params">(<span class="meta">@PathVariable(&quot;storeId&quot;)</span> Long storeId, Store store)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>@FeignClient</code> 注解中，字符串 value（即上面的 “stores”）是一个任意的 client name，用于创建一个 Ribbon 负载均衡或者 Spring Cloud LoadBalancer。你还可以使用 <code>url</code> 属性（绝对值或者一个主机名）指定一个 URL。应用上下文中 Bean 的名称是接口的完全限定名。为了指定你自己的别名，你可以使用 <code>@FeignClient</code> 注解的 <code>qualifiers</code> 值。</p><p>上面的负载均衡客户端将会希望发现 “stores” 服务的物理地址。如果你的应用是 Eureka 客户端，则它将在 Eureka 服务注册表中解析该服务。如果你不想使用 Eureka，则可以使用 <code>SimpleDiscoveryClient</code> 在外部配置中简单地配置服务器列表。</p><h3 id="1-2-Overriding-Feign-Defaults"><a href="#1-2-Overriding-Feign-Defaults" class="headerlink" title="1.2. Overriding Feign Defaults"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-overriding-defaults">1.2. Overriding Feign Defaults</a></h3><p>Spring Cloud 的 Feign 支持中的一个核心概念就是有名客户端。每个 Feign 客户端都是一群组件的部分，它们共同协作按需与远程服务进行连接，并且这个整体有一个你作为开发者使用 <code>@FeignClient</code> 注解赋予的名字。Spring Cloud 使用 <code>FeignClientsConfiguration</code> 为每个有名客户端按需地，以 <code>ApplicationContext</code> 的形式创建一个全新的整体。这包含一个 <code>feign.Decoder</code>，一个 <code>feign.Encoder</code>，以及一个 <code>feign.Contract</code>。可以使用 <code>@FeignClient</code> 注解的 <code>contextId</code> 属性覆盖该整体的名称。</p><p>Spring Cloud 使你可以使用 <code>@FeignClient</code> 声明额外的配置（覆盖 <code>FeignClientsConfiguration</code>）完全控制 feign 客户端。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;stores&quot;, configuration = FooConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StoreClient</span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，客户端是由已经存在于 <code>FeignClientsConfiguration</code> 中的组件，以及 <code>FooConfiguration</code> （后者覆盖前者）中的种种组成。</p><blockquote><p><code>FooConfiguration</code> 不需要 <code>@Configuration</code> 注解。但是，如果这样做，请将其从任何 <code>@ComponentScan</code> 中排除，否则将包含此配置，因为它将将成为 <code>feign.Decoder</code>，<code>feign.Encoder</code>，<code>feign.Contract</code> 等默认源。</p></blockquote><p><code>name</code> 和 <code>url</code> 属性也支持占位符。</p><h4 id="1-2-1-SpringEncoder-configuration"><a href="#1-2-1-SpringEncoder-configuration" class="headerlink" title="1.2.1. SpringEncoder configuration"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#springencoder-configuration">1.2.1. SpringEncoder configuration</a></h4><p>在我们提供的 <code>SpringEncoder</code> 中，我们为二进制内容类型设置了 <code>null</code> 字符集，并未所有其他的设置了 <code>UTF-8</code>。</p><p>你可以通过设置 <code>feign.encoder.charset-from-content-type</code> 的值为 <code>true</code>来修改此行为，以从 <code>Content-Type</code> 头部 charset 获得字符集。</p><h3 id="1-3-Timeout-Handling"><a href="#1-3-Timeout-Handling" class="headerlink" title="1.3. Timeout Handling"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#timeout-handling">1.3. Timeout Handling</a></h3><p>我们可以在默认和有名客户端上配置超时。OpenFeign 可与两个超时参数一起使用：</p><ul><li><code>connectTime</code></li><li><code>readTimeout</code></li></ul><h3 id="1-5-Feign-Hystrix-Support"><a href="#1-5-Feign-Hystrix-Support" class="headerlink" title="1.5. Feign Hystrix Support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-hystrix">1.5. Feign Hystrix Support</a></h3><p>如果 Hystrix 在类路径，并且 <code>feign.hystrix.enabled=true</code>，Feign 将用熔断器包装所有方法。还提供返回一个 <code>com.netflix.hystrix.HystrixCommand</code>。这使你可以使用响应式模式。</p><h3 id="1-6-Feign-Hystrix-Fallbacks"><a href="#1-6-Feign-Hystrix-Fallbacks" class="headerlink" title="1.6. Feign Hystrix Fallbacks"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-hystrix-fallback">1.6. Feign Hystrix Fallbacks</a></h3><h3 id="1-10-Feign-Inheritance-Support"><a href="#1-10-Feign-Inheritance-Support" class="headerlink" title="1.10. Feign Inheritance Support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-inheritance">1.10. Feign Inheritance Support</a></h3><p>Feign 通过单继承接口支持样板 API。这允许你将通用操作分组为方便的基础接口。</p><p><strong>UserService.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value =&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserResource.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserResource</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserClient.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> project.user;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-Timeout-Handling-1"><a href="#1-3-Timeout-Handling-1" class="headerlink" title="1.3. Timeout Handling"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#timeout-handling">1.3. Timeout Handling</a></h3><p>我们可以在默认和有名客户端上配置 timeout 属性。OpenFeign 用这两个 timeout 参数进行工作：</p><ul><li><code>connectTimeout</code> 防止由于较长的服务端处理时间导致的阻塞。</li><li><code>readTimeout</code> 在连接建立的时候使用，并且当返回响应花费太久的时候会触发</li></ul><blockquote><p>如果服务没有运行或者不可用，数据包可能以连接被拒绝结束。通信以错误信息或者后背方式结束。如果 <code>connectTimeout</code> 设置非常低，这就有可能在 <code>connectTimeout</code> 之前就结束通信。执行查找以及接收这样的数据包的时间可能会产生较大一部分延迟。可以基于涉及到 DNS 查找的远程主机修改该值。</p></blockquote><p>当启用 Hystrix 后，超时配置默认是 1000 毫秒。因此，它可能发生在我们前面配置的客户端超时之前。增加该超时，防止发生这种情况。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">timeout:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure><blockquote><p>当启用 Hystrix 的 timeout 且它的 timeout 设置得比 feign client 更长时，<code>HystrixTimeoutException</code> 会包装一个 feign 异常。否则，唯一的区别就是异常的原因。<code>HystrixTimeoutException</code> 的目的是包装先发生的任何运行时异常，并抛出自身实例。</p></blockquote><h3 id="1-5-Feign-Hystrix-Support-1"><a href="#1-5-Feign-Hystrix-Support-1" class="headerlink" title="1.5. Feign Hystrix Support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-hystrix">1.5. Feign Hystrix Support</a></h3><p>如果 Hystrix 在类路径中，且 <code>feign.hystrix.enabled=true</code>，Feign 将使用熔断器包装所有的方法。还可以返回一个 <code>HystrixCommand</code>。</p><h3 id="1-12-Feign-logging"><a href="#1-12-Feign-logging" class="headerlink" title="1.12. Feign logging"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#feign-logging">1.12. Feign logging</a></h3><p>为每个 Feign 客户端创建了一个 logger。默认情况下，logger 的名字是用于创建 Feign 客户端的接口的完全限定类名。Feign 日志仅仅响应 <code>DEBUG</code> 级别。</p><p><strong>application.yml</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.project.user.UserClient</span>: <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><p>你可以为每个客户端配置的 <code>Logger.Level</code> 对象，告诉 Feign 多少要记录。选项如下：</p><ul><li><code>NONE</code>，不记录日志（DEFAULT）</li><li><code>BASIC</code>，仅仅记录请求方法，URL，响应状态码，以及执行时间</li><li><code>HEADERS</code>，记录基本信息，以及请求头和响应头</li><li><code>FULL</code>，记录来自请求或响应的头部</li></ul><h3 id="1-13-Feign-QueryMap-support"><a href="#1-13-Feign-QueryMap-support" class="headerlink" title="1.13. Feign @QueryMap support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#feign-querymap-support">1.13. Feign @QueryMap support</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Cloud-OpenFeign&quot;&gt;&lt;a href=&quot;#Spring-Cloud-OpenFeign&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud OpenFeign&quot;&gt;&lt;/a&gt;Spring Cloud OpenFei</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring Cloud" scheme="http://example.com/tags/Spring-Cloud/"/>
    
    <category term="OpenFeign" scheme="http://example.com/tags/OpenFeign/"/>
    
  </entry>
  
  <entry>
    <title>Eureka 配置实践</title>
    <link href="http://example.com/2022/07/12/Eureka-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2022/07/12/Eureka-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-07-12T08:28:41.000Z</published>
    <updated>2022-07-12T10:23:05.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h1><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>确保引入 maven 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>Eureka 的 Server 配置没有特别好的文档，官网的指引也只是让你看源代码注释。</p><h3 id="Eureka-Instance-Config"><a href="#Eureka-Instance-Config" class="headerlink" title="Eureka Instance Config"></a>Eureka Instance Config</h3><ul><li>Instance Id<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getInstanceId</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><p>获得该实例注册到 eureka 的唯一 ID（在 appName 范围内）</p><ul><li>App Name<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getAppname</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul><p>获得注册到 eureka 的应用名称</p><ul><li>lease renewal interval in seconds</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getLeaseRenewalIntervalInSeconds()</span><br></pre></td></tr></table></figure><p>字面意思：租约续期间隔。</p><p>表示 eureka 客户端多久发送心跳给 eureka server，告诉它自己还活着。如果心跳在 <code>getLeaseExpirationDurationInSeconds()</code> 指定的期间还未收到，eureka server 就会从它的视图中移除该实例，从而禁用了该实例的流量。</p><blockquote><p>该参数只是用于 Eureka Client 发送心跳间隔。需要确保与 Eureka Server 的 <code>getLeaseExpirationDurationInSeconds()</code> 参数值一致，否则 Eureka Server 无法正常工作。</p></blockquote><ul><li>lease expiration duration in seconds</li></ul><p>表示 Eureka Server 自收到某个实例最后一次心跳，在可以从它的视图中移除该实例从而禁用该实例流量之前，等待的时间，单位：秒。</p><p>设置该值太长可能意味着，即使该实例并不存活，也可以将流量路由到该实例。设置该值太小可能意味着，由于临时的网络故障，该实例可能会从流量中剔除。该值设置至少高于 <code>getLeaseRenewalIntervalInSeconds()</code> 指定的值。</p><blockquote><p>如果该值比 <code>getLeaseRenewalIntervalInSeconds()</code> 小，那么实例将无法存活于注册表，即使注册成功，很快就被剔除。</p></blockquote><h3 id="Eureka-Server-Config"><a href="#Eureka-Server-Config" class="headerlink" title="Eureka Server Config"></a>Eureka Server Config</h3><ul><li>AWS Access Id</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getAWSAccessId</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>AWS 云 Access ID</p><ul><li>AWS Secret Key</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getAWSSecretKey</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>AWS 云 Secret Key</p><ul><li><p>EIPBindRebindRetries</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getEIPBindRebindRetries</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>EIPBindingRetryIntervalMsWhenUnbound</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getEIPBindingRetryIntervalMsWhenUnbound</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p>EIPBindingRetryIntervalMs</p></li><li><p>enable-self-preservation</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">shouldEnableSelfPreservation</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>是否开启自我保护机制。</p><p>启用后，Eureka Server 将跟踪其应该从服务接收到的续约次数。任何时候，续约数量低于 <code>getRenewalPercentThreshold()</code> 定义的阈值百分比，Eureka Server 会关闭过期以避免危险。这有助于在 Eureka Client 与 Eureka Server 之间发生网络问题时维持注册表信息。</p><blockquote><p>注意，自我保护是防止一些网络问题误杀。</p></blockquote><ul><li>eviction-interval-timer-in-ms</li></ul><p>清理无效节点的时间间隔。默认值 60000</p><blockquote><p>可以将这个时间设置的短一些，进行快速下线。防止使用不可用的服务。</p></blockquote><ul><li>expected-client-renewalI-interval-seconds</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getExpectedClientRenewalIntervalSeconds</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>期望客户端以这个间隔发送它们的心跳。</p><p>默认值：30</p><p>如果客户端以不同的频率发送心跳，例如每 15 秒发送一次，那么应该相应地调整此参数，否则，自我保护将无法按预期工作。</p><blockquote><p>该参数用于计算内部的阈值。</p></blockquote><ul><li>Response Cache Update Interval Ms</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">getResponseCacheUpdateIntervalMs</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>获取更新 Eureka Client 负载缓存的时间间隔。</p><ul><li>Use Read Only Response Cache</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">shouldUseReadOnlyResponseCache</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>字面意思：是否使用只读响应缓存</p><p><code>com.netflix.eureka.registry.ResponseCache</code> 当前使用两级缓存策略来响应。带有过期策略的独写缓存，以及不会过期的只读缓存。</p><ul><li>Renewal Percent Threshold</li></ul><p>在由 <code>getRenewalThresholdUpdateIntervalMs()</code> 指定的期间，期望从服务端续期次数的最小百分比。</p><p>如果续约降低到阈值以下，并且启用了 <code>shouldEnableSelfPreservation()</code> 则会禁用过期。</p><ul><li>getRenewalThresholdUpdateIntervalMs</li></ul><p>由 <code>getRenewalPercentThreshold()</code> 指定的阈值，应该更新的间隔。阈值更新间隔</p><ul><li>shouldEnableSelfPreservation</li></ul><p>检查 eureka server 是否启用了自我保护。</p><p>当启用，服务会跟踪它应该从微服务接受到的续约次数。在任何时候，续订次数的数量低于 <code>getRenewalPercentThreshold()</code> 定义的阈值百分比，服务器就会关闭过期以避免危险。这有助于在客户端和服务端之间产生网络问题时服务器维持注册信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Eureka-Server&quot;&gt;&lt;a href=&quot;#Eureka-Server&quot; class=&quot;headerlink&quot; title=&quot;Eureka Server&quot;&gt;&lt;/a&gt;Eureka Server&lt;/h1&gt;&lt;h2 id=&quot;如何使用？&quot;&gt;&lt;a href=&quot;#如何使用</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Cloud Netflix</title>
    <link href="http://example.com/2022/07/12/Spring-Cloud/Spring-Cloud-Netflix/"/>
    <id>http://example.com/2022/07/12/Spring-Cloud/Spring-Cloud-Netflix/</id>
    <published>2022-07-12T08:26:07.000Z</published>
    <updated>2022-07-17T02:50:07.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/">Spring Cloud Netflix</a></h1><h2 id="1-Service-Discovery-Eureka-Clients"><a href="#1-Service-Discovery-Eureka-Clients" class="headerlink" title="1. Service Discovery: Eureka Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#service-discovery-eureka-clients">1. Service Discovery: Eureka Clients</a></h2><p>服务发现是微服务架构的关键原则之一。手工配置每个客户端或基于某种约定是非常脆弱的。Eureka 是 Netflix 服务发现服务端和客户端。服务可以被配置和部署，变得高可用，每个服务都会复制其他已经注册服务的状态。</p><h3 id="1-1-How-to-Include-Eureka-Client"><a href="#1-1-How-to-Include-Eureka-Client" class="headerlink" title="1.1. How to Include Eureka Client"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-eureka-client-starter">1.1. How to Include Eureka Client</a></h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-Registering-with-Eureka"><a href="#1-2-Registering-with-Eureka" class="headerlink" title="1.2. Registering with Eureka"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#registering-with-eureka">1.2. Registering with Eureka</a></h3><p>当 Eureka Client 注册 Eureka Server 时，它会提供自己的元数据，比如：主机，端口，健康指示器 URL，主页等详细信息。Eureka Server 接收属于某个服务的每个实例的心跳消息。如果心跳在可配置的时间表上失败，则通常从注册表中删除实例。</p><p>以下实例展示了最小的 Eureka Client 应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(Application.class).web(<span class="literal">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，前面的示例展示了一个普通的 Spring Boot 应用。通过包含 <code>spring-cloud-starter-netflix-eureka-client</code> 于类路径，你的应用会自动注册到 Eureka Server。需要配置的就是定位 Eureka Server，如下示例所示：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure><p>在前面的示例中，<code>defaultZone</code> 是一个魔术字符串备用值，它为任何没有表示首选项的客户端提供服务 URL（换句话说，这是一个有用的默认值）。</p><blockquote><p><code>defaultZone</code> 属性是大小写敏感，并且需要驼峰格式，因为 <code>serviceUrl</code> 属性是一个 <code>Map&lt;String, String&gt;</code>。因此，<code>defaultZone</code> 属性不遵循通常的 Spring Boot 蛇形约定 <code>default-zone</code>。</p></blockquote><p>默认的应用名（即，服务 ID），虚拟机主机名，以及非安全端口（从 <code>Environment</code> 中获取）分别是 <code>$&#123;spring.application.name&#125;</code>，<code>$&#123;spring.application.name&#125;</code>，以及 <code>$&#123;server.port&#125;</code>。</p><h3 id="1-3-Authenticating-with-the-Eureka-Server"><a href="#1-3-Authenticating-with-the-Eureka-Server" class="headerlink" title="1.3. Authenticating with the Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#authenticating-with-the-eureka-server">1.3. Authenticating with the Eureka Server</a></h3><p>如果 eureka.client.serviceUrl.defaultZone 之一有凭证嵌入其中，则会自动把 HTTP basic 认证添加到 eureka 客户端。</p><p><strong>注意</strong> 这里并不是给 URL 添加凭证，只是激活 HTTP basic 用于请求的认证。</p><h3 id="1-4-Status-Page-and-Health-Indicator"><a href="#1-4-Status-Page-and-Health-Indicator" class="headerlink" title="1.4. Status Page and Health Indicator"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#status-page-and-health-indicator">1.4. Status Page and Health Indicator</a></h3><h3 id="1-5-Registering-a-Secure-Application"><a href="#1-5-Registering-a-Secure-Application" class="headerlink" title="1.5. Registering a Secure Application"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#registering-a-secure-application">1.5. Registering a Secure Application</a></h3><p>如果你的应用希望通过 HTTPS 连接，你可以在 <code>EurekaInstanceConfig</code> 设置两个标记：</p><ul><li><code>eureka.instance.[nonSecurePortEnabled]=[false]</code></li><li><code>eureka.instance.[securePortEnabled]=[true]</code></li></ul><h3 id="1-6-Eureka’s-Health-Checks"><a href="#1-6-Eureka’s-Health-Checks" class="headerlink" title="1.6. Eureka’s Health Checks"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#eurekas-health-checks">1.6. Eureka’s Health Checks</a></h3><h3 id="1-7-Eureka-Metadata-for-Instances-and-Clients"><a href="#1-7-Eureka-Metadata-for-Instances-and-Clients" class="headerlink" title="1.7. Eureka Metadata for Instances and Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#eureka-metadata-for-instances-and-clients">1.7. Eureka Metadata for Instances and Clients</a></h3><h4 id="1-7-1-Using-Eureka-on-Cloud-Foundry"><a href="#1-7-1-Using-Eureka-on-Cloud-Foundry" class="headerlink" title="1.7.1. Using Eureka on Cloud Foundry"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-eureka-on-cloud-foundry">1.7.1. Using Eureka on Cloud Foundry</a></h4><h4 id="1-7-2-Using-Eureka-on-AWS"><a href="#1-7-2-Using-Eureka-on-AWS" class="headerlink" title="1.7.2. Using Eureka on AWS"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-eureka-on-aws">1.7.2. Using Eureka on AWS</a></h4><p>如果你计划将应用程序部署到 AWS 云上，则必须将 Eureka 实例配置为 AWS-aware。你可以通过自定义 <code>EurekaInstanceConfigBean</code> 来做到这一点，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&quot;!default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> EurekaInstanceConfigBean <span class="title function_">eurekaInstanceConfig</span><span class="params">(InetUtils inetUtils)</span> &#123;</span><br><span class="line">  <span class="type">EurekaInstanceConfigBean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EurekaInstanceConfigBean</span>(inetUtils);</span><br><span class="line">  <span class="type">AmazonInfo</span> <span class="variable">info</span> <span class="operator">=</span> AmazonInfo.Builder.newBuilder().autoBuild(<span class="string">&quot;eureka&quot;</span>);</span><br><span class="line">  b.setDataCenterInfo(info);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-3-Changing-the-Eureka-Instance-ID"><a href="#1-7-3-Changing-the-Eureka-Instance-ID" class="headerlink" title="1.7.3. Changing the Eureka Instance ID"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#changing-the-eureka-instance-id">1.7.3. Changing the Eureka Instance ID</a></h3><p>一般地，NetFlix Eureka 实例以 host name 注册为其主机名。Spring Cloud Eureka 提供了一个明确的默认值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;spring.cloud.client.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span><br></pre></td></tr></table></figure><p>例如：<code>myhost:myappname:8080</code></p><p>在 Spring Cloud 中，你可以通过提供唯一标识符 <code>eureka.instance.instanceId</code> 来覆盖该值：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instanceId:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;vcap.application.instance_id:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-8-Using-the-EurekaClient"><a href="#1-8-Using-the-EurekaClient" class="headerlink" title="1.8. Using the EurekaClient"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-the-eurekaclient">1.8. Using the EurekaClient</a></h3><p>一旦你拥有一个发现客户端的应用程序，你可以使用它从 Eureka Server 发现服务实例。这样做的一种方法是使用本地 <code>com.netflix.discovery.EurekaClient</code></p><h2 id="1-9-Alternatives-to-the-Native-Netflix-EurekaClient"><a href="#1-9-Alternatives-to-the-Native-Netflix-EurekaClient" class="headerlink" title="1.9. Alternatives to the Native Netflix EurekaClient"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#alternatives-to-the-native-netflix-eurekaclient">1.9. Alternatives to the Native Netflix EurekaClient</a></h2><p>你无需使用原生的 NetFlix 的 <code>EurekaClient</code>。而且，在某种形式的包装之后通常会更容易使用它。通过逻辑 eureka 服务标识符（VIPs）而不是物理 URL，Spring Cloud 支持 Feign（一个 REST 客户端构建器）以及 Spring RestTemplate。</p><h2 id="1-10-Why-Is-It-so-Slow-to-Register-a-Service"><a href="#1-10-Why-Is-It-so-Slow-to-Register-a-Service" class="headerlink" title="1.10. Why Is It so Slow to Register a Service?"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#why-is-it-so-slow-to-register-a-service">1.10. Why Is It so Slow to Register a Service?</a></h2><p>作为一个实例，还涉及到向注册中心（通过 client 的 serviceUrl）的定期心跳，默认时间为 30 秒。一个服务，直到该实例，注册中心，客户端缓存中都有相同的元数据（因此需要 3 个心跳），客户端才能发现其不可用。你可以通过设置 <code>eureka.instance.leaseRenewalIntervalInSeconds</code> 来更改周期。将其设置为小于 30 的值，可以加快客户端连接到其他服务的进程。在生产中，由于注册中心的内部计算对租赁续期做了假设，因此最好坚持使用默认值。</p><h1 id="2-Service-Discovery-Eureka-Server"><a href="#2-Service-Discovery-Eureka-Server" class="headerlink" title="2. Service Discovery: Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server">2. Service Discovery: Eureka Server</a></h1><p><a href="https://gitee.com/jiang_chun_bo/cannedbread-parent/tree/master/cannedbread-eureka-server">参考配置</a></p><h2 id="2-1-How-to-Include-Eureka-Server"><a href="#2-1-How-to-Include-Eureka-Server" class="headerlink" title="2.1. How to Include Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-eureka-server-starter">2.1. How to Include Eureka Server</a></h2><p>要在你的项目中包含 Eureka Server，请使用 group ID 为 <code>org.springframework.cloud</code> 以及 artifact ID 为 <code>spring-cloud-starter-netflix-eureka-server</code> 的 starter。参见 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</a></p><h2 id="2-2-How-to-Run-a-Eureka-Server"><a href="#2-2-How-to-Run-a-Eureka-Server" class="headerlink" title="2.2. How to Run a Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-running-eureka-server">2.2. How to Run a Eureka Server</a></h2><p>服务端有一个主页和 HTTP API （在 &#x2F;eureka&#x2F;* 下）。</p><p>&amp;nbsp;</p><h2 id="2-3-High-Availability-Zones-and-Regions"><a href="#2-3-High-Availability-Zones-and-Regions" class="headerlink" title="2.3. High Availability, Zones and Regions"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-zones-and-regions">2.3. High Availability, Zones and Regions</a></h2><p>Eureka 服务端并没有后端存储，但是注册表中的服务实例都必须发送心跳，来保持它们的注册最新（这可以在内存中完成）。客户端还有一个内存中的 Eureka 注册缓存，因此对于每个服务的请求，不必跳转到注册表。</p><p>默认情况下，每个 Eureka 服务端也是 Eureka 客户端，至少需要一个服务 URL 来定位对等体。如果没有提供服务 URL，服务跑起来并开始工作，就会填充大量的噪音到日志中（无法与对等体注册的异常）。</p><p>&amp;nbsp;</p><h2 id="2-4-Standalone-Mode"><a href="#2-4-Standalone-Mode" class="headerlink" title="2.4. Standalone Mode"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-standalone-mode">2.4. Standalone Mode</a></h2><p>双缓存和心跳机制，两者组合可以让独立 Eureka Server 对于失败具有相当的弹性，只要有某种监视器或者弹性的运行时间保持存活。在独立模式下，你可能更希望关闭客户端行为，避免不断尝试并无法达到对等体的错误。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong> serviceUrl 需要指向本地实例相同的主机。</p><h2 id="2-5-Peer-Awareness"><a href="#2-5-Peer-Awareness" class="headerlink" title="2.5. Peer Awareness"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-peer-awareness">2.5. Peer Awareness</a></h2><p>通过运行多个实例，并让他们互相注册，eureka 可以变得更具有弹性和可用性。实际上，这是默认的行为，所以你只需要向对等体添加有效的 serviceUrl 即可。</p><p>为了在单个主机上体验对等感知，可以操作 <code>/etc/hosts</code> 文件来解析主机名。实际上，如果运行在一台已知主机名的机器上时，没有必要配置 <code>eureka.instance.hostname</code>。默认地，会使用 <code>java.net.InetAddress</code> 寻找。</p><p>你可以向一个系统添加多个对等体，只要它们通过至少边缘彼此连接，它们之间就会同步注册信息。如果对等体物理分离，那么系统原则上存在脑裂的问题。</p><h2 id="2-6-When-to-Prefer-IP-Address"><a href="#2-6-When-to-Prefer-IP-Address" class="headerlink" title="2.6. When to Prefer IP Address"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-prefer-ip-address">2.6. When to Prefer IP Address</a></h2><p>在某些情况下，eureka 更偏向于建议使用服务的 IP 而不是主机名。设置 <code>eureka.instance.preferIpAddress</code> 为 true，那么当应用注册到 eureka 时，将会使用 IP 地址而不是主机名。</p><blockquote><p>如果 Java 无法确定 hostname，那么就会发送 IP 地址给 eureka。</p></blockquote><h2 id="2-8-Disabling-Ribbon-with-Eureka-Server-and-Client-starters"><a href="#2-8-Disabling-Ribbon-with-Eureka-Server-and-Client-starters" class="headerlink" title="2.8. Disabling Ribbon with Eureka Server and Client starters"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#disabling-ribbon-with-eureka-server-and-client-starters">2.8. Disabling Ribbon with Eureka Server and Client starters</a></h2><p><code>spring-cloud-starter-netflix-eureka-server</code> 和 <code>spring-cloud-starter-netflix-eureka-client</code> y与 <code>spring-cloud-starter-netflix-ribbon</code> 一起出现。由于 Ribbon 负载均衡处于维护模式，因此我们建议切换使用 Spring Cloud LoadBalancer，也包含在 Eureka starter 中。</p><p>为此，你可以将 <code>spring.cloud.loadbalancer.ribbon.enabled</code> 属性设置为 <code>false</code>。</p><p>然后，你还可以从构建文件中地 Eureka starter 中排除 ribbon 相关的依赖，像这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-Circuit-Breaker-Spring-Cloud-Circuit-Breaker-With-Hystrix"><a href="#3-Circuit-Breaker-Spring-Cloud-Circuit-Breaker-With-Hystrix" class="headerlink" title="3. Circuit Breaker: Spring Cloud Circuit Breaker With Hystrix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix">3. Circuit Breaker: Spring Cloud Circuit Breaker With Hystrix</a></h2><h3 id="3-1-Disabling-Spring-Cloud-Circuit-Breaker-Hystrix"><a href="#3-1-Disabling-Spring-Cloud-Circuit-Breaker-Hystrix" class="headerlink" title="3.1. Disabling Spring Cloud Circuit Breaker Hystrix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#disabling-spring-cloud-circuit-breaker-hystrix">3.1. Disabling Spring Cloud Circuit Breaker Hystrix</a></h3><p>你可以通过设置 <code>spring.cloud.circuitbreaker.hystrix.enabled</code> 为 <code>false</code> 来禁用自动配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.cloud.circuitbreaker.hystrix.enabled=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="3-2-Configuring-Hystrix-Circuit-Breakers"><a href="#3-2-Configuring-Hystrix-Circuit-Breakers" class="headerlink" title="3.2. Configuring Hystrix Circuit Breakers"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#configuring-hystrix-circuit-breakers">3.2. Configuring Hystrix Circuit Breakers</a></h3><h4 id="3-2-1-Default-Configuration"><a href="#3-2-1-Default-Configuration" class="headerlink" title="3.2.1. Default Configuration"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#default-configuration">3.2.1. Default Configuration</a></h4><p>为了给您所有的断路器提供默认配置，请创建传递一个 <code>HystrixCircuitBreakerFactory</code> 或者 <code>ReactiveHystrixCircuitBreakerFactory</code> 的 <code>Customize</code> Bean。<code>configureDefault</code> 方法可用于提供默认配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;HystrixCircuitBreakerFactory&gt; <span class="title function_">defaultConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configureDefault(id -&gt; HystrixCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))</span><br><span class="line">            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">            .withExecutionTimeoutInMilliseconds(<span class="number">4000</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Reactive-Example"><a href="#Reactive-Example" class="headerlink" title="Reactive Example"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#reactive-example">Reactive Example</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;ReactiveHystrixCircuitBreakerFactory&gt; <span class="title function_">defaultConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configureDefault(id -&gt; HystrixObservableCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))</span><br><span class="line">            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                    .withExecutionTimeoutInMilliseconds(<span class="number">4000</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-Specific-Circuit-Breaker-Configuration"><a href="#3-2-2-Specific-Circuit-Breaker-Configuration" class="headerlink" title="3.2.2. Specific Circuit Breaker Configuration"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#specific-circuit-breaker-configuration">3.2.2. Specific Circuit Breaker Configuration</a></h4><p>类似于提供默认配置，您可以传递一个 <code>HystrixCircuitBreakerFactory</code> 创建一个 <code>Customize</code> Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;HystrixCircuitBreakerFactory&gt; <span class="title function_">customizer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configure(builder -&gt; builder.commandProperties(</span><br><span class="line">                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(<span class="number">2000</span>)), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Reactive-Example-1"><a href="#Reactive-Example-1" class="headerlink" title="Reactive Example"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#reactive-example-2">Reactive Example</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;ReactiveHystrixCircuitBreakerFactory&gt; <span class="title function_">customizer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configure(builder -&gt; builder.commandProperties(</span><br><span class="line">                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(<span class="number">2000</span>)), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Circuit-Breaker-Hystrix-Clients"><a href="#4-Circuit-Breaker-Hystrix-Clients" class="headerlink" title="4. Circuit Breaker: Hystrix Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#circuit-breaker-hystrix-clients">4. Circuit Breaker: Hystrix Clients</a></h2><p>Netflix 已经创建了一个名为 Hystrix 的库，该库实现了 <a href="https://martinfowler.com/bliki/CircuitBreaker.html">circuit breaker pattern</a>（熔断器模式）。在微服务体系结构中，通常具有多层服务调用，如下示例所示：</p><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/main/docs/src/main/asciidoc/images/Hystrix.png"><p><strong>Figure 1. Microservice Graph</strong></p><p>较低级别的服务失败可能导致级联失败，直至用户。当对特定服务调用超过 <code>circuitBreaker.requestVolumeThreshold</code>（默认是 20 次请求），并且，在一个由 <code>metrics.rollingStats.timeInMilliseconds</code> 定义滑动窗口（默认为 10 秒）内，失败百分比大于 <code>circuitBreaker.errorThresholdPercentage</code>（默认 &gt;50%）， 熔断器会打开，并且不进行调用。在出错并且熔断器打开的情况下，开发者可以提供一个 fallback。</p><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/main/docs/src/main/asciidoc/images/HystrixFallback.png"><p><strong>Figure 2. Hystrix fallback prevents cascading failures</strong></p><h2 id="4-1-How-to-Include-Hystrix"><a href="#4-1-How-to-Include-Hystrix" class="headerlink" title="4.1. How to Include Hystrix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#how-to-include-hystrix">4.1. How to Include Hystrix</a></h2><p>若要在你的项目中包含 Hystrix，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-netflix-hystrix</code> 的 starter。</p><p>下面示例展示了一个极简的带有 Hystrix 熔断器的 Eureka 服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(Application.class).web(<span class="literal">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoreIntegration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getStores</span><span class="params">(Map&lt;String, Object&gt; parameters)</span> &#123;</span><br><span class="line">        <span class="comment">//do stuff that might fail</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">defaultStores</span><span class="params">(Map&lt;String, Object&gt; parameters)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/* something useful */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@HystrixCommand</code> 由名为 <a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica">“javanica”</a> 的 Netflix contrib 库提供。Spring Cloud 以代理的方式包装具有该注解的 Spring Bean，用于连接到 Hystrix 熔断器。熔断器计算何时打开和关闭回路，以及在失败的情况下做什么。</p><p>要配置 <code>@HystrixCommand</code>，你可以以 <code>@HystrixProperty</code> 注解列表的形式使用 <code>commandProperties</code> 属性。有关更多详情，请参见<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration">此处</a>。有关可用属性的详细信息，参见 <a href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix wiki</a></p><h2 id="4-2-Propagating-the-Security-Context-or-Using-Spring-Scopes"><a href="#4-2-Propagating-the-Security-Context-or-Using-Spring-Scopes" class="headerlink" title="4.2. Propagating the Security Context or Using Spring Scopes"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-hystrix-starter">4.2. Propagating the Security Context or Using Spring Scopes</a></h2><p>如果你希望一些线程的本地上下文传播到 <code>@HystrixCommand</code>，默认声明并不起作用，因为它在线程池中执行命令（在超时情况下）。你可以通过配置或者直接在注解上，请求 Hystrix 使用不同的 “Isolation Strategy”，切换 Hystrix 使用相同的线程作为调用者。以下示例演示了在注解中设置线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;stubMyService&quot;,</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;</span></span><br><span class="line"><span class="meta">      @HystrixProperty(name=&quot;execution.isolation.strategy&quot;, value=&quot;SEMAPHORE&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-3-Health-Indicator"><a href="#4-3-Health-Indicator" class="headerlink" title="4.3. Health Indicator"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#health-indicator">4.3. Health Indicator</a></h3><p>连接熔断器的状态也可以暴露在调用应用的 <code>/health</code> 端点上，如下示例所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hystrix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;openCircuitBreakers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;StoreIntegration::getStoresByLocationLink&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CIRCUIT_OPEN&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="4-4-Hystrix-Metrics-Stream"><a href="#4-4-Hystrix-Metrics-Stream" class="headerlink" title="4.4. Hystrix Metrics Stream"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#hystrix-metrics-stream">4.4. Hystrix Metrics Stream</a></h3><p>若要启动 Hystrix metrics stream，请包含关于 <code>spring-boot-starter-actuator</code> 的依赖，并设置 <code>management.endpoints.web.exposure.include=hystrix.stream</code>。这样做会暴露 <code>/actuator/hystrix.stream</code> 作为管理端点，如下示例所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-Circuit-Breaker-Hystrix-Dashboard"><a href="#5-Circuit-Breaker-Hystrix-Dashboard" class="headerlink" title="5. Circuit Breaker: Hystrix Dashboard"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#circuit-breaker-hystrix-dashboard">5. Circuit Breaker: Hystrix Dashboard</a></h2><p>只需要引入以下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置类添加以下注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure><h2 id="6-Hystrix-Timeouts-And-Ribbon-Clients"><a href="#6-Hystrix-Timeouts-And-Ribbon-Clients" class="headerlink" title="6. Hystrix Timeouts And Ribbon Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#hystrix-timeouts-and-ribbon-clients">6. Hystrix Timeouts And Ribbon Clients</a></h2><p>当使用 Hystrix command 包装你希望的 Ribbon 客户端时，确保你的 Hystrix 配置的 timeout 比 Ribbon 配置的 timeout 更长，包括任何可能的重试。例如，如果你的 Ribbon 连接 timeout 是 1 秒，并且 Ribbon 客户端可能重试请求 3 次，那么你的 Hystrix 超时时间应该略高于 3 秒。</p><blockquote><p><strong>作者的话</strong> 如果上述示例配置低于 3 秒，那么 Ribbon 可能还未完成 3 次重试就已经结束，并不满足配置预期。</p></blockquote><h3 id="6-1-How-to-Include-the-Hystrix-Dashboard"><a href="#6-1-How-to-Include-the-Hystrix-Dashboard" class="headerlink" title="6.1. How to Include the Hystrix Dashboard"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#netflix-hystrix-dashboard-starter">6.1. How to Include the Hystrix Dashboard</a></h3><p>若要在你的项目包含 Hystrix Dashboard，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-netflix-hystrix-dashboard</code> 的 starter。</p><p>若要运行 Hystrix Dashboard，请使用 <code>@EnableHystrixDashboard</code> 注解你的 Spring Boot 主类。然后访问 <code>/hystrix</code>，并将 dashboard 指向一个实例在 Hystrix 客户端应用中的 <code>/hystrix.stream</code> 端点。</p><h2 id="7-Client-Side-Load-Balancer-Ribbon"><a href="#7-Client-Side-Load-Balancer-Ribbon" class="headerlink" title="7. Client Side Load Balancer: Ribbon"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-ribbon">7. Client Side Load Balancer: Ribbon</a></h2><p>Ribbon 是一个客户端的负载均衡，可以对 HTTP 和 TCP 客户端行为进行大量控制。Feign 已经使用了 Ribbon，因此，如果你使用 <code>@FeignClient</code>，这部分也会使用。</p><blockquote><p>Ribbon 是一个进程内 LB</p></blockquote><p>Ribbon 的核心概念是有名客户端。每个负载均衡器都是组件集合的一部分，组件们在一起工作，按需要连接到远程服务器，并且整体有一个名字，这是你作为开发者赋予的名字。根据需要，Spring Cloud 通过使用 <code>RibbonClientConfiguration</code> 以 <code>ApplicationContext</code> 为每个有名客户端创建一个新的整体。这包含一个 <code>ILoadBalancer</code>，一个 <code>RestClient</code>，以及一个 <code>ServerListFiter</code>。</p><h3 id="7-1-How-to-Include-Ribbon"><a href="#7-1-How-to-Include-Ribbon" class="headerlink" title="7.1. How to Include Ribbon"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-ribbon-starter">7.1. How to Include Ribbon</a></h3><p>要在你的项目使用 ribbon，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-netflix-ribbon</code> 的 starter。有关使用当前 Spring Cloud Release Train 设置你的构建系统详情见 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</a></p><blockquote><p>如果你依赖了 eureka，则 ribbon 也会同时引入，无需显式引入</p></blockquote><h3 id="7-2-Customizing-the-Ribbon-Client"><a href="#7-2-Customizing-the-Ribbon-Client" class="headerlink" title="7.2. Customizing the Ribbon Client"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#customizing-the-ribbon-client">7.2. Customizing the Ribbon Client</a></h3><p>你可以通过使用 <code>&lt;client&gt;.ribbon.*</code> 之中的外部属性配置 Ribbon 客户端的一些部分，这类似于使用原生的 Netflix API，但你可以使用 Spring Boot 配置文件。原生选项可以在 <a href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java"><code>CommonClientConfigKey</code></a>  （ribbon-core 的一部分）以静态字段查看。</p><p>Spring Cloud 还让你通过使用 <code>@RibbonClient</code> 声明额外配置（除了 <code>RibbonClientConfiguration</code>）来完全控制客户端，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;custom&quot;, configuration = CustomConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个案例中，客户端由已经存在于 <code>RibbonClientConfiguration</code> 的组件，以及在 <code>CustomConfiguration</code> （后者通常覆盖前者）中的一些组成。</p><blockquote><p><code>CustomConfiguration</code> 类必须是 <code>@Configuration</code> 类，但是注意，不要放在主应用上下文的 <code>@ComponentScan</code> 中。否则，它将被所有的 <code>@RibbonClients</code> 共享。如果你使用 <code>@ComponentScan</code>（或者 <code>@SpringBootApplication</code>），你需要采取一些方法以避免将其包括在内（例如，你可以将其放入分开的，不重叠的包中，或者在 <code>@ComponentScan</code> 中指定要明确扫描的包）。</p></blockquote><h3 id="7-3-Customizing-the-Default-for-All-Ribbon-Clients"><a href="#7-3-Customizing-the-Default-for-All-Ribbon-Clients" class="headerlink" title="7.3. Customizing the Default for All Ribbon Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#customizing-the-default-for-all-ribbon-clients">7.3. Customizing the Default for All Ribbon Clients</a></h3><p>可以通过使用 <code>@RibbonClients</code> 注解，注册一个默认的配置，为所有的 Ribbon 客户端提供默认配置，如下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonClientDefaultConfigurationTestsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BazServiceList</span> <span class="keyword">extends</span> <span class="title class_">ConfigurationBasedServerList</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BazServiceList</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.initWithNiwsConfig(config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultRibbonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">ribbonRule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BestAvailableRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IPing <span class="title function_">ribbonPing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PingUrl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerList&lt;Server&gt; <span class="title function_">ribbonServerList</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RibbonClientDefaultConfigurationTestsConfig</span>.BazServiceList(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerListSubsetFilter <span class="title function_">serverListFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServerListSubsetFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerListSubsetFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-Customizing-the-Ribbon-Client-by-Setting-Properties"><a href="#7-4-Customizing-the-Ribbon-Client-by-Setting-Properties" class="headerlink" title="7.4. Customizing the Ribbon Client by Setting Properties"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#customizing-the-ribbon-client-by-setting-properties">7.4. Customizing the Ribbon Client by Setting Properties</a></h3><p>从 1.2.0 开始，Spring Cloud Netflix 现在支持通过设置兼容 <a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers#components-of-load-balancer">Ribbon documentation</a> 属性来定制化 Ribbon 客户端。</p><p>这使你可以在不同环境中更改启动时行为。</p><p>下面的列表展示了支持的属性：</p><ul><li><code>&lt;clientName&gt;.ribbon.NFLoadBalancerClassName</code>：应该实现了 <code>ILoadBalancer</code></li><li><code>&lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName</code>：应该实现了 <code>IRule</code></li><li><code>&lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName</code>：应该实现了 <code>IPing</code></li><li><code>&lt;clientName&gt;.ribbon.NIWSServerListClassName</code>：应该实现了 <code>ServerList</code></li><li><code>&lt;clientName&gt;.ribbon.NIWSServerListFilterClassName</code>：应该实现了 <code>ServerListFilter</code></li></ul><blockquote><p>这些属性中定义的类，相较于使用 <code>@RibbonClient(configuration=MyRibbonConfig.class)</code> 定义的 Bean，以及由 Spring Cloud Netflix 提供的默认值，具有更高优先级</p></blockquote><p>要设置名为 <code>users</code> 的服务名的 <code>IRule</code></p><h3 id="7-6-Example-How-to-Use-Ribbon-Without-Eureka"><a href="#7-6-Example-How-to-Use-Ribbon-Without-Eureka" class="headerlink" title="7.6. Example: How to Use Ribbon Without Eureka"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-ribbon-without-eureka">7.6. Example: How to Use Ribbon Without Eureka</a></h3><p>Eureka 是一种便捷的方式，它抽象化远程服务的发现，因此你不必在客户端中进行硬编码。但是，如果你不想使用 Eureka，Ribbon 和 Feign 也可以工作。假设你已经声明了 “stores” 的 <code>@RibbonClient</code>，并且 Eureka 没有使用（甚至不在类路径）。Ribbon 客户端默认到配置好的服务列表。你可以按如下方式提供配置：</p><p><strong>application.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stores:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">listOfServers:</span> <span class="string">example.com,google.com</span></span><br></pre></td></tr></table></figure><h3 id="7-7-Example-Disable-Eureka-Use-in-Ribbon"><a href="#7-7-Example-Disable-Eureka-Use-in-Ribbon" class="headerlink" title="7.7. Example: Disable Eureka Use in Ribbon"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#example-disable-eureka-use-in-ribbon">7.7. Example: Disable Eureka Use in Ribbon</a></h3><p>将 <code>ribbon.eureka.enabled</code> 属性设置为 <code>false</code>，显式地禁用 Ribbon 中 Eureka 的使用，如下示例所示：</p><p><strong>application.yml</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eureka:</span></span><br><span class="line">   <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="7-8-Using-the-Ribbon-API-Directly"><a href="#7-8-Using-the-Ribbon-API-Directly" class="headerlink" title="7.8. Using the Ribbon API Directly"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-the-ribbon-api-directly">7.8. Using the Ribbon API Directly</a></h3><p>你也可以直接使用 <code>LoadBalanceClient</code>，如下示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStuff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> loadBalancer.choose(<span class="string">&quot;stores&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">storesUri</span> <span class="operator">=</span> URI.create(String.format(<span class="string">&quot;https://%s:%s&quot;</span>, instance.getHost(), instance.getPort()));</span><br><span class="line">        <span class="comment">// ... do something with the URI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring-Cloud-Netflix&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Netflix&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Netflix&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://docs.spri</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring Cloud" scheme="http://example.com/tags/Spring-Cloud/"/>
    
    <category term="Netflix" scheme="http://example.com/tags/Netflix/"/>
    
  </entry>
  
</feed>
