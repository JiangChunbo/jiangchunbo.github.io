<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java 日期操作问题汇总</title>
    <url>/2022/09/20/Java-%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>获得本月第一天</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br></pre></td></tr></table></figure>

<p>获得本月最后一天</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.MONTH, <span class="number">1</span>);</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Nginx 官方学习笔记</title>
    <url>/2022/07/12/Nginx-%E5%AE%98%E6%96%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Nginx-官方学习笔记"><a href="#Nginx-官方学习笔记" class="headerlink" title="Nginx 官方学习笔记"></a>Nginx 官方学习笔记</h1><h2 id="Module-参考"><a href="#Module-参考" class="headerlink" title="Module 参考"></a>Module 参考</h2><h3 id="ngx-http-core-module"><a href="#ngx-http-core-module" class="headerlink" title="ngx_http_core_module"></a><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html">ngx_http_core_module</a></h3><blockquote>
<p>语法：server_name name …;<br>默认：server_name “”;<br>上下文：server</p>
</blockquote>
<p>设置虚拟主机名，例如：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个名字成为主服务名。</p>
<p>服务名可以包含一个星号（”*”）替换名字的第一个部分或者最后一个部分：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> example.com <span class="regexp">*.example.com</span> <span class="regexp">www.example.*</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的名称称为通配符名。</p>
<p>上面提到的前两个名称可以合并为一个：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> .example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在服务名称中使用正则表达式，并在名字前面使用波浪号（”~”）：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com ~^www\d+\.example\.com$;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正则表达式中有名捕获会创建变量（0.8.25），之后可以在其他指令中使用：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> ~^(www\.)?(?&lt;domain&gt;.+)$;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /sites/<span class="variable">$domain</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /sites/default;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>允许该服务在没有 “Host” 头部字段的情况下为给定的 address:port 对处理请求。</p>
<blockquote>
<p>在 0.8.48 之前，默认使用机器的主机名。</p>
</blockquote>
<h3 id="ngx-http-log-module"><a href="#ngx-http-log-module" class="headerlink" title="ngx_http_log_module"></a><a href="https://nginx.org/en/docs/http/ngx_http_log_module.html">ngx_http_log_module</a></h3><p><code>ngx_http_log_module</code> 模块以指定格式写入请求日志</p>
<h4 id="Example-Configuration"><a href="#Example-Configuration" class="headerlink" title="Example Configuration"></a>Example Configuration</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">log_format compression &#x27;$remote_addr - $remote_user <span class="selector-attr">[$time_local]</span> &#x27;</span><br><span class="line">                       &#x27;&quot;$request&quot; $status $bytes_sent &#x27;</span><br><span class="line">                       &#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">access_log /spool/logs/nginx-access<span class="selector-class">.log</span> compression buffer=<span class="number">32</span>k;</span><br></pre></td></tr></table></figure>

<h4 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h4><h5 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h5><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">access_log <span class="selector-attr">[path [buffer=size]</span> <span class="selector-attr">[gzip[=level]</span>] <span class="selector-attr">[flush=time]</span> <span class="selector-attr">[if=condition]</span>];</span><br><span class="line">access_log off;</span><br></pre></td></tr></table></figure>
<p>默认值:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">access_log logs/access<span class="selector-class">.log</span> combined;</span><br></pre></td></tr></table></figure>
<p>上下文：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">http, server, location, if in location, limit_except</span><br></pre></td></tr></table></figure>

<p>为缓冲日志写入设置 path，format，以及配置。可以在同一配置级别上指定几个日志。可以在第一个参数中指定 “<code>syslog:</code>“ 前缀来配置日志记录到 syslog。特殊值 <code>off</code> 取消当前级别上所有的 access_log 指令。如果没有指定 format，那么就会使用预定义的 “combined”。</p>
<p>如果使用 <code>buffer</code> 或者 <code>gzip</code> 参数，那么写入日志将会缓冲。</p>
<p>当开启缓冲时，以下几种时机将会把数据写入文件：</p>
<ul>
<li>如果下一行日志放不下缓冲区；</li>
<li>如果缓冲数据比 <code>flush</code> 参数指定的还要旧；</li>
<li>当工作进程重新打开日志文件，或者工作进程关闭</li>
</ul>
<p>如果使用 <code>gzip</code> 参数，则在写入文件之前压缩缓冲区的数据。压缩的级别可以设置在 1（最快，压缩率低）到 9 （最慢，压缩率高）之间。默认情况下，缓冲区大小为 64K 字节，压缩级别为 1。由于数据在原子块中压缩，日志文件可以通过 “<code>zcat</code>“ 解压缩或读取。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">access_log /path/to/log.gz combined gzip flush=5m;</span><br></pre></td></tr></table></figure>

<p>文件路径可以包含变量（0.7.6+），但是此类日志有一些约束：</p>
<ul>
<li>由 worker process 使用的用户凭据应该有权限使用此类日志在文件夹创建文件</li>
<li>不可以使用缓冲写</li>
<li>为每个日志写入打开并关闭文件。但是，由于可以将频繁使用的文件描述符存储到缓存中，在由 open_log_file_cache 指令的 valid 参数指定的时间内，旧文件的写入可以继续。</li>
<li>在每个日志写入过程中，请检查请求的 root 目录是否存在，如果不存在，日志不会创建。因此，指定 root 和 access_log 以相同的配置级别是一个好主意：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    root       /spool/vhost/data/$host;</span><br><span class="line">    access_log /spool/vhost/logs/$host;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code> 参数可以开启有条件的日志记录。如果 <code>condition</code> 等于 0 或者一个空字符串，则不会记录请求。在下面的示例中，请求码为 2xx 以及 3xx 不会被记录：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">map $status $loggable &#123;</span><br><span class="line">    ~^<span class="selector-attr">[23]</span>  <span class="number">0</span>;</span><br><span class="line">    default <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">access_log /path/<span class="selector-tag">to</span>/access<span class="selector-class">.log</span> combined if=$loggable;</span><br></pre></td></tr></table></figure>

<h5 id="log-format"><a href="#log-format" class="headerlink" title="log_format"></a>log_format</h5><p>日志格式可以包含一些通用的变量，以及一些仅仅存在于日志写入时的变量：</p>
<p>$bytes_sent 客户端发送的字节数</p>
<p>$connection 连接序列号</p>
<p>$connection_requests 通过一个连接发起的请求的当前序号</p>
<p>$msec 日志写入的时间，以秒为单位，精确到毫秒</p>
<p>$pipe 如果请求是管道，则是 “p”，否则为 “.”</p>
<p>$request_length 请求长度（包含请求行，头部，以及请求体）</p>
<p>$request_time 请求处理时间，以秒为单位，精确到毫秒，从客户端读取第一个字节，并在最后一个字节发送给客户端之后写入日志所用时间</p>
<p>$status 响应状态码</p>
<p>$time_iso8601 以 ISO 8601 标准格式的本地时间。类似 <code>2022-07-12T15:05:16+08:00</code></p>
<p>$time_local 以通用日志格式的本地时间。类似 <code>12/Jul/2022:15:05:16 +0800</code></p>
<p>配置始终包含预定义的 “<code>combined</code>“ 格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">log_format combined &#x27;$remote_addr - $remote_user <span class="selector-attr">[$time_local]</span> &#x27;</span><br><span class="line">                    &#x27;&quot;$request&quot; $status $body_bytes_sent &#x27;</span><br><span class="line">                    &#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&#x27;;</span><br></pre></td></tr></table></figure>


<h5 id="open-log-file-cache"><a href="#open-log-file-cache" class="headerlink" title="open_log_file_cache"></a>open_log_file_cache</h5><p>定义一个缓冲，该缓冲存储了名称包含变量的频繁使用的日志文件描述符。该指令具有如下参数：</p>
<p>max</p>
<p>inactive</p>
<p>min_uses</p>
<p>valid</p>
<p>设置应该检查仍然存在相同名称的文件的时间，默认情况下，为 60 秒</p>
<p>off<br>禁用缓存</p>
]]></content>
  </entry>
  <entry>
    <title>Python 爬虫学习笔记</title>
    <url>/2022/06/29/Python-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Python-爬虫"><a href="#Python-爬虫" class="headerlink" title="Python 爬虫"></a>Python 爬虫</h1><h2 id="1-urllib"><a href="#1-urllib" class="headerlink" title="1. urllib"></a>1. urllib</h2><h3 id="1-1-参考文档"><a href="#1-1-参考文档" class="headerlink" title="1.1. 参考文档"></a>1.1. 参考文档</h3><p><a href="https://docs.python.org/3/howto/urllib2.html">https://docs.python.org/3/howto/urllib2.html</a></p>
<h3 id="1-2-抓取-url"><a href="#1-2-抓取-url" class="headerlink" title="1.2. 抓取 url"></a>1.2. 抓取 url</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>) <span class="keyword">as</span> response:</span><br><span class="line">    html = response.read()</span><br></pre></td></tr></table></figure>

<p>如果你想抓取 url 并存储到临时文件夹下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(<span class="string">&#x27;http://python.org/&#x27;</span>) <span class="keyword">as</span> response:</span><br><span class="line">    <span class="keyword">with</span> tempfile.NamedTemporaryFile(delete=<span class="literal">False</span>) <span class="keyword">as</span> tmp_file:</span><br><span class="line">        shutil.copyfileobj(response, tmp_file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(tmp_file.name) <span class="keyword">as</span> html:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>定制化 Request</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(<span class="string">&#x27;http://www.voidspace.org.uk&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">   the_page = response.read()</span><br></pre></td></tr></table></figure>

<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.someserver.com/cgi-bin/register.cgi&#x27;</span></span><br><span class="line">values = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;Michael Foord&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;location&#x27;</span> : <span class="string">&#x27;Northampton&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;language&#x27;</span> : <span class="string">&#x27;Python&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">data = urllib.parse.urlencode(values)</span><br><span class="line">data = data.encode(<span class="string">&#x27;ascii&#x27;</span>) <span class="comment"># data should be bytes</span></span><br><span class="line">req = urllib.request.Request(url, data)</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">   the_page = response.read()</span><br></pre></td></tr></table></figure>
<h2 id="2-requests"><a href="#2-requests" class="headerlink" title="2. requests"></a>2. requests</h2><p><a href="https://requests.readthedocs.io/en/latest/">https://requests.readthedocs.io/en/latest/</a></p>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">&#x27;https://api.github.com/events&#x27;</span>)</span><br><span class="line">r = requests.post(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, data=&#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line">r = requests.put(<span class="string">&#x27;https://httpbin.org/put&#x27;</span>, data=&#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line">r = requests.delete(<span class="string">&#x27;https://httpbin.org/delete&#x27;</span>)</span><br><span class="line">r = requests.head(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">r = requests.options(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置编码格式</span></span><br><span class="line">r.encoding = <span class="string">&#x27;UTF-8&#x27;</span></span><br><span class="line"><span class="comment"># 返回响应字符串</span></span><br><span class="line">r.text</span><br><span class="line"><span class="comment"># 返回 url 地址</span></span><br><span class="line">r.url</span><br><span class="line"><span class="comment"># 返回响应字节</span></span><br><span class="line">r.content</span><br><span class="line"><span class="comment"># 响应状态码</span></span><br><span class="line">r.status_code</span><br><span class="line"><span class="comment"># 响应头</span></span><br><span class="line">r.headers</span><br></pre></td></tr></table></figure>

<h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, params=params, headers=headers)</span><br></pre></td></tr></table></figure>

<h1 id="BS4"><a href="#BS4" class="headerlink" title="BS4"></a>BS4</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回数组</span></span><br><span class="line">soup.select(<span class="string">&#x27;#haha&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h1><h2 id="headless"><a href="#headless" class="headerlink" title="headless"></a>headless</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">share_browser</span>():</span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    path = <span class="string">&#x27;C:\Program Files\Google\Chrome\Application\chrome.exe&#x27;</span></span><br><span class="line">    chrome_options.binary_location = path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> webdriver.Chrome(chrome_options=chrome_options)</span><br></pre></td></tr></table></figure>


<h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<h3 id="Get-请求"><a href="#Get-请求" class="headerlink" title="Get 请求"></a>Get 请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, params=params, headers=headers)</span><br><span class="line">content = response.text</span><br></pre></td></tr></table></figure>


<h2 id="scrapy"><a href="#scrapy" class="headerlink" title="scrapy"></a>scrapy</h2><p>以下这段话来自 <a href="https://scrapy.org/">https://scrapy.org/</a></p>
<blockquote>
<p>An open source and collaborative framework for extracting the data you need from websites.<br>In a fast, simple, yet extensible way.</p>
</blockquote>
<p>scrapy 是一个开源和协作框架，用于从网站上提取所需的数据。<br>以快速，简单但可扩展的方式。</p>
<h3 id="安装错误总结"><a href="#安装错误总结" class="headerlink" title="安装错误总结"></a>安装错误总结</h3><blockquote>
<p>来自于尚硅谷 Python 视频</p>
</blockquote>
<ol>
<li>缺少 twisted.test.raiser 扩展</li>
</ol>
<p><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a></p>
<ol start="2">
<li>升级 pip</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>



<h3 id="快速开始-1"><a href="#快速开始-1" class="headerlink" title="快速开始"></a>快速开始</h3><ol>
<li>创建爬虫项目</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy startproject myproject</span><br></pre></td></tr></table></figure>
<blockquote>
<p>myproject 为自定义项目名称。项目名称必须以字母开头，并且只包含字母、数字、下划线。</p>
</blockquote>
<p>命令执行完毕会得到如下目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├─myproject</span><br><span class="line">│  │  scrapy.cfg</span><br><span class="line">│  │</span><br><span class="line">│  └─myproject</span><br><span class="line">│      │  items.py</span><br><span class="line">│      │  middlewares.py</span><br><span class="line">│      │  pipelines.py</span><br><span class="line">│      │  settings.py</span><br><span class="line">│      │  __init__.py</span><br><span class="line">│      │</span><br><span class="line">│      └─spiders</span><br><span class="line">│              __init__.py</span><br></pre></td></tr></table></figure>


<ol>
<li>创建爬虫文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy genspider 爬虫名 爬取网页</span><br></pre></td></tr></table></figure>


<ol>
<li>运行爬虫代码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy crawl 爬虫名</span><br></pre></td></tr></table></figure>


<h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><p>获取响应字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response.text</span><br></pre></td></tr></table></figure>


<p>获取响应二进制数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response.body</span><br></pre></td></tr></table></figure>


<p>获取</p>
]]></content>
  </entry>
  <entry>
    <title>SMB 协议对接</title>
    <url>/2022/09/14/SMB-%E5%8D%8F%E8%AE%AE%E5%AF%B9%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="参考引用"><a href="#参考引用" class="headerlink" title="参考引用"></a>参考引用</h1><p><a href="https://github.com/hierynomus/smbj">https://github.com/hierynomus/smbj</a></p>
<p>fileAttributes，包含文件属性掩码<br><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/ca28ec38-f155-4768-81d6-4bfeb8586fc9">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/ca28ec38-f155-4768-81d6-4bfeb8586fc9</a></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>maven</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hierynomus<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>smbj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SMB 关于 Windows 的共享文件夹</p>
<p>如果开启了<strong>密码保护</strong>需要提供<strong>账户</strong>和<strong>密码</strong></p>
<p>计算机处于睡眠状态时无法访问共享目录</p>
<p>如果为 EveryOne 开启了访问权限，即使不存在的<strong>账户</strong>，也可以访问，此时密码应该被忽略</p>
<p>如果<strong>账户</strong>是系统存在的，则会进行<strong>密码</strong>认证，失败则不通过。</p>
<h2 id="获得一个-SMBClient"><a href="#获得一个-SMBClient" class="headerlink" title="获得一个 SMBClient"></a>获得一个 SMBClient</h2><p>无参构造器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SMBClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SMBClient</span>();</span><br></pre></td></tr></table></figure>

<p>自定义配置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SmbConfig</span> <span class="variable">config</span> <span class="operator">=</span> SmbConfig.builder()</span><br><span class="line">        .withTimeout(<span class="number">120</span>, TimeUnit.SECONDS) <span class="comment">// Timeout sets Read, Write, and Transact timeouts (default is 60 seconds)</span></span><br><span class="line">        .withSoTimeout(<span class="number">180</span>, TimeUnit.SECONDS) <span class="comment">// Socket Timeout (default is 0 seconds, blocks forever)</span></span><br><span class="line">        .build();</span><br><span class="line"><span class="type">SMBClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SMBClient</span>(config);</span><br></pre></td></tr></table></figure>


<h2 id="获得一个-Connection"><a href="#获得一个-Connection" class="headerlink" title="获得一个 Connection"></a>获得一个 Connection</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意关闭</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> client.connect(<span class="string">&quot;127.0.0.1&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 可能 client connect 超时</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e.getMessage(), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="获得一个-Session"><a href="#获得一个-Session" class="headerlink" title="获得一个 Session"></a>获得一个 Session</h2><p>获得一个会话示例代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> connection.authenticate(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AuthenticationContext</span>(<span class="string">&quot;USERNAME&quot;</span>, <span class="string">&quot;PASSWORD&quot;</span>.toCharArray(), <span class="literal">null</span>));</span><br></pre></td></tr></table></figure>

<h2 id="获得-DiskShare"><a href="#获得-DiskShare" class="headerlink" title="获得 DiskShare"></a>获得 DiskShare</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Connect to Share</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">DiskShare</span> <span class="variable">share</span> <span class="operator">=</span> (DiskShare) session.connectShare(<span class="string">&quot;shareDirectory&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (FileIdBothDirectoryInformation f : share.list(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;*.csv&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File : &quot;</span> + f.getFileName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整体-Demo"><a href="#整体-Demo" class="headerlink" title="整体 Demo"></a>整体 Demo</h2><p>获得共享名称为 shareDir 下的所有文件名信息，并输出: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1. 使用 try 语句块自动关闭资源</span></span><br><span class="line"><span class="comment">    * 2. client.connect 参数 hostname 可能导致抛出异常</span></span><br><span class="line"><span class="comment">    * 3. connection.authenticate 认证失败可能导致抛出异常</span></span><br><span class="line"><span class="comment">    * 4. session.connectShare shareName 不存在可能导致抛出异常</span></span><br><span class="line"><span class="comment">    * 5. share.list 传入的 path 错误可能导致抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">SMBClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SMBClient</span>();</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> client.connect(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> connection.authenticate(<span class="keyword">new</span> <span class="title class_">AuthenticationContext</span>(<span class="string">&quot;USERNAME&quot;</span>, <span class="string">&quot;PASSWORD&quot;</span>.toCharArray(), <span class="literal">null</span>));</span><br><span class="line">        <span class="type">DiskShare</span> <span class="variable">share</span> <span class="operator">=</span> (DiskShare) session.connectShare(<span class="string">&quot;shareDir&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (FileIdBothDirectoryInformation f : share.list(<span class="string">&quot;&quot;</span>, <span class="string">&quot;*.csv&quot;</span>)) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;File : &quot;</span> + f.getFileName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="com-hierynomus-smbj-share-File"><a href="#com-hierynomus-smbj-share-File" class="headerlink" title="com.hierynomus.smbj.share.File"></a><code>com.hierynomus.smbj.share.File</code></h2><ul>
<li>打开一个文件（读）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">smbFileRead</span> <span class="operator">=</span> dirShare.openFile(</span><br><span class="line">    fileName, <span class="comment">// 路径</span></span><br><span class="line">    EnumSet.of(AccessMask.GENERIC_READ), <span class="comment">// Set&lt;AccessMask&gt;</span></span><br><span class="line">    <span class="literal">null</span>, <span class="comment">// Set&lt;FileAttributes&gt;</span></span><br><span class="line">    SMB2ShareAccess.ALL, <span class="comment">// Set&lt;SMB2ShareAccess&gt;</span></span><br><span class="line">    SMB2CreateDisposition.FILE_OPEN, <span class="comment">// SMB2CreateDisposition</span></span><br><span class="line">    <span class="literal">null</span>); <span class="comment">// Set&lt;SMB2CreateOptions&gt;</span></span><br></pre></td></tr></table></figure>


<p>SMB2CreateDisposition: 如果传递 <code>FILE_OPEN</code>，那么文件找不到的情况下会抛出异常；如果设置为 <code>FILE_OPEN_IF</code>，那么文件找不到的情况下会静默继续</p>
<ul>
<li>远程拷贝</li>
</ul>
<p>就是直接在远程机器上将一个文件拷贝到另一个文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保拷贝到的文件夹存在</span></span><br><span class="line"><span class="built_in">this</span>.ensureDirectoryExists(diskShare, dir);</span><br><span class="line">com.hierynomus.smbj.share.<span class="type">File</span> <span class="variable">backupShareFile</span> <span class="operator">=</span> diskShare.openFile(</span><br><span class="line">        <span class="string">&quot;copy-directory\\&quot;</span> + filename,</span><br><span class="line">        EnumSet.of(AccessMask.GENERIC_ALL), <span class="comment">// Set&lt;AccessMask&gt;</span></span><br><span class="line">        <span class="literal">null</span>, <span class="comment">// Set&lt;FileAttributes&gt;</span></span><br><span class="line">        SMB2ShareAccess.ALL, <span class="comment">// Set&lt;SMB2ShareAccess&gt;</span></span><br><span class="line">        SMB2CreateDisposition.FILE_CREATE, <span class="comment">// SMB2CreateDisposition</span></span><br><span class="line">        <span class="literal">null</span>);</span><br><span class="line">smbFile.remoteCopyTo(backupShareFile);</span><br></pre></td></tr></table></figure>


<ul>
<li>如何判断一个 <code>File</code> 是否是文件夹</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FileIdBothDirectoryInformation</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isDirectory</span> <span class="operator">=</span> (f.getFileAttributes() &amp; <span class="number">0x10</span>) == <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// File</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">directory</span> <span class="operator">=</span> shareFile.getFileInformation().getStandardInformation().isDirectory();</span><br></pre></td></tr></table></figure>



<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>将共享文件夹 <code>\\127.0.0.1\shareDirectory</code> 下的所有文件都转移到 <code>\\127.0.0.1\shareDirectory\backup</code> 文件夹下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">transferAllFiles</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">SMBClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SMBClient</span>();</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> client.connect(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> connection.authenticate(<span class="keyword">new</span> <span class="title class_">AuthenticationContext</span>(<span class="string">&quot;USERNAME&quot;</span>, <span class="string">&quot;PASSWORD&quot;</span>.toCharArray(), <span class="literal">null</span>));</span><br><span class="line">            <span class="type">DiskShare</span> <span class="variable">share</span> <span class="operator">=</span> (DiskShare) session.connectShare(<span class="string">&quot;shareDirectory&quot;</span>)) &#123;</span><br><span class="line">        List&lt;FileIdBothDirectoryInformation&gt; fileIdBothDirectoryInformationList = share.list(path, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        fileIdBothDirectoryInformationList = fileIdBothDirectoryInformationList.stream().filter(fileIdBothDirectoryInformation -&gt; &#123;</span><br><span class="line">            <span class="comment">// 过滤掉文件夹</span></span><br><span class="line">            <span class="keyword">return</span> (fileIdBothDirectoryInformation.getFileAttributes() &amp; <span class="number">0x10</span>) == <span class="number">0</span>;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (FileIdBothDirectoryInformation f : fileIdBothDirectoryInformationList) &#123;</span><br><span class="line">            com.hierynomus.smbj.share.<span class="type">File</span> <span class="variable">shareFile</span> <span class="operator">=</span> share.openFile(</span><br><span class="line">                    path + <span class="string">&quot;\\&quot;</span> + f.getFileName(), <span class="comment">// 路径</span></span><br><span class="line">                    EnumSet.of(AccessMask.GENERIC_ALL), <span class="comment">// Set&lt;AccessMask&gt;</span></span><br><span class="line">                    <span class="literal">null</span>, <span class="comment">// Set&lt;FileAttributes&gt;</span></span><br><span class="line">                    SMB2ShareAccess.ALL, <span class="comment">// Set&lt;SMB2ShareAccess&gt;</span></span><br><span class="line">                    SMB2CreateDisposition.FILE_OPEN, <span class="comment">// SMB2CreateDisposition</span></span><br><span class="line">                    <span class="literal">null</span>); <span class="comment">// Set&lt;SMB2CreateOptions&gt;</span></span><br><span class="line">            com.hierynomus.smbj.share.<span class="type">File</span> <span class="variable">backupShareFile</span> <span class="operator">=</span> share.openFile(</span><br><span class="line">                    path + <span class="string">&quot;\\backup\\&quot;</span> + f.getFileName(),</span><br><span class="line">                    EnumSet.of(AccessMask.GENERIC_ALL), <span class="comment">// Set&lt;AccessMask&gt;</span></span><br><span class="line">                    <span class="literal">null</span>, <span class="comment">// Set&lt;FileAttributes&gt;</span></span><br><span class="line">                    SMB2ShareAccess.ALL, <span class="comment">// Set&lt;SMB2ShareAccess&gt;</span></span><br><span class="line">                    SMB2CreateDisposition.FILE_CREATE, <span class="comment">// SMB2CreateDisposition</span></span><br><span class="line">                    <span class="literal">null</span>);</span><br><span class="line">            shareFile.remoteCopyTo(backupShareFile);</span><br><span class="line">            <span class="comment">// 最后要删掉</span></span><br><span class="line">            shareFile.deleteOnClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>TCP 协议笔记</title>
    <url>/2022/07/20/TCP-%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><hr>
<h2 id="报文种类"><a href="#报文种类" class="headerlink" title="报文种类"></a>报文种类</h2><ul>
<li>SYN</li>
<li>Data</li>
<li>FIN</li>
<li>Reset</li>
<li>ACK</li>
</ul>
<p>SYN、Data、FIN 这三种报文发送方一定要收到 ACK 报文，如果在超时时间内不确认，发送方会一直重传，直到对方确认，或者达到重传上线次数而 Reset 连接。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/crypto/TCP%20%E6%8F%A1%E6%89%8B.drawio.svg">


<p>三次握手本质上是四次报文交互：</p>
<ol>
<li>A 发送 SYN 报文给 B</li>
<li>B 发送 ACK 报文给 A，确认步骤 1</li>
<li>B 发送 SYN 报文给 A</li>
<li>A 发送 ACK 报文给 B，确认步骤 3</li>
</ol>
<p>为了缩短延迟，将步骤 2、步骤 3 合并在一个报文发送，即 SYN + ACK 报文，形成三次握手。</p>
<p>第 1 次握手：</p>
<p>Client 将标志位 SYN 置为 1，随机产生一个 Initial sequence number（简称为 seq），假设 seq &#x3D; x</p>
<p>将该数据包发送给 Server，Client 进入 SYN_SENT 状态</p>
<p>第 2 次握手：</p>
<p>Server 接收到数据包后，由标志位 SYN &#x3D; 1 知道该报文是 Client 请求建立连接</p>
<p>Server 也会记录 Client 的 seq&#x3D;x</p>
<blockquote>
<p>Server 不会将 SYN 与 SYN+ACK 混淆，因为只有 SYN&#x3D;1</p>
</blockquote>
<p>Server 准备一个报文，将标志位 SYN 和 ACK 都置为 1，ack &#x3D; x + 1，随机产生一个 seq &#x3D; y，并将该数据包发送给 Client，进入 SYN_RCVD 状态</p>
<p>第 3 次握手：</p>
<p>Client 收到确认后，检查 ack 是否为 x + 1，如果正确，则将标志位 ACK 置为 1，ack &#x3D; y + 1，并将该数据包发送给 Server，Client 进入 ESTABLISHED 状态</p>
<p>Server 检查 ack 是否为 y + 1，ACK 是否为 1，如果正确，则建立连接成功，Server 进入 ESTABLISHED 状态</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="https://img-blog.csdnimg.cn/2021071716371797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>假设 Client 主动关闭连接，</p>
<p>第 1 次挥手：Client 发送一个 FIN，以及一个序号 seq，告知 Server：我打算关闭连接了，Client 进入 FIN-WAIT-1 状态</p>
<p>第 2 次挥手：Server 收到 FIN 后，发送 ACK 给 Client，Server 进入 CLOSE-WAIT 状态，这时候 Server 可能还有一些数据没有传输完毕，继续传输。</p>
<p>第 3 次挥手：当 Server 没有数据发送给 Client 时，Server 发送一个 FIN 给 Client，告知 Client：我也没有数据给你了，我也可以关闭了，Server 进入 LAST-ACK 状态</p>
<p>第 4 次挥手，Client 收到 FIN，Client 进入 TIME_WAIT 状态，发送 ACK 给 Server，Server 接收到 ACK 之后，进入 CLOSED 状态。</p>
<h3 id="TIME-WAIT-存在的问题？"><a href="#TIME-WAIT-存在的问题？" class="headerlink" title="TIME_WAIT 存在的问题？"></a>TIME_WAIT 存在的问题？</h3><p>一个连接进入 TIME_WAIT 状态后需要等待 2 * MSL 的事件才能断开连接释放连接占用的资源</p>
<p>服务器：短时间内关闭了大量的 Client 连接，会造成服务器上出现大量的 TIME_WAIT 连接，占据大量的 tuple，严重消耗着服务器的资源。</p>
<p>客户端：短时间内大量的短链接，会大量消耗 Client 机器的接口，端口只有 65535 个，端口被耗尽，无法发起新的连接。</p>
<p>关于 Windows 的端口使用问题：</p>
<p>Windows 系统供用户使用的端口是具有一定配置的，可以通过以下命令查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\JiangChunbo&gt;netsh int ipv4 show dynamicport tcp</span><br><span class="line"></span><br><span class="line">协议 tcp 动态端口范围</span><br><span class="line">---------------------------------</span><br><span class="line">启动端口        : 49152</span><br><span class="line">端口数          : 16384</span><br></pre></td></tr></table></figure>

<p>通常具有一个启动端口（start）表示可用的起始端口号，以及端口数（num）表示从起始端口号开始可用的端口数。默认是从 49152 - 65535。</p>
<p>参考 <a href="https://docs.microsoft.com/zh-cn/previous-versions/office/exchange-server-analyzer/bb397382(v=exchg.80)">MaxUserPort</a>、<a href="https://docs.microsoft.com/zh-cn/previous-versions/office/exchange-server-analyzer/bb397379(v=exchg.80)?redirectedfrom=MSDN">TcpTimedWaitDelay</a>、<a href="https://docs.microsoft.com/zh-cn/biztalk/technical-guides/settings-that-can-be-modified-to-improve-network-performance">优化网络性能的可修改设置</a></p>
<p>测试 Windows 端口耗尽，例如使用如下 PHP 脚本将本机器的端口全部耗尽：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable">$conn</span> = <span class="title function_ invoke__">mysqli_connect</span>(<span class="string">&quot;******&quot;</span>, <span class="string">&quot;******&quot;</span>, <span class="string">&quot;******&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">mysqli_close</span>(<span class="variable">$conn</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候，尝试申请数据库连接的时候会产生如下警告：</p>
<img src="https://img-blog.csdnimg.cn/277e8a9905c3452c9a6ba9f5329ccef1.png">


<h1 id="TCP-协议端口连接状态"><a href="#TCP-协议端口连接状态" class="headerlink" title="TCP 协议端口连接状态"></a>TCP 协议端口连接状态</h1><h2 id="LISTENING"><a href="#LISTENING" class="headerlink" title="LISTENING"></a>LISTENING</h2><p>提供某种服务，侦听远方 TCP 端口的连接请求，当提供的服务没有连接时，处于 LISTENING 状态，端口时开放的，等待连接。</p>
<h2 id="SYN-SENT-客户端状态"><a href="#SYN-SENT-客户端状态" class="headerlink" title="SYN_SENT(客户端状态)"></a>SYN_SENT(客户端状态)</h2><p>客户端调用 connect，发送一个 SYN 请求建立一个连接，在发送连接请求后等待匹配的连接请求，此时状态为 SYN_SENT</p>
<h2 id="SYN-RECEIVED（服务端状态）"><a href="#SYN-RECEIVED（服务端状态）" class="headerlink" title="SYN_RECEIVED（服务端状态）"></a>SYN_RECEIVED（服务端状态）</h2><p>在收到和发送一个连接请求后，等待对方对连接请求的确认，当服务器收到客户端发送的同步信号时，将标志位 ACK 和 SYN 置为 1 发送给客户端，此时服务端处于 SYN_RCVD 状态，如果连接成功就变为 ESTABLISED，正常情况下 SYN_RECEIVED 非常短暂</p>
<h2 id="ESTABLISHED"><a href="#ESTABLISHED" class="headerlink" title="ESTABLISHED"></a>ESTABLISHED</h2><p>ESTABLISHED 状态是表示两台机器正在传输数据</p>
<h2 id="FIN-WAIT-1"><a href="#FIN-WAIT-1" class="headerlink" title="FIN-WAIT-1"></a>FIN-WAIT-1</h2><p>等待远程 TCP 连接中断请求，或先前的连接中断请求的确认，主动关闭端应用程序调用 close，TCP 发出 FIN 请求主动关闭连接，之后进入 FIN_WAIT1状态</p>
<h2 id="FIN-WAIT-2"><a href="#FIN-WAIT-2" class="headerlink" title="FIN-WAIT-2"></a>FIN-WAIT-2</h2><p>从远程 TCP 等待连接中断请求，主动关闭端接到 ACK 后，就进入了 FIN-WAIT-2。这是在关闭连接时，客户端和服务端两次握手之后的状态，是著名的半关闭状态，在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据，但是也有一种可能是，客户端一直处于 FIN-WAIT-2 状态，服务端则一直处于 WAIT_CLOSE 状态，而直到应用层来决定关闭这个状态。</p>
<h2 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE-WAIT"></a>CLOSE-WAIT</h2><p>等待从本地用户发来的连接中断请求，被动关闭端 TCP 接到 FIN 后，就发出 ACK 以回应 FIN 请求（它的接收也作为文件结束符传递给上层应用程序），并进入 CLOSE_WAIT</p>
<h2 id="CLOSING"><a href="#CLOSING" class="headerlink" title="CLOSING"></a>CLOSING</h2><p>等待远程 TCP 对连接中断的确认，处于此种状态比较少见</p>
<h2 id="LAST-ACK"><a href="#LAST-ACK" class="headerlink" title="LAST-ACK"></a>LAST-ACK</h2><p>等待原来的发向远程 TCP 的连接中断请求的确认，被动关闭段一段时间后接收到文件结束符的应用程序将调用 CLOSE 关闭连接，TCP 也发送一个 FIN，等待对方的 ACK，进入 LAST-ACK</p>
<h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME-WAIT"></a>TIME-WAIT</h2><p>在主动关闭段接收到 FIN 后，TCP 就发送 ACK 包，并进入 TIME-WAIT 状态，等待足够的事件以确保 TCP 接收到连接中断请求的确认，很大程度上保证了双方都可以正常结束，但是也存在问题，必须等待 2MSL 时间的过去才能进行下一次连接。</p>
<h2 id="CLOSED"><a href="#CLOSED" class="headerlink" title="CLOSED"></a>CLOSED</h2><p>被动关闭端在接收到 ACK 包后，就进入了closed的状态，连接结束，没有任何连接状态</p>
]]></content>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>undo 分配</title>
    <url>/2022/05/09/undo-%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>分配临时回滚段和持久回滚段的函数名不同只在于末尾的单词不同：</p>
<p>trx_assign_rseg_temp</p>
<p>trx_assign_rseg_durable</p>
<p>当一个事务被判定为读写模式时，会为其分配 trx_id 以及持久回滚段。</p>
<p>分配临时回滚段是当调用 <code>trx_undo_report_row_operation</code> 时，判断是否是临时表而动态分配的。</p>
]]></content>
  </entry>
  <entry>
    <title>undo 清理</title>
    <url>/2022/05/02/undo-%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<h1 id="purge-queue"><a href="#purge-queue" class="headerlink" title="purge_queue"></a>purge_queue</h1><p>purge_queue中记录了所有等待Purge的Rollback Segment和其History中trx_no最小的事务</p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>storage&#x2F;innobase&#x2F;trx&#x2F;trx0undo.cc</p>
<p>事务结束的时候，对于需要Purge的Update类型的Undo Log，会按照事务提交的顺序trx_no，挂载到Rollback Segment Header的History List上。</p>
<p>在 trx_undo_update_cleanup 函数中调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trx_undo_update_cleanup</span><span class="params">(<span class="type">trx_t</span> *trx, <span class="type">trx_undo_ptr_t</span> *undo_ptr, <span class="type">page_t</span> *undo_page, <span class="type">bool</span> update_rseg_history_len, ulint n_added_logs, <span class="type">mtr_t</span> *mtr)</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 update undo 添加到 history</span></span><br><span class="line">  trx_purge_add_update_undo_to_history(</span><br><span class="line">      trx, undo_ptr, undo_page, update_rseg_history_len, n_added_logs, mtr);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/purge.svg">



<p><code>srv_do_purge()</code> 为入口函数</p>
<p><code>trx_purge()</code> 获取最老的视图复制给 <code>purge_sys-&gt;view</code>，方便之后真正 purge undo log 时判断其是否不会再被访问到了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trx_sys-&gt;mvcc-&gt;clone_oldest_view(&amp;purge_sys-&gt;view);</span><br></pre></td></tr></table></figure>


<p>通过 <code>trx_purge_attach_undo_recs()</code> 获取需要被 purge 的undo log：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n_pages_handled = trx_purge_attach_undo_recs(n_purge_threads, batch_size);</span><br></pre></td></tr></table></figure>

<p>trx_purge_attach_undo_recs</p>
<p>通过 <code>trx_purge_fetch_next_rec()</code> 循环获取可以被purge 的 undo log，默认最多获取 300 个 undo 页</p>
<blockquote>
<p>可以通过 innodb_purge_batch_size 来调整</p>
</blockquote>
<h2 id="trx-purge-fetch-next-rec-流程"><a href="#trx-purge-fetch-next-rec-流程" class="headerlink" title="trx_purge_fetch_next_rec 流程"></a>trx_purge_fetch_next_rec 流程</h2><ol>
<li>trx_purge_choose_next_log</li>
</ol>
<p>该函数作用：选择下一个需要清理的 undo log，并且更新 purge_sys 的信息</p>
<p>通过 <code>trx_purge_choose_next_log()</code> 从<code>purge_sys::purge_queue</code> 取出第一个回滚段</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/trx_purge_choose_next_log.svg">

<ol start="2">
<li>trx_purge_get_next_rec</li>
</ol>
<p>从其 history list 上读取最老还未被 purge 的事务的undo log header。<br>从此 undo log header 依次读取undo log record，每次读取会设置purge_sys的变量</p>
<p>读取完毕后，重新统计此回滚段最老还未被purge的事务的位点，然后重新放入purge_sys::purge_queue；最后回到第一步。</p>
<h2 id="trx-purge-choose-next-log"><a href="#trx-purge-choose-next-log" class="headerlink" title="trx_purge_choose_next_log"></a>trx_purge_choose_next_log</h2><p>依次从 purge_queue 中 pop 出拥有全局最小 trx_no 的 Undo Log。</p>
<h2 id="TrxUndoRsegsIterator-set-next-流程"><a href="#TrxUndoRsegsIterator-set-next-流程" class="headerlink" title="TrxUndoRsegsIterator::set_next() 流程"></a>TrxUndoRsegsIterator::set_next() 流程</h2><p>如果满足 <code>m_iter != m_trx_undo_rsegs.end()</code>，表示当前即将处理的 rollback segment 还未到最后一个，即还有更多的 rollback segment 需要处理。</p>
<p>如果当前即将处理的 rollback segment 已经到最后一个了，那么将会进入一个 <code>while(!m_purge_sys-&gt;purge_queue-&gt;empty())</code> 循环：</p>
<ul>
<li><p>如果满足 <code>m_trx_undo_rsegs.get_trx_no() == UINT64_UNDEFINED</code>，表示当前需要处理的 rollback segment 对应的事务并不存在（一条伪记录），那么将会将 purge_queue 顶部的元素赋值给 <code>m_trx_undo_rsegs</code>。弹出顶部 rollback segment</p>
</li>
<li><p>其次，如果满足 <code>purge_sys-&gt;purge_queue-&gt;top().get_trx_no() == m_trx_undo_rsegs.get_trx_no()</code>，表示 purge_queue 顶部的 rollback segment 对应的事务就是当前待处理的事务，那么将purge_queue 顶部的 rollback segment 添加到 <code>m_trx_undo_rsegs</code>。弹出顶部 rollback segment</p>
</li>
<li><p>否则，表示当前待处理的 rollback segment 集合对应的事务并不等于 purge_queue 顶部事务，跳出循环</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>各类场景请求参数</title>
    <url>/2022/05/24/%E5%90%84%E7%B1%BB%E5%9C%BA%E6%99%AF%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li>身份证号码</li>
</ul>
<p>存在 X 这种非数字的符号，需要注意用户可能会小写</p>
]]></content>
  </entry>
  <entry>
    <title>软件架构的杂项记录</title>
    <url>/2022/09/20/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9D%82%E9%A1%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>传统软件架构：客户层、表现层、控制层、业务逻辑层、数据库层</p>
<p>客户层: 一般指客户端和浏览器</p>
<p>表现层: 将客户端的请求提交到业务层, 将控制层的返回的数据渲染展示给客户</p>
<p>控制层: 等同于 MVC 中的控制层。接受表现层的请求寻找相应的业务处理</p>
<p>业务逻辑层：实现业务逻辑</p>
<p>数据库层：存放和管理用户所使用的数据</p>
<p>传统软件架构：客户层、表现层、控制层、业务逻辑层、数据库层</p>
<h2 id="多租户数据存储方案"><a href="#多租户数据存储方案" class="headerlink" title="多租户数据存储方案"></a>多租户数据存储方案</h2><ul>
<li>独立数据库</li>
</ul>
<p>最便捷。物理上，每个租户都单独拥有自己的一整套数据，而且是单独存放。</p>
<blockquote>
<p>具体来说，多个机器分别安装 MySQL 实例，每个企业使用单独一台机器。</p>
</blockquote>
<ul>
<li>共享数据库，隔离数据架构</li>
</ul>
<p>所有租户共同使用一个数据库，但是各自有各自的一套不同的数据表结构。</p>
<blockquote>
<p>具体来说，单台机器安装 MySQL，可以通过不同的 schema （库）区分，也可以通过表名区分，例如：a_user, b_user</p>
</blockquote>
<ul>
<li>共享数据库，共享数据架构</li>
</ul>
<p>所有租户共享同一个数据表，同一个数据表结构，存储在同一模式中。</p>
<blockquote>
<p>具体来说，将所有租户都记录在同一张表中，通过特定字段区分。例如，通过 TenantID 区别</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Android 笔记</title>
    <url>/2022/07/18/Android/Android-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h1><h1 id="Activities"><a href="#Activities" class="headerlink" title="Activities"></a>Activities</h1><h2 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h2><h3 id="创建一个-fragment"><a href="#创建一个-fragment" class="headerlink" title="创建一个 fragment"></a>创建一个 fragment</h3><p>一个 fragment 表示某个 activity 中用户接口的一个模块化部分。一个 fragment 有它自己的生命周期，接受它自己的输入事件，并且你可以在activity 运行时添加或移除 fragment。</p>
<h4 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h4><p>fragments 需要 AndroidX fragment 库的依赖。为此，你需要添加 Google Maven 仓库到你的项目 build.grade 文件。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了将 AndroidX Fragment 库包含到你的项目，需要在你的 App 的 build.gradle 文件添加如下依赖：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def fragment_version = &quot;<span class="number">1.3</span>.<span class="number">5</span>&quot;</span><br><span class="line"></span><br><span class="line">    // Java language implementation</span><br><span class="line">    implementation &quot;androidx<span class="selector-class">.fragment</span>:fragment:$fragment_version<span class="string">&quot;</span></span><br><span class="line"><span class="string">    // Kotlin</span></span><br><span class="line"><span class="string">    implementation &quot;</span>androidx.fragment:fragment-ktx:$fragment_version<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建一个-fragment-类"><a href="#创建一个-fragment-类" class="headerlink" title="创建一个 fragment 类"></a>创建一个 fragment 类</h4><p>为了创建一个 fragment，需要继承 AndroidX 的 <code>Fragment</code> 类，并覆盖它的方法，类似你创建一个 <code>Activity</code> 类。为了创建一个定义了自己的布局的最小 fragment，需要为基本构造器提供 fragment 的布局资源。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleFragment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_fragment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fragment 库还提供了更多专业的 fragment 基类：</p>
<ul>
<li><p>DialogFragment<br>显示悬浮对话框，使用此类创建一个对话框是一个对于使用 Activity  dialog helper 方法的好的替代方案，因为 fragment 会自动处理对话框的创建和清理。详细信息参考 DialogFragment。</p>
</li>
<li><p>PreferenceFragmentCompat<br>显示作为列表的 Preference 对象的层次结构。你可以使用<br>PreferenceFragmentCompat 来为你的 App 创建一个设置屏幕。</p>
</li>
</ul>
<h4 id="添加一个-fragment-到-activity"><a href="#添加一个-fragment-到-activity" class="headerlink" title="添加一个 fragment 到 activity"></a>添加一个 fragment 到 activity</h4><p>通常，你的 fragment 必须嵌入在 AndroidX <code>FragmentActivity</code> 中，用以贡献一部分 UI 到 activity 布局。<code>FragmentActivity</code> 是 <code>AppCompatActivity</code> 基类，因此如果你已经在你的 App 中为 AppCompatActivity 提供了向后兼容性，那么你不必改变你的 activity 基类。</p>
<p>你可以通过两种方式添加 fragment：</p>
<ul>
<li>在 activity 的布局文件中定义片段</li>
<li>在 activity 布局文件定义 fragment 容器，后面通过程序添加到 activity。</li>
</ul>
<p>在任何一种情况下，你都需要添加一个 <code>FragmentContainerView</code>，定义了 fragment 应该放在 activity 试图层次结构中的位置。</p>
<p>强烈建议：使用 Fragment 作为 fragment 的容器，因为 <code>FragmentContainerView</code> 包含了其他 View Group（如 FrameLayout）没有提供的修复程序。</p>
<h5 id="通过-XML-添加-fragment"><a href="#通过-XML-添加-fragment" class="headerlink" title="通过 XML 添加 fragment"></a>通过 XML 添加 fragment</h5><p>为了声明将 fragment 添加到你的 activity 布局 XML，你需要添加一个 <code>FragmentContainerView</code> 元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/example_activity.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_container_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.example.ExampleFragment&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>Android:name 指定要实例化的 fragment 类名。当 activity 布局填充时，指定的 fragment 会实例化，当新实例化 fragment 时，onInflate() 会被调用，并且会创建一个 <code>FragmentTransaction</code> 去将 fragment 添加到 <code>FragmentManager</code>。</p>
<h5 id="程序化添加-fragment"><a href="#程序化添加-fragment" class="headerlink" title="程序化添加 fragment"></a>程序化添加 fragment</h5><p>为了程序化添加 fragment 到 activity，布局应该引入 <code>FragmentContainerView</code> 作为 fragment 容器，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/example_activity.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_container_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>与 XML 方式不同，android:name 属性并未使用，因此不会自动实例化特定 fragment。相反，使用 FragmentTransaction 来实例化 fragment 并将其添加到 activity 的布局中。</p>
<p>当你的 activity 在运行时，你可以制造 fragment transaction 例如添加、删除或者替换 fragment。在 <code>FragmentActivity</code> 中，你可以获得 <code>FragmentManager</code> 的实例，你可以通过它创建 <code>FragmentTransaction</code>。 在 activity 的 onCreate() 方法中，你可以使用 FragmentTransaction.add() 实例化你的 fragment，传递参数 ViewGroup ID 和 fragment Class，然后提交事务，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleActivity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">            getSupportFragmentManager().beginTransaction()</span><br><span class="line">                .setReorderingAllowed(<span class="literal">true</span>)</span><br><span class="line">                .add(R.id.fragment_container_view, ExampleFragment.class, <span class="literal">null</span>)</span><br><span class="line">                .commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当执行一个 FragmentTransaction 时，你应该总是使用 setReorderingAllowed(true)。更多信息参考官网。</p>
</blockquote>
<p>在前面的例子中，请注意，只有在 savedInstanceState 为 null 时，才会创建 fragment 事务。这是为了确保仅仅当 activity 第一次创建的时候，fragment 才会添加一次。发生配置更改或者 activity recreate，savedInstanceState 不再为 null，并且不需要再添加一次 fragment，因为 fragment 可以自动从 savedInstanceState 恢复。</p>
<p>如果你的 fragment 需要一些初始化数据，你可以通过在调用 FragmentTransaction.add() 时提供一个 Bundle，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleActivity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">            bundle.putInt(<span class="string">&quot;some_int&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            getSupportFragmentManager().beginTransaction()</span><br><span class="line">                .setReorderingAllowed(<span class="literal">true</span>)</span><br><span class="line">                .add(R.id.fragment_container_view, ExampleFragment.class, bundle)</span><br><span class="line">                .commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 fragment 中，你可以通过调用 <code>requireArguments()</code> 来获取参数 Bundle，并且可以使用适合的 getter 方法来获取每个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleFragment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">someInt</span> <span class="operator">=</span> requireArguments().getInt(<span class="string">&quot;some_int&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">implementation &#x27;com<span class="selector-class">.squareup</span><span class="selector-class">.okhttp3</span>:okhttp:<span class="number">4.9</span>.<span class="number">0</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>向 Activity 添加 Fragment</title>
    <url>/2022/07/18/Android/%E5%90%91-Activity-%E6%B7%BB%E5%8A%A0-Fragment/</url>
    <content><![CDATA[<h1 id="向-Activity-添加-Fragment"><a href="#向-Activity-添加-Fragment" class="headerlink" title="向 Activity 添加 Fragment"></a>向 Activity 添加 Fragment</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>在 Activity 的布局文件内声明片段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.news.ArticleListFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/list&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.news.ArticleReaderFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/viewer&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><code>&lt;fragment&gt;</code> 的 android:name 属性指定要在布局中进行实例化的 Fragment 类。</p>
<p>创建 activity 布局时，系统会将每个 fragment 实例化，并调用 OnCreateView() 方法，以检索每个片段的布局。系统会返回插入 fragment 后的 View。</p>
<blockquote>
<p>注意：每个片段都需要唯一标识符，重启 Activity 时，系统可使用该标识符来恢复片段（您也可以使用该标识符来捕获片段，从而执行某些事务，如将其移除）。可以通过两种方式为片段提供 ID：</p>
</blockquote>
<p>为 android:id 属性提供唯一 ID。<br>为 android:tag 属性提供唯一字符串。</p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>在 activity 运行期间，可以随时将片段添加到 activity 布局中，只需指定 fragment 放入哪个 ViewGroup。</p>
<p>在 activity 中执行片段事务（如添加、移除或替换片段），必须使用 FragmentTransaction API。</p>
<p>可以从 FragmentActivity 获取一个FragmentTransaction实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FragmentManager</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> getSupportFragmentManager();</span><br><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">fragmentTransaction</span> <span class="operator">=</span> fragmentManager.beginTransaction();</span><br></pre></td></tr></table></figure>

<p>然后，使用 add() 方法添加片段，指定要添加的片段以及插入哪个视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExampleFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleFragment</span>();</span><br><span class="line">fragmentTransaction.add(R.id.fragment_container, fragment);</span><br><span class="line">fragmentTransaction.commit();</span><br></pre></td></tr></table></figure>

<p>一旦通过 FragmentTransaction 做出了更改，就必须调用 commit() 以使更改生效。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 笔记</title>
    <url>/2022/07/20/Git/Git-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="官方网址"><a href="#官方网址" class="headerlink" title="官方网址"></a>官方网址</h1><hr>
<p><a href="https://git-scm.com/">https://git-scm.com/</a></p>
<p><a href="https://git-scm.com/book/zh/v2/">https://git-scm.com/book/zh/v2/</a></p>
<h1 id="使用前的准备"><a href="#使用前的准备" class="headerlink" title="使用前的准备"></a>使用前的准备</h1><p><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE">配置用户信息</a></p>
<p>项目配置优先生效，如果没有项目配置，则使用全局配置。</p>
<h1 id="服务器-Git"><a href="#服务器-Git" class="headerlink" title="服务器 Git"></a>服务器 Git</h1><p><a href="https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BA-Git">裸仓库搭建</a></p>
<p>&amp;nbsp;</p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="Getting-and-Creating-Projects"><a href="#Getting-and-Creating-Projects" class="headerlink" title="Getting and Creating Projects"></a>Getting and Creating Projects</h2><h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a><a href="https://git-scm.com/docs/git-clone">clone</a></h3><p><code>git clone &lt;repository&gt;</code><br>克隆仓库。默认克隆全部分支。</p>
<p><code>git clone -b &lt;branch&gt; &lt;repository&gt; &lt;dirname&gt;</code><br>指定克隆某个分支。如果只需要一个分支，可以使用此命令，减少 clone 时间。</p>
<p>执行了这条命令之后自动在当前文件夹下初始化本地库且克隆了远程库，提供了一个名为 origin 的指向远程库的别名。</p>
<p>注意：<br>(1) windows 的凭据管理器会记住你的登录信息并不再需要登录，因此在同一机器上想要达到不同角色 push 的效果时需注意。<br>(2) 通过添加 -b 参数可以指定克隆的分支。long style: –branch<br>(3) dirname 表示生成的本地文件夹名称，默认为仓库名</p>
<h2 id="Branching-and-Merging"><a href="#Branching-and-Merging" class="headerlink" title="Branching and Merging"></a>Branching and Merging</h2><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a><a href="https://git-scm.com/docs/git-branch">branch</a></h3><p>可以简写为 <code>git branch</code>，列出本地存在的分支。当前分支会以绿色高亮并带 * 前缀。short style: <code>git branch -l</code><br><img src="https://img-blog.csdnimg.cn/e62d35e42b064b82a88638d37e972731.png" alt="在这里插入图片描述"></p>
<h3 id="git-branch-remote"><a href="#git-branch-remote" class="headerlink" title="git branch --remote"></a><code>git branch --remote</code></h3><p>列出远程分支，short style: <code>git branch -r</code><br><img src="https://img-blog.csdnimg.cn/7b4a04429ffd47eb9ba204c7adabdf67.png" alt="在这里插入图片描述"></p>
<h3 id="git-branch-all"><a href="#git-branch-all" class="headerlink" title="git branch --all"></a><code>git branch --all</code></h3><p>列出所有分支，short style: <code>git branch -a</code><br><img src="https://img-blog.csdnimg.cn/eed9d23a5e35469fbe35f83a2a1d9cbc.png" alt="在这里插入图片描述"></p>
<h3 id="git-branch-list-lt-pattern-gt"><a href="#git-branch-list-lt-pattern-gt" class="headerlink" title="git branch --list &lt;pattern&gt;"></a><code>git branch --list &lt;pattern&gt;</code></h3><p>使用 shell 通配符列出 branch，pattern 可以传入多个，它们之间是 “或” 关系，即匹配任意一个即可。<br><img src="https://img-blog.csdnimg.cn/64b84c70d2a1432ba931eaa2b92ba3b9.png" alt="在这里插入图片描述"></p>
<h3 id="git-branch-d-lt-branch-gt"><a href="#git-branch-d-lt-branch-gt" class="headerlink" title="git branch -d &lt;branch&gt;"></a><code>git branch -d &lt;branch&gt;</code></h3><p>删除分支。或者：<code>git branch -D &lt;branch&gt;</code></p>
<h3 id="git-branch-m-lt-oldbranch-gt-lt-newbranch-gt"><a href="#git-branch-m-lt-oldbranch-gt-lt-newbranch-gt" class="headerlink" title="git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;"></a><code>git branch -m &lt;oldbranch&gt; &lt;newbranch&gt;</code></h3><p>重命名分支。如果 <newbranch> 已经存在，需要使用 -M 强制。</p>
<h3 id="git-branch-set-upstream-to-lt-远程主机-gt-lt-远程分支-gt-lt-本地分支-gt"><a href="#git-branch-set-upstream-to-lt-远程主机-gt-lt-远程分支-gt-lt-本地分支-gt" class="headerlink" title="git branch --set-upstream-to=&lt;远程主机&gt;/&lt;远程分支&gt; &lt;本地分支&gt;"></a><code>git branch --set-upstream-to=&lt;远程主机&gt;/&lt;远程分支&gt; &lt;本地分支&gt;</code></h3><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><h4 id="撤销-add"><a href="#撤销-add" class="headerlink" title="撤销 add"></a>撤销 add</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">edit</span><br><span class="line">git add frotz.c filfre.c</span><br><span class="line">git reset </span><br></pre></td></tr></table></figure>
<ol>
<li>你愉快地在做某件事，发现这些文件的更改都完成了。你不想在 <code>git diff</code> 看到他们，因为你打算操作别的文件了，这些文件的更改可能会干扰你的注意力。</li>
<li>有人让你 pull，这些更改听起来值得合并</li>
<li>但是，你已经弄脏了 index（例如，你的 index 并不匹配 <code>HEAD</code> commit）。但你知道，你打算 pull 的操作并不会影响 <code>frotz.c</code> 或者 <code>filfre.c</code>，因此你 revert 对这两个文件索引的更改。在工作树中你的更改仍然存在。</li>
<li>然后，你可以 pull 且 merge，<code>frotz.c</code> 和 <code>filefre.c</code> 的更改仍然在工作树</li>
</ol>
<p>&amp;nbsp;</p>
<h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><p>管理被跟踪仓库的设置</p>
<ul>
<li><code>git remote [-v | --verbose]</code></li>
</ul>
<p>查看所有的别名。</p>
<p>-v | –verbose 表示显示更详细内容。</p>
<ul>
<li><code>git remote add &lt;别名&gt; &lt;地址&gt;</code></li>
</ul>
<p>给远程库添加别名。</p>
<ul>
<li><code>git remote rename &lt;old&gt; &lt;new&gt;</code></li>
</ul>
<p>将名为 <code>&lt;old&gt;</code>  的 remote 重命名为 <code>&lt;new&gt;</code>。更新所有远程跟踪分支和配置设置。</p>
<ul>
<li><code>git remote remove &lt;name&gt;</code></li>
</ul>
<p>删除名为 <code>&lt;name&gt;</code> 的 remote。所有 跟踪的 remote 分支和配置设置都会被删除。</p>
<p>&amp;nbsp;</p>
<h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><h3 id="git-checkout-lt-branch-gt"><a href="#git-checkout-lt-branch-gt" class="headerlink" title="git checkout &lt;branch&gt;"></a><code>git checkout &lt;branch&gt;</code></h3><p>切换分支。</p>
<p>情况一 <branch> 是本地已存在的分支。立即切换，保留工作树的改动。</p>
<p>情况二 <branch> 本地不存在，远程不存在。从远程拉取分支，并切换，保留工作树的改动。</p>
<p>情况三 <branch> 本地和远程都不存在。git 会将 <branch> 识别为一个本地文件或文件夹，此时 git 会丢弃该文件当前工作树上所有的改动（危险！！！）。<br>用法：<code>git checkout .</code> 可以以当前所在目录为根，递归丢弃当前文件夹下所有改动，对于 PHP 线上调试还原比较有用。</p>
<h3 id="git-checkout-b-lt-branch-gt"><a href="#git-checkout-b-lt-branch-gt" class="headerlink" title="git checkout -b &lt;branch&gt;"></a><code>git checkout -b &lt;branch&gt;</code></h3><p>等价于 <code>git branch &lt;branch&gt;</code> + <code>git checkout &lt;branch&gt;</code>，但如果 <branch> 已经存在，则会报错，因为 <code>git branch &lt;branch&gt;</code> 不允许创建重名分支。</p>
<h3 id="git-checkout-B-lt-branch-gt"><a href="#git-checkout-B-lt-branch-gt" class="headerlink" title="git checkout -B &lt;branch&gt;"></a><code>git checkout -B &lt;branch&gt;</code></h3><p>情况一 如果 <branch> 不存在，则创建并切换。<br>情况二 如果 <branch> 存在，则将 <branch> 重置为当前分支的状态，切换，工作树保留。（危险！！！）</p>
<h3 id="将-dev-分支的某个文件改动合并到-master"><a href="#将-dev-分支的某个文件改动合并到-master" class="headerlink" title="将 dev 分支的某个文件改动合并到 master"></a>将 dev 分支的某个文件改动合并到 master</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到 master</span></span><br><span class="line">git checkeout master</span><br><span class="line"><span class="comment"># 进入手选模式</span></span><br><span class="line">git checkout --patch dev 要合并的文件路径</span><br></pre></td></tr></table></figure>



<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><h3 id="git-rm-cached-lt-file-gt"><a href="#git-rm-cached-lt-file-gt" class="headerlink" title="git rm --cached &lt;file&gt;"></a><code>git rm --cached &lt;file&gt;</code></h3><p>删除文件缓存。可以将已经被 git 跟踪，但从此不想被跟踪的文件进行缓存删除。</p>
<h3 id="git-rm-r-cached-lt-dir-gt"><a href="#git-rm-r-cached-lt-dir-gt" class="headerlink" title="git rm -r --cached &lt;dir&gt;"></a><code>git rm -r --cached &lt;dir&gt;</code></h3><p>删除文件夹缓存。可以将已经被 git 跟踪，但从此不想被跟踪的文件进行缓存删除。-r 代表递归，用于文件夹。</p>
<p>删除一个 maven 项目下所有 target 文件夹的跟踪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cache -r --ignore-unmatch */target</span><br></pre></td></tr></table></figure>


<h2 id="Administration"><a href="#Administration" class="headerlink" title="Administration"></a>Administration</h2><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a><code>clean</code></h3><p>删除所有未跟踪的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git clean -d -f</span><br></pre></td></tr></table></figure>

<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a><code>git stash</code></h3><p>创建储藏</p>
<h3 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a><code>git stash list</code></h3><p>查看贮藏</p>
<h3 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a><code>git stash apply</code></h3><p>使用贮藏。默认使用最近的一个，如果要指定最近的第二个，则 <code>git stash apply stash@&#123;2&#125;</code></p>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a><code>config</code></h3><p>修改 git log 显示格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地仓库格式修改</span></span><br><span class="line">git config log.date <span class="string">&quot;format:%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line">git config log.date iso8601</span><br><span class="line">git config log.date short <span class="comment"># 只显示日期</span></span><br><span class="line"><span class="comment"># 修改全局样式</span></span><br><span class="line">git config --global log.date <span class="string">&quot;format:%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line">git config --global log.date iso8601</span><br><span class="line">git config --global log.date short <span class="comment"># 只显示日期</span></span><br></pre></td></tr></table></figure>




<h1 id="凭证存储"><a href="#凭证存储" class="headerlink" title="凭证存储"></a>凭证存储</h1><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">官方文档</a></p>
<p>凭证存储涉及到免密登录</p>
<h1 id="IDE-的使用"><a href="#IDE-的使用" class="headerlink" title="IDE 的使用"></a>IDE 的使用</h1><p>Eclipse 如何给没有 git 版本控制的项目添加版本控制？</p>
<h1 id="Github-访问慢"><a href="#Github-访问慢" class="headerlink" title="Github 访问慢"></a>Github 访问慢</h1><p><a href="https://blog.csdn.net/qq_45921491/article/details/115977828">https://blog.csdn.net/qq_45921491/article/details/115977828</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java Collection</title>
    <url>/2022/07/19/JDK/Java-Collection/</url>
    <content><![CDATA[<h1 id="Java-Collection"><a href="#Java-Collection" class="headerlink" title="Java Collection"></a>Java Collection</h1><h2 id="容器底层数据结构"><a href="#容器底层数据结构" class="headerlink" title="容器底层数据结构"></a>容器底层数据结构</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><code>ArrayList</code>: <code>Object[]</code> 数组</li>
<li><code>Vector</code>: <code>Object[]</code> 数组</li>
<li><code>LinkedList</code>: JDK 1.7 之前，双向循环链表；JDK 1.7 之后，双向链表</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><p><code>HashMap</code>：JDK 1.8 之前，数组 + 链表；JDK 1.8 之后，数组 + 链表&#x2F;红黑树</p>
</li>
<li><p><code>LinkedHashMap</code>：双向链表 + 数组 + 链表</p>
</li>
<li><p><code>Hashtable</code>: 数组 + 链表</p>
</li>
<li><p><code>TreeMap</code>：红黑树</p>
</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><code>HashSet</code>: 基于 <code>HashMap</code> 实现</p>
<p><code>LinkedHashSet</code>: 基于 <code>LinkedHashMap</code> 实现</p>
<p><code>TreeSet</code>: 红黑树</p>
<blockquote>
<p><strong>思考</strong>：为什么 <code>HashSet</code> 底层 <code>HashMap</code> 的 value 不存储 null，反而是一个 Object?</p>
</blockquote>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>PriorityQueue</code>: <code>Object[]</code> 数组二叉堆</p>
<p><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</p>
<h2 id="集合选择场景"><a href="#集合选择场景" class="headerlink" title="集合选择场景"></a>集合选择场景</h2><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><ul>
<li><p>一些签名计算要求传入的参数按照 ascii 排序可以使用 <code>TreeMap</code></p>
</li>
<li><p>多线程场合 <code>ConcurrentHashMap</code></p>
</li>
<li><p>其余场合 <code>HashMap</code></p>
</li>
</ul>
<h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><p>保证元素唯一 <code>TreeSet</code>、<code>HashSet</code>，做一些统计</p>
<h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><p>没有特别要求就选择 <code>ArrayList</code>、<code>LinkedList</code></p>
]]></content>
      <tags>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Java I/O 笔记</title>
    <url>/2022/07/20/JDK/Java-I-O-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><p>当应用程序发起 I&#x2F;O 调用后，会经历两个步骤：</p>
<ol>
<li>内核等待 I&#x2F;O 设备准备好数据</li>
<li>内核将数据从内核空间拷贝到用户空间。</li>
</ol>
<h1 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h1><ul>
<li>BIO (Blocking I&#x2F;O)</li>
</ul>
<p>同步阻塞 I&#x2F;O 模型，应用程序（线程）发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p>
<ul>
<li>NIO (Non-blocking&#x2F;New I&#x2F;O)</li>
</ul>
<p>I&#x2F;O 多路复用模型。属于同步非阻塞 I&#x2F;O 模型。应用程序会一直发起 read 调用，检查是否有数据。数据从内核空间拷贝到用户空间的这段时间，线程依然是阻塞。</p>
<p>相比于同步阻塞 I&#x2F;O，同步非阻塞 I&#x2F;O 避免了无数据阻塞。但是轮询十分消耗 CPU。</p>
<p>I&#x2F;O 多路复用模型。线程发起 select 调用，询问内核数据是否准备就绪，等内核数据准备好了，用户线程再发起 read 调用。</p>
<p>Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>
<h1 id="一般-IO"><a href="#一般-IO" class="headerlink" title="一般 IO"></a>一般 IO</h1><ul>
<li>InputStream 所有字节输入流的超类<ul>
<li>FileInputStream 用于操作文件的读取</li>
<li>ByteArrayInputStream</li>
<li>FilterInputStream<ul>
<li>BufferedInputStream</li>
<li>DataInputStream</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;nbsp;</p>
<ul>
<li>OutputStream<ul>
<li>FilterOutputStream<ul>
<li>DataOutputStream</li>
<li>PrintStream</li>
<li>BufferedOutputStream</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&amp;nbsp;<br>Java 1.1 对基本 I&#x2F;O 流类库进行了重大改写。Reader 和 Writer 属于其中的新产物，不过它们的出现并不是取代 InputStream 和 OutputStream，因为 InputStream 和 OutputStream 在面向字节的 I&#x2F;O 仍然具有价值，Reader 和 Writer 则提供了兼容 Unicode 与面向字符的 I&#x2F;O。</p>
<ul>
<li>Reader<ul>
<li>InputStreamReader<ul>
<li>FileReader</li>
</ul>
</li>
</ul>
</li>
<li>Writer<ul>
<li>OutputStreamWriter<ul>
<li>FileWriter</li>
</ul>
</li>
<li>PrintWriter</li>
</ul>
</li>
</ul>
<p>案例 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getFileContent</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">         <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fileInputStream, StandardCharsets.UTF_8);</span><br><span class="line">         <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">readLine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((readLine = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.append(readLine);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putFileContent</span><span class="params">(String content, String path)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(path), <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">         <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(printWriter);) &#123;</span><br><span class="line">        bufferedWriter.write(content);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><p>Blocking IO 的缩写，意思是阻塞型 IO</p>
<p>ServerSocket.accept() 方法会一直阻塞到一个连接建立，返回一个新的 Socket 用于客户端和服务器之间的通信。</p>
<p>如果为每个客户端创建一个新的 Thread，有以下问题: </p>
<ol>
<li><p>任何时候都可能有大量的线程处于休眠状态，只是等待输入或输出数据，造成资源浪费</p>
</li>
<li><p>需要为每个线程的调用栈都分配内存，内存消耗问题</p>
</li>
<li><p>即使忽略内存消耗问题，上下文的切换开销也很大</p>
</li>
</ol>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>FileChannel、DatagramChannel、ServerSocketChannel、SocketChannel</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><blockquote>
<p>关于以下属性的解释可以参考：<a href="https://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html">https://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html</a></p>
</blockquote>
<p>mark: 缓冲区的 mark 是在调用 reset 方法时将其位置重置到的索引。</p>
<p>position: 缓冲区的 position 是下一个要读或写的元素的索引。缓冲区的位置永远不会为负，也永远不会大于其 limit。</p>
<p>limit: 缓冲区的 limit 是不应该读取或写入的第一个元素的索引。缓冲区的 limit 永远不会是负的，也永远不会超过它的 capacity 。</p>
<p>capacity: 缓冲区的 capacity 就是它包含的元素的数量。缓冲区的容量永远不会是负的，也永远不会改变。</p>
<p>具有 0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity </p>
<p>clear(): 使 buffer 为新的读取或者相对 put 操作做好准备，它将设置 limit 为 capacity，并且 position 设置为 0</p>
<p>flip(): 使 buffer 为新的序列写入或者相对 get 操作做好准备，他将设置 limit 为当前的位置，并且设置 position 为 0</p>
<p>rewind(): 使 buffer 为重新读取已经包含的数据做好准备，它将保持 limit 不变，设置 position 为 0</p>
<h3 id="只读-Buffer"><a href="#只读-Buffer" class="headerlink" title="只读 Buffer"></a>只读 Buffer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">byteBuffer.asReadOnlyBuffer();</span><br></pre></td></tr></table></figure>

<h3 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h3><p>文件的修改在堆外内存进行</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/MappedByteBuffer.html">https://docs.oracle.com/javase/8/docs/api/java/nio/MappedByteBuffer.html</a></p>
</blockquote>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>select() 方法是阻塞操作。但可以设置超时时间。</p>
<p>SelectionKey<br>包含以下 int 类型常量 OP_READ、OP_WRITE、OP_CONNECT、OP_ACCEPT</p>
]]></content>
  </entry>
  <entry>
    <title>Java HotSpot VM 笔记</title>
    <url>/2022/07/20/JVM/Java-HotSpot-VM-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2><p>目前主流的两款商用 Java VM （HotSpot、OpenJ9）里，Java 程序最初都是通过解释器（Interperter）进行解释的。当 VM 发现某个方法或者代码块的运行特别频繁，就会把这些代码认定为 “热点代码”（Hot Spot Code），为了提到热点代码的执行效率，在运行时，VM 会将这些代码编译成本地机器码，并以各种手段尽可能地进行代码优化，运行时完成这个任务的后端编译器被称为即时编译器。</p>
<h2 id="HotSpot-分代"><a href="#HotSpot-分代" class="headerlink" title="HotSpot 分代"></a>HotSpot 分代</h2><p>针对 J2SE 5.0 HotSpot JVM：</p>
<p>Java HotSpot 虚拟机的内存被分为三代：young generation（年轻代）、old generation（老年代）、permanent generation（永久代）。大多数对象一开始的时候都是分配在年轻代。老年代的对象是那些已经在年轻代经历了几次回收且存货下来的对象，以及一些可以直接分配在老年代的大型对象。永久代存储描述类和方法的对象，以及类和方法本身。</p>
<p>年轻代包含一个叫 Eden 的区域，以及 2 个较小的 Survivor Spaces。大多数对象一开始都是被分配在 Eden。（之所以用”大多数”，因为少部分大型对象可能直接被分配在老年代）。Survivor Spaces 存放那些至少活过 1 次年轻代的回收，被给予了更多死亡的机会，但是依然存活下来，足够老，可以”晋升”到老年代。在任何给定的时刻，Survivor Spaces 中只有 1 个持有对象，另一个Survivor Space 是空的，且保留不使用，直到下一次回收，循环使用。</p>
<blockquote>
<p>每次回收，将会交换幸存者空间的使用。</p>
</blockquote>
<p>当年轻代满了的时候，年轻代会执行垃圾回收（有时候也叫 minor collection）。当老年代或者永久代满了，所谓的 full collection 将会执行（有时候也叫 major collection）。也就是说，所有的代都会回收垃圾。通常，年轻代首先被回收，使用特别为它设计的回收算法，因为这种算法通常是在年轻代识别垃圾最高效的算法。如果发生压缩，每个代也都是单独压缩的。</p>
<h3 id="Serial-Collector"><a href="#Serial-Collector" class="headerlink" title="Serial Collector"></a>Serial Collector</h3><p>Serial Collector 可以叫做串行回收器。使用串行回收器，年轻代和老年代都会在 stop-the-world 状态下，串行地进行回收工作（使用单 CPU）。也就是说，当回收工作进行时，应用执行会终止（即停止全部线程）。</p>
<h4 id="使用串行回收器进行年轻代回收"><a href="#使用串行回收器进行年轻代回收" class="headerlink" title="使用串行回收器进行年轻代回收"></a>使用串行回收器进行年轻代回收</h4><p>下图描述了年轻代使用串行回收器回收的操作。Eden 中存活的对象将拷贝到一开始是空的幸存者空间（即<em>To</em>）。</p>
<img src="https://img-blog.csdnimg.cn/b67e8215c77f4412ba43a752967e9c4d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<blockquote>
<p>除了那些太大，<em>To</em> 空间都放不下的对象，这样的对象会直接拷贝到老年代。</p>
</blockquote>
<p>在被占用的幸存者空间（即<em>From</em>）中，存活下来的对象，而且相对比较年轻的（经历回收次数不多）会转移到另一个幸存者空间（<em>To</em>）。</p>
<blockquote>
<p>相对比较老的（经历回收次数多）对象会拷贝到老年代。</p>
</blockquote>
<blockquote>
<p>另外注意：如果 <em>To</em> 空间满了，那些来自于 Eden 或者 From 空间的，存活着，但还没有拷贝的对象直接进入老年代，不管它们经历了几次存活。</p>
</blockquote>
<p>在存活对象拷贝之后，任何还留在 Eden 或者 From 空间的对象，按定义来说，都不再存活，而且，它们也不必再检查了。</p>
<blockquote>
<p>图中标记了 “X” 的对象都是垃圾对象，不过实际上，回收器也不会检查它们，或者标记它们，只是为了展示，一般直接回收掉。</p>
</blockquote>
<p>在年轻代回收完毕之后，Eden 和之前被占用的幸存者空间（之前的<em>From</em>）都是空的，仅仅只有之前是空的幸存者空间（之前的<em>To</em>）包含了存活对象。这时候可以说，幸存者空间交换了角色（<em>To</em> 和 <em>From</em> 角色交换，如下图）。</p>
<img src="https://img-blog.csdnimg.cn/66ed535803f64911ad2e8880bcfff26f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<h4 id="Serial-Old-回收器"><a href="#Serial-Old-回收器" class="headerlink" title="Serial Old 回收器"></a>Serial Old 回收器</h4><p>Serial 回收器老年代版本，老年代和永久代通过 “标记-清理-压缩” 回收算法进行回收工作。在标记阶段，回收器识别哪些对象是存活的。清理阶段识别、清理老年代中垃圾。然后，回收器执行移动压缩，将存活的对象移动到老年代的一端（永久代也类似），使剩下的空闲区域形成一个连续的块位于另一端。压缩可以让以后分配到老年代和永久代的操作使用快速的 bump-the-pointer 技术。</p>
<h4 id="串行回收器的使用场景"><a href="#串行回收器的使用场景" class="headerlink" title="串行回收器的使用场景"></a>串行回收器的使用场景</h4><p>现在，串行回收器并非没有它的价值。对于运行在 Client 模式下的虚拟机，串行回收器是默认的新生代回收器。优势在于：简单高效、没有线程交互开销。</p>
<h4 id="串行回收器的选择"><a href="#串行回收器的选择" class="headerlink" title="串行回收器的选择"></a>串行回收器的选择</h4><p>在 J2SE 5.0 发行版，在非 server-class 的机器上，默认选择串行回收器。在其他机器，串行回收器需要使用 <code>-XX:+UseSerialGC</code> 命令行选项。</p>
<h3 id="Parallel-Collector"><a href="#Parallel-Collector" class="headerlink" title="Parallel Collector"></a>Parallel Collector</h3><p>Parallel Collector 可以叫做并行回收器。</p>
<h4 id="使用并行回收器进行年轻代回收"><a href="#使用并行回收器进行年轻代回收" class="headerlink" title="使用并行回收器进行年轻代回收"></a>使用并行回收器进行年轻代回收</h4><p>并行回收器使用的是串行回收器进行年轻代回收工作的算法的并行版本。它仍然是一个 stop-the-world 并进行拷贝的回收器，但是，它可以使用多 CPU，并行地执行年轻代的回收工作，减少了垃圾回收的开销，因此可以提高应用吞吐量。下图描述了串行回收器和并行回收器在年轻代工作时的区别。</p>
<img src="https://img-blog.csdnimg.cn/8144d34935e84481a7db57b8b3676974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<h4 id="使用并行回收器进行老年代回收"><a href="#使用并行回收器进行老年代回收" class="headerlink" title="使用并行回收器进行老年代回收"></a>使用并行回收器进行老年代回收</h4><p>用并行回收器进行老年代垃圾回收工作，将会使用和串行回收器相同的串行 “标记-清理-压缩” 回收算法。</p>
<h4 id="何时使用并行回收器"><a href="#何时使用并行回收器" class="headerlink" title="何时使用并行回收器?"></a>何时使用并行回收器?</h4><p>运行在多处理器的机器上，并且，没有对暂停时间要求不高的应用程序将能从并行回收器获益。</p>
<blockquote>
<p>因为有可能发生长时间的老年代回收，尽管比较少见。</p>
</blockquote>
<p>比较合适使用并行回收器的应用，例如：批处理、账单服务、支付、科学计算等。</p>
<h3 id="Parallel-Compacting-Collector"><a href="#Parallel-Compacting-Collector" class="headerlink" title="Parallel Compacting Collector"></a>Parallel Compacting Collector</h3><p>Parallel Compacting Collector，可以翻译为并行压缩回收器。</p>
<p>首先在 JDK 5 update 6 中提供， JDK 6 中实现性能显著改进。</p>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/par-compaction-6.html">JDK</a></p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><ul>
<li>JDK 6</li>
</ul>
<p>默认情况不启用并行压缩，如果需要，添加选项 <code>-XX:+UseParallelOldGC</code> 到 Java 命令行。</p>
<p>注意：并行压缩不能与 CMS 回收器一起使用。它只能与年轻代的并行回收器一起使用。</p>
<h4 id="使用-Parallel-Compacting-Collector-进行年轻代回收"><a href="#使用-Parallel-Compacting-Collector-进行年轻代回收" class="headerlink" title="使用 Parallel Compacting Collector 进行年轻代回收"></a>使用 Parallel Compacting Collector 进行年轻代回收</h4><p>对于 Parallel Compacting Collector 进行年轻代垃圾回收工作，会使用与 Parallel Collector 一样的算法。</p>
<h4 id="使用-Parallel-Compacting-Collector-进行老年代回收"><a href="#使用-Parallel-Compacting-Collector-进行老年代回收" class="headerlink" title="使用 Parallel Compacting Collector 进行老年代回收"></a>使用 Parallel Compacting Collector 进行老年代回收</h4><p>使用 Parallel Compacting Collector，老年代和永久代在 stop-the-world 下进行垃圾回收，通常伴随着滑动压缩。</p>
<blockquote>
<p>与 Parallel 一样，都需要 stop-the-world</p>
</blockquote>
<p>回收器使用三个阶段。(1) 每个代，从逻辑上被划分为固定大小的区（region）。在 marking 阶段，应用程序代码直接可达的存活对象的初始集合在垃圾回收线程被划分，然后并行地标记所有的存活对象。当识别出对象是存活时，对象所在 region 关于对象大小和位置的信息数据被更新。</p>
<p>(2) 汇总阶段是在 region 上操作，而不是对象。由于之前回收的压缩，通常，每个代左边的部分是密集的，包含了大多数存活对象。从这些密集的 region 中回收空间是不值得它们去压缩的。region 到那一点的左边被认为是 dense  prefix，并且没有对象会移动到那些区域。那一点右边的区域会被压缩，消除所有死亡的空间。汇总阶段计算并存储下每个压缩 region 存活数据的第一个字节的新位置。注意：汇总阶段当前以串行实现，并行化是可能的，但是对于执行来说，不如标记和压缩阶段的并行化重要。</p>
<p>(3) 在压缩阶段，垃圾回收线程使用汇总的数据来识别需要填充的 region，并且线程可以独立把数据拷贝进 region。这样就产生了一个一端高密度的堆，另一端是一个巨大的空块。</p>
<h4 id="何时使用-Parallel-Compacting-Collector"><a href="#何时使用-Parallel-Compacting-Collector" class="headerlink" title="何时使用 Parallel Compacting Collector"></a>何时使用 Parallel Compacting Collector</h4><p>与并行回收器一样，并行压缩回收器对于运行在多核 CPU 的机器上的应用程序是有益的。此外，老年代回收的并行操作缩短了暂停时间，并且，对于有暂停时间约束的应用程序，并行压缩回收器比并行回收器更适合。</p>
<p>并行压缩回收器也许不太适合运行在大型的共享机器的应用程序，在这种情况下，单个应用程序不能长时间独自霸占多 CPU。在这样的机器上，要么考虑减少垃圾回收现成的数量（通过 <code>-XX:ParaleelGCThreads=n</code> 命令行选项），要么选择别的回收器。</p>
<h4 id="选择并行压缩回收器"><a href="#选择并行压缩回收器" class="headerlink" title="选择并行压缩回收器"></a>选择并行压缩回收器</h4><p>如果你想使用并行压缩回收器，你必须指定命令行选项 <code>-XX:+UseParallelOldGC</code></p>
<h3 id="Concurrent-Mark-Sweep-CMS-Collector"><a href="#Concurrent-Mark-Sweep-CMS-Collector" class="headerlink" title="Concurrent Mark-Sweep (CMS) Collector"></a>Concurrent Mark-Sweep (CMS) Collector</h3><p>并发标记清理回收器，可以简称为 CMS。</p>
<h4 id="使用并发标记清理收集器进行老年代收集"><a href="#使用并发标记清理收集器进行老年代收集" class="headerlink" title="使用并发标记清理收集器进行老年代收集"></a>使用并发标记清理收集器进行老年代收集</h4><p>使用 CMS 进行的老年代清理工作能够与应用程序并发执行。</p>
<p>对于 CMS 来说，1 个收集的周期从一个短暂的停止开始（叫做 <em>initial mark</em>，初始标记），识别出直接可达的存活对象，形成初始集合。然后，在并发标记阶段，收集器标记所有从这些集合中，间接可达的存活对象。因为在标记阶段的时候，应用程序也在运行，更新引用，所以不能保证在并发标记阶段结束的时候，所有存活的对象都能被标记到。</p>
<blockquote>
<p>可能存在存活对象在并发阶段被认为是死亡对象，见<a href="#%E5%AF%B9%E8%B1%A1%E6%B6%88%E5%A4%B1">对象消失</a>。也可能存在浮动垃圾，但是不具有致命影响。</p>
</blockquote>
<p>为了解决这个问题，应用程序再一次停止（叫做 <em>remark</em>），通过重访在并发标记阶段被修改的对象最终确定标记。因为 remark 阶段比 initial 标记工作量更大，多线程并行运行可以提高效率。</p>
<blockquote>
<p>并发标记阶段必须再次停止用户线程，否则又会产生<a href="#%E5%AF%B9%E8%B1%A1%E6%B6%88%E5%A4%B1">对象消失</a>的问题。</p>
</blockquote>
<p>在 remark 阶段结束的时候，所有堆中存活的对象都能保证被标记，因此，接下来的并发清理阶段会回收所有识别出来的垃圾。</p>
<img src="https://img-blog.csdnimg.cn/f2e98462cbf7415eaa1dff0477fc066b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<p>由于一些任务，比如重访 remark 阶段的对象，增加了收集器的工作量，它的开销也相应增加。不过，对于大多数尝试减少停止时间的 GC 来说，这也是一种权衡。</p>
<p>CMS 是仅有的一个不压缩的收集器。也就是说，在释放了死亡对象的空间之后，它不会把存活的对象移动到老年代的一边。</p>
<img src="https://img-blog.csdnimg.cn/a6bb9c66afd34851aa49c6ba0c35cf56.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<p>这节约了时间，但是由于空闲空间不是连续的，收集器不再简单地使用一个指针指向下一个对象可分配的空间区域。相反，它现在需要使用空闲列表。也就是说，它会创建一些列表，连接着未分配的区域内存，每次对象需要分配时，基于内存需要，搜索适当的列表，找到足够大能够存储对象的一块区域。结果，分配进入老年代比使用简单的 bump-the-pointer 代价更大。这也会给年轻代的收集工作带来额外的开销，因为大多数老年代的分配工作都是因为对象在年轻代收集阶段晋升到老年代。</p>
<p>另一个 CMS 的缺陷是，需要比其他收集器更多的堆内存。考虑到应用程序可以在并发标记阶段运行，它可以继续分配内存，因此有可能继续增加老年代。另外，虽然 CMS 能够保证，识别在 GC 过程中所有存活的对象，但是一些对象可能在并发标记阶段变成了垃圾，它们得不到清理直到下一次老年代收集工作。这种垃圾叫做 <em>floating garbage</em>（浮动垃圾）。</p>
<p>与其他 GC 不同的是，CMS 不会在老年代满了的时候才开始进行老年代回收工作。相反，它会早一点开始回收工作，以便在老年代满之前完成清理。</p>
<blockquote>
<p>因为 CMS 收集期间，老年代仍然可能增长。如果不早一点，CMS 可能会回退到使用并行和串行收集器，进行更费时的 stop-the-world  标记-清理-压缩算法。</p>
</blockquote>
<p>为了避免上述可能，CMS 收集器会根据之前的回收时间和老年代占满的时间进行统计，得到合适的时间来提前开始。如果老年代的占用，超过了一个叫 initiating occupancy 的东西，CMS 回收器也会开始回收。</p>
<blockquote>
<p>initiating occupancy 的值可以通过命令行选项 <code>-XX:CMSInitiatingOccupancyFraction=n</code>，其中 n 是一个老年代大小的百分数值。默认是 68。</p>
</blockquote>
<h4 id="增量模式"><a href="#增量模式" class="headerlink" title="增量模式"></a>增量模式</h4><p>Incremental Mode，增量模式、增量 GC。通过慢慢地进行 GC 在缩短 mutator 最大暂停时间的一种手段。</p>
<p>CMS 回收器使用一种&#x3D;&#x3D;并发阶段&#x3D;&#x3D;增量进行的模式。这个模式通过阶段性的停止并发阶段来让出 CPU 给应用程序，以减少长并发阶段的影响。回收器的工作被划分成一个一个小块的时间。</p>
<p>当运行在一些处理器比较少的机器上时（比如只有 1 个或 2 个），应用程序又需要并发回收器提供低暂停时间，那么这个特性还是有用的。</p>
<h4 id="什么时候使用-CMS-回收器"><a href="#什么时候使用-CMS-回收器" class="headerlink" title="什么时候使用 CMS 回收器?"></a>什么时候使用 CMS 回收器?</h4><p>如果 (1) 你的应用程序需要更短的垃圾回收暂停时间，(2) 而且，可以承担得起垃圾回收器与应用程序一起共享处理器资源，那么你可以选择 CMS 回收器。</p>
<blockquote>
<p>由于并发性，CMS 回收器在回收周期内，会占用应用程序一定的 CPU 周期</p>
</blockquote>
<p>通常，应用程序有相对大一点的老年代，并且运行在两个以上的处理器机器上时，更有利于该回收器。例如，Web 服务器。</p>
<p>对于那些需要低暂停时间的应用程序来说，可以考虑 CMS 回收器。对于老年代不太大，又运行在单单处理器上的交互式应用程序来说，CMS 回收器可能也有不错的效果。</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>yum 的使用</title>
    <url>/2022/07/25/Linux/yum-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>更新所有已安装的 rpm 包<br>yum -y update</p>
<p>yum clean all</p>
]]></content>
  </entry>
  <entry>
    <title>MyBatis Generator 笔记</title>
    <url>/2022/08/16/MyBatis/MyBatis-Generator-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MyBatis-Generator-笔记"><a href="#MyBatis-Generator-笔记" class="headerlink" title="MyBatis Generator 笔记"></a>MyBatis Generator 笔记</h1><h2 id="XML-配置参考"><a href="#XML-配置参考" class="headerlink" title="XML 配置参考"></a>XML 配置参考</h2><h3 id="lt-context-gt-元素"><a href="#lt-context-gt-元素" class="headerlink" title="&lt;context&gt; 元素"></a><code>&lt;context&gt;</code> 元素</h3><h4 id="必需的属性"><a href="#必需的属性" class="headerlink" title="必需的属性"></a>必需的属性</h4><ul>
<li>id</li>
</ul>
<p>该上下文的唯一标识符。该值将会在一些错误信息中使用到。</p>
<h4 id="可选的属性"><a href="#可选的属性" class="headerlink" title="可选的属性"></a>可选的属性</h4><ul>
<li>defaultModelType</li>
</ul>
<p>如果 targer runtime 是 MyBatis3Simple, MyBatis3DynamicSql, 或者 MyBatis3Kotlin，该属性会被忽略。</p>
<ul>
<li>targetRuntime</li>
</ul>
<p>该属性用于生成代码的运行时目标。</p>
<p><strong>MyBatisDynamicSql</strong></p>
<h4 id="支持的属性"><a href="#支持的属性" class="headerlink" title="支持的属性"></a>支持的属性</h4><ul>
<li><p>beginningDelimiter</p>
</li>
<li><p>endingDelimiter</p>
</li>
</ul>
<h3 id="lt-javaClientGenerator-gt-元素"><a href="#lt-javaClientGenerator-gt-元素" class="headerlink" title="&lt;javaClientGenerator&gt; 元素"></a><code>&lt;javaClientGenerator&gt;</code> 元素</h3><p><code>&lt;javaClientGenerator&gt;</code> 元素用于定义 Java 客户端生成器的属性。</p>
<h4 id="必需的属性-1"><a href="#必需的属性-1" class="headerlink" title="必需的属性"></a>必需的属性</h4><ul>
<li>type</li>
</ul>
<p>该属性用来选择预定义的 Java 客户端生成器之一，或者指定一个用户提供的 Java 客户端生成器。</p>
<p><strong>XMLMAPPER</strong></p>
<p>生成的对象是 MyBatis 3.x mapper 基础设施的 Java 接口。接口将依赖于生成的 XML mapper 文件。</p>
<ul>
<li>targetPackage</li>
</ul>
<p>这是生成的接口和实现类所在的包。</p>
<ul>
<li>targetProject</li>
</ul>
<p>这用于为生成的接口和类指定目标项目。</p>
<h3 id="lt-javaModelGenerator-gt-元素"><a href="#lt-javaModelGenerator-gt-元素" class="headerlink" title="&lt;javaModelGenerator&gt; 元素"></a><code>&lt;javaModelGenerator&gt;</code> 元素</h3><p><code>&lt;javaModelGenerator&gt;</code> 元素用于定义 Java 模型生成器的属性。Java 模型生成器构建主键类，记录类，以及与自省表匹配的按照 Example 类查询。该元素是 <code>&lt;context&gt;</code> 元素必须的子元素。</p>
<h4 id="必需的属性-2"><a href="#必需的属性-2" class="headerlink" title="必需的属性"></a>必需的属性</h4><ul>
<li>targetPackage</li>
</ul>
<p>这是生成的类将被放置的包。在默认的生成器中，属性 “enableSubPackages” 控制如何计算实际的包。如果为 true，则计算出的包是 targetPackage 加上表的 catalog 和 schema 的子包（如果存在）。</p>
<ul>
<li>targetProject</li>
</ul>
<p>这用于为生成的对象指定目标项目。在 Eclipse 环境中运行时，这将会指定保存对象的项目和源文件夹。在其他环境中，该值应该是本地文件系统上的已经存在的目录。如果此目录不存在， MyBatis Generator 将不会创建此目录。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>创建配置文件，比如在 resources&#x2F;mybatis-generator&#x2F; 下面创建 generatorConfig.xml 配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;mybatis-generator/generator.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span>  <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beginningDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;endingDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--注释--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是否压制时间戳--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressDate&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suppressAllComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 注解采用数据库的标注，suppressAllComments 必须设置为 false 才会生效 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addRemarkComments&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--数据库连接参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span></span></span><br><span class="line"><span class="tag">                <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/xxx?characterEncoding=utf8<span class="symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">userId</span>=<span class="string">&quot;xxx&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">password</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mysql 获取数据库注解的方式，想要获取数据库注解必须添加 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useInformationSchema&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;forceBigDecimals&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 实体类的包名和存放路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成映射文件*.xml的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 生成DAO的包名和位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;xxx&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- tableName：数据库中的表名或视图名；domainObjectName：生成的实体类的类名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;book&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Book&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li>字段名和关键字冲突问题</li>
</ul>
<p>配置界定符</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;beginningDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>&gt;</span>&lt;/property &gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;endingDelimiter&quot;</span> <span class="attr">value</span>=<span class="string">&quot;`&quot;</span>&gt;</span>&lt;/property &gt;</span><br></pre></td></tr></table></figure>

<p>在 table 节点添加属性 <code>delimitAllColumns=&quot;true&quot;</code></p>
]]></content>
  </entry>
  <entry>
    <title>MyBatis 构造 Mapper Proxy 原理</title>
    <url>/2022/07/16/MyBatis/MyBatis-%E6%9E%84%E9%80%A0-Mapper-Proxy-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在 MyBatis 应用中，我们定义的 <code>Mapper</code> 接口，最终都会转换为 JDK 动态代理对象 <code>Proxy</code>。</p>
<p>假设有 UserMapper.xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure>
<p>在 MyBatis 的框架中，提供了 <code>SqlSession</code> 的默认实现类 <code>DefaultSqlSession</code>，关注其实现方法 <code>getMapper()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultSqlSession.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.getMapper(type, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 getMapper 内部调用了属性 <code>Configuration</code> 的 getMapper 方法，将代码细节委托给 <code>Configuration</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configuration.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Configuration</code> 内部的实现是将 getMapper 的细节委托给 <code>MapperRegistry</code> 实现，顾名思义，Mapper 注册表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MapperRegistry.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保该类型被识别</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由 <code>MapperRegistry</code> 的实现可以知道，其内部维护了一个 <code>knownMappers</code> 结构，用于进行 <code>Mapper</code> 接口到 <code>MapperProxyFactory</code> 的映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><code>MapperProxyFactory</code>，由类名可以知道这是一个批量生产 MapperProxy 的工厂类，关注其如何生产 MapperProxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MapperProxyFactory.java</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 InvocationHandler</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 JDK 动态代理的方法创建代理类</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，创建了一个 <code>MapperProxy</code>，这是一个由 MyBatis 提供的 <code>InvocationHandler</code> 的实现类，然后将其传递给 <code>Proxy.newProxyInstance</code> 方法创建 Proxy 并返回。</p>
<blockquote>
<p>从名字上看，MapperProxyFactory 似乎是生产 MapperProxy 的工厂，但在过程中，MapperProxy 只是扮演了代理类的 Handler 角色，MapperProxyFactory 真正生产的应该是代理类。</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL InnoDB Buffer Pool</title>
    <url>/2022/07/20/MySQL/MySQL-%E7%BC%93%E5%86%B2%E6%B1%A0-Buffer-Pool/</url>
    <content><![CDATA[<h1 id="MySQL-InnoDB-Buffer-Pool"><a href="#MySQL-InnoDB-Buffer-Pool" class="headerlink" title="MySQL InnoDB Buffer Pool"></a>MySQL InnoDB Buffer Pool</h1><p>​</p>
<blockquote>
<p>本文主要内容源自官网：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-buffer-pool.html">MySQL :: MySQL 8.0 Reference Manual :: 15.5.1 Buffer Pool</a><br>感兴趣的可以直接阅读</p>
</blockquote>
<p>​缓冲池是主内存的一块区域，其中 InnoDB 访问表和索引数据时会在其中进行缓存。Buffer Pool 允许从内存中访问频繁使用的数据，这加快了处理速度。在专用服务器上，通常将多达 80% 的物理内存分配给 Buffer Pool。</p>
<p>为了大容量的读操作效率，Buffer Pool 被分为多个页面，这些页面可能包含多个行。为了缓存管理的效率，Buffer Pool 被实现为 Page 的链表。使用 LRU （Least Recently Used，最近最少使用）算法的变体将数据从缓存中老化淘汰出去。</p>
<p>知道如何利用 Buffer Pool，以将经常访问的数据保存在内存中是 MySQL 调整的重要方面。</p>
<h1 id="缓冲池-LRU-算法"><a href="#缓冲池-LRU-算法" class="headerlink" title="缓冲池 LRU 算法"></a>缓冲池 LRU 算法</h1><p>缓冲池 LRU 算法将缓冲池作为列表进行管理。当缓冲池空间不足，但有新页面需要添加到缓冲池时，将驱逐最近最少使用的页面，并将新页面添加到列表的 Midpoint（中点）。总列表分为两个子列表（Sublist）：</p>
<ol>
<li><p>最前面的是最近访问过的新页面（或者叫 young 页面，年轻页面）子列表</p>
</li>
<li><p>末尾是最近访问的旧页面的子列表</p>
</li>
</ol>
<img src="https://img-blog.csdnimg.cn/20210201232619278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">


<p>​<br>该算法将经常需要访问的页面保留在 New Sublist。Old Sublist 包含不常用的页面，这些页面是驱逐的候选对象。</p>
<p>通常情况，该算法遵循以下规则：</p>
<p>1.  的 Buffer Pool 用于 Old Sublist</p>
<ol start="2">
<li><p>列表的 Midpoint 是 New Sublist 的 Tail 和 Old Sublist 的 Head 相交的边界。</p>
</li>
<li><p>当 InnoDB 将页面读入缓冲池时，它首先将页面插入 Midpoint。通过用户触发的动作（比如 SQL 查询）或者预读操作可以对页面进行读取。</p>
</li>
</ol>
<p>注意：官方这里说的读取（read）并不代表访问（access），请看下面。</p>
<ol start="4">
<li>访问（access）Old Sublist 中的页面会让其变得 young，然后将其移至 New Sublist 的 Head。如果是因为用户触发的动作需要读取页面，则将立即进行第一次 access，使页面 young。如果是由于预读操作而读取了该页面，则第一次 access 不会立即访问，甚至在页面离开之前都不会发生！</li>
</ol>
<p>注意：预读未必会让页面变 young。</p>
<ol start="5">
<li>随着数据库的运行，通过将页面移动到列表的尾部，缓冲池中的页面将会“老化”。New 和 Old Sublist 都会随着其他页面的更新而老化。随着将页面插入 Midpoint，旧子列表中的页面也会老化。最终，未使用的页面到达子列表的尾部并被逐出。</li>
</ol>
<p>注意：这里有个有趣的现象，页面是先插入到 Midpoint，而且这些页面插入之后属于 Old Sublist 的范围，所以他们很可能会马上“老化”，唯一让他们变得 young 的途径就是 access 一次。</p>
<p>默认情况下，查询（Query）读取的页面会立即移入新的子列表，这意味着它们在缓冲池停留的时间更长。</p>
<p>举个例子，mysqldump 操作或者 SELECT 不带 WHERE 子句的语句可能会将大量数据带入缓冲池，并驱逐出相当多的旧数据，即使加入 New Sublist Head 的新数据在 access 一次之后都不会再被使用了。同样，预读线程加载的页面，且仅仅访问过一次，那么也会移至 New Sublist 的开头。这些情况可能会将常用页面推到旧的子列表，然后被逐出。</p>
<p>所以，这似乎有个问题，有些 page 明明使用的频率不如其他页面，却可以插在其他页面前面，甚至逐出其他页面 ，官方给出了优化此行为的方法：让缓冲池的扫描具有“抵抗力”、配置 InnoDB 缓冲池预读（具体见官网）。</p>
<h1 id="使用标准监视器监视-Buffer-Pool"><a href="#使用标准监视器监视-Buffer-Pool" class="headerlink" title="使用标准监视器监视 Buffer Pool"></a>使用标准监视器监视 Buffer Pool</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">----------------------</span><br><span class="line">BUFFER POOL AND MEMORY</span><br><span class="line">----------------------</span><br><span class="line">Total large memory allocated 137428992 <span class="comment"># 为缓冲池分配的总内存（单位：字节）</span></span><br><span class="line">Dictionary memory allocated 2774195 <span class="comment"># 为 InnoDB 数据字典分配的总内存（单位：字节）</span></span><br><span class="line">Buffer pool size   8192 <span class="comment"># 分配给缓冲池的页数</span></span><br><span class="line">Free buffers       957 <span class="comment"># 缓冲池空闲列表的页数</span></span><br><span class="line">Database pages     6896 <span class="comment"># 缓冲池 LRU 列表的页数</span></span><br><span class="line">Old database pages 2525 <span class="comment"># 缓冲池 Old Sublist 的页数</span></span><br><span class="line">Modified db pages  0 <span class="comment"># 缓冲池中当前修改的页数</span></span><br><span class="line">Pending reads      0 <span class="comment"># 等待读入缓冲池的页数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pending writes LRU 来自于 LRU 列表底部待写的旧脏页数</span></span><br><span class="line"><span class="comment"># Pending writes flush list 检查点期间要刷新的缓冲池页面数</span></span><br><span class="line"><span class="comment"># Pending writes single page 缓冲池中暂挂的独立页面写入数</span></span><br><span class="line">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pages made young 缓冲池 LRU 列表中变年轻的页面数（已移至 New Sublist 开头）</span></span><br><span class="line"><span class="comment"># Pages made not young 缓冲池 LRU 列表中非年轻的页数（在 Old Sublist 没有年轻的页面）</span></span><br><span class="line">Pages made young 38061, not young 2052025</span><br><span class="line"><span class="comment"># youngs/s 每秒导致 LRU 列表中旧页面访问的平均次数</span></span><br><span class="line"><span class="comment"># non-youngs/s </span></span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pages read 从缓冲池读取的页面总数</span></span><br><span class="line"><span class="comment"># Pages created 从缓冲池中创建的页面总数</span></span><br><span class="line"><span class="comment"># Pages written 从缓冲池写入的页面总数</span></span><br><span class="line">Pages <span class="built_in">read</span> 416647, created 103098, written 239695</span><br><span class="line"><span class="comment"># reads/s 平均每秒缓冲池页面读取数</span></span><br><span class="line"><span class="comment"># creates/s 平均每秒创建缓冲池的数目</span></span><br><span class="line"><span class="comment"># writes/s 平均每秒缓冲池页面写入数</span></span><br><span class="line">0.00 reads/s, 0.00 creates/s, 0.00 writes/s</span><br><span class="line">No buffer pool page gets since the last printout</span><br><span class="line">Pages <span class="built_in">read</span> ahead 0.00/s, evicted without access 0.00/s, Random <span class="built_in">read</span> ahead 0.00/s</span><br><span class="line">LRU len: 6896, unzip_LRU len: 0</span><br><span class="line">I/O <span class="built_in">sum</span>[0]:cur[0], unzip <span class="built_in">sum</span>[0]:cur[0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​</p>
]]></content>
  </entry>
  <entry>
    <title>RFC 6749</title>
    <url>/2022/07/26/RFC/RFC-6749/</url>
    <content><![CDATA[<p>1.1. Roles 角色</p>
<p>OAuth 定义了四个角色：</p>
<ul>
<li>resource owner 资源拥有者:</li>
</ul>
<p>一个实体，其能够授予受保护的资源的访问权限。当 resource owner 是一个人，他被称之为一个终端用户。</p>
<ul>
<li>resource server 资源服务器</li>
</ul>
<p>一个服务，其托管受保护的资源，能够接受并响应使用 access token 进行受保护资源的请求。</p>
<ul>
<li>client 客户端</li>
</ul>
<p>一个应用，代表资源拥有者发出受保护资源的请求，并使用其授权。术语 “client” 并不表示任何特别的实现特征（例如，不论该应用在服务器，桌面，或者其他设备上执行）。</p>
<ul>
<li>authorization server</li>
</ul>
<p>一个服务，在成功认证了  并获得了授权之后，颁发 access_token 给 client。</p>
<p>OAuth 定义了四种授予类型:</p>
<ul>
<li>authorization code，授权码</li>
<li>implicit，隐藏式</li>
<li>resource owner password credentials，密码</li>
<li>client credentials，凭证式</li>
</ul>
<h2 id="authorization-code"><a href="#authorization-code" class="headerlink" title="authorization code"></a>authorization code</h2><blockquote>
<p>企业微信的授权与 code 很类似，但有所不同。企业微信 code 并不是换取 access_token，而是换取 userid。也就是，一般的 OAuth2，code 与 user 有关联，code 换取的 access_token 与 user 也有关联，用户可以通过 access_token 访问自己权限下的信息。 </p>
</blockquote>
<h2 id="resource-owner-password-credentials，密码"><a href="#resource-owner-password-credentials，密码" class="headerlink" title="resource owner password credentials，密码"></a>resource owner password credentials，密码</h2><p>A 网站直接要求用户提供 B 网站的用户名和密码。拿到之后，A 直接向 B 请求令牌。</p>
<h2 id="client-credentials，客户端凭证式"><a href="#client-credentials，客户端凭证式" class="headerlink" title="client credentials，客户端凭证式"></a>client credentials，客户端凭证式</h2><p>适用于没有前端的命令行应用。</p>
<p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p>
<p>企业微信的 access_token 获取类似于这种方式</p>
<p>(A) client 通过将 resource owner 的 user-agent 重定向到 authorization 后端，开始流程。client 包含它的 client identifier，requested scope，local state，以及一个 redirection uri，一旦授权（或者拒绝）该访问，授权服务器会把 user-agent 发回该 uri。</p>
<blockquote>
<p>client 可以认为是第三方应用的页面（上面具有一个授权按钮），用户点击该按钮，就会跳转到授权服务器，同时会附带一些参数。</p>
</blockquote>
<p>(B) 授权服务器认证 resource owner，并确定 resource owner 是授权还是拒绝 client 的范围请求。</p>
<p>(C) 假设 resource owner 授权访问，授权服务器使用之前提供的 redirection uri 将 user-agent 重定向回 client。redirection uri 包含 authorization code 以及之前 client 提供的任何本地状态。</p>
<blockquote>
<p>code 的实现可以是 UUID、UUID+MD5 等</p>
</blockquote>
<p>(D) client 通过前面步骤获得的 authorization code 从授权服务器的 token 后端请求 access token。当发出请求时，client 使用授权服务器认证。client 包含 redirection URI ，用于获取进行验证的授权码。</p>
<p>(E) 授权服务器认证客户端，验证授权码，确保接受到的 redirection URI  </p>
<h1 id="10-Security-Considerations"><a href="#10-Security-Considerations" class="headerlink" title="10. Security Considerations"></a>10. Security Considerations</h1><h2 id="10-4-Refresh-Tokens"><a href="#10-4-Refresh-Tokens" class="headerlink" title="10.4. Refresh Tokens"></a>10.4. Refresh Tokens</h2><p>Authorization Server 可以（MAY）给 Web 应用客户端和本地应用客户端颁发 Refresh Token。</p>
<p>Refresh Token 必须（MUST）在运输和存储的过程中保密，并且仅仅在 Authorization Server 和颁发了 Refresh Token 的客户端之间共享。Authorzation Server 必须（MUST） 维护 Refresh Token 和颁发了 Refresh Token 的客户端之间的绑定关系。Refresh Token 必须（MUST）只能使用 TLS 传输。??</p>
<p>每当客户身份可以验证时，Authorzation Server 必须（MUST）验证 Refresh Token 和客户身份之间的绑定关系。当无法进行客户端认证时，Authorization Server 应当（SHOULD）调配其他方案，以检测 Refresh Token 滥用。</p>
<p>例如，Authorization Server 可以使用 Refresh Token 循环，每个 access Token 刷新响应就在循环中颁发一个新的 Refresh Token。前一个 Refresh Token 失效，但是还会被 Authorization Server 保留。如果一个 Refresh Token 被渗透了，随后都被攻击者和合法客户端使用，其中一个会出现无效的 Refresh Token，它将告知授权服务器违规。</p>
<p><em>授权服务器</em>必须确保 Refresh Token 不能被生成，篡改，或者猜测以生成有效的刷新令牌。</p>
]]></content>
  </entry>
  <entry>
    <title>AES 加密算法</title>
    <url>/2022/07/18/Security/AES-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="AES-加密算法"><a href="#AES-加密算法" class="headerlink" title="AES 加密算法"></a>AES 加密算法</h1><h2 id="密钥扩展算法"><a href="#密钥扩展算法" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h2><img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/crypto/AES%E5%AF%86%E9%92%A5%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95.drawio.svg">

<p>步骤说明：</p>
<ol>
<li><p>将密钥 key 按左图的格式，从上到下，从左到右排列，每一列 4 个字节，其中 $k_n$ 表示 1 个字节。</p>
<blockquote>
<p>AES 支持密钥长度为 16、24、32 字节，因此可能的列数是 4、6、8</p>
</blockquote>
</li>
<li><p>将每一列的 4 字节从上到下拼接成 32 bit，记为 $W_t$</p>
</li>
</ol>
<blockquote>
<p>根据密钥长度不同，列数是 4、6、8，因此 $W$ 每一行的长度是 4、6、8</p>
</blockquote>
<ol start="3">
<li>依次求解 $W_t$，$t$ 的范围是 $[4,43]$（因为已经得到 $[0,3]$ 的值），规则如下：<br>若 $t%4&#x3D;0$，则：<br>$$w[t]&#x3D;w[t-4]⊕g(w[t-1])$$<br>否则：<br>$$w[t]&#x3D;w[t-4]⊕w[t-1]；$$</li>
</ol>
<p>g 函数的流程如下：</p>
<ol>
<li>将 $W_t$ 循环左移 8 bit（即 1 字节）</li>
<li>对每个字节做 S 盒置换</li>
<li>将每个字节与 32 bit 常量$(RC[t&#x2F;4],0,0,0)$进行异或。</li>
</ol>
<blockquote>
<p>$RC$ 是一个一维数组，其所需长度随着 AES 算法密钥的长度变化，</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/luop/p/4334160.html">https://www.cnblogs.com/luop/p/4334160.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>OAuth 2.0 Authorization Server 设计</title>
    <url>/2022/08/12/Security/OAuth-2-0-Authorization-Server-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>OAuth2 设计</title>
    <url>/2022/08/03/Security/OAuth2-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="OAuth2-设计"><a href="#OAuth2-设计" class="headerlink" title="OAuth2 设计"></a>OAuth2 设计</h1><h2 id="暴露的端点"><a href="#暴露的端点" class="headerlink" title="暴露的端点"></a>暴露的端点</h2><ul>
<li><p>GET &#x2F;oauth&#x2F;authorize<br>该端点采用 GET 请求，主要是让用户能够跳转到授权页面。</p>
</li>
<li><p>GET &#x2F;oauth&#x2F;confirm_access<br>提供用户确认授权的视图</p>
</li>
<li><p>POST &#x2F;oauth&#x2F;authorize<br>用户确认授权</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>加密解密笔记</title>
    <url>/2022/07/10/Security/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="加密解密笔记"><a href="#加密解密笔记" class="headerlink" title="加密解密笔记"></a>加密解密笔记</h1><h2 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h2><ul>
<li>原文：或者叫明文，就是被隐藏的文字。</li>
<li>加密法：指隐藏原文的法则。</li>
<li>密文：或者叫伪文，指对原文按照加密法处理过后生成的可公开传递的文字。</li>
<li>密钥：在加密法中起决定性的因素，可能是数字、词汇，也可能是一些字母，或者这些东西的组合。</li>
</ul>
<h2 id="1-对称加密算法"><a href="#1-对称加密算法" class="headerlink" title="1. 对称加密算法"></a>1. 对称加密算法</h2><p>对称加密是指加密和解密使用同一个密钥。对称加密只有一个密钥，作为私钥。<br>具体的算法有：DES、3DES、TDEA、Blowfish、RC5、IDEA。常用的有：DES、AES</p>
<p>优点：计算量小、加密速度快<br>缺点：不太安全，需要保存好密钥，而且，一般会为每个用户准备不同私钥，存储量大。</p>
<h3 id="1-1-ECB-和-CBC"><a href="#1-1-ECB-和-CBC" class="headerlink" title="1.1. ECB 和 CBC"></a>1.1. ECB 和 CBC</h3><ul>
<li>ECB 模式</li>
</ul>
<p>Electronic Codebook 电码本。将数据按照8个字节一段进行DES加密或解密得到一段段的8个字节的密文或者明文，最后一段不足8个字节（一般补0或者F），按照需求补足8个字节进行计算（并行计算），之后按照顺序将计算所得的数据连在一起即可，各段数据之间互不影响。</p>
<ul>
<li>CBC 模式</li>
</ul>
<p>Cipher Block Chaining 密文分组链接模式。</p>
<p>(1) 将数据按照 8 字节分组，得到D1, D2, … , Dn（若数据不是8的整数倍，用指定的PADDING数据补位）<br>(2) 第一组数据 D1 与初始化向量 I 异或后的结果进行 DES 加密得到第一组密文 C1<br>(3) 第二组数据 D2 与第一组的加密结果 C1 异或以后的结果进行 DES 加密，得到第二组密文 C2<br>(4) 之后的数据以此类推，得到Cn<br>(5) 按顺序连为C1C2C3…Cn即为加密结果。</p>
<h3 id="1-2-DES"><a href="#1-2-DES" class="headerlink" title="1.2. DES"></a>1.2. DES</h3><p>分组密码，以 64 位为分组对数据加密，密钥长度是 56 位。穷举法进行搜索，运算次数为 $2^{56}$ </p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>PHP</li>
</ul>
<p>php 7.1 之前加密与解密参考<a href="https://github.com/JiangChunbo/crypto/blob/master/des/php7.1-/DES.php">这里</a></p>
<p>php 7.1 之后加密解密 —— openssl</p>
<h4 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h4><ul>
<li>pkcs7Padding 函数</li>
</ul>
<p>可能在填充字节的过程中遇到。如果是 pkcs5Padding，固定传入 $size &#x3D; 8 即可</p>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/des/php7.1-/DES.php#L30">代码参考</a></p>
<p>&amp;nbsp;</p>
<ul>
<li>php 7.1 之前加密与解密</li>
</ul>
<p>如果与 Java 系统对接，建议传入 $key 固定为 8 位，保持与 Java 加解密库兼容。</p>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/des/php7.1-/DES.php">代码参考</a></p>
<p>&amp;nbsp;</p>
<ul>
<li>php 7.1 之后加密解密 —— openssl</li>
</ul>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/des/php7.1+/DES.php">代码参考</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openssl_encrypt</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">string</span> <span class="variable">$data</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">string</span> <span class="variable">$cipher_algo</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">string</span> <span class="variable">$passphrase</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> <span class="variable">$options</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">string</span> <span class="variable">$iv</span> = <span class="string">&quot;&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">	&amp;<span class="variable">$tag</span>, <span class="keyword">string</span> <span class="variable">$aad</span> = <span class="string">&quot;&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> <span class="variable">$tag_length</span> = <span class="number">16</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">string</span>|<span class="title">false</span></span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$data</td>
<td align="left">数据</td>
</tr>
<tr>
<td align="left">$options</td>
<td align="left">OPENSSL_NO_PADDING：需要手动填充，否则不对齐返回 false<br>OPENSSL_RAW_DATA：自动以 pkcs5 填充</td>
</tr>
</tbody></table>
<p>&amp;nbsp;</p>
<ul>
<li>Java 加密解密</li>
</ul>
<p>Java DESKeySpec 需要密码至少 8 字节，如果超过 8 字节，只取前 8 字节。</p>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/des/jdk8+/DES.java">代码参考</a></p>
<h3 id="1-2-AES"><a href="#1-2-AES" class="headerlink" title="1.2. AES"></a>1.2. AES</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>AES 是一个高级加密标准（Advanced Encryption Standard）。</p>
<p>AES 按加密方式分为：AES-128、AES-192、AES-256</p>
<p>按加密模式分为：ECB、CBC、CTR、CFB、OCF</p>
<p>对称分组密码体制，分组长度 128 位。这种加密算法是美国联邦政府采用的区块加密标准，AES 标准用来代替原先的 DES。</p>
<p>javax.crypto 包下。</p>
<p>加解密功能由 Cipher 组件提供，</p>
<p>在设置 Cipher 类的时候注意点：<br>(1) Cipher 在使用时需以参数方式指定 transformation<br>(2) transformation 格式为 algorithm&#x2F;mode&#x2F;padding，其中 algorithm 为必输项，<br>(3) 缺省的 mode 为 ECB，缺省的 padding 为 PKCS5Padding<br>(4) 在 block 算法与流加密模式组合时，需在 mode 后面指定每次处理的 bit 数，如 DES&#x2F;CFB8&#x2F;NoPadding，如未指定则使用缺省值，SunJCE 缺省值为 64 bits<br>(5) Cipher 有 4 中操作模式：ENCRYPT_MODE(加密)、DECRYPT_MODE(解密)、WRAP_MODE(导出Key)、UNWRAP_MODE(导入Key)，初始化（init）时需要指定某种操作模式</p>
<h4 id="代码参考"><a href="#代码参考" class="headerlink" title="代码参考"></a>代码参考</h4><ul>
<li><a href="https://github.com/JiangChunbo/crypto/blob/master/AES/php/AES.php">PHP 版本</a></li>
</ul>
<p>&amp;nbsp;</p>
<h3 id="1-3-Discuz"><a href="#1-3-Discuz" class="headerlink" title="1.3. Discuz"></a>1.3. Discuz</h3><p>php 论坛框架 discuz 的加密算法，也兼容过期时间校验。</p>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/discuz/php/DiscuzUtil.php">代码参考</a></p>
<p>&amp;nbsp;</p>
<h2 id="2-非对称加密算法"><a href="#2-非对称加密算法" class="headerlink" title="2. 非对称加密算法"></a>2. 非对称加密算法</h2><p>加密和解密用的不是同一个密钥。每个用户拥有 2 把钥匙，公钥和私钥。顾名思义，公钥，是可以对外发布的，私钥是自己保存，只有自己知道的。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>信息加密和解密</strong> 用 A 用户的公钥加密后只能用 A 用户的私钥解密。B 需要告诉 A：请来 X 区域找我。B 使用 A 的公钥进行加密，将密文发送给 A，其他人拿到密文没有 A 私钥是无法知道内容的，只有 A 拿到密文之后使用私钥解密才行。</p>
<p><strong>加签和解签</strong> 公钥是用来解密信息的，确保别人知道这条消息是由我发布的，且是完整的。</p>
<p>A 用户通过私钥加密：我是 A，我收到了你的信息。此时，B 通过 A 的公钥解密，确认 A 已经收到了自己的消息。</p>
<h3 id="生成-RSA-密钥对"><a href="#生成-RSA-密钥对" class="headerlink" title="生成 RSA 密钥对"></a>生成 RSA 密钥对</h3><ul>
<li><p>openssl 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1024 密钥长度</span></span><br><span class="line">openssl genrsa -out key.pem 1024</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-out</td>
<td align="left">指定生成文件，包含公钥和私钥</td>
</tr>
</tbody></table>
</li>
<li><p>Java 代码生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">keySize</span> <span class="operator">=</span> <span class="number">1028</span>;</span><br><span class="line"><span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">keyPairGenerator.initialize(keySize);</span><br><span class="line"><span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line"></span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());</span><br></pre></td></tr></table></figure>
</li>
<li><p>PHP 代码生成</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$opensslConfigPath</span> = <span class="string">&#x27;D:\wampserver\bin\apache\apache2.4.46\conf\openssl.cnf&#x27;</span>;</span><br><span class="line"><span class="variable">$config</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;digest_alg&#x27;</span> =&gt; <span class="string">&#x27;sha512&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;private_key_bits&#x27;</span> =&gt; <span class="number">1024</span>,</span><br><span class="line">    <span class="string">&#x27;private_key_type&#x27;</span> =&gt; OPENSSL_KEYTYPE_RSA,</span><br><span class="line">    <span class="string">&#x27;config&#x27;</span>=&gt; <span class="variable">$opensslConfigPath</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$res</span> = <span class="title function_ invoke__">openssl_pkey_new</span>(<span class="variable">$config</span>); <span class="comment">//创建密钥对</span></span><br><span class="line"><span class="title function_ invoke__">openssl_pkey_export</span>(<span class="variable">$res</span>, <span class="variable">$privkey</span>, <span class="literal">null</span>, <span class="variable">$config</span>); <span class="comment">//生成私钥</span></span><br><span class="line"><span class="variable">$pubKey</span> = <span class="title function_ invoke__">openssl_pkey_get_details</span>(<span class="variable">$res</span>)[<span class="string">&#x27;key&#x27;</span>]; <span class="comment">//生成公钥</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$privkey</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$pubKey</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="RSA-加密与解密"><a href="#RSA-加密与解密" class="headerlink" title="RSA 加密与解密"></a>RSA 加密与解密</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul>
<li><p>Java 公钥加密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">modulus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">pubExp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="type">RSAPublicKeySpec</span> <span class="variable">pubKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSAPublicKeySpec</span>(modulus, pubExp);</span><br><span class="line"><span class="type">RSAPublicKey</span> <span class="variable">key</span> <span class="operator">=</span> (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);</span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line"><span class="type">byte</span>[] cipherData = cipher.doFinal(<span class="string">&quot;密文&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 私钥解密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] encrypted = <span class="string">&quot;&quot;</span>; <span class="comment">// 密文，需要 base64 解码</span></span><br><span class="line"><span class="type">PKCS8EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(Base64.getDecoder().decode(<span class="string">&quot;非 PEM 格式私钥&quot;</span>));</span><br><span class="line"><span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="type">RSAPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> (RSAPrivateKey) keyFactory.generatePrivate(keySpec);</span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line"><span class="type">byte</span>[] decrptyed = cipher.doFinal(encrypted);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decrptyed));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul>
<li>公钥加密</li>
</ul>
<p>使用 <strong>JSEncrypt</strong> 库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">JSEncrypt</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;jsencrypt/lib/JSEncrypt&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> publicKey = <span class="string">&#x27;&#x27;</span> <span class="comment">// PEM 格式公钥</span></span><br><span class="line"><span class="keyword">const</span> origin = <span class="string">&#x27;&#x27;</span> <span class="comment">// 需要加密的数据</span></span><br><span class="line"><span class="keyword">const</span> jsEncrypt = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>()</span><br><span class="line">jsEncrypt.<span class="title function_">setPublicKey</span>(publicKey)</span><br><span class="line"><span class="keyword">const</span> encrypted = jsEncrypt.<span class="title function_">encrypt</span>(origin) <span class="comment">// 返回的是 base64 编码的结果</span></span><br></pre></td></tr></table></figure>

<ul>
<li>私钥解密<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&#x27;&#x27;</span> <span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> encrypted = <span class="string">&#x27;&#x27;</span> <span class="comment">// 传递 base64 编码的加密值</span></span><br><span class="line"><span class="keyword">const</span> jsEncrypt = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>()</span><br><span class="line">jsEncrypt.<span class="title function_">setPrivateKey</span>(privateKey)</span><br><span class="line"><span class="keyword">const</span> decrypted = jsEncrypt.<span class="title function_">decrypt</span>(msg)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul>
<li>解密<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$encrypted</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 密文，如果有必要需要进行 base64 解码</span></span><br><span class="line"><span class="variable">$decrypted</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 解密之后存放的变量</span></span><br><span class="line"><span class="variable">$private_key</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">// PEM 格式私钥</span></span><br><span class="line"><span class="title function_ invoke__">openssl_private_decrypt</span>(<span class="variable">$password</span>, <span class="variable">$decrypted</span>, <span class="variable">$private_key</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h2><p>通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能。数据摘要算法也被称为哈希算法或散列算法。</p>
<p>具体摘要算法：</p>
<p>CRC8 CRC16 CRC 32</p>
<p>MD2 MD4 MD5 </p>
<p>SHA1 SHA256  SHA384  SHA512，SHA（Secure Hash Algorithm）是由美国专门制定密码算法的标准机构——美国国家标准技术研究院制定。</p>
<p>RIPEMD、PANAMA、TIGER、ADLER32 </p>
<h1 id="bcrypt"><a href="#bcrypt" class="headerlink" title="bcrypt"></a>bcrypt</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$2b$[cost]$[22 character salt][31 character <span class="built_in">hash</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$2a$10<span class="variable">$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy</span></span><br><span class="line">\__/\/ \____________________/\_____________________________/</span><br><span class="line"> Alg Cost      Salt                        Hash</span><br></pre></td></tr></table></figure>
<p><code>$2a$</code> hash算法的唯一标志</p>
<p>10 代价因子，这里是 2 的 10 次方，</p>
<p>N9qo8uLOickgx2ZMRZoMye  16 字节的 salt经过 base64 编码得到的 22 长度字符</p>
<p>IjZAgcfl7p92ldGxad68LJZdL17lhWy 是 24 个字节的 hash，经过 base64 编码的 31 长度字符</p>
]]></content>
      <tags>
        <tag>crpto</tag>
      </tags>
  </entry>
  <entry>
    <title>短信接口防盗用</title>
    <url>/2022/07/27/Security/%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%8F%A3%E9%98%B2%E7%9B%97%E7%94%A8/</url>
    <content><![CDATA[<ol>
<li>校验 Referer 头部</li>
<li>签名校验</li>
<li>mobile 参数可以略微进行 AES 加密等，增加复杂度</li>
<li>IP + UA 限制次数<br>例如，使用 Redis 记录次数</li>
</ol>
<p>假设 key 特定前缀是 code_send_limit_</p>
<p>key &#x3D; code_send_limit_ + <code>&lt;IP 和 UA 的混合&gt;</code><br>value &#x3D; 次数</p>
<blockquote>
<p>incr  expireAt</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FrequencyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大限制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxLimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> periodInSeconds;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FrequencyInterceptor</span><span class="params">(<span class="type">int</span> maxLimit, <span class="type">int</span> periodInSeconds, RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxLimit = maxLimit;</span><br><span class="line">        <span class="built_in">this</span>.periodInSeconds = periodInSeconds;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ipAddr</span> <span class="operator">=</span> IpUtil.getIpAddr(request);</span><br><span class="line">        <span class="type">String</span> <span class="variable">userAgent</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-agent&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">MessageDigest</span> <span class="variable">md5</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] digest = md5.digest((ipAddr + userAgent).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ipAndUa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="number">1</span>, md5.digest()).toString(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;send_msg_limit:&quot;</span> + ipAndUa;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">limit</span> <span class="operator">=</span> (Integer) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span> (limit == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处可能高并发</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">newValue</span> <span class="operator">=</span> redisTemplate.opsForValue().increment(key);</span><br><span class="line">            <span class="keyword">if</span> (newValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 出错</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;网络繁忙，请稍后重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只需考虑第一个设置过期时间</span></span><br><span class="line">            <span class="keyword">if</span> (newValue == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, Duration.ofSeconds(periodInSeconds));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newValue &lt;= maxLimit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是溢出请求，全部打回</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;操作频繁，请稍后重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (limit &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// 一般情况，溢出打回</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;操作频繁，请稍后重试&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">newValue</span> <span class="operator">=</span> redisTemplate.opsForValue().increment(key);</span><br><span class="line">            <span class="keyword">if</span> (newValue == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;网络繁忙，请稍后重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newValue &lt;= maxLimit) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;操作频繁，请稍后重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Shiro BasicHttpAuthenticationFilter 认证流程</title>
    <url>/2022/07/08/Shiro/Shiro-BasicHttpAuthenticationFilter-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Shiro-BasicHttpAuthenticationFilter-认证流程分析"><a href="#Shiro-BasicHttpAuthenticationFilter-认证流程分析" class="headerlink" title="Shiro BasicHttpAuthenticationFilter 认证流程分析"></a>Shiro BasicHttpAuthenticationFilter 认证流程分析</h1><p>以 Shiro 1.8.0 为例子，其中新增了一些新的组件，譬如 <code>HttpAuthenticationFilter</code><br>之前使用的 1.4.1 并不存在 <code>HttpAuthenticationFilter</code> 组件</p>
<h2 id="1-BasicHttpAuthenticationFilter-层次结构"><a href="#1-BasicHttpAuthenticationFilter-层次结构" class="headerlink" title="1. BasicHttpAuthenticationFilter 层次结构"></a>1. BasicHttpAuthenticationFilter 层次结构</h2><p>要分析 <code>BasicHttpAuthenticationFilter</code> 的认证流程，其实也是分析该过滤器（<code>doFilter</code>）的执行流程，而该过滤器的继承层次有一定复杂度，因此先了解一下其继承结构：</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/BasicHttpAuthenticationFilter.png" width="500">


<h2 id="2-OncePerRequestFilter-doFilter"><a href="#2-OncePerRequestFilter-doFilter" class="headerlink" title="2. OncePerRequestFilter.doFilter"></a>2. OncePerRequestFilter.doFilter</h2><p>从继承关系可以看到 <code>BasicHttpAuthenticationFilter</code> 继承自抽象类 <code>OncePerRequestFilter</code>。</p>
<blockquote>
<p><code>OncePerRequestFilter</code> 的字面意思是：Once Per Request，即每个请求只执行一次，它巧妙的设计使得无论添加多少个过滤器，都只执行一次。</p>
</blockquote>
<p>如下是 <code>OncePerRequestFilter</code> 的 <code>doFilter</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(request <span class="keyword">instanceof</span> HttpServletRequest) || !(response <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;OncePerRequestFilter just supports HTTP requests&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">    <span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">alreadyFilteredAttributeName</span> <span class="operator">=</span> getAlreadyFilteredAttributeName();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasAlreadyFilteredAttribute</span> <span class="operator">=</span> request.getAttribute(alreadyFilteredAttributeName) != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasAlreadyFilteredAttribute || skipDispatch(httpRequest) || shouldNotFilter(httpRequest)) &#123;</span><br><span class="line">        <span class="comment">// 继续执行，不调用此过滤器</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用该过滤器</span></span><br><span class="line">        request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doFilterInternal(httpRequest, httpResponse, filterChain);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 为本次请求删除 &quot;已经过滤&quot; 的请求属性，能够释放一些空间</span></span><br><span class="line">            request.removeAttribute(alreadyFilteredAttributeName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-AdviceFilter-doFilterInternal"><a href="#3-AdviceFilter-doFilterInternal" class="headerlink" title="3. AdviceFilter.doFilterInternal"></a>3. AdviceFilter.doFilterInternal</h2><p>可以知道 <code>OncePerRequestFilter</code> 已经实现了 <code>doFilter</code>，而且知道，真正的处理逻辑在 <code>doFilterInternal()</code> 方法中。然而，<code>doFilterInternal()</code> 方法是在子类 <code>AdviceFilter</code> 实现的，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前置处理</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">continueChain</span> <span class="operator">=</span> preHandle(request, response);</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Invoked preHandle method.  Continuing chain?: [&quot;</span> + continueChain + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否继续</span></span><br><span class="line">        <span class="keyword">if</span> (continueChain) &#123;</span><br><span class="line">            executeChain(request, response, chain);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置处理</span></span><br><span class="line">        postHandle(request, response);</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Successfully invoked postHandle method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        exception = e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cleanup(request, response, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-PathMatchingFilter-preHandle"><a href="#4-PathMatchingFilter-preHandle" class="headerlink" title="4. PathMatchingFilter.preHandle"></a>4. PathMatchingFilter.preHandle</h2><p>下面先看 preHandle，<code>PathMatchingFilter</code> 已经实现了 preHandle()。PathMatchingFilter，顾名思义，路径匹配过滤器，它的作用就是来根据路径匹配结果，调用相应过滤器（没匹配上的直接 return true，即继续执行过滤器链）。</p>
<blockquote>
<p>path 匹配是通过 <code>FilterChainDefinitionMap</code> 注册的，比如设置了 “&#x2F;login”, “anon”，那么如果本次请求的地址也是 &#x2F;login，则会匹配上。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.appliedPaths == <span class="literal">null</span> || <span class="built_in">this</span>.appliedPaths.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;appliedPaths property is null or empty.  This Filter will passthrough immediately.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String path : <span class="built_in">this</span>.appliedPaths.keySet()) &#123;</span><br><span class="line">        <span class="comment">// If the path does match, then pass on to the subclass implementation for</span></span><br><span class="line">        <span class="comment">// specific checks</span></span><br><span class="line">        <span class="comment">// (first match &#x27;wins&#x27;):</span></span><br><span class="line">        <span class="keyword">if</span> (pathsMatch(path, request)) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Current requestURI matches pattern &#x27;&#123;&#125;&#x27;.  Determining filter chain execution...&quot;</span>, path);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">config</span> <span class="operator">=</span> <span class="built_in">this</span>.appliedPaths.get(path);</span><br><span class="line">            <span class="keyword">return</span> isFilterChainContinued(request, response, path, config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no path matched, allow the request to go through:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码中的 config 对象具有非常高的灵活性，在 <code>BasicHttpAuthenticationFilter</code> 的流程中，你可以进行一些 HTTP Method、permissive 的特殊配置，这些设计都是内嵌在过滤器中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示对于 /** 的 GET POST 请求都需要经过 Basic 验证</span></span><br><span class="line">chainDefinition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authcBasic[get,post]&quot;</span>);</span><br><span class="line"><span class="comment">// 表示对于 /permissive 开头的请求都会放行</span></span><br><span class="line">chainDefinition.addPathDefinition(<span class="string">&quot;/permissive/**&quot;</span>, <span class="string">&quot;authcBasic[permissive]&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果 path 匹配成功，则会先执行 isFilterChainContinued()，isFilterChainContinued() 方法也是在 PathMatchingFilter 实现的。它的作用就是判断过滤器是否可用，如果可用就继续执行；否则，跳过，return true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFilterChainContinued</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">    String path, Object pathConfig)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEnabled(request, response, path, pathConfig)) &#123; <span class="comment">// isEnabled check added in 1.2</span></span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Filter &#x27;&#123;&#125;&#x27; is enabled for the current request under path &#x27;&#123;&#125;&#x27; with config [&#123;&#125;].  &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Delegating to subclass implementation for &#x27;onPreHandle&#x27; check.&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; getName(), path, pathConfig &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//The filter is enabled for this specific request, so delegate to subclass implementations</span></span><br><span class="line"><span class="comment">//so they can decide if the request should continue through the chain or not:</span></span><br><span class="line">        <span class="keyword">return</span> onPreHandle(request, response, pathConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Filter &#x27;&#123;&#125;&#x27; is disabled for the current request under path &#x27;&#123;&#125;&#x27; with config [&#123;&#125;].  &quot;</span> +</span><br><span class="line">            <span class="string">&quot;The next element in the FilterChain will be called immediately.&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; getName(), path, pathConfig &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//This filter is disabled for this specific request,</span></span><br><span class="line"><span class="comment">//return &#x27;true&#x27; immediately to indicate that the filter will not process the request</span></span><br><span class="line"><span class="comment">//and let the request/response to continue through the filter chain:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>isEnabled 方法本质上是判断 enabled 是否为 true。其实几乎所有的过滤器都可以执行，因此 enabled 默认为 true，除非人为的去设置它的值：</p>
<h2 id="5-AccessControlFilter-onPreHandle"><a href="#5-AccessControlFilter-onPreHandle" class="headerlink" title="5. AccessControlFilter.onPreHandle"></a>5. AccessControlFilter.onPreHandle</h2><p>从 <code>preHandle()</code> 走下来的，这里之所以起名为 <code>onPreHandle()</code>，是因为这才是真正的执行逻辑，之前的种种都是可以看作判断。</p>
<p><code>onPreHandle()</code> 在 <code>PathMatchingFilter</code> 的子类 <code>AccessControlFilter</code> 有了新的实现，它的返回值依赖两个方法 isAccessAllowed()、onAccessDenied()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述逻辑可以转换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (isAccessAllowed(request, response, mappedValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onAccessDenied(request, response, mappedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-HttpAuthenticationFilter-isAccessAllowed"><a href="#6-HttpAuthenticationFilter-isAccessAllowed" class="headerlink" title="6. HttpAuthenticationFilter.isAccessAllowed"></a>6. HttpAuthenticationFilter.isAccessAllowed</h2><p>当执行 AccessControlFilter.onPreHandle 会首先判断 <code>isAccessAllowed</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> WebUtils.toHttp(request);</span><br><span class="line">    <span class="type">String</span> <span class="variable">httpMethod</span> <span class="operator">=</span> httpRequest.getMethod();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether the current request&#x27;s method requires authentication.</span></span><br><span class="line">    <span class="comment">// If no methods have been configured, then all of them require auth,</span></span><br><span class="line">    <span class="comment">// otherwise only the declared ones need authentication.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的 mappedValue 其实就是上述的 config 对象，本质上是一个 String[]</span></span><br><span class="line">    <span class="comment">// 这里可以校验一些 HTTP Method 是否需要认证</span></span><br><span class="line">    <span class="comment">// 这也就是为什么你可以设计为 authBasic[get,post]</span></span><br><span class="line">    Set&lt;String&gt; methods = httpMethodsFromOptions((String[]) mappedValue);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">authcRequired</span> <span class="operator">=</span> methods.size() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String m : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (httpMethod.toUpperCase(Locale.ENGLISH).equals(m)) &#123;</span><br><span class="line">            <span class="comment">// 需要认证</span></span><br><span class="line">            authcRequired = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (authcRequired) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.isAccessAllowed(request, response, mappedValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述校验 HTTP Method 的方法对 RESTful 风格非常有效：<br>实际上，该方法先做了一个 HTTP Method 的比对，自定义 FilterChainDefinitionMap 的时候，可以设置一批 HTTP method 是需要认证的，比如：<br>如果当前使用 RESTful 风格请求。现有 [PUT] &#x2F;project 用于更新，[GET] &#x2F;project 用于获取全部数据，这两个请求 URL 都是一样的，但如何让 GET 请求通过，PUT 请求需要授权呢？答案就是使用 HTTP Method 方法过滤。<br>配置 &#x2F;project &#x3D; authcBasic[PUT]<br>那么，访问 &#x2F;project 的时候，GET 方法是不用认证的。<br>所以现在知道，即使没有写 GET，依然也会走 BasicHttpAuthenticationFilter，只是认证直接跳过（return true）。<br>因此，如果 HTTP Method 属于这一类 Method，那么就调用了 super.isAccessAllowed 进行判断。</p>
<h2 id="7-AuthenticationFilter-isAccessAllowed"><a href="#7-AuthenticationFilter-isAccessAllowed" class="headerlink" title="7. AuthenticationFilter.isAccessAllowed"></a>7. AuthenticationFilter.isAccessAllowed</h2><p>下面继续观察 super.isAccessAllowed() 方法到底做了什么？</p>
<p>首先，在继承链上，离 <code>HttpAuthenticationFilter</code> 最近的 <code>AuthenticatingFilter</code> 也实现了 isAccessAllowed() 方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.isAccessAllowed(request, response, mappedValue) ||</span><br><span class="line">            (!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注意到，该方法也使用了 super 去调用父类方法，找到最近的有实现方法的父类 AuthenticationFilter，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> getSubject(request, response);</span><br><span class="line">    <span class="keyword">return</span> subject.isAuthenticated();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 Subject，然后调用 isAuthenticated() 判断是否已经认证过了。</p>
<blockquote>
<p>作用：判断是否认证过了，通俗来说，就是登陆了没。</p>
</blockquote>
<p>如果 isAccessAllowed 返回 false，表示不允许访问，那么需要继续判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>isLoginRequest()</code> 的判断，在本 BasicHttpAuthenticationFilter 的案例中，根据请求头判断<br><code>isPermissive()</code> 的判断是根据你是否在 chainDefinition 配置 [permissive]</p>
</blockquote>
<h2 id="8-BasicHttpAuthenticationFilter-isLoginRequest"><a href="#8-BasicHttpAuthenticationFilter-isLoginRequest" class="headerlink" title="8. BasicHttpAuthenticationFilter.isLoginRequest"></a>8. BasicHttpAuthenticationFilter.isLoginRequest</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isLoginRequest</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.isLoginAttempt(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLoginAttempt</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">authzHeader</span> <span class="operator">=</span> getAuthzHeader(request);</span><br><span class="line">    <span class="comment">// 判断头部 Authorization 是否以 BASIC 开头</span></span><br><span class="line">    <span class="keyword">return</span> authzHeader != <span class="literal">null</span> &amp;&amp; isLoginAttempt(authzHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-BasicHttpAuthenticationFilter-onAccessDenied"><a href="#9-BasicHttpAuthenticationFilter-onAccessDenied" class="headerlink" title="9. BasicHttpAuthenticationFilter.onAccessDenied"></a>9. BasicHttpAuthenticationFilter.onAccessDenied</h2><p>回到 AccessControlFilter.onPreHandle 第二个处理逻辑 —— <code>onAccessDenied</code></p>
<p>该方法就是 isAccessAllowed 返回 false 之后执行的，即访问拒绝的逻辑。</p>
<p><code>BasicHttpAuthenticationFilter</code> 实现了自己的 onAccessDenied：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loggedIn</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// false by default or we wouldn&#x27;t be in this method</span></span><br><span class="line">    <span class="comment">// 判断是否是 Basic 特定请求头</span></span><br><span class="line">    <span class="keyword">if</span> (isLoginAttempt(request, response)) &#123;</span><br><span class="line">        loggedIn = executeLogin(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!loggedIn) &#123;</span><br><span class="line">        <span class="comment">// 发送质询</span></span><br><span class="line">        sendChallenge(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loggedIn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="10-AuthenticatingFilter-executeLogin"><a href="#10-AuthenticatingFilter-executeLogin" class="headerlink" title="10. AuthenticatingFilter.executeLogin"></a>10. AuthenticatingFilter.executeLogin</h2><p>BasicHttpAuthenticationFilter 是没有实现 executeLogin() 的，因此将调用父类 AuthenticatingFilter 的 executeLogin() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span> createToken(request, response);</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;createToken method implementation returned null. A valid non-null AuthenticationToken &quot;</span> +</span><br><span class="line">            <span class="string">&quot;must be created in order to execute a login attempt.&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> getSubject(request, response);</span><br><span class="line">        subject.login(token);</span><br><span class="line">        <span class="keyword">return</span> onLoginSuccess(token, subject, request, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> onLoginFailure(token, e, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createToken()，该方法又是 BasicHttpAuthenticationFilter 来实现的，其实也就是从 Authorization 的 Request Header 提取base64 编码的用户名和密码，然后解析，最终会实例化 UsernamePasswordToken。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AuthenticationToken <span class="title function_">createToken</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">authorizationHeader</span> <span class="operator">=</span> getAuthzHeader(request);</span><br><span class="line">    <span class="keyword">if</span> (authorizationHeader == <span class="literal">null</span> || authorizationHeader.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Create an empty authentication token since there is no</span></span><br><span class="line">        <span class="comment">// Authorization header.</span></span><br><span class="line">        <span class="keyword">return</span> createToken(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;Attempting to execute login with auth header&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String[] prinCred = getPrincipalsAndCredentials(authorizationHeader, request);</span><br><span class="line">    <span class="keyword">if</span> (prinCred == <span class="literal">null</span> || prinCred.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// Create an authentication token with an empty password,</span></span><br><span class="line">        <span class="comment">// since one hasn&#x27;t been provided in the request.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> prinCred == <span class="literal">null</span> || prinCred.length == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : prinCred[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> createToken(username, <span class="string">&quot;&quot;</span>, request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> prinCred[<span class="number">0</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> prinCred[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createToken(username, password, request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在 createToken 之后，会 getSubject，执行 login()。后面会委托给 SecurityManager.login 方法，在 securityManager 中会对 token 进行验证，本质上就是调用 Realm 方法验证，如果验证过程中没有异常抛出，则顺利执行，</p>
<p>​如果认证过程没有异常抛出，最终会走到 onLoginSuccess()，如果有异常抛出则执行 onLoginFailure()。</p>
<blockquote>
<p>一般也就是在 Realm 的执行逻辑中抛出异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro DefaultFilter 使用笔记</title>
    <url>/2022/07/14/Shiro/Shiro-DefaultFilter-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Shiro-DefaultFilter-使用笔记"><a href="#Shiro-DefaultFilter-使用笔记" class="headerlink" title="Shiro DefaultFilter 使用笔记"></a>Shiro DefaultFilter 使用笔记</h1><h2 id="anon"><a href="#anon" class="headerlink" title="anon"></a>anon</h2><p>AnonymousFilter</p>
<p>匿名过滤器，请求 <code>onPreHandle()</code> 直接通过。</p>
<h2 id="authc"><a href="#authc" class="headerlink" title="authc"></a>authc</h2><p>FormAuthenticationFilter</p>
<p>onAccessDenied 方法分 loginUrl 处理和非 loginUrl 处理：<br>(1) 当请求是 loginUrl 时，其中又根据是否为 POST 请求判断是否是 login 页面请求还是，login 提交。<br>(2) 当请求是非 loginUrl 时，向 session 存储了一个属性 shiroSavedRequest， 然后跳转到登录页面。</p>
<h2 id="authcBasic"><a href="#authcBasic" class="headerlink" title="authcBasic"></a>authcBasic</h2><p>BasicHttpAuthenticationFilter</p>
<p>onAccessDenied 逻辑：</p>
<ol>
<li>通过请求头 Authorization 判断是否为 login 请求，如果是，执行 executeLogin 逻辑，获取 username, password 构造 AuthenticationToken 进行 Realm 认证。</li>
<li>如果不是 login 请求，或者登录失败，发送质询</li>
</ol>
<h2 id="invalidRequest"><a href="#invalidRequest" class="headerlink" title="invalidRequest"></a>invalidRequest</h2><p>InvalidRequestFilter</p>
<p>默认全局过滤器，过滤一些非法请求</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro FilterChainDefinitionMap 注册原理</title>
    <url>/2022/07/14/Shiro/Shiro-FilterChainDefinitionMap-%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Shiro-FilterChainDefinitionMap-注册原理"><a href="#Shiro-FilterChainDefinitionMap-注册原理" class="headerlink" title="Shiro FilterChainDefinitionMap 注册原理"></a>Shiro FilterChainDefinitionMap 注册原理</h1><p>在进行 <code>FilterChainDefinitionMap</code> 配置的时候，需要准备两个字符串，分别称之为 <code>antPath</code> 和 <code>definition</code>。以如下的配置为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultShiroFilterChainDefinition</span> <span class="variable">chainDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShiroFilterChainDefinition</span>();</span><br><span class="line">chainDefinition.addPathDefinition(<span class="string">&quot;/url&quot;</span>, <span class="string">&quot;authc, roles[admin,user], perms[file:edit]&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个字符串可以认为是路径（可以包含通配符），第二个字符串是过滤器链定义</p>
</blockquote>
<p>对于 <code>FilterChainDefinitionMap</code> 中每个 filter Chain Definition 的处理都是在 <code>DefaultFilterChainManager</code> 进行的，主要关注如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处的 chainName 就是 antPath </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createChain</span><span class="params">(String chainName, String chainDefinition)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(chainName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;chainName cannot be null or empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(chainDefinition)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;chainDefinition cannot be null or empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Creating chain [&quot;</span> + chainName + <span class="string">&quot;] with global filters &quot;</span> + globalFilterNames + <span class="string">&quot; and from String definition [&quot;</span> + chainDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先以此添加全局 filter，比如 InvalidRequestFilter</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(globalFilterNames)) &#123;</span><br><span class="line">        globalFilterNames.stream().forEach(filterName -&gt; addToChain(chainName, filterName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对值进行标记解析，以获得最后特定于过滤器的配置项</span></span><br><span class="line">    <span class="comment">// 这里以半角逗号(,) 作为分隔符，忽略两边空白符</span></span><br><span class="line">    <span class="comment">// 例如对于值：</span></span><br><span class="line">    <span class="comment">//     &quot;authc, roles[admin,user], perms[file:edit]&quot;</span></span><br><span class="line">    <span class="comment">// 最终的标记数组为：</span></span><br><span class="line">    <span class="comment">//     &#123; &quot;authc&quot;, &quot;roles[admin,user]&quot;, &quot;perms[file:edit]&quot; &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    String[] filterTokens = splitChainDefinition(chainDefinition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个标记都是特定于每个过滤器的</span></span><br><span class="line">    <span class="comment">// 即，这些配置可能是过滤器约定好的，你需要熟悉这些用法</span></span><br><span class="line">    <span class="comment">// 譬如 roles[admin,user] 括号 [] 之间代表着角色</span></span><br><span class="line">    <span class="comment">//      perms[file:edit] 括号 [] 之间代表权限，权限又用 : 隔开，前者表示操作对象，后者表示操作类型</span></span><br><span class="line">    <span class="comment">// 剥离 name，提取括号 [] 之间的特定于过滤器的配置</span></span><br><span class="line">    <span class="keyword">for</span> (String token : filterTokens) &#123;</span><br><span class="line">        <span class="comment">// 一定是一个包含 2 个元素的数组，第一个是 filter name，第二个 config 可能是 null</span></span><br><span class="line">        <span class="comment">// [ &quot;authc&quot;, null ]</span></span><br><span class="line">        <span class="comment">// [ &quot;roles&quot;, &quot;admin,user&quot; ]</span></span><br><span class="line">        <span class="comment">// [ &quot;perms&quot;, &quot;file:edit&quot; ]</span></span><br><span class="line">        String[] nameConfigPair = toNameConfigPair(token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在，我们拥有过滤器名称，路径，以及特定于路径的配置（可能是 null，也就是没有配置）</span></span><br><span class="line">        addToChain(chainName, nameConfigPair[<span class="number">0</span>], nameConfigPair[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToChain</span><span class="params">(String chainName, String filterName, String chainSpecificFilterConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(chainName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;chainName cannot be null or empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> getFilter(filterName);</span><br><span class="line">    <span class="keyword">if</span> (filter == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;There is no filter with name &#x27;&quot;</span> + filterName +</span><br><span class="line">                <span class="string">&quot;&#x27; to apply to chain [&quot;</span> + chainName + <span class="string">&quot;] in the pool of available Filters.  Ensure a &quot;</span> +</span><br><span class="line">                <span class="string">&quot;filter with that name/path has first been registered with the addFilter method(s).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里主要就是把配置字符串，如：admin,user 按照半角逗号（,）分割</span></span><br><span class="line">    <span class="comment">// 将得到的 chainName 和 [admin, user] 放入过滤器中  Map&lt;String, Object&gt; appliedPaths 结构中</span></span><br><span class="line">    <span class="comment">// 之所以这样做，是因为对于不同的路径，可能会配置同一个过滤器的不同过滤规则</span></span><br><span class="line">    <span class="comment">// 比如： 学校列表学校管理员与区级管理员可访问，区列表仅区级管理员访问</span></span><br><span class="line">    <span class="comment">//      /school/list  roles[school_admin, area_admin]</span></span><br><span class="line">    <span class="comment">//      /area/list    roles[area_admin]</span></span><br><span class="line">    applyChainConfig(chainName, filter, chainSpecificFilterConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensureChain 顾名思义，表示确保 chain 存在，如果不存在就新建一个</span></span><br><span class="line">    <span class="type">NamedFilterList</span> <span class="variable">chain</span> <span class="operator">=</span> ensureChain(chainName);</span><br><span class="line">    chain.add(filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro Subject login 流程分析</title>
    <url>/2022/07/14/Shiro/Shiro-Subject-login-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Subject-login-流程分析"><a href="#Subject-login-流程分析" class="headerlink" title="Subject login 流程分析"></a>Subject login 流程分析</h1><p>通常，在执行登录之前，我们必须拥有一个 <code>Subject</code> 对象，可能是从 <code>SecurityUtils</code> 类中获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p>Shiro 框架中 <code>Subject</code> 实现类 <code>DelegatingSubject</code>，顾名思义，委托中的 <code>Subject</code>，该类本身不做 login 操作，而是将 login 操作委托给 <code>SecurityManager</code></p>
<p>Subject.login() 的方法声明如下，需要传入一个 <code>AuthenticationToken</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">login</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException;</span><br></pre></td></tr></table></figure>

<p>具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    clearRunAsIdentitiesInternal();</span><br><span class="line">    <span class="comment">// 委托给 SecurityManager 执行</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> securityManager.login(<span class="built_in">this</span>, token);</span><br><span class="line"></span><br><span class="line">    PrincipalCollection principals;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subject <span class="keyword">instanceof</span> DelegatingSubject) &#123;</span><br><span class="line">        <span class="type">DelegatingSubject</span> <span class="variable">delegating</span> <span class="operator">=</span> (DelegatingSubject) subject;</span><br><span class="line">        <span class="comment">//we have to do this in case there are assumed identities - we don&#x27;t want to lose the &#x27;real&#x27; principals:</span></span><br><span class="line">        principals = delegating.principals;</span><br><span class="line">        host = delegating.host;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        principals = subject.getPrincipals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (principals == <span class="literal">null</span> || principals.isEmpty()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Principals returned from securityManager.login( token ) returned a null or &quot;</span> +</span><br><span class="line">                <span class="string">&quot;empty value.  This value must be non null and populated with one or more elements.&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.principals = principals;</span><br><span class="line">    <span class="built_in">this</span>.authenticated = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (token <span class="keyword">instanceof</span> HostAuthenticationToken) &#123;</span><br><span class="line">        host = ((HostAuthenticationToken) token).getHost();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (host != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> subject.getSession(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = decorate(session);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultSecurityManager</code> 的 login 方法如下，其中 authenticate 是执行认证的关键方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Subject <span class="title function_">login</span><span class="params">(Subject subject, AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    AuthenticationInfo info;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        info = authenticate(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onFailedLogin(token, ae, subject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;onFailedLogin method threw an &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;exception.  Logging and propagating original AuthenticationException.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ae; <span class="comment">//propagate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">loggedIn</span> <span class="operator">=</span> createSubject(token, info, subject);</span><br><span class="line"></span><br><span class="line">    onSuccessfulLogin(token, info, loggedIn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loggedIn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SecurityManager</code> 将认证的方法委托给了内部认证器 <code>Authenticator</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AuthenticationInfo <span class="title function_">authenticate</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.authenticator.authenticate(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractAuthenticator</code> 认证方法 <code>authenticate()</code> 代码如下，其中 <code>doAuthenticate()</code> 是认证的关键方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AuthenticationInfo <span class="title function_">authenticate</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Method argument (authentication token) cannot be null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.trace(<span class="string">&quot;Authentication attempt received for token [&#123;&#125;]&quot;</span>, token);</span><br><span class="line"></span><br><span class="line">    AuthenticationInfo info;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        info = doAuthenticate(token);</span><br><span class="line">        <span class="keyword">if</span> (info == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;No account information found for authentication token [&quot;</span> + token + <span class="string">&quot;] by this &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Authenticator instance.  Please check that it is configured correctly.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="type">AuthenticationException</span> <span class="variable">ae</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">            ae = (AuthenticationException) t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ae == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more</span></span><br><span class="line">            <span class="comment">//severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Authentication failed for token submission [&quot;</span> + token + <span class="string">&quot;].  Possible unexpected &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;error? (Typical or expected login exceptions should extend from AuthenticationException).&quot;</span>;</span><br><span class="line">            ae = <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(msg, t);</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled())</span><br><span class="line">                log.warn(msg, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notifyFailure(token, ae);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to send notification for failed authentication attempt - listener error?.  &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Please check your AuthenticationListener implementation(s).  Logging sending exception &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;and propagating original AuthenticationException instead...&quot;</span>;</span><br><span class="line">                log.warn(msg, t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> ae;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;Authentication successful for token [&#123;&#125;].  Returned account [&#123;&#125;]&quot;</span>, token, info);</span><br><span class="line"></span><br><span class="line">    notifySuccess(token, info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，我们可以认为 Shiro 框架中的认证器就是 <code>ModularRealmAuthenticator</code>，因为没有其他实现类了，其 <code>doAuthenticate()</code> 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doAuthenticate</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    assertRealmsConfigured();</span><br><span class="line">    Collection&lt;Realm&gt; realms = getRealms();</span><br><span class="line">    <span class="keyword">if</span> (realms.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有 1 个 Realm</span></span><br><span class="line">        <span class="keyword">return</span> doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 具有多个 Realm</span></span><br><span class="line">        <span class="keyword">return</span> doMultiRealmAuthentication(realms, authenticationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果配置了多个 <code>Realm</code>，会使用到认证策略 <code>AuthenticationStrategy</code>，认证策略也有很多种，其中的 <code>AllSuccessfulStrategy</code> 要求所有的 <code>Realm</code> 都必须认证成功，并且会合并所有的 <code>AuthenticationInfo</code> 中的 <code>PrincipalCollection</code> 形成 <code>MutablePrincipalCollection</code>，凭证 <code>credential</code> 也会合并为集合。</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro 架构</title>
    <url>/2022/07/24/Shiro/Shiro-%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Shiro-架构"><a href="#Shiro-架构" class="headerlink" title="Shiro 架构"></a>Shiro 架构</h1><h2 id="Apache-Shiro-架构"><a href="#Apache-Shiro-架构" class="headerlink" title="Apache Shiro 架构"></a><a href="https://shiro.apache.org/architecture.html">Apache Shiro 架构</a></h2><p>Apache Shiro 的设计目的就是，通过直观化且易于使用来简化应用程序安全性。Shiro 的核心设计模型化了大多数人考虑应用安全性的方式 —— 在某人（或某物）与应用程序交互的上下文中。</p>
<p>软件应用通常基于用户故事设计的。即，你通常会根据用户将会（或者应该）如何与软件交互来设计用户接口或者服务 API。例如，你可能会说，”如果与我的软件交互的用户已经登陆了，我将向他们展示一个按钮，他们可以点机查看其账户信息。如果他们未登录，我将显示一个注册按钮”。</p>
<p>该实例语句标识，应用程序主要是为了满足用户需求和需要而大量编写的。即使“用户”是另一个软件系统，不是一个人类，你仍然可以编码，根据谁（或者什么东西）目前正在与你的软件进行交互反映行为。</p>
<h3 id="高级概述"><a href="#高级概述" class="headerlink" title="高级概述"></a>高级概述</h3><img src="https://shiro.apache.org/images/ShiroBasicArchitecture.png">

<ul>
<li><strong>Subject</strong>: 正如我们在教程中提及的，<code>Subject</code> 本质上是当前正在执行用户的安全性特定“视图”。尽管词语“用户”通常表示一个人，但是 <code>Subject</code> 可以是一个人，但它也可以表示第三方服务，守护账户，cron 作业，或者任何类似的东西 —— 基本任何当前与软件交互的东西。</li>
</ul>
<p><code>Subject</code> 实例都会绑定到（且需要）一个 <code>SecurityManager</code>。当你和一个 <code>Subject</code> 交互时，这些交互会转换为特定于 subject 的与 <code>SecurityManager</code> 的交互。</p>
<ul>
<li><strong>SecurityManager</strong>: <code>SecurityManager</code> 是 Shiro 架构的核心。它主要是一个 “伞” 对象，可以协调其管理的组件，确保他们能顺序运行。</li>
</ul>
<p>我们将在稍后详细讨论 <code>SecurityManager</code>，但是重要的是要意识到，当你与 <code>Subject</code> 进行互动时，实际上，幕后的 <code>SecurityManager</code> 为任何 <code>Subject</code> 安全操作做了所有繁重的工作。这反映在上面的基本流程图中。</p>
<ul>
<li><strong>Realms</strong>: Realm 充当 Shiro 与你应用程序安全性数据之间的“桥梁”或者连接器。</li>
</ul>
<p>从这个意义上讲，一个 Realm 本质上是一种特定于安全性的 DAO: 它封装了数据源的连接细节，并使得 Shiro 在需要时获得相关数据。当配置 Shiro 时，你必须至少指定一个用于认证以及（或者）授权的 Realm。<code>SecurityManager</code> 可以配置多个 Realm，但至少需要配置一个。</p>
<h3 id="详细架构"><a href="#详细架构" class="headerlink" title="详细架构"></a><a href="https://shiro.apache.org/architecture.html">详细架构</a></h3><p><img src="https://img-blog.csdnimg.cn/66b4aa43259d4065b55e1a631f72918c.png" alt="请添加图片描述"></p>
<ul>
<li>Subject (<code>org.apache.shiro.subject.Subject</code>) 当前正在与软件交互的，特定安全的实体视图（用户，第三方服务，cron 任务等）</li>
<li>SecurityManager (<code>org.apache.shiro.mgt.SecurityManager</code>) 如上所述，<code>SecurityManager</code> 是 Shiro 架构的核心。它主要是一个 “伞” 对象，可以协调其管理的组件，确保他们能顺序运行。它还管理每个应用用户的视图，因此它知道每个用户如何执行安全操作。</li>
<li>Authenticator (<code>org.apache.shiro.authc.Authenticator</code>) <code>Authenticator</code> 是负责执行和响应用户的认证（登录）请求的组件。当一个用户尝试登录，<code>Authenticator</code> 就会执行该逻辑。<code>Authenticator</code> 知道如何与一个或多个存储相关用户&#x2F;账户信息的 <code>Realms</code> 协作。用从这些 <code>Realms</code> 获得的数据验证用户身份，保证用户的确如他们所说。</li>
<li>Authorizer (<code>org.apache.shiro.authz.Authorizer</code>) <code>Authorizer</code> 是负责确定用户在应用程序中访问控制的组件。归根结底地说，这是一种机制，判断是否用户允许做某事。像 <code>Authenticator</code> 一样，<code>Authorizer</code> 也知道如何与多个后端数据源协作，访问角色和权限信息。<code>Authorizer</code> 使用这些信息，确定是否用户允许执行给定的操作。</li>
<li>SessionManager (<code>org.apache.shiro.session.mgt.SessionManager</code>) <code>SessionManager</code>  知道如何创建和管理用户 <code>Session</code> 生命周期，为所有环境中的用户提供强大的会话体验。这是安全框架的世界独有的功能，Shiro 有能力本地化地管理任何环境下的用户会话，即使没有可用的 Web&#x2F;Servlet 或者 EJB 容器。默认情况下，Shiro 将使用现有的会话机制，如果可用，（例如 Servlet Container），但是如果没有，例如在一个独立应用或者非 Web 环境下，将使用其内建的企业会话管理，提供相同的编程体验。<code>SessionDAO</code> 允许使用任何数据源持久化 Session。</li>
<li>CacheManager (<code>org.apache.shiro.cache.CacheManager</code>)</li>
<li>Cryptography (org.apache.shiro.crypto.*) </li>
<li>Realms (<code>org.apache.shiro.realm.Realm</code>) 如上所述，Realms 充当 Shiro 和应用安全数据之间的 “桥梁” 或者 “连接器”。当实际需要与安全相关数据（就像用户账户）进行交互，执行认证（login）以及授权（访问控制）的时候，Shiro 会从一个或多个为应用配置的 Realms 中查找许多相关的数据。你可以根据需要配置尽可能多的 <code>Realms</code>（通常每个数据源配一个），Shiro 在认证和授权的时候，根据需要协调它们。</li>
</ul>
<h3 id="Apache-Shiro-Web-Support"><a href="#Apache-Shiro-Web-Support" class="headerlink" title="Apache Shiro Web Support"></a><a href="https://shiro.apache.org/web.html">Apache Shiro Web Support</a></h3><h3 id="Default-Filters"><a href="#Default-Filters" class="headerlink" title="Default Filters"></a>Default Filters</h3><h3 id="Session-Management"><a href="#Session-Management" class="headerlink" title="Session Management"></a>Session Management</h3><h4 id="Servlet-Container-Sessions"><a href="#Servlet-Container-Sessions" class="headerlink" title="Servlet Container Sessions"></a>Servlet Container Sessions</h4><p>在 Web 环境下，Shiro 的默认会话管理器 <code>SessionManager</code> 的实现是 <code>ServletContainerSessionManager</code>。这是一个非常简易的实现，将所有会话管理的职责（包括会话集群，如果 Servlet 容器支持）委托给运行时的 Servlet 容器。它本质上是 Shiro 会话 API 到 Servlet 容器的桥梁，几乎没做什么。</p>
<h4 id="Native-Sessions"><a href="#Native-Sessions" class="headerlink" title="Native Sessions"></a>Native Sessions</h4><p>如果你希望会话配置设置以及集群可以在 Servlet 容器上移植，或者你想控制特定的会话&#x2F;集群功能，你可以启用 Shiro 的本地会话管理。</p>
<p>这里 “Native” 一词意味着，将会使用 Shiro 自己的企业会话管理实现，支持所有 <code>Subject</code> 以及 <code>HttpServletRequest</code> 会话，并完全绕过 Servlet 容器。但是，请放心，Shiro 直接实现了相关的 Servlet 规范部分，因此任何现有的 web&#x2F;http 相关代码都可以按照预期工作，并且也不需要知道 Shiro 正在透明地管理会话。</p>
<h5 id="DefaultWebSessionManager"><a href="#DefaultWebSessionManager" class="headerlink" title="DefaultWebSessionManager"></a><code>DefaultWebSessionManager</code></h5>]]></content>
  </entry>
  <entry>
    <title>ShiroFilter 执行流程</title>
    <url>/2022/07/23/Shiro/ShiroFilter%20%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="ShiroFilter-执行流程"><a href="#ShiroFilter-执行流程" class="headerlink" title="ShiroFilter 执行流程"></a>ShiroFilter 执行流程</h1><h2 id="SpringShiroFilter"><a href="#SpringShiroFilter" class="headerlink" title="SpringShiroFilter"></a>SpringShiroFilter</h2><p><code>SpringShiroFilter</code> 是 Shiro 整合 Spring Web 提供的一个 <code>Filter</code>，通过将其配置到 Servlet 容器的过滤器链中参与处理。</p>
<ol>
<li>包装 Request 和 Response，使它们由原来的 HttpServlet 系列包装（装饰）为 ShiroHttpServletRequest</li>
</ol>
<blockquote>
<p>装饰器设计模式，扩展了一些功能</p>
</blockquote>
<ol start="2">
<li>创建 Subject，传递给接下来的过滤器（通过 ThreadLocal）；</li>
</ol>
<p>如果没有定义任何 <code>FilterChainDefinitionMap</code>，那 Shiro 也会把 Request 交给它默认的过滤器过滤。</p>
<ol start="3">
<li><p>寻找合适的 <code>FilterChain</code>，如果找到则转交给该 <code>FilterChain</code> 过滤</p>
</li>
<li><p>更新 SessionLastAccessTime（native sessions）</p>
</li>
</ol>
<p>以下是 <code>SpringShiroFilter</code> 的代码清单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, <span class="keyword">final</span> FilterChain chain)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 装饰原生 request response</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> prepareServletRequest(servletRequest, servletResponse, chain);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> prepareServletResponse(request, servletResponse, chain);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> createSubject(request, response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="comment">// 通过 Callable 进行增强，底层会将 subject、securityManager 都存到 ThreadLocal</span></span><br><span class="line">        subject.execute(<span class="keyword">new</span> <span class="title class_">Callable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 更新 session last access time</span></span><br><span class="line">                updateSessionLastAccessTime(request, response);</span><br><span class="line">                <span class="comment">// 执行链</span></span><br><span class="line">                executeChain(request, response, chain);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</span><br><span class="line">        t = ex.getCause();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        t = throwable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ServletException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (ServletException) t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//otherwise it&#x27;s not one of the two exceptions expected by the filter method signature - wrap it in one:</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Filtered request failed.&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(msg, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>从上述代码可以看到，subject 对象并不是直接调用相关的方法，而是通过向 execute 方法传递一个 <code>Callable</code>，该 <code>Callable</code> 实际会被 Shiro 的 <code>SubjectCallable</code> 包装起来，可以认为是一种装饰器模式。<code>SubjectCallable</code> 调用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// threadState 实际上是 SubjectThreadState</span></span><br><span class="line">        <span class="comment">// bind 方法底层会将 subject, securityManager 都绑定到一个 Map 的 ThreadLocal</span></span><br><span class="line">        threadState.bind();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实际调用被装饰的 callable</span></span><br><span class="line">        <span class="keyword">return</span> doCall(<span class="built_in">this</span>.callable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadState.restore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> V <span class="title function_">doCall</span><span class="params">(Callable&lt;V&gt; target)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> target.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Subject 执行 executeChain 的代码清单如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">executeChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain origChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">// 寻找合适的 FilterChain</span></span><br><span class="line">    <span class="comment">// 可能是 Tomcat 原生（未找到），也可能是 Shiro 自己链</span></span><br><span class="line">    <span class="type">FilterChain</span> <span class="variable">chain</span> <span class="operator">=</span> getExecutionChain(request, response, origChain);</span><br><span class="line">    chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是通过 requestURI 获取 FilterChain 的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> FilterChain <span class="title function_">getChain</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain originalChain)</span> &#123;</span><br><span class="line">    <span class="type">FilterChainManager</span> <span class="variable">filterChainManager</span> <span class="operator">=</span> getFilterChainManager();</span><br><span class="line">    <span class="keyword">if</span> (!filterChainManager.hasChains()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> getPathWithinApplication(request);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">requestURINoTrailingSlash</span> <span class="operator">=</span> removeTrailingSlash(requestURI);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//the &#x27;chain names&#x27; in this implementation are actually path patterns defined by the user.  We just use them</span></span><br><span class="line">    <span class="comment">//as the chain name for the FilterChainManager&#x27;s requirements</span></span><br><span class="line">    <span class="keyword">for</span> (String pathPattern : filterChainManager.getChainNames()) &#123;</span><br><span class="line">        <span class="comment">// If the path does match, then pass on to the subclass implementation for specific checks:</span></span><br><span class="line">        <span class="keyword">if</span> (pathMatches(pathPattern, requestURI)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;Matched path pattern [&#123;&#125;] for requestURI [&#123;&#125;].  &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Utilizing corresponding filter chain...&quot;</span>, pathPattern, Encode.forHtml(requestURI));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> filterChainManager.proxy(originalChain, pathPattern);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// in spring web, the requestURI &quot;/resource/menus&quot; ---- &quot;resource/menus/&quot; bose can access the resource</span></span><br><span class="line">            <span class="comment">// but the pathPattern match &quot;/resource/menus&quot; can not match &quot;resource/menus/&quot;</span></span><br><span class="line">            <span class="comment">// user can use requestURI + &quot;/&quot; to simply bypassed chain filter, to bypassed shiro protect</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在 Spring Web 中，requestURI &quot;/resource/menus&quot; ---- &quot;resource/menus/&quot; 都可以访问资源</span></span><br><span class="line">            <span class="comment">// 但是 pathPattern 匹配 &quot;/resource/menus&quot; 不能匹配 &quot;resource/menus/&quot;</span></span><br><span class="line">            <span class="comment">// 用户可能使用 requestURI + &quot;/&quot; 来简单跳过 chain filter，以避开 shiro 的保护</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因此，这里去除了末尾的 &quot;/&quot;</span></span><br><span class="line">            pathPattern = removeTrailingSlash(pathPattern);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逻辑类似上面</span></span><br><span class="line">            <span class="keyword">if</span> (pathMatches(pathPattern, requestURINoTrailingSlash)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                    log.trace(<span class="string">&quot;Matched path pattern [&#123;&#125;] for requestURI [&#123;&#125;].  &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;Utilizing corresponding filter chain...&quot;</span>, pathPattern, Encode.forHtml(requestURINoTrailingSlash));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> filterChainManager.proxy(originalChain, pathPattern);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Spring Boot 启动流程</title>
    <url>/2022/07/24/Spring-Boot/Spring-Boot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Spring-Boot-启动流程"><a href="#Spring-Boot-启动流程" class="headerlink" title="Spring Boot 启动流程"></a>Spring Boot 启动流程</h1><h2 id="Spring-Boot-入口"><a href="#Spring-Boot-入口" class="headerlink" title="Spring Boot 入口"></a>Spring Boot 入口</h2><p>一般会使用静态方法，也可以自己 new 一个 <code>SpringApplication</code>，或者使用 Buidler 定制化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartupApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(StartupApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>SpringApplication 构造器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// 资源加载器，默认 null</span></span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 主要资源类，Set 去重</span></span><br><span class="line">    <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="comment">// 推断 Web 环境，底层通过 classpath 是否包含特定类检测，NONE, SERVLET, REACTIVE</span></span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 设置应用上下文初始化器 （从 META-INF/spring.factories）</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 设置监听器 （从 META-INF/spring.factories）</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// 推断主应用类，通过 stackTrace</span></span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面之所以要加载 <code>ApplicationListener</code> 保存到 <code>SpringApplication</code>，是因为下面要传递给 <code>ApplicationEventMulticaster</code>。<code>SpringApplication</code> 作为 <code>EventPublishingRunListener</code> 参数传入。</p>
</blockquote>
<p><code>SpringApplication</code> 运行方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个秒表，并启动</span></span><br><span class="line">    <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 设置系统属性 java.awt.headless</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 创建所有 SpringApplicationRunListener（EventPublishingRunListener）</span></span><br><span class="line">    <span class="comment">// 将所有 SpringApplicationRunListener 封装到 SpringApplicationRunListeners</span></span><br><span class="line">    <span class="comment">// 底层会读取 spring.factories 的 org.springframework.boot.SpringApplicationRunListener</span></span><br><span class="line">    <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即发布 ApplicationStartingEvent 应用启动事件</span></span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化默认应用参数类</span></span><br><span class="line">        <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">        <span class="comment">// 根据 SpringApplicationRunListener 和应用参数准备 spring Environment</span></span><br><span class="line">        <span class="comment">// 发布 ApplicationEnvironmentPreparedEvent 事件</span></span><br><span class="line">        <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        <span class="comment">// 将要忽略的 bean 的参数打开</span></span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">// 创建 Banner 打印类</span></span><br><span class="line">        <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">        <span class="comment">// 创建应用上下文（借助构造器推断的 webApplicationType 选择类）</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        <span class="comment">// 准备上下文</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 刷新</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">// 后置处理</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 停止秒表</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发布应用上下文启动完毕事件 ApplicationStartedEvent</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// 执行所有的 Runner</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 发布 ApplicationReadyEvent 事件</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StopWatch"><a href="#StopWatch" class="headerlink" title="StopWatch"></a>StopWatch</h2><p>计时器&#x2F;秒表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">stopWatch.start();</span><br></pre></td></tr></table></figure>


<h2 id="configureHeadlessProperty"><a href="#configureHeadlessProperty" class="headerlink" title="configureHeadlessProperty"></a>configureHeadlessProperty</h2><p>设置属性 <code>java.awt.headless</code>，如果不存在默认值设置为 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureHeadlessProperty</span><span class="params">()</span> &#123;</span><br><span class="line">    System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS,</span><br><span class="line">            System.getProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(<span class="built_in">this</span>.headless)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getRunListeners"><a href="#getRunListeners" class="headerlink" title="getRunListeners"></a>getRunListeners</h2><p>该方法返回一个 <code>SpringApplicationRunListeners</code> 实例，注意末尾有一个 “s”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SpringApplication</span></span><br><span class="line"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title function_">getRunListeners</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] types = <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;;</span><br><span class="line">    <span class="comment">// 传入的 this 参数就是 SpringApplication</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationRunListeners</span>(logger,</span><br><span class="line">            getSpringFactoriesInstances(SpringApplicationRunListener.class, types, <span class="built_in">this</span>, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>照应前面所说，之所以将 <code>SpringApplication</code> 传入，作为后续的构造器参数，是因为后面需要往 <code>ApplicationEventMulticaster</code> 加入 <code>ApplicationListener</code>，而 <code>ApplicationListener</code> 已经在 <code>SpringApplication</code> 的构造器加载完毕</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line">    <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，只有 spring-boot 下面的 spring.factories 配置了一个 <code>EventPublishingRunListener</code>，其构造器如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EventPublishingRunListener</span><span class="params">(SpringApplication application, String[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.application = application;</span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">    <span class="comment">// 事件多播器</span></span><br><span class="line">    <span class="built_in">this</span>.initialMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line">    <span class="comment">// 获得所有发现的 ApplicationListener</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123;</span><br><span class="line">        <span class="comment">// 添加到事件多播器</span></span><br><span class="line">        <span class="built_in">this</span>.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="listeners-starting"><a href="#listeners-starting" class="headerlink" title="listeners.starting()"></a>listeners.starting()</h2><p>在获得了 <code>SpringApplicationRunListeners</code> 之后立即发布一个事件，告诉所有 <code>ApplicationListener</code> 容器正在启动。</p>
<p>通常这里只有 1 个 listeners，即 <code>EventPublishingRunListener</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="built_in">this</span>.listeners) &#123;</span><br><span class="line">        listener.starting();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EventPublishingRunListener</code> 底层调用内部的 <code>Multicaster</code> 进行广播。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 构造一个事件广播</span></span><br><span class="line">    <span class="built_in">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> <span class="title class_">ApplicationStartingEvent</span>(<span class="built_in">this</span>.application, <span class="built_in">this</span>.args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 resolveDefaultEventType，解析得到 ResolvableType</span></span><br><span class="line">    multicastEvent(event, resolveDefaultEventType(event));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得关心该事件的 <code>ApplicationListener</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(ApplicationEvent event, ResolvableType eventType) &#123;</span><br><span class="line">    <span class="comment">// 获得 event 中的 source，一般为 SpringApplication</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">source</span> <span class="operator">=</span> event.getSource();</span><br><span class="line">    Class&lt;?&gt; sourceType = (source != <span class="literal">null</span> ? source.getClass() : <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 获得 key</span></span><br><span class="line">    <span class="type">ListenerCacheKey</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListenerCacheKey</span>(eventType, sourceType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Potential new retriever to populate</span></span><br><span class="line">    <span class="comment">// retriever 检索器</span></span><br><span class="line">    <span class="type">CachedListenerRetriever</span> <span class="variable">newRetriever</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Quick check for existing entry on ConcurrentHashMap</span></span><br><span class="line">    <span class="type">CachedListenerRetriever</span> <span class="variable">existingRetriever</span> <span class="operator">=</span> <span class="built_in">this</span>.retrieverCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (existingRetriever == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Caching a new ListenerRetriever if possible</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.beanClassLoader == <span class="literal">null</span> ||</span><br><span class="line">                (ClassUtils.isCacheSafe(event.getClass(), <span class="built_in">this</span>.beanClassLoader) &amp;&amp;</span><br><span class="line">                        (sourceType == <span class="literal">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="built_in">this</span>.beanClassLoader)))) &#123;</span><br><span class="line">            newRetriever = <span class="keyword">new</span> <span class="title class_">CachedListenerRetriever</span>();</span><br><span class="line">            <span class="comment">// 用新的覆盖</span></span><br><span class="line">            existingRetriever = <span class="built_in">this</span>.retrieverCache.putIfAbsent(cacheKey, newRetriever);</span><br><span class="line">            <span class="keyword">if</span> (existingRetriever != <span class="literal">null</span>) &#123;</span><br><span class="line">                newRetriever = <span class="literal">null</span>;  <span class="comment">// no need to populate it in retrieveApplicationListeners</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingRetriever != <span class="literal">null</span>) &#123;</span><br><span class="line">        Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners();</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If result is null, the existing retriever is not fully populated yet by another thread.</span></span><br><span class="line">        <span class="comment">// Proceed like caching wasn&#x27;t possible for this current local attempt.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retrieveApplicationListeners(eventType, sourceType, newRetriever);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，这里会根据 Starting 事件匹配到 4 个：</p>
<ul>
<li>LoggingApplicationListener</li>
<li>BackgroundPreinitializer</li>
<li>DelegatingApplicationListener</li>
<li>LiquibaseServiceLocatorApplicationListener</li>
</ul>
<h2 id="prepareEnvironment"><a href="#prepareEnvironment" class="headerlink" title="prepareEnvironment"></a>prepareEnvironment</h2><p>准备环境。也会发布事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableEnvironment <span class="title function_">prepareEnvironment</span><span class="params">(</span></span><br><span class="line"><span class="params">        SpringApplicationRunListeners listeners,</span></span><br><span class="line"><span class="params">        ApplicationArguments applicationArguments)</span> &#123;</span><br><span class="line">    <span class="comment">// Create and configure the environment</span></span><br><span class="line">    <span class="comment">// 根据 webApplicationType 实例化 Environment，注意其间不断调用父类默认构造器</span></span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> getOrCreateEnvironment();</span><br><span class="line">    <span class="comment">// 配置环境，设置 ConversionService；添加命令行</span></span><br><span class="line">    configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line">    <span class="comment">// 发布事件</span></span><br><span class="line">    listeners.environmentPrepared(environment);</span><br><span class="line">    bindToSpringApplication(environment);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isCustomEnvironment) &#123;</span><br><span class="line">        environment = <span class="keyword">new</span> <span class="title class_">EnvironmentConverter</span>(getClassLoader()).convertEnvironmentIfNecessary(environment,</span><br><span class="line">                deduceEnvironmentClass());</span><br><span class="line">    &#125;</span><br><span class="line">    ConfigurationPropertySources.attach(environment);</span><br><span class="line">    <span class="keyword">return</span> environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>补充一下 <code>StandardServletEnvironment</code> 构造器做了什么:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractEnvironment</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AbstractEnvironment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// customizePropertySources 是一个空实现</span></span><br><span class="line">    <span class="comment">// 这里传入了 this 属性，但可以不传?</span></span><br><span class="line">    customizePropertySources(<span class="built_in">this</span>.propertySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 <code>StandardServletEnvironment</code> 对于 <code>customizePropertySources</code> 的覆盖（定制化）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StandardServletEnvironment</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加 servletConfigInitParams</span></span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> <span class="title class_">StubPropertySource</span>(SERVLET_CONFIG_PROPERTY_SOURCE_NAME));</span><br><span class="line">    <span class="comment">// 添加 servletContextInitParams</span></span><br><span class="line">    propertySources.addLast(<span class="keyword">new</span> <span class="title class_">StubPropertySource</span>(SERVLET_CONTEXT_PROPERTY_SOURCE_NAME));</span><br><span class="line">    <span class="keyword">if</span> (JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable()) &#123;</span><br><span class="line">        propertySources.addLast(<span class="keyword">new</span> <span class="title class_">JndiPropertySource</span>(JNDI_PROPERTY_SOURCE_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意，这里也调用了父类 StandardEnvironement 的方法</span></span><br><span class="line">    <span class="built_in">super</span>.customizePropertySources(propertySources);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 <code>StandardEnvironement</code> 关于 <code>customizePropertySources</code> 方法的覆盖（定制化）: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StandardEnvironement</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加系统属性</span></span><br><span class="line">    propertySources.addLast(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PropertiesPropertySource</span>(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));</span><br><span class="line">    <span class="comment">// 添加环境变量</span></span><br><span class="line">    propertySources.addLast(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SystemEnvironmentPropertySource</span>(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prepareContext"><a href="#prepareContext" class="headerlink" title="prepareContext"></a>prepareContext</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span><br><span class="line"><span class="params">        SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> &#123;</span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="literal">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;springApplicationArguments&quot;</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;springBootBanner&quot;</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="built_in">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazyInitialization) &#123;</span><br><span class="line">        context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">LazyInitializationBeanFactoryPostProcessor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    <span class="comment">// 加载资源，包括启动类</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">&quot;Sources must not be empty&quot;</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]));</span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Eureka 配置实践</title>
    <url>/2022/07/12/Spring-Cloud/Eureka-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h1><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>确保引入 maven 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>Eureka 的 Server 配置没有特别好的文档，官网的指引也只是让你看源代码注释。</p>
<h3 id="Eureka-Instance-Config"><a href="#Eureka-Instance-Config" class="headerlink" title="Eureka Instance Config"></a>Eureka Instance Config</h3><ul>
<li>Instance Id<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getInstanceId</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获得该实例注册到 eureka 的唯一 ID（在 appName 范围内）</p>
<ul>
<li>App Name<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getAppname</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获得注册到 eureka 的应用名称</p>
<ul>
<li>lease renewal interval in seconds</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getLeaseRenewalIntervalInSeconds()</span><br></pre></td></tr></table></figure>

<p>字面意思：租约续期间隔。</p>
<p>表示 eureka 客户端多久发送心跳给 eureka server，告诉它自己还活着。如果心跳在 <code>getLeaseExpirationDurationInSeconds()</code> 指定的期间还未收到，eureka server 就会从它的视图中移除该实例，从而禁用了该实例的流量。</p>
<blockquote>
<p>该参数只是用于 Eureka Client 发送心跳间隔。需要确保与 Eureka Server 的 <code>getLeaseExpirationDurationInSeconds()</code> 参数值一致，否则 Eureka Server 无法正常工作。</p>
</blockquote>
<ul>
<li>lease expiration duration in seconds</li>
</ul>
<p>表示 Eureka Server 自收到某个实例最后一次心跳，在可以从它的视图中移除该实例从而禁用该实例流量之前，等待的时间，单位：秒。</p>
<p>设置该值太长可能意味着，即使该实例并不存活，也可以将流量路由到该实例。设置该值太小可能意味着，由于临时的网络故障，该实例可能会从流量中剔除。该值设置至少高于 <code>getLeaseRenewalIntervalInSeconds()</code> 指定的值。</p>
<blockquote>
<p>如果该值比 <code>getLeaseRenewalIntervalInSeconds()</code> 小，那么实例将无法存活于注册表，即使注册成功，很快就被剔除。</p>
</blockquote>
<h3 id="Eureka-Server-Config"><a href="#Eureka-Server-Config" class="headerlink" title="Eureka Server Config"></a>Eureka Server Config</h3><ul>
<li>AWS Access Id</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getAWSAccessId</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>AWS 云 Access ID</p>
<ul>
<li>AWS Secret Key</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getAWSSecretKey</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>AWS 云 Secret Key</p>
<ul>
<li><p>EIPBindRebindRetries</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getEIPBindRebindRetries</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EIPBindingRetryIntervalMsWhenUnbound</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getEIPBindingRetryIntervalMsWhenUnbound</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EIPBindingRetryIntervalMs</p>
</li>
<li><p>enable-self-preservation</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">shouldEnableSelfPreservation</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>是否开启自我保护机制。</p>
<p>启用后，Eureka Server 将跟踪其应该从服务接收到的续约次数。任何时候，续约数量低于 <code>getRenewalPercentThreshold()</code> 定义的阈值百分比，Eureka Server 会关闭过期以避免危险。这有助于在 Eureka Client 与 Eureka Server 之间发生网络问题时维持注册表信息。</p>
<blockquote>
<p>注意，自我保护是防止一些网络问题误杀。</p>
</blockquote>
<ul>
<li>eviction-interval-timer-in-ms</li>
</ul>
<p>清理无效节点的时间间隔。默认值 60000</p>
<blockquote>
<p>可以将这个时间设置的短一些，进行快速下线。防止使用不可用的服务。</p>
</blockquote>
<ul>
<li>expected-client-renewalI-interval-seconds</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getExpectedClientRenewalIntervalSeconds</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>期望客户端以这个间隔发送它们的心跳。</p>
<p>默认值：30</p>
<p>如果客户端以不同的频率发送心跳，例如每 15 秒发送一次，那么应该相应地调整此参数，否则，自我保护将无法按预期工作。</p>
<blockquote>
<p>该参数用于计算内部的阈值。</p>
</blockquote>
<ul>
<li>Response Cache Update Interval Ms</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">getResponseCacheUpdateIntervalMs</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>获取更新 Eureka Client 负载缓存的时间间隔。</p>
<ul>
<li>Use Read Only Response Cache</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">shouldUseReadOnlyResponseCache</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>字面意思：是否使用只读响应缓存</p>
<p><code>com.netflix.eureka.registry.ResponseCache</code> 当前使用两级缓存策略来响应。带有过期策略的独写缓存，以及不会过期的只读缓存。</p>
<ul>
<li>Renewal Percent Threshold</li>
</ul>
<p>在由 <code>getRenewalThresholdUpdateIntervalMs()</code> 指定的期间，期望从服务端续期次数的最小百分比。</p>
<p>如果续约降低到阈值以下，并且启用了 <code>shouldEnableSelfPreservation()</code> 则会禁用过期。</p>
<ul>
<li>getRenewalThresholdUpdateIntervalMs</li>
</ul>
<p>由 <code>getRenewalPercentThreshold()</code> 指定的阈值，应该更新的间隔。阈值更新间隔</p>
<ul>
<li>shouldEnableSelfPreservation</li>
</ul>
<p>检查 eureka server 是否启用了自我保护。</p>
<p>当启用，服务会跟踪它应该从微服务接受到的续约次数。在任何时候，续订次数的数量低于 <code>getRenewalPercentThreshold()</code> 定义的阈值百分比，服务器就会关闭过期以避免危险。这有助于在客户端和服务端之间产生网络问题时服务器维持注册信息。</p>
]]></content>
  </entry>
  <entry>
    <title>Hystrix 配置实践</title>
    <url>/2022/07/15/Spring-Cloud/Hystrix-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>涉及到断路器的参数（HystrixCommandProperties）：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">circuitBreaker.enabled</td>
<td align="left">是否开启断路器</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">circuitBreaker.requestVolumeThreshold</td>
<td align="left">请求总数阈值。这意味着，如果 hystrix 命令在休眠窗口期间调用次数不足 20 次，即使请求都失败，断路器也不会打开</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left">circuitBreaker.sleepWindowInMilliseconds</td>
<td align="left">休眠窗口</td>
<td align="left">5000</td>
</tr>
<tr>
<td align="left">circuitBreaker.errorThresholdPercentage</td>
<td align="left">错误阈值。当请求总数在休眠窗口内超过了阈值，断路器就会打开。</td>
<td align="left">50</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Spring Cloud BootstrapImportSelector</title>
    <url>/2022/07/22/Spring-Cloud/Spring-Cloud-BootstrapImportSelector/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-BootstrapImportSelector"><a href="#Spring-Cloud-BootstrapImportSelector" class="headerlink" title="Spring Cloud BootstrapImportSelector"></a>Spring Cloud BootstrapImportSelector</h1><p>在 <code>BootstrapApplicationListener</code> 监听器中，会将 <code>BootstrapImportSelectorConfiguration</code> 配置类注入到 IoC 容器，该配置类有一个注解 <code>@Import</code>，将 <code>BootstrapImportSelector</code> 类注入到容器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(BootstrapImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootstrapImportSelectorConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>BootstrapImportSelector</code> 获得 spring.factories 文件中 key 为 <code>org.springframework.cloud.bootstrap.BootstrapConfiguration</code> 的配置组件。</p>
<h2 id="构建-bootstrapServiceContext-流程"><a href="#构建-bootstrapServiceContext-流程" class="headerlink" title="构建 bootstrapServiceContext 流程"></a>构建 bootstrapServiceContext 流程</h2><p>在 <code>SpringApplication</code> 运行 run 方法的过程中会调用 <code>prepareEnvironment</code> 进行环境准备，其中会调用所有的监听器 <code>SpringApplicationRunListener</code> 进行环境准备，调用链如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplication.run()</span><br><span class="line">-&gt; SpringApplication.prepareEnvironment()</span><br><span class="line">-&gt; listeners.environmentPrepared()</span><br></pre></td></tr></table></figure>

<p>一般来说，默认只有一个监听器 <code>EventPublishingRunListener</code>，以下是 <code>SpringApplicationRunListeners</code> 的调用入口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="built_in">this</span>.listeners) &#123;</span><br><span class="line">        listener.environmentPrepared(environment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EventPublishingRunListener</code> 会调用内部的 <code>initialMulticaster</code> 进行事件广播，代码清单如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initialMulticaster</span><br><span class="line">            .multicastEvent(<span class="keyword">new</span> <span class="title class_">ApplicationEnvironmentPreparedEvent</span>(<span class="built_in">this</span>.application, <span class="built_in">this</span>.args, environment));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接下来会进入 <code>SimpleApplicationEventMulticaster</code> 的广播事件逻辑，将会获取所有的 <code>ApplicationListener</code>（这也包括 <code>BootstrapApplicationListener</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, <span class="meta">@Nullable</span> ResolvableType eventType)</span> &#123;</span><br><span class="line">    <span class="type">ResolvableType</span> <span class="variable">type</span> <span class="operator">=</span> (eventType != <span class="literal">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="literal">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用事件逻辑链如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleApplicationEventMulticaster.invokeListener()</span><br><span class="line">-&gt; SimpleApplicationEventMulticaster.doInvokeListener()</span><br><span class="line">-&gt; ApplicationListener.onApplicationEvent(event)</span><br></pre></td></tr></table></figure>


<p>下面 <code>BootstrapApplicationListener</code> 开始处理事件:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> event.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (!environment.getProperty(<span class="string">&quot;spring.cloud.bootstrap.enabled&quot;</span>, Boolean.class,</span><br><span class="line">            <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// don&#x27;t listen to events in a bootstrap context</span></span><br><span class="line">    <span class="keyword">if</span> (environment.getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">configName</span> <span class="operator">=</span> environment</span><br><span class="line">            .resolvePlaceholders(<span class="string">&quot;$&#123;spring.cloud.bootstrap.name:bootstrap&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (ApplicationContextInitializer&lt;?&gt; initializer : event.getSpringApplication()</span><br><span class="line">            .getInitializers()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (initializer <span class="keyword">instanceof</span> ParentContextApplicationContextInitializer) &#123;</span><br><span class="line">            context = findBootstrapContext(</span><br><span class="line">                    (ParentContextApplicationContextInitializer) initializer,</span><br><span class="line">                    configName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里调用 bootstrapServiceContext 创建了一个上下文</span></span><br><span class="line">        context = bootstrapServiceContext(environment, event.getSpringApplication(), configName);</span><br><span class="line">        event.getSpringApplication().addListeners(<span class="keyword">new</span> <span class="title class_">CloseContextOnFailureApplicationListener</span>(context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    apply(context, event.getSpringApplication(), environment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 BoostrapApplicationListener 创建上下文的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ConfigurableApplicationContext <span class="title function_">bootstrapServiceContext</span><span class="params">(</span></span><br><span class="line"><span class="params">        ConfigurableEnvironment environment, <span class="keyword">final</span> SpringApplication application,</span></span><br><span class="line"><span class="params">        String configName)</span> &#123;</span><br><span class="line">    <span class="type">StandardEnvironment</span> <span class="variable">bootstrapEnvironment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    <span class="type">MutablePropertySources</span> <span class="variable">bootstrapProperties</span> <span class="operator">=</span> bootstrapEnvironment</span><br><span class="line">            .getPropertySources();</span><br><span class="line">    <span class="keyword">for</span> (PropertySource&lt;?&gt; source : bootstrapProperties) &#123;</span><br><span class="line">        bootstrapProperties.remove(source.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> environment</span><br><span class="line">            .resolvePlaceholders(<span class="string">&quot;$&#123;spring.cloud.bootstrap.location:&#125;&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">configAdditionalLocation</span> <span class="operator">=</span> environment</span><br><span class="line">            .resolvePlaceholders(<span class="string">&quot;$&#123;spring.cloud.bootstrap.additional-location:&#125;&quot;</span>);</span><br><span class="line">    Map&lt;String, Object&gt; bootstrapMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    bootstrapMap.put(<span class="string">&quot;spring.config.name&quot;</span>, configName);</span><br><span class="line">    <span class="comment">// if an app (or test) uses spring.main.web-application-type=reactive, bootstrap</span></span><br><span class="line">    <span class="comment">// will fail</span></span><br><span class="line">    <span class="comment">// force the environment to use none, because if though it is set below in the</span></span><br><span class="line">    <span class="comment">// builder</span></span><br><span class="line">    <span class="comment">// the environment overrides it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一个应用（或者 test）使用 spring.main.web-application-type=reactive，bootstrap 就会失败</span></span><br><span class="line">    <span class="comment">// 强制环境使用 none，因为如果在构建器中设置为 below，环境就会覆盖???</span></span><br><span class="line">    bootstrapMap.put(<span class="string">&quot;spring.main.web-application-type&quot;</span>, <span class="string">&quot;none&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(configLocation)) &#123;</span><br><span class="line">        bootstrapMap.put(<span class="string">&quot;spring.config.location&quot;</span>, configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(configAdditionalLocation)) &#123;</span><br><span class="line">        bootstrapMap.put(<span class="string">&quot;spring.config.additional-location&quot;</span>,</span><br><span class="line">                configAdditionalLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    bootstrapProperties.addFirst(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(BOOTSTRAP_PROPERTY_SOURCE_NAME, bootstrapMap));</span><br><span class="line">    <span class="keyword">for</span> (PropertySource&lt;?&gt; source : environment.getPropertySources()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source <span class="keyword">instanceof</span> StubPropertySource) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bootstrapProperties.addLast(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> is it possible or sensible to share a ResourceLoader?</span></span><br><span class="line">    <span class="type">SpringApplicationBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class="line">            .profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)</span><br><span class="line">            .environment(bootstrapEnvironment)</span><br><span class="line">            <span class="comment">// Don&#x27;t use the default properties in this builder</span></span><br><span class="line">            .registerShutdownHook(<span class="literal">false</span>).logStartupInfo(<span class="literal">false</span>)</span><br><span class="line">            .web(WebApplicationType.NONE);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SpringApplication</span> <span class="variable">builderApplication</span> <span class="operator">=</span> builder.application();</span><br><span class="line">    <span class="keyword">if</span> (builderApplication.getMainApplicationClass() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// gh_425:</span></span><br><span class="line">        <span class="comment">// SpringApplication cannot deduce the MainApplicationClass here</span></span><br><span class="line">        <span class="comment">// if it is booted from SpringBootServletInitializer due to the</span></span><br><span class="line">        <span class="comment">// absense of the &quot;main&quot; method in stackTraces.</span></span><br><span class="line">        <span class="comment">// But luckily this method&#x27;s second parameter &quot;application&quot; here</span></span><br><span class="line">        <span class="comment">// carries the real MainApplicationClass which has been explicitly</span></span><br><span class="line">        <span class="comment">// set by SpringBootServletInitializer itself already.</span></span><br><span class="line">        builder.main(application.getMainApplicationClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (environment.getPropertySources().contains(<span class="string">&quot;refreshArgs&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// If we are doing a context refresh, really we only want to refresh the</span></span><br><span class="line">        <span class="comment">// Environment, and there are some toxic listeners (like the</span></span><br><span class="line">        <span class="comment">// LoggingApplicationListener) that affect global static state, so we need a</span></span><br><span class="line">        <span class="comment">// way to switch those off.</span></span><br><span class="line">        builderApplication</span><br><span class="line">                .setListeners(filterListeners(builderApplication.getListeners()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里配了一个 BootstrapImportSelectorConfiguration</span></span><br><span class="line">    builder.sources(BootstrapImportSelectorConfiguration.class);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> builder.run();</span><br><span class="line">    <span class="comment">// gh-214 using spring.application.name=bootstrap to set the context id via</span></span><br><span class="line">    <span class="comment">// `ContextIdApplicationContextInitializer` prevents apps from getting the actual</span></span><br><span class="line">    <span class="comment">// spring.application.name</span></span><br><span class="line">    <span class="comment">// during the bootstrap phase.</span></span><br><span class="line">    context.setId(<span class="string">&quot;bootstrap&quot;</span>);</span><br><span class="line">    <span class="comment">// Make the bootstrap context a parent of the app context</span></span><br><span class="line">    addAncestorInitializer(application, context);</span><br><span class="line">    <span class="comment">// It only has properties in it now that we don&#x27;t want in the parent so remove</span></span><br><span class="line">    <span class="comment">// it (and it will be added back later)</span></span><br><span class="line">    bootstrapProperties.remove(BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">    mergeDefaultProperties(environment.getPropertySources(), bootstrapProperties);</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="BootstrapImportSelector-如何进行-selectImports-操作"><a href="#BootstrapImportSelector-如何进行-selectImports-操作" class="headerlink" title="BootstrapImportSelector 如何进行 selectImports 操作"></a><code>BootstrapImportSelector</code> 如何进行 <code>selectImports</code> 操作</h2><p><code>bootstrapServiceContext</code> 与一般的 <code>ApplicationContext</code> 类似，也需要进行容器 <code>refresh</code> 操作。</p>
<p>其中会调用许多 <code>BeanFactoryPostProcessor</code> 进行处理，包括 <code>ConfigurationClassPostProcessor</code>，Bean Definition <code>bootstrapImportSelectorConfiguration</code> 就是其处理对象，也可以说是候选人 <code>candidates</code> 之一。</p>
<p>候选人经过 <code>ConfigurationClassParser</code> 解析，解析之后会得到许多 <code>ConfigurationClass</code>。解析的过程主要分两个步骤：解析、延迟处理：</p>
<blockquote>
<p>对于那些实现了 <code>DeferredImportSelector</code> 接口的 <code>ImportSelector</code>，会在延迟处理中处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConfigurationClassParser</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parse</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> holder.getBeanDefinition();</span><br><span class="line">        <span class="comment">// 以下的 parse 方法也会特殊过滤 DeferredImportSelector</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;</span><br><span class="line">                parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                parse(bd.getBeanClassName(), holder.getBeanName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">                    <span class="string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 延迟处理 ImportSelector</span></span><br><span class="line">    <span class="built_in">this</span>.deferredImportSelectorHandler.process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>parse</code> 方法执行结束，接着使用 <code>ConfigurationClassBeanDefinitionReader</code> 加载所有的 <code>ConfigurationClass</code>。一般这里会解析到如下：</p>
<ul>
<li>org.springframework.cloud.bootstrap.BootstrapImportSelectorConfiguration</li>
<li>org&#x2F;springframework&#x2F;cloud&#x2F;bootstrap&#x2F;config&#x2F;PropertySourceBootstrapConfiguration.class</li>
<li>org&#x2F;springframework&#x2F;cloud&#x2F;bootstrap&#x2F;encrypt&#x2F;EncryptionBootstrapConfiguration.class</li>
<li>org&#x2F;springframework&#x2F;cloud&#x2F;autoconfigure&#x2F;ConfigurationPropertiesRebinderAutoConfiguration.class</li>
<li>org&#x2F;springframework&#x2F;boot&#x2F;autoconfigure&#x2F;context&#x2F;PropertyPlaceholderAutoConfiguration.class</li>
<li>org&#x2F;springframework&#x2F;cloud&#x2F;util&#x2F;random&#x2F;CachedRandomPropertySourceAutoConfiguration.class</li>
</ul>
<p>针对这些 <code>ConfigurationClass</code>，以此进行 Bean Definition 的加载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConfigurationClassBeanDefinitionReader.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadBeanDefinitionsForConfigurationClass</span><span class="params">(</span></span><br><span class="line"><span class="params">        ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (trackedConditionEvaluator.shouldSkip(configClass)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> configClass.getBeanName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="built_in">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.registry.removeBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.importRegistry.removeImportingClass(configClass.getMetadata().getClassName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (configClass.isImported()) &#123;</span><br><span class="line">        registerBeanDefinitionForImportedConfigurationClass(configClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (BeanMethod beanMethod : configClass.getBeanMethods()) &#123;</span><br><span class="line">        loadBeanDefinitionsForBeanMethod(beanMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于处理导入资源</span></span><br><span class="line">    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());</span><br><span class="line">    <span class="comment">// 用于处理 </span></span><br><span class="line">    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway</title>
    <url>/2022/07/15/Spring-Cloud/Spring-Cloud-Gateway/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/">Spring Cloud Gateway</a></h1><h2 id="1-How-to-Include-Spring-Cloud-Gateway"><a href="#1-How-to-Include-Spring-Cloud-Gateway" class="headerlink" title="1. How to Include Spring Cloud Gateway"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gateway-starter">1. How to Include Spring Cloud Gateway</a></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你包含了 starter，但是你不想启用网关，则可以设置 <code>spring.cloud.gateway.enabled=false</code></p>
<h2 id="2-Glossary"><a href="#2-Glossary" class="headerlink" title="2. Glossary"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#glossary">2. Glossary</a></h2><ul>
<li><strong>Route</strong>: 网关的基本构建。它由 ID，目标 URI，谓词集合，以及过滤器集合定义。如果聚合谓词为 true，则匹配路由。</li>
<li><strong>Predicate</strong>: 这是 Java 8 Function Predicate。输入类型是 <code>Spring Framework ServerWebExchange</code>。这使你可以匹配来自 HTTP 请求中的任何东西，例如 Header 或者参数。</li>
<li><strong>Filter</strong>: 这些是一些 <code>GatewayFilter</code> 实例，它们由特定的工厂构建出来。在这里，你可以在发送下游请求之前或之后修改请求和响应。</li>
</ul>
<h2 id="4-Configuring-Route-Predicate-Factories-and-Gateway-Filter-Factories"><a href="#4-Configuring-Route-Predicate-Factories-and-Gateway-Filter-Factories" class="headerlink" title="4. Configuring Route Predicate Factories and Gateway Filter Factories"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#configuring-route-predicate-factories-and-gateway-filter-factories">4. Configuring Route Predicate Factories and Gateway Filter Factories</a></h2><p>配置谓词和过滤器有两种方式：快捷方式和完全扩展参数。下面大多数示例都是用快捷方式。</p>
<h3 id="4-1-Shortcut-Configuration"><a href="#4-1-Shortcut-Configuration" class="headerlink" title="4.1. Shortcut Configuration"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#shortcut-configuration">4.1. Shortcut Configuration</a></h3><p>快捷方式配置由过滤器名称识别，跟着一个等号（<code>=</code>），后面跟着由逗号（<code>,</code>）分割的参数值。</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=mycookie,mycookievalue</span></span><br></pre></td></tr></table></figure>
<p>上面的样例定义了具有两个参数的 <code>Cookie</code> 路由谓词工厂，参数分别是，cookie name <code>mycookie</code>，以及要匹配 <code>mycookievalue</code> 的值。</p>
<h1 id="5-Route-Predicate-Factories"><a href="#5-Route-Predicate-Factories" class="headerlink" title="5. Route Predicate Factories"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gateway-request-predicates-factories">5. Route Predicate Factories</a></h1><p>Spring Cloud Gateway 包含许多内置的路由谓词工厂，所有这些谓词匹配不同的 HTTP 请求属性</p>
<h2 id="5-1-The-After-Route-Predicate-Factory"><a href="#5-1-The-After-Route-Predicate-Factory" class="headerlink" title="5.1. The After Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-after-route-predicate-factory">5.1. The After Route Predicate Factory</a></h2><p><code>After</code> 路由谓词工厂携带一个参数，即一个 <code>datetime</code>（其实是 Java 的 <code>ZonedDateTime</code>）。该谓词匹配发生在指定时间之后的请求。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">After=2021-06-03T10:00:00.000+08:00</span></span><br></pre></td></tr></table></figure>


<h2 id="5-2-The-Before-Route-Predicate-Factory"><a href="#5-2-The-Before-Route-Predicate-Factory" class="headerlink" title="5.2. The Before Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-before-route-predicate-factory">5.2. The Before Route Predicate Factory</a></h2><p><code>Before</code> 路由谓词工厂携带一个参数，即一个 <code>datetime</code>（其实是 Java 的 <code>ZonedDateTime</code>）。该谓词匹配发生在指定时间之前的请求。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Before=2021-06-03T10:00:00.000+08:00</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-The-Between-Route-Predicate-Factory"><a href="#5-3-The-Between-Route-Predicate-Factory" class="headerlink" title="5.3. The Between Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-between-route-predicate-factory">5.3. The Between Route Predicate Factory</a></h2><p><code>Between</code> 路由谓词工厂携带两个参数，<code>datetime1</code> 和 <code>datetime2</code>，他们都是 Java 的 <code>ZonedDateTime</code> 对象。该谓词匹配发生在 <code>datetime1</code> 之后，以及 <code>datetime2</code> 之前的请求。<code>datetime2</code> 参数必须在 <code>datetime1</code> 之后。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017-01-21T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure>

<h2 id="5-4-The-Cookie-Route-Predicate-Factory"><a href="#5-4-The-Cookie-Route-Predicate-Factory" class="headerlink" title="5.4. The Cookie Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-cookie-route-predicate-factory">5.4. The Cookie Route Predicate Factory</a></h2><p><code>Cookie</code> 路由谓词工厂携带两个参数，<code>name</code> 和 <code>regexp</code>（本质是 Java 的正则表达式）。该谓词匹配具有给定名称，并且值匹配正则表达式的 cookie。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Cookie=x-token,</span> <span class="string">\w+</span></span><br></pre></td></tr></table></figure>

<h2 id="5-5-The-Header-Route-Predicate-Factory"><a href="#5-5-The-Header-Route-Predicate-Factory" class="headerlink" title="5.5. The Header Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-header-route-predicate-factory">5.5. The Header Route Predicate Factory</a></h2><p><code>Header</code> 路由谓词工厂携带两个参数，<code>name</code> 和 <code>regexp</code>（本质是 Java 的正则表达式）。该谓词匹配具有给定名称，并且值匹配正则表达式的 header。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>


<h2 id="5-6-The-Host-Route-Predicate-Factory"><a href="#5-6-The-Host-Route-Predicate-Factory" class="headerlink" title="5.6. The Host Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-host-route-predicate-factory">5.6. The Host Route Predicate Factory</a></h2><p><code>Header</code> 路由谓词工厂携带一个参数：主机名 <code>patterns</code> 列表。模式是一种 Ant 风格的带有 <code>.</code> 作为分隔符的模式。该谓词匹配模式中的的 <code>Host</code> 头部。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>消息头部的字段名是大小写不敏感的，也就是头部 X-Request-Id，也可以传递 x-request-id<br>RFC 2616 <a href="https://www.rfc-editor.org/rfc/inline-errata/rfc2616.html%EF%BC%8C%E6%9F%A5%E8%AF%A2">https://www.rfc-editor.org/rfc/inline-errata/rfc2616.html，查询</a> (“:”) 关键字附近文字可以找到：Field names are case-insensitive.</p>
</blockquote>
<h2 id="5-7-The-Method-Route-Predicate-Factory"><a href="#5-7-The-Method-Route-Predicate-Factory" class="headerlink" title="5.7. The Method Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-method-route-predicate-factory">5.7. The Method Route Predicate Factory</a></h2><p><code>Method</code> 路由谓词工厂携带一个参数 <code>methods</code>，该参数是一个或者多个参数：待匹配的 HTTP 方法。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure>

<h2 id="5-8-The-Path-Route-Predicate-Factory"><a href="#5-8-The-Path-Route-Predicate-Factory" class="headerlink" title="5.8. The Path Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-path-route-predicate-factory">5.8. The Path Route Predicate Factory</a></h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/echo/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="5-9-The-Query-Route-Predicate-Factory"><a href="#5-9-The-Query-Route-Predicate-Factory" class="headerlink" title="5.9. The Query Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-query-route-predicate-factory">5.9. The Query Route Predicate Factory</a></h2><p><code>Query</code> 路由谓词工厂携带两个参数，一个必需的 <code>param</code> 和一个可选的 <code>regexp</code>（本质是 Java 的正则表达式）。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=id</span></span><br></pre></td></tr></table></figure>

<h2 id="5-10-The-RemoteAddr-Route-Predicate-Factory"><a href="#5-10-The-RemoteAddr-Route-Predicate-Factory" class="headerlink" title="5.10. The RemoteAddr Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-remoteaddr-route-predicate-factory">5.10. The RemoteAddr Route Predicate Factory</a></h2><p><code>RemoteAddr</code> 路由谓词工厂携带一个 <code>sources</code> 列表，这是 CIDR 符号字符串，例如 <code>192.168.0.1/16</code>，此处 <code>192.168.0.1</code> 是 IP 地址，16 是子网掩码。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.0.187/24</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud OpenFeign</title>
    <url>/2022/07/13/Spring-Cloud/Spring-Cloud-OpenFeign/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h1><h2 id="1-Declarative-REST-Client-Feign"><a href="#1-Declarative-REST-Client-Feign" class="headerlink" title="1. Declarative REST Client: Feign"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign">1. Declarative REST Client: Feign</a></h2><p>Feign 是一个声明式 Web 服务客户端。它使得编写 Web 服务客户端更容易。使用 Feign 创建一个接口并注解它。它具有可插入的注解支持，包括 Feign 注解和 JAX-RS 注解。Feign 还支持可插拔的编码器和解码器。Spring Cloud 增加了对 Spring MVC 注解的支持，以及支持使用 Spring Web 中默认项相同的 <code>HttpMessageConverters</code>。Spring Cloud 集成了 Ribbon 以及 Eureka，Spring Cloud CiruitBreaker，以及 Spring Cloud LoadBalancer，以便在使用 Feign 时提供负载均衡的 HTTP 客户端。</p>
<h3 id="1-1-How-to-Include-Feign"><a href="#1-1-How-to-Include-Feign" class="headerlink" title="1.1. How to Include Feign"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#netflix-feign-starter">1.1. How to Include Feign</a></h3><p>要在项目中包含 Feign，请使用 group 为 <code>org.springframework.cloud</code>，artifact id 为 <code>spring-cloud-starter-openfeign</code> 的 starter。有关使用当前 Spring Cloud Release Train 设置你的构建系统的详情，参见 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</a></p>
<p>示例 Spring Boot 应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>StoreClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;stores&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StoreClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)</span></span><br><span class="line">    List&lt;Store&gt; <span class="title function_">getStores</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)</span></span><br><span class="line">    Page&lt;Store&gt; <span class="title function_">getStores</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.POST, value = &quot;/stores/&#123;storeId&#125;&quot;, consumes = &quot;application/json&quot;)</span></span><br><span class="line">    Store <span class="title function_">update</span><span class="params">(<span class="meta">@PathVariable(&quot;storeId&quot;)</span> Long storeId, Store store)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>@FeignClient</code> 注解中，字符串 value（即上面的 “stores”）是一个任意的 client name，用于创建一个 Ribbon 负载均衡或者 Spring Cloud LoadBalancer。你还可以使用 <code>url</code> 属性（绝对值或者一个主机名）指定一个 URL。应用上下文中 Bean 的名称是接口的完全限定名。为了指定你自己的别名，你可以使用 <code>@FeignClient</code> 注解的 <code>qualifiers</code> 值。</p>
<p>上面的负载均衡客户端将会希望发现 “stores” 服务的物理地址。如果你的应用是 Eureka 客户端，则它将在 Eureka 服务注册表中解析该服务。如果你不想使用 Eureka，则可以使用 <code>SimpleDiscoveryClient</code> 在外部配置中简单地配置服务器列表。</p>
<h3 id="1-2-Overriding-Feign-Defaults"><a href="#1-2-Overriding-Feign-Defaults" class="headerlink" title="1.2. Overriding Feign Defaults"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-overriding-defaults">1.2. Overriding Feign Defaults</a></h3><p>Spring Cloud 的 Feign 支持中的一个核心概念就是有名客户端。每个 Feign 客户端都是一群组件的部分，它们共同协作按需与远程服务进行连接，并且这个整体有一个你作为开发者使用 <code>@FeignClient</code> 注解赋予的名字。Spring Cloud 使用 <code>FeignClientsConfiguration</code> 为每个有名客户端按需地，以 <code>ApplicationContext</code> 的形式创建一个全新的整体。这包含一个 <code>feign.Decoder</code>，一个 <code>feign.Encoder</code>，以及一个 <code>feign.Contract</code>。可以使用 <code>@FeignClient</code> 注解的 <code>contextId</code> 属性覆盖该整体的名称。</p>
<p>Spring Cloud 使你可以使用 <code>@FeignClient</code> 声明额外的配置（覆盖 <code>FeignClientsConfiguration</code>）完全控制 feign 客户端。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;stores&quot;, configuration = FooConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StoreClient</span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，客户端是由已经存在于 <code>FeignClientsConfiguration</code> 中的组件，以及 <code>FooConfiguration</code> （后者覆盖前者）中的种种组成。</p>
<blockquote>
<p><code>FooConfiguration</code> 不需要 <code>@Configuration</code> 注解。但是，如果这样做，请将其从任何 <code>@ComponentScan</code> 中排除，否则将包含此配置，因为它将将成为 <code>feign.Decoder</code>，<code>feign.Encoder</code>，<code>feign.Contract</code> 等默认源。</p>
</blockquote>
<p><code>name</code> 和 <code>url</code> 属性也支持占位符。</p>
<h4 id="1-2-1-SpringEncoder-configuration"><a href="#1-2-1-SpringEncoder-configuration" class="headerlink" title="1.2.1. SpringEncoder configuration"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#springencoder-configuration">1.2.1. SpringEncoder configuration</a></h4><p>在我们提供的 <code>SpringEncoder</code> 中，我们为二进制内容类型设置了 <code>null</code> 字符集，并未所有其他的设置了 <code>UTF-8</code>。</p>
<p>你可以通过设置 <code>feign.encoder.charset-from-content-type</code> 的值为 <code>true</code>来修改此行为，以从 <code>Content-Type</code> 头部 charset 获得字符集。</p>
<h3 id="1-3-Timeout-Handling"><a href="#1-3-Timeout-Handling" class="headerlink" title="1.3. Timeout Handling"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#timeout-handling">1.3. Timeout Handling</a></h3><p>我们可以在默认和有名客户端上配置超时。OpenFeign 可与两个超时参数一起使用：</p>
<ul>
<li><code>connectTime</code></li>
<li><code>readTimeout</code></li>
</ul>
<h3 id="1-5-Feign-Hystrix-Support"><a href="#1-5-Feign-Hystrix-Support" class="headerlink" title="1.5. Feign Hystrix Support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-hystrix">1.5. Feign Hystrix Support</a></h3><p>如果 Hystrix 在类路径，并且 <code>feign.hystrix.enabled=true</code>，Feign 将用熔断器包装所有方法。还提供返回一个 <code>com.netflix.hystrix.HystrixCommand</code>。这使你可以使用响应式模式。</p>
<h3 id="1-6-Feign-Hystrix-Fallbacks"><a href="#1-6-Feign-Hystrix-Fallbacks" class="headerlink" title="1.6. Feign Hystrix Fallbacks"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-hystrix-fallback">1.6. Feign Hystrix Fallbacks</a></h3><h3 id="1-10-Feign-Inheritance-Support"><a href="#1-10-Feign-Inheritance-Support" class="headerlink" title="1.10. Feign Inheritance Support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-inheritance">1.10. Feign Inheritance Support</a></h3><p>Feign 通过单继承接口支持样板 API。这允许你将通用操作分组为方便的基础接口。</p>
<p><strong>UserService.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value =&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserResource.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserResource</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> project.user;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-Timeout-Handling-1"><a href="#1-3-Timeout-Handling-1" class="headerlink" title="1.3. Timeout Handling"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#timeout-handling">1.3. Timeout Handling</a></h3><p>我们可以在默认和有名客户端上配置 timeout 属性。OpenFeign 用这两个 timeout 参数进行工作：</p>
<ul>
<li><code>connectTimeout</code> 防止由于较长的服务端处理时间导致的阻塞。</li>
<li><code>readTimeout</code> 在连接建立的时候使用，并且当返回响应花费太久的时候会触发</li>
</ul>
<blockquote>
<p>如果服务没有运行或者不可用，数据包可能以连接被拒绝结束。通信以错误信息或者后背方式结束。如果 <code>connectTimeout</code> 设置非常低，这就有可能在 <code>connectTimeout</code> 之前就结束通信。执行查找以及接收这样的数据包的时间可能会产生较大一部分延迟。可以基于涉及到 DNS 查找的远程主机修改该值。</p>
</blockquote>
<p>当启用 Hystrix 后，超时配置默认是 1000 毫秒。因此，它可能发生在我们前面配置的客户端超时之前。增加该超时，防止发生这种情况。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">timeout:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当启用 Hystrix 的 timeout 且它的 timeout 设置得比 feign client 更长时，<code>HystrixTimeoutException</code> 会包装一个 feign 异常。否则，唯一的区别就是异常的原因。<code>HystrixTimeoutException</code> 的目的是包装先发生的任何运行时异常，并抛出自身实例。</p>
</blockquote>
<h3 id="1-5-Feign-Hystrix-Support-1"><a href="#1-5-Feign-Hystrix-Support-1" class="headerlink" title="1.5. Feign Hystrix Support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-hystrix">1.5. Feign Hystrix Support</a></h3><p>如果 Hystrix 在类路径中，且 <code>feign.hystrix.enabled=true</code>，Feign 将使用熔断器包装所有的方法。还可以返回一个 <code>HystrixCommand</code>。</p>
<h3 id="1-12-Feign-logging"><a href="#1-12-Feign-logging" class="headerlink" title="1.12. Feign logging"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#feign-logging">1.12. Feign logging</a></h3><p>为每个 Feign 客户端创建了一个 logger。默认情况下，logger 的名字是用于创建 Feign 客户端的接口的完全限定类名。Feign 日志仅仅响应 <code>DEBUG</code> 级别。</p>
<p><strong>application.yml</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.level.project.user.UserClient</span>: <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>你可以为每个客户端配置的 <code>Logger.Level</code> 对象，告诉 Feign 多少要记录。选项如下：</p>
<ul>
<li><code>NONE</code>，不记录日志（DEFAULT）</li>
<li><code>BASIC</code>，仅仅记录请求方法，URL，响应状态码，以及执行时间</li>
<li><code>HEADERS</code>，记录基本信息，以及请求头和响应头</li>
<li><code>FULL</code>，记录来自请求或响应的头部</li>
</ul>
<h3 id="1-13-Feign-QueryMap-support"><a href="#1-13-Feign-QueryMap-support" class="headerlink" title="1.13. Feign @QueryMap support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#feign-querymap-support">1.13. Feign @QueryMap support</a></h3>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean @Autowired 与 JSR-250 @Resource</title>
    <url>/2022/07/19/Spring-Framework/Spring-Core-@Resource-%E4%B8%8E-@Autowired/</url>
    <content><![CDATA[<h1 id="Spring-Bean-Autowired-与-JSR-250-Resource"><a href="#Spring-Bean-Autowired-与-JSR-250-Resource" class="headerlink" title="Spring Bean @Autowired 与 JSR-250 @Resource"></a>Spring Bean @Autowired 与 JSR-250 @Resource</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>由 Spring 提供的注解，依赖注入的过程由 <code>AutowiredAnnotationBeanPostProcessor</code> 执行。</p>
<p>通常这一步骤发生在 <code>populateBean</code> 流程之中，使用特定的 <code>InstantiationAwareBeanPostProcessor</code> 进行属性注入</p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p>由 JSR-250 中提供的注解，依赖注入的过程由 <code>CommonAnnotationBeanPostProcessor</code> 执行。</p>
<p>通常这一步骤发生在 <code>populateBean</code> 流程之中，使用特定的 <code>InstantiationAwareBeanPostProcessor</code> 进行属性注入</p>
<ol>
<li>如果 <code>@Resource</code> 指定了 <code>name</code>，则按照 <code>name</code> 查找 Bean，找到则注入；找不到抛出异常</li>
<li>如果 <code>@Resource</code> 没有指定 <code>name</code>，通过 Java 反射得到 <code>Field</code> 属性 <code>name</code>，找不到则按照类型匹配</li>
</ol>
<blockquote>
<p>由于显式指定了 <code>@Resource</code> 的 <code>name</code>，因此在找不到的情况下必须抛出异常，这可能是人为的疏漏；如果没有指定 <code>name</code>，那么容器会智能地按照属性名、类型地顺序依次寻找。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">autowireResource</span><span class="params">(BeanFactory factory, LookupElement element, <span class="meta">@Nullable</span> String requestingBeanName)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchBeanDefinitionException &#123;</span><br><span class="line"></span><br><span class="line">    Object resource;</span><br><span class="line">    Set&lt;String&gt; autowiredBeanNames;</span><br><span class="line">    <span class="comment">// 此处的 element.name 以及在构造器中赋值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> element.name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">        <span class="type">AutowireCapableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (AutowireCapableBeanFactory) factory;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> element.getDependencyDescriptor();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.fallbackToDefaultTypeMatch &amp;&amp; element.isDefaultName &amp;&amp; !factory.containsBean(name)) &#123;</span><br><span class="line">            autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">            resource = beanFactory.resolveDependency(descriptor, requestingBeanName, autowiredBeanNames, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (resource == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(element.getLookupType(), <span class="string">&quot;No resolvable resource object&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resource = beanFactory.resolveBeanByName(name, descriptor);</span><br><span class="line">            autowiredBeanNames = Collections.singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        resource = factory.getBean(name, element.lookupType);</span><br><span class="line">        autowiredBeanNames = Collections.singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">        <span class="type">ConfigurableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (ConfigurableBeanFactory) factory;</span><br><span class="line">        <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestingBeanName != <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(autowiredBeanName)) &#123;</span><br><span class="line">                beanFactory.registerDependentBean(autowiredBeanName, requestingBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Spring Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework Data Access</title>
    <url>/2022/08/26/Spring-Framework/Spring-Framework-Data-Access/</url>
    <content><![CDATA[<h1 id="Data-Access"><a href="#Data-Access" class="headerlink" title="Data Access"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#spring-data-tier">Data Access</a></h1><hr>
<h2 id="1-Transaction-Management"><a href="#1-Transaction-Management" class="headerlink" title="1. Transaction Management"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction">1. Transaction Management</a></h2><h3 id="1-1-Advantages-of-the-Spring-Framework’s-Transaction-Support-Model"><a href="#1-1-Advantages-of-the-Spring-Framework’s-Transaction-Support-Model" class="headerlink" title="1.1. Advantages of the Spring Framework’s Transaction Support Model"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction-motivation">1.1. Advantages of the Spring Framework’s Transaction Support Model</a></h3><h3 id="1-1-1-Global-Transactions"><a href="#1-1-1-Global-Transactions" class="headerlink" title="1.1.1. Global Transactions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction-global">1.1.1. Global Transactions</a></h3><h2 id="1-2-Understanding-the-Spring-Framework-Transaction-Abstraction"><a href="#1-2-Understanding-the-Spring-Framework-Transaction-Abstraction" class="headerlink" title="1.2. Understanding the Spring Framework Transaction Abstraction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction-strategies">1.2. Understanding the Spring Framework Transaction Abstraction</a></h2><p>Spring 事务抽象的关键在于事务策略概念。事务策略被定义在 <code>TransactionManager</code>，特别是，PlatformTransactionManager 用于命令式事务管理和 ReactiveTransactionManager 用于响应式事务管理。</p>
<p>PlatformTransactionManager 类似 Spring Framework IoC 容器的其他 bean。这种好处是，让 Spring Framework 事务称为一个抽象，即使你使用 JTA。你可以比直接使用 JTA 更轻松地测试事务代码。</p>
<p>同样，在 Spring 中，可以被任何 PlatformTransactionManager 接口额方法抛出的 TransactionException 是未检查的（也就是继承于 RuntimeException）。事务基础架构的错误总是致命的。在罕见的情况下，应用程序的代码可以从事务发生的故障中恢复，开发人员仍然可以选择 catch 和处理 TransactionException。</p>
<p><code>TransactionDefinition</code> 接口指定如下内容：</p>
<ul>
<li>Propagation：通常，在一个事务范围中的所有代码运行在那个事务中。但是，如果当一个事务上下文已经存在时，运行了一个事务方法，则可以指定这种行为。例如，代码可以继续运行在现有事务中（通常的情况），或者暂停已存在的事务，创建一个新的事务。</li>
<li>Isolation：隔离级别。该事务从其他事务的工作中隔离的程度。</li>
<li>Timeout：超时。在超时之前该事务可以运行的时间，并且会自动由事务底层机制回滚。</li>
<li>Read-only status：你可以在代码读取但不修改数据时使用只读状态。在某些情况下，只读事务时有用的优化，如 Hibernate。</li>
</ul>
<p>这些设置反映了标准的事务概念。</p>
<h3 id="1-4-Declarative-Transaction-Management"><a href="#1-4-Declarative-Transaction-Management" class="headerlink" title="1.4. Declarative Transaction Management"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction-declarative">1.4. Declarative Transaction Management</a></h3><blockquote>
<p>大多数 Spring 框架用户选择声明式事务管理。此选项对应用程序代码影响最小，是最符合非侵入式轻量容器的理想方式。</p>
</blockquote>
<p>基于 Spring 面向切面编程（AOP），Spring 框架的声明式事务管理是可能的。但是，由于事务切面代码随着 Spring Framework 发布而来，并且可以在样板中使用，AOP 的概念没有必要理解为充分利用这段代码。</p>
<p>Spring Framework 的声明式事务管理类似于 EJB CMT，因此你可以指定事务行为到单个方法级别。如有必要，你可以在事务上下文中调用 setRollBackOnly()。</p>
<h4 id="1-4-1-Understanding-the-Spring-Framework’s-Declarative-Transaction-Implementation"><a href="#1-4-1-Understanding-the-Spring-Framework’s-Declarative-Transaction-Implementation" class="headerlink" title="1.4.1. Understanding the Spring Framework’s Declarative Transaction Implementation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#tx-decl-explained">1.4.1. Understanding the Spring Framework’s Declarative Transaction Implementation</a></h4><p>仅仅使用 <code>@Transactional</code> 注解是没有用的，还需要添加 <code>@EnableTransactionManagement</code> 到配置类中。</p>
<p>掌握 Spring Framework 声明式事务支持最重要的概念是通过 AOP 代理开启的支持和由元数据（XML 或者 注解）驱动的 transactional advice。AOP 和事务元数据的组合产生了 AOP 代理，其使用 TransactionInterceptor 与适当的 TransactionManager 实现来驱动围绕方法调用事务。</p>
<p>Spring 框架的 <code>TransactionInterceptor</code> 为命令式和响应式编程模型提供事务管理。拦截器通过检查方法返回类型来检测所需的事务管理。</p>
<h4 id="1-4-6-Using-Transactional"><a href="#1-4-6-Using-Transactional" class="headerlink" title="1.4.6. Using @Transactional"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction-declarative-annotations">1.4.6. Using @Transactional</a></h4><p>除了基于注解的声明式方式进行事务配置之外，你还可以使用基于注解的方式。直接在 Java 代码中声明事务语义上更贴近受影响的代码。</p>
<p>使用在类级别上，表示注解默认作用域声明类的所有方法（包括子类）。或者，每个方法可以被单独注解。注意，类级别的注解不会使用祖先类到类的层次结构；在这样的场景中，需要在本地重新声明，一边参与子类级注解。</p>
<p>在 xml 配种，标签 <code>&lt;tx:annotation-driven/&gt;</code>提供相似的简便方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>如果你想绑定的 <code>TransactionManager</code> 名称就是 <code>transactionManager</code>，你可以省略配置 <code>&lt;tx:annotation-driven/&gt;</code> 标签中的 <code>transaction-manager</code> 属性；否则你不得不指定 <code>transaction-manager</code> 属性。</li>
</ul>
</blockquote>
<h5 id="Transactional-Settings"><a href="#Transactional-Settings" class="headerlink" title="@Transactional Settings"></a>@Transactional Settings</h5><p><code>@Transactional</code> 注解是指定接口，类或者方法必须具有事务语义。默认的 <code>@Transactional</code> 设置如下：</p>
<ul>
<li>传播类型 <code>PROPAGATION_REQUIRED</code></li>
<li>隔离级别 <code>ISOLATION_DEFAULT</code></li>
<li>事务是读写型</li>
<li>事务超时默认为底层事务系统的默认超时时间，如果不支持超时，则没有</li>
<li>任何 <code>RuntimeException</code> 触发回滚，任何检查型 <code>Exception</code> 并不会。</li>
</ul>
<p>&amp;nbsp;</p>
<h5 id="Custom-Composed-Annotations"><a href="#Custom-Composed-Annotations" class="headerlink" title="Custom Composed Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#tx-custom-attributes">Custom Composed Annotations</a></h5><h4 id="1-4-7-Transaction-Propagation"><a href="#1-4-7-Transaction-Propagation" class="headerlink" title="1.4.7. Transaction Propagation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#tx-propagation">1.4.7. Transaction Propagation</a></h4><p>本节描述 Spring 中事务传播的一些语义。请注意，本节不是对事务传播本身的介绍。相反，它详细描述了 Spring 中关于事务传播的一些语义。</p>
<p>在 Spring 管理的事务中，要注意物理事务和逻辑事务之间的区别，以及传播设置如何应用的区别。</p>
<h5 id="Understanding-PROPAGATION-REQUIRED"><a href="#Understanding-PROPAGATION-REQUIRED" class="headerlink" title="Understanding PROPAGATION_REQUIRED"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#tx-propagation-required">Understanding <code>PROPAGATION_REQUIRED</code></a></h5><img src="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/images/tx_prop_required.png">

<p><code>PROPAGATION_REQUIRED</code> 强制执行一个物理事务，如果不存在事务，则本地为当前范围开启事务，或者参与定义为更大范围的已经存在的外部事务。在同一个线程内的公用调用栈安排中，这是一个很好的默认值（例如，一个委托给几个仓库方法的服务门面，其中所有的底层资源都必须参与服务级别事务）</p>
<p>当传播设置为 <code>PROPAGATION_REQUIRED</code> 时，会为每个设置应用的方法创建一个逻辑事务范围。每个此类逻辑事务范围可以单独决定仅回滚状态，外部事务范围逻辑上独立于内部事务范围。在标准的 <code>PROPAGATION_REQUIRED</code> 行为下，所有这些范围都映射相同的物理事务。内部事务范围的仅回滚标记确实会影响到外部事务实际提交的机会。</p>
<h5 id="Understanding-PROPAGATION-REQUIRES-NEW"><a href="#Understanding-PROPAGATION-REQUIRES-NEW" class="headerlink" title="Understanding PROPAGATION_REQUIRES_NEW"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#tx-propagation-requires_new">Understanding <code>PROPAGATION_REQUIRES_NEW</code></a></h5><p>相较于 <code>PROPAGATION_REQUIRED</code>，<code>PROPAGATION_REQUIRES_NEW</code> 总是为每个受影响的事务范围使用独立的物理事务，从不参与到外部范围的现有事务中去。在这种安排下，底层资源事务是不同的，因此，可以独立提交、回滚，外部事务不受内部事务回滚状态影响，并且内部事务的锁在完成后立即释放。这种独立的内部事务也可以声明自己的隔离级别，超时，以及是否只读，而不继承外部事物的特征。</p>
<h5 id="Understanding-PROPAGATION-NESTED"><a href="#Understanding-PROPAGATION-NESTED" class="headerlink" title="Understanding PROPAGATION_NESTED"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#tx-propagation-nested">Understanding <code>PROPAGATION_NESTED</code></a></h5><p><code>PROPAGATION_NESTED</code> 使用一个具有多个可以回滚保存点的物理事务。这种部分回滚让内部事务范围触发其范围内的回滚，并且即使某些操作已经回滚，外部事务仍能够继续物理事务。这个设置通常映射到 JDBC 保存点，因此它只适用于 JDBC 资源事务。参见 Spring 的 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html"><code>DataSourceTransactionManager</code></a></p>
<h4 id="1-5-3-Using-the-TransactionManager"><a href="#1-5-3-Using-the-TransactionManager" class="headerlink" title="1.5.3. Using the TransactionManager"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction-programmatic-tm">1.5.3. Using the TransactionManager</a></h4><h5 id="Using-the-PlatformTransactionManager"><a href="#Using-the-PlatformTransactionManager" class="headerlink" title="Using the PlatformTransactionManager"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction-programmatic-ptm">Using the PlatformTransactionManager</a></h5><p>对于强制性的事务，你可以直接使用 <code>org.springframework.transaction.PlatformTransactionManager</code> 来管理事务。为此，将你要使用的 <code>PlatformTransactionManager</code> 的实现类传递给你的 bean。然后，通过使用 <code>TransactionDefinition</code> 和 <code>TransactionStatus</code> 对象，你可以启动，回滚以及提交事务。</p>
<h5 id="Using-the-ReactiveTransactionManager"><a href="#Using-the-ReactiveTransactionManager" class="headerlink" title="Using the ReactiveTransactionManager"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction-programmatic-rtm">Using the ReactiveTransactionManager</a></h5><p>当使用响应式事务时，你可以直接使用 <code>org.springframework.transaction.ReactiveTransactionManager</code> 管理你的事务。</p>
<h3 id="1-6-Choosing-Between-Programmatic-and-Declarative-Transaction-Management"><a href="#1-6-Choosing-Between-Programmatic-and-Declarative-Transaction-Management" class="headerlink" title="1.6. Choosing Between Programmatic and Declarative Transaction Management"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#tx-decl-vs-prog">1.6. Choosing Between Programmatic and Declarative Transaction Management</a></h3><p>当你具有少量的事务操作时，编程式事务管理通常是个不错的主意。</p>
<p>&amp;nbsp;</p>
<h2 id="2-DAO-Support"><a href="#2-DAO-Support" class="headerlink" title="2. DAO Support"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#dao">2. DAO Support</a></h2><h3 id="2-1-Consistent-Exception-Hierarchy"><a href="#2-1-Consistent-Exception-Hierarchy" class="headerlink" title="2.1. Consistent Exception Hierarchy"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#dao-exceptions">2.1. Consistent Exception Hierarchy</a></h3><p>Spring 提供了特定异常到自己异常类层次结构的转换。该类层次结构将 <code>DataAccessException</code> 作为根异常。</p>
<h2 id="3-Data-Access-with-JDBC"><a href="#3-Data-Access-with-JDBC" class="headerlink" title="3. Data Access with JDBC"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#jdbc">3. Data Access with JDBC</a></h2><h3 id="3-1-Choosing-an-Approach-for-JDBC-Database-Access"><a href="#3-1-Choosing-an-Approach-for-JDBC-Database-Access" class="headerlink" title="3.1. Choosing an Approach for JDBC Database Access"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#jdbc-choose-style">3.1. Choosing an Approach for JDBC Database Access</a></h3><p>你可以选择及中方来构建 JDBC 数据库访问基础。除了三种 JdbcTemplate 之外，一个新的 SimpleJdbcInsert 和 SimpleJdbcCall 方法优化了数据库元数据，并且 RDBMS 对象风格采取了一种更面向对象的方式，类似于 JDO 查询设计。</p>
<ul>
<li><code>JdbcTemplate</code> 是经典且最流行的 Spring JDBC 方式。这种 “最低级别” 的方法和所有其他封装的方法使用 <code>JdbcTemplate</code></li>
<li><code>NamedParameterJdbcTemplate</code> 包装了一个 <code>JdbcTemplate</code> 以提供命名参数而不是传统的 JDBC ? 占位符。当你的 SQL 语句有多个参数时，这种方法提供了更好的文档性且易于使用。</li>
<li><code>SimpleJdbcInsert</code> 和 <code>SimpleJdbcCall</code> 优化了数据库元数据来限制必要配置的数量。这种方法简化了编码，你只需要提供表名称，或者存储过程名称，并且提供一个参数与列名匹配的映射。</li>
</ul>
<h3 id="3-3-Using-the-JDBC-Core-Classes-to-Control-Basic-JDBC-Processing-and-Error-Handling"><a href="#3-3-Using-the-JDBC-Core-Classes-to-Control-Basic-JDBC-Processing-and-Error-Handling" class="headerlink" title="3.3. Using the JDBC Core Classes to Control Basic JDBC Processing and Error Handling"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#jdbc-core">3.3. Using the JDBC Core Classes to Control Basic JDBC Processing and Error Handling</a></h3><h4 id="3-3-1-Using-JdbcTemplate"><a href="#3-3-1-Using-JdbcTemplate" class="headerlink" title="3.3.1. Using JdbcTemplate"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#jdbc-JdbcTemplate">3.3.1. Using JdbcTemplate</a></h4><p><code>JdbcTemplate</code> 是 JDBC <code>core</code> 包下的核心类。它处理资源的创建与释放，这可以帮助你避免一些常见的错误，比如忘记关闭连接。它执行核心 JDBC 工作流的基本任务（如语句的创建和执行），让应用程序代码来提供 SQL 和获取结果集。</p>
<p><code>JdbcTemplate</code> 可以做如下的事情：</p>
<ul>
<li>运行 SQL 查询</li>
<li>更新语句以及存储过程调用</li>
<li>执行 <code>ResultSet</code> 的迭代，以及提取返回参数值的结果</li>
<li>捕获 JDBC 异常，并将其转换为定义在 <code>org.springframework.dao</code> 包下的更通用，更具信息意义的异常层次</li>
</ul>
<p>当你使用 <code>JdbcTemplate</code> 时，你只需要实现一个回调接口，给出明确定义的约定。给定一个 <code>JdbcTemplate</code> 类提供的 <code>Connection</code>，<code>PreparedStatementCreator</code> 回调接口会创建一个 预编译的语句，提供了 SQL 以及任何必要的参数。<code>CallableStatementCreator</code> 接口也是如此，它创建可调用的语句。<code>RowCallbackHandler</code> 接口从 <code>ResultSet</code> 的每一行中提取值。</p>
<p>你可以在你的 DAO 实现中通过给予一个 <code>DataSource</code> 的引用直接实例化 <code>JdbcTempalte</code> 并使用；或者，你可以配置它到 Spring IoC 容器里，并将其作为一个 bean 引用给 DAO。</p>
<blockquote>
<p><code>DataSource</code> 应当总是配置为一个 Spring Ioc 容器中的 bean。</p>
</blockquote>
<p>此类发出的所有 SQL 都以 debug 级别的日志记录下来，</p>
<h5 id="Querying-SELECT"><a href="#Querying-SELECT" class="headerlink" title="Querying (SELECT)"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#jdbc-JdbcTemplate-examples-query">Querying (SELECT)</a></h5><h5 id="Updating-INSERT-UPDATE-and-DELETE-with-JdbcTemplate"><a href="#Updating-INSERT-UPDATE-and-DELETE-with-JdbcTemplate" class="headerlink" title="Updating (INSERT, UPDATE, and DELETE) with JdbcTemplate"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#jdbc-JdbcTemplate-examples-update">Updating (INSERT, UPDATE, and DELETE) with JdbcTemplate</a></h5><h4 id="3-3-3-Using-SQLExceptionTranslator"><a href="#3-3-3-Using-SQLExceptionTranslator" class="headerlink" title="3.3.3. Using SQLExceptionTranslator"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#jdbc-SQLExceptionTranslator">3.3.3. Using SQLExceptionTranslator</a></h4><p>SQLExceptionTranslator 是一个接口，用于 SQLExceptions 和 Spring 的 DataAccessException 之间进行转换。</p>
<p>SQLErrorCodeSQLExceptionTranslator 是 SQLExceptionTranslator 默认的实现。此实现使用特定的供应商代码，比 SQLState 更精确。错误代码转换基于名为 SQLErrorCodes 的 JavaBean 类中保存的代码。此类由 SQLErrorCodesFactory 创建和填充，是基于 sql-error-codes.xml 的配置文件的内容创建的工厂。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring Framework Integration</title>
    <url>/2022/07/27/Spring-Framework/Spring-Framework-Integration/</url>
    <content><![CDATA[<h1 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#spring-integration">Integration</a></h1><hr>
<h2 id="Message-Conversion"><a href="#Message-Conversion" class="headerlink" title="Message Conversion"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#rest-message-conversion">Message Conversion</a></h2><p>WebMvcConfigurationSupport 内含默认的 Converter</p>
<p>BufferedImageHttpMessageConverter 返回图片</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(path = &quot;/image/&#123;id&#125;&quot;, produces = MediaType.IMAGE_JPEG_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> BufferedImage <span class="title function_">getImage</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Weather</span> <span class="variable">weather</span> <span class="operator">=</span> weatherMapper.getById(id);</span><br><span class="line">    <span class="keyword">return</span> ImageIO.read(weather.getPicture());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="6-Mail"><a href="#6-Mail" class="headerlink" title="6. Mail"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#mail">6. Mail</a></h2><p>Spring Boot 的使用方式：</p>
<p>(1) 配置并将 <code>JavaMailSender</code> 注入到 IOC 容器，类似一个 Mail 工厂配置，可以 getSession，也可以 createMimeMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaMailConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(name = &quot;javaMailSender&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JavaMailSenderImpl <span class="title function_">javaMailSender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JavaMailSenderImpl</span> <span class="variable">javaMailSender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaMailSenderImpl</span>(); <span class="comment">// 唯一的实现</span></span><br><span class="line">        javaMailSender.setHost(<span class="string">&quot;smtp.qq.com&quot;</span>); <span class="comment">// 设置 SMTP 主机</span></span><br><span class="line">        javaMailSender.setUsername(<span class="string">&quot;945086245@qq.com&quot;</span>);</span><br><span class="line">        javaMailSender.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        javaMailSender.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> javaMailSender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 使用 javaMailSender 发送。MimeMessageHelper 类似 Builder 设计，但是没有做链式调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MimeMessage</span> <span class="variable">mimeMessage</span> <span class="operator">=</span> javaMailSender.createMimeMessage();</span><br><span class="line"><span class="type">MimeMessageHelper</span> <span class="variable">mimeMessageHelper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mimeMessage, <span class="literal">true</span>);</span><br><span class="line">mimeMessageHelper.setFrom(<span class="string">&quot;945086245@qq.com&quot;</span>); <span class="comment">// 发送人</span></span><br><span class="line">mimeMessageHelper.setTo(email); <span class="comment">// 接收人</span></span><br><span class="line">mimeMessageHelper.setSubject(<span class="string">&quot;验证码&quot;</span>);</span><br><span class="line">mimeMessageHelper.setText(<span class="string">&quot;您的验证码是: 9836, 如非本人操作请忽视。&quot;</span>);</span><br><span class="line">javaMailSender.send(mimeMessage);</span><br></pre></td></tr></table></figure>

<h2 id="7-Task-Execution-and-Scheduling"><a href="#7-Task-Execution-and-Scheduling" class="headerlink" title="7. Task Execution and Scheduling"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#scheduling">7. Task Execution and Scheduling</a></h2><p>Spring Framework 分别使用 <code>TaskExecutor</code> 和 <code>TaskScheduler</code> 接口为异步执行和任务调度提供了抽象。Spring 还具有那些支持线程池的接口实现或在应用程序服务器环境中委托 CommonJ。最终，通用接口之间的这些实现的使用抽象出了 Java SE5，Java SE 6 以及 Java EE 环境的差异。</p>
<p>Spring 还具有支持使用 <code>Timer</code> 调度的集成类，以及 Quartz Scheduler。你可以通过使用 <code>FactoryBean</code>，可选的分别对 <code>Timer</code> 或者 <code>Trigger</code> 实例的引用设置这两个调度器。此外，用于 Quartz 调度器和 <code>Timer</code> 的便利类是可用的，它让你调用现存的目标对象的方法（类似于普通的 <code>MethodInvokingFactoryBean</code> 操作）。</p>
<h3 id="7-1-The-Spring-TaskExecutor-Abstraction"><a href="#7-1-The-Spring-TaskExecutor-Abstraction" class="headerlink" title="7.1. The Spring TaskExecutor Abstraction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#scheduling-task-executor">7.1. The Spring TaskExecutor Abstraction</a></h3><p>Executor 是 JDK 用于线程池概念的名称。之所以叫 “executor” 是因为实际上不能保证底层的实现就是池。一个 executor 可以是单线程，甚至是同步的。Spring 的抽象隐藏了 Java SE 和 Java EE 环境之间的实现细节。</p>
<p>Spring 的 <code>TaskExecutor</code> 接口与 <code>java.util.concurrent.Executor</code> 接口相同。实际上，最初其主要存在的原因就是在使用线程池的时候抽象出对 Java 5 的需求。该接口只有一个方法（<code>execute(Runnable task)</code>），该方法接受给予线程池的语义和配置的任务。</p>
<h4 id="7-1-1-TaskExecutor-Types"><a href="#7-1-1-TaskExecutor-Types" class="headerlink" title="7.1.1. TaskExecutor Types"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#scheduling-task-executor-types">7.1.1. TaskExecutor Types</a></h4><p>Spring 包含了许多预置的 <code>TaskExecutor</code> 实现。很有可能，你永远不需要实现自己的类。Spring 提供的变体如下：</p>
<ul>
<li><p><code>SyncTaskExecutor</code>: 此实现不会异步运行调用。相反，每个调用都发生在调用线程中。它主要用于不需要多线程的情况，例如在简单的测试用例中。</p>
</li>
<li><p><code>ThreadPoolTaskExecutor</code>: 此实现最常用。它暴露了用于配置 <code>java.util.concurrent.ThreadPoolExecutor</code> 的 Bean 属性，并将其包装在 <code>TaskExecutor</code> 中。如果你需要适应其他类型的 <code>java.util.concurrent.Executor</code>，我们建议你改用 <code>ConcurrentTaskExecutor</code>。</p>
</li>
</ul>
<h4 id="7-1-2-Using-a-TaskExecutor"><a href="#7-1-2-Using-a-TaskExecutor" class="headerlink" title="7.1.2. Using a TaskExecutor"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#scheduling-task-executor-usage">7.1.2. Using a TaskExecutor</a></h4><p>Spring 的 <code>TaskExecutor</code> 实现被用作简单的 Java Bean。在下面的示例中，我们定义了一个使用 <code>ThreadPoolTaskExecutor</code> 的 Bean，异步地打印一组消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.task.TaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutorExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">MessagePrinterTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MessagePrinterTask</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.message = message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TaskExecutor taskExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TaskExecutorExample</span><span class="params">(TaskExecutor taskExecutor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskExecutor = taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessages</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">            taskExecutor.execute(<span class="keyword">new</span> <span class="title class_">MessagePrinterTask</span>(<span class="string">&quot;Message&quot;</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如你所见，你没有从池中检索线程并自己执行，而是将你的 <code>Runnable</code> 添加到队列中。然后 <code>TaskExecutor</code> 使用其内部规则来决定任务何时运行。</p>
<p>为了配置 <code>TaskExecutor</code> 使用的规则，我们将公开简单的 Bean 属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;taskExecutor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueCapacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;taskExecutorExample&quot;</span> <span class="attr">class</span>=<span class="string">&quot;TaskExecutorExample&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;taskExecutor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-The-Spring-TaskScheduler-Abstraction"><a href="#7-2-The-Spring-TaskScheduler-Abstraction" class="headerlink" title="7.2. The Spring TaskScheduler Abstraction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#scheduling-task-scheduler">7.2. The Spring TaskScheduler Abstraction</a></h3><p>除了 <code>TaskExecutor</code> 抽象外，</p>
<h2 id="8-Cache-Abstraction"><a href="#8-Cache-Abstraction" class="headerlink" title="8. Cache Abstraction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache">8. Cache Abstraction</a></h2><h3 id="8-1-Understanding-the-Cache-Abstraction"><a href="#8-1-Understanding-the-Cache-Abstraction" class="headerlink" title="8.1. Understanding the Cache Abstraction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-strategies">8.1. Understanding the Cache Abstraction</a></h3><p><strong>Buffer 和 Cache</strong></p>
<p>一般地，buffer 可以翻译为缓冲区，用于高速与低速的实体之间的中间存储，缓冲区至少对知晓它的一方是可见的。</p>
<p>cache 可以翻译为缓存，根据定义是隐藏的，任何一方都不知晓。</p>
<p><strong>Spring 提供了一些缓存抽象的实现</strong>：</p>
<ul>
<li>SimpleCacheConfiguration</li>
<li>EhCacheCacheConfiguration</li>
<li>GenericCacheConfiguration</li>
<li>RedisCacheConfiguration</li>
<li>…</li>
</ul>
<p>SpringBoot <code>CacheAutoConfiguration</code> 中使用 <code>@Import</code> 导入了 <code>CacheConfigurationImportSelector.class</code>，其中导入了枚举类 <code>CacheType</code> 中所有的缓存类型。</p>
<p><strong>SimpleCacheConfiguration</strong></p>
<p>底层使用 <code>concurrentMap</code> 实现，见 <code>SimpleCacheConfiguration</code>  注入 <code>ConcurrentMapCacheManager</code>。<code>ConcurrentMapCacheManager </code> 属性 <code>dynamic</code> 可以配置 <code>cacheName</code> 是否可以动态生成，默认为 true。</p>
<h3 id="8-2-Declarative-Annotation-based-Caching"><a href="#8-2-Declarative-Annotation-based-Caching" class="headerlink" title="8.2. Declarative Annotation-based Caching"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-annotations">8.2. Declarative Annotation-based Caching</a></h3><p>Spring 缓存抽象提供了一组 Java 注解：</p>
<ul>
<li><code>@Cacheable</code>：触发缓存填充</li>
<li><code>@CacheEvict</code>：触发缓存驱逐</li>
<li><code>@CachePut</code>：在不干扰方法执行的情况下更新缓存</li>
<li><code>@Caching</code>：重新组合要应用于方法的多个缓存操作</li>
<li><code>@CacheConfig</code>：在类级别共享一些常见的缓存相关设置</li>
</ul>
<h4 id="8-2-1-The-Cacheable-Annotation"><a href="#8-2-1-The-Cacheable-Annotation" class="headerlink" title="8.2.1. The @Cacheable Annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-annotations-cacheable">8.2.1. The @Cacheable Annotation</a></h4><table>
<thead>
<tr>
<th align="left">注解属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">value &#x2F; cacheNames</td>
<td align="left">缓存的名字</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">缓存数据使用的 key，默认使用方法参数</td>
</tr>
<tr>
<td align="left">keyGenerator</td>
<td align="left">自定义 key 生成器，实现 KeyGenerator</td>
</tr>
<tr>
<td align="left">cacheManager</td>
<td align="left">指定缓存管理器</td>
</tr>
<tr>
<td align="left">condition</td>
<td align="left">指定符合条件的情况下才缓存</td>
</tr>
<tr>
<td align="left">unless</td>
<td align="left">缓存的否定条件</td>
</tr>
<tr>
<td align="left">sync</td>
<td align="left">是否使用异步模式</td>
</tr>
</tbody></table>
<h5 id="Default-Key-Generation"><a href="#Default-Key-Generation" class="headerlink" title="Default Key Generation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-annotations-cacheable-default-key">Default Key Generation</a></h5><p>key 默认采用 <code>SimpleKeyGenerator</code> 生成。以方法参数为标识。</p>
<h5 id="Synchronized-Caching"><a href="#Synchronized-Caching" class="headerlink" title="Synchronized Caching"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-annotations-cacheable-synchronized">Synchronized Caching</a></h5><p>Spring Core 框架的 <code>CacheManager</code> 实现都支持 sync。其他缓存库未必。</p>
<h5 id="Available-Caching-SpEL-Evaluation-Context"><a href="#Available-Caching-SpEL-Evaluation-Context" class="headerlink" title="Available Caching SpEL Evaluation Context"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-spel-context">Available Caching SpEL Evaluation Context</a></h5><p>Cache SpEL 可用元数据，具体见官方表。</p>
<h4 id="8-2-2-The-CachePut-Annotation"><a href="#8-2-2-The-CachePut-Annotation" class="headerlink" title="8.2.2. The @CachePut Annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-annotations-put">8.2.2. The @CachePut Annotation</a></h4><p>每次都调用方法，缓存结果。</p>
<h4 id="8-2-3-The-CacheEvict-annotation"><a href="#8-2-3-The-CacheEvict-annotation" class="headerlink" title="8.2.3. The @CacheEvict annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-annotations-evict">8.2.3. The @CacheEvict annotation</a></h4><p>清空缓存</p>
<h4 id="8-2-6-Enabling-Caching-Annotations"><a href="#8-2-6-Enabling-Caching-Annotations" class="headerlink" title="8.2.6. Enabling Caching Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-annotation-enable">8.2.6. Enabling Caching Annotations</a></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-JCache-JSR-107-Annotations"><a href="#8-3-JCache-JSR-107-Annotations" class="headerlink" title="8.3. JCache (JSR-107) Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-jsr-107">8.3. JCache (JSR-107) Annotations</a></h3><p>从 Spring 4.1 开始，Spring 缓存抽象完全支持 JCache 注解</p>
<h4 id="8-3-1-Feature-Summary"><a href="#8-3-1-Feature-Summary" class="headerlink" title="8.3.1. Feature Summary"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#cache-jsr-107-summary">8.3.1. Feature Summary</a></h4><table>
<thead>
<tr>
<th align="left">Spring</th>
<th align="left">JSR-107</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Cacheable</td>
<td align="left">@CacheResult</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">@CachePut</td>
<td align="left">@CachePut</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">@CacheEvict</td>
<td align="left">@CacheRemove</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">@CacheEvict(allEntries&#x3D;true)</td>
<td align="left">@CacheRemoveAll</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">@CacheConfig</td>
<td align="left">@CacheDefaults</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>JCache 的 CacheResolver 概念上与 Spring CacheResolver 接口相同，只是 JCache 仅支持单个 Cache。默认，Simple 实现会根据注解上的名称检索要使用的 Cache，如果注解上没有指定名称，则会自动生成一个默认值。</p>
<h4 id="8-3-2-Enabling-JSR-107-Support"><a href="#8-3-2-Enabling-JSR-107-Support" class="headerlink" title="8.3.2. Enabling JSR-107 Support"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/integration.html#enabling-jsr-107-support">8.3.2. Enabling JSR-107 Support</a></h4><p>如果类路径同时存在 JSR-107 API 和 spring-context-support，<code>@EnableCaching</code> 和 <code>cache:annotation-driven</code> 都会自启用 JCache。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring MVC DispatcherServlet 处理请求的过程</title>
    <url>/2022/07/22/Spring-Framework/Spring-MVC-DispatcherServlet-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Spring-MVC-DispatcherServlet-处理请求的过程"><a href="#Spring-MVC-DispatcherServlet-处理请求的过程" class="headerlink" title="Spring MVC DispatcherServlet 处理请求的过程"></a>Spring MVC DispatcherServlet 处理请求的过程</h1><h2 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是否为 Multipart，底层根据 Content-Type</span></span><br><span class="line">            <span class="comment">// 这里看似 check（检查），其实还有转换（包装）请求，返回 MultipartHttpServletRequest</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">// 确定当前请求的 handler</span></span><br><span class="line">            <span class="comment">// 此处本质上返回的是 handler 的包装 HandlerExecutionChain</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            <span class="comment">// 确定当前请求的 handler 适配器</span></span><br><span class="line">            <span class="comment">// 因为 handler 是个 Object，它不可能具有处理请求的方法，需要适配</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> HttpMethod.GET.matches(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前置处理，应用一些拦截器，如果返回 false，则不再处理，或者抛出异常被 catch</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 实际调用 handler</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 后置处理，应用一些拦截器</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 包括调用 HandlerInterceptor.afterCompletion</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h2><h3 id="getHandler"><a href="#getHandler" class="headerlink" title="getHandler"></a>getHandler</h3><p>找到合适的 <code>HandlerMapping</code> ，把请求映射为 <code>HandlerExecutionChain</code> 对象（其中包含一个类型为 <code>Object</code> 的 handler 对象）</p>
<p>默认情况下，Spring 提供了 5 个默认的 <code>HandlerMapping</code>，分别是：</p>
<ul>
<li><code>RequestMappingHandlerMapping</code></li>
<li><code>BeanNameUrlHandlerMapping</code></li>
<li><code>RouterFunctionMapping</code></li>
<li><code>SimpleUrlHandlerMapping</code></li>
<li><code>WelcomePageHandlerMapping</code></li>
</ul>
<p>比较常用的就是 <code>RequestMappingHandlerMapping</code>，一般用于 <code>@RequestMapping</code> 注解；<code>SimpleUrlHandlerMapping</code>，一般用于映射静态资源。</p>
<h3 id="getHandlerAdapter"><a href="#getHandlerAdapter" class="headerlink" title="getHandlerAdapter"></a>getHandlerAdapter</h3><p>找到 handler 的适配器。</p>
<p>由于 handler 没有一个统一的接口，因此需要寻找合适的适配器。</p>
<blockquote>
<p>即使 handler 设计一个统一的接口，在统一处理的时候也要写大量的 if else 根据具体的实现类进行逻辑匹配。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC ReturnValueHandler 原理</title>
    <url>/2022/07/30/Spring-Framework/Spring-MVC-ReturnValueHandlerr-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Spring-MVC-ReturnValueHandler-原理"><a href="#Spring-MVC-ReturnValueHandler-原理" class="headerlink" title="Spring MVC ReturnValueHandler 原理"></a>Spring MVC ReturnValueHandler 原理</h1><p>本文章中提及的 ReturnValueHandler 实际为 <code>HandlerMethodReturnValueHandler</code> 类型。</p>
<p>该 <code>ReturnValueHandler</code> 会在调用 handler 方法的时候发挥作用，其中通过以下代码注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注入类型为 HandlerMethodReturnValueHandlerComposite，是一个具有许多 ReturnValueHandler 的类型</span></span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br></pre></td></tr></table></figure>


<h2 id="Handler-Method-处理框架"><a href="#Handler-Method-处理框架" class="headerlink" title="Handler Method 处理框架"></a>Handler Method 处理框架</h2><p>以下是 handler 方法被调用的整体流程: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 调用 handler，获得返回值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">    setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="literal">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">            disableContentCachingIfNecessary(webRequest);</span><br><span class="line">            mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">        <span class="comment">// 与 ResponseStatus 相关</span></span><br><span class="line">        mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mavContainer.setRequestHandled(<span class="literal">false</span>);</span><br><span class="line">    Assert.state(<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>, <span class="string">&quot;No return value handlers&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理返回值</span></span><br><span class="line">        <span class="built_in">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">                returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Return-Value-处理框架"><a href="#Return-Value-处理框架" class="headerlink" title="Return Value 处理框架"></a>Return Value 处理框架</h2><p>若要处理返回值，需要找到合适的返回值处理器，然后调用其 <code>handleReturnValue</code> 方法进行处理，以下是处理返回值的整体流程代码清单:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandlerMethodReturnValueHandlerComposite</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandler</span> <span class="variable">handler</span> <span class="operator">=</span> selectHandler(returnValue, returnType);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown return value type: &quot;</span> + returnType.getParameterType().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="判断-Return-Value-是否支持"><a href="#判断-Return-Value-是否支持" class="headerlink" title="判断 Return Value 是否支持"></a>判断 Return Value 是否支持</h2><p>关于如何判断一个 <code>ReturnValueHandler</code> 是否支持这种返回值，主要是通过自定义实现的方法 <code>supportsReturnType</code> 完成，以下是挑选合适 <code>ReturnValueHandler</code> 的代码清单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> HandlerMethodReturnValueHandler <span class="title function_">selectHandler</span><span class="params">(<span class="meta">@Nullable</span> Object value, MethodParameter returnType)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isAsyncValue</span> <span class="operator">=</span> isAsyncReturnValue(value, returnType);</span><br><span class="line">    <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="built_in">this</span>.returnValueHandlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAsyncValue &amp;&amp; !(handler <span class="keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler.supportsReturnType(returnType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>是否支持该返回值，具体逻辑根据不同 <code>ReturnValueHandler</code> 有所不同，但一般来说都是通过类型判断</p>
</blockquote>
<p>应该注意到，<code>selectHandler</code> 会首先调用 <code>isAsyncReturnValue</code> 判断是否是一个异步返回值，但默认情况下，始终返回 false，因为并不存在 <code>AsyncHandlerMethodReturnValueHandler</code> 实例，<code>isAsyncReturnValue</code> 逻辑如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isAsyncReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object value, MethodParameter returnType)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (HandlerMethodReturnValueHandler handler : <span class="built_in">this</span>.returnValueHandlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> AsyncHandlerMethodReturnValueHandler &amp;&amp;</span><br><span class="line">                ((AsyncHandlerMethodReturnValueHandler) handler).isAsyncReturnValue(value, returnType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Spring-MVC-支持的返回值"><a href="#Spring-MVC-支持的返回值" class="headerlink" title="Spring MVC 支持的返回值"></a>Spring MVC 支持的返回值</h2><ul>
<li><code>ModelAndView</code> 对象</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Spring Web MVC HandlerAdapter 笔记</title>
    <url>/2022/07/23/Spring-Framework/Spring-Web-MVC-HandlerAdapter-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>Spring Boot 默认的 HandlerAdapter 有：</p>
<ul>
<li><code>RequestMappingHandlerAdapter</code>，注解 <code>@RequestMapping</code></li>
<li><code>HandlerFunctionAdapter</code>，端点</li>
<li><code>HttpRequestHandlerAdapter</code>，用于一些静态资源</li>
<li><code>SimpleControllerHandlerAdapter</code>，用于 <code>Controller</code> 接口</li>
</ul>
<blockquote>
<p><code>AnnotationMethodHandlerAdapter</code> 是之前使用的一个，现在已经废弃</p>
</blockquote>
<p>这些实现类需要关注的就是它们的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h2><p><code>RequestMappingHandlerAdapter</code> 是 <code>AbstractHandlerMethodAdapter</code> 的子类，父类也已经实现了 <code>supports()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的返回值由两个条件决定：</p>
<ul>
<li>第一个是 handler 是否是 <code>HandlerMethod</code> 的实例。如果之前的 HandlerMapping 是 <code>RequestMappingHandlerMapping</code>，那么它返回的一定是 <code>HandlerMethod</code>。</li>
<li>第二个是由子类实现的 <code>supportsInternal()</code> 方法，不过 <code>RequestMappingHandlerAdapter</code> 始终返回 <code>true</code></li>
</ul>
<h2 id="HttpRequestHandlerAdapter"><a href="#HttpRequestHandlerAdapter" class="headerlink" title="HttpRequestHandlerAdapter"></a>HttpRequestHandlerAdapter</h2><p>一般用于适配静态资源请求</p>
]]></content>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Web MVC HandlerMapping 笔记</title>
    <url>/2022/07/22/Spring-Framework/Spring-Web-MVC-HandlerMapping-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Spring-Web-MVC-HandlerMapping-笔记"><a href="#Spring-Web-MVC-HandlerMapping-笔记" class="headerlink" title="Spring Web MVC HandlerMapping 笔记"></a>Spring Web MVC HandlerMapping 笔记</h1><h1 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p><code>HandlerMapping</code> 用于将请求映射到 handler，以及前置处理拦截器和后置处理拦截器。该映射基于某些规则，其中的细节随着 <code>HandlerMapping</code> 的实现有所不同。</p>
<p>两个主要的 <code>HandlerMapping</code> 的实现类：</p>
<p>(1) <code>RequestMappingHandlerMapping </code>，它支持 <code>@RequestMapping</code> 注解的方法</p>
<p>(2) <code>SimpleUrlHandlerMapping</code>，它维护 URI 路径模式到 handler 的指定注册</p>
<blockquote>
<p>参考官方文档 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-special-bean-types">1.1.2. Special Bean Types</a></p>
</blockquote>
<h2 id="2-Spring-Boot"><a href="#2-Spring-Boot" class="headerlink" title="2. Spring Boot"></a>2. Spring Boot</h2><p>默认情况下，Spring Boot 提供 5 个默认的 <code>HandlerMapping</code>，他们分别是：</p>
<ul>
<li><code>RequestMappingHandlerMapping</code></li>
<li><code>BeanNameUrlHandlerMapping</code></li>
<li><code>RouterFunctionMapping</code></li>
<li><code>SimpleUrlHandlerMapping</code></li>
<li><code>WelcomePageHandlerMapping</code></li>
</ul>
<p>上述这几个 <code>HandlerMapping</code> 都是在 <code>WebMvcAutoConfiguration</code> 内部类 <code>EnableWebMvcConfiguration</code> 中配置的。</p>
<p>为了能够通过类名立即能知道该类实现了 <code>HandlerMapping</code> 接口，这些实现类都以 <code>HandlerMapping</code> 为结尾，以前缀标识其作用。</p>
<blockquote>
<p>通常 <code>SimpleUrlHandlerMapping</code> 会返回 <code>ResourceHttpRequestHandler</code>；<code>RequestMappingHandlerMapping</code> 返回 <code>HandlerMethod</code></p>
</blockquote>
<p><strong>如何找到当前请求使用哪个 <code>HandlerMapping</code> 处理？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (HandlerMapping mapping : <span class="built_in">this</span>.handlerMappings) &#123;</span><br><span class="line">			<span class="type">HandlerExecutionChain</span> <span class="variable">handler</span> <span class="operator">=</span> mapping.getHandler(request);</span><br><span class="line">            <span class="comment">// 通过返回值是否为 null 确定</span></span><br><span class="line">			<span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> handler;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractHandlerMapping"><a href="#AbstractHandlerMapping" class="headerlink" title="AbstractHandlerMapping"></a>AbstractHandlerMapping</h3><p><code>AbstractHandlerMapping</code> 是所有 <code>HandlerMapping</code> 的父类，以下是所有请求获取 handler 的统一入口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// getHandlerInternal 是抽象方法，留给子类实现</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getHandlerInternal(request);</span><br><span class="line">	<span class="comment">// 如果子类无法找到 handler 则使用默认 handler</span></span><br><span class="line">	<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">		handler = getDefaultHandler();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果没有默认 handler，则返回 null</span></span><br><span class="line">	<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">	<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">		handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">HandlerExecutionChain</span> <span class="variable">executionChain</span> <span class="operator">=</span> getHandlerExecutionChain(handler, request);</span><br><span class="line">	<span class="keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;</span><br><span class="line">		<span class="type">CorsConfiguration</span> <span class="variable">globalConfig</span> <span class="operator">=</span> <span class="built_in">this</span>.globalCorsConfigSource.getCorsConfiguration(request);</span><br><span class="line">		<span class="type">CorsConfiguration</span> <span class="variable">handlerConfig</span> <span class="operator">=</span> getCorsConfiguration(handler, request);</span><br><span class="line">		<span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> (globalConfig != <span class="literal">null</span> ? globalConfig.combine(handlerConfig) : handlerConfig);</span><br><span class="line">		executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getHandlerInternal</code> 是抽象方法，由子类实现，因此官方才会有这样一句话：</p>
<blockquote>
<p>The mapping is based on some criteria, the details of which vary by <code>HandlerMapping</code> implementation.</p>
</blockquote>
<h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p><code>RequestMappingHandlerMapping</code> 是 <code>RequestMappingInfoHandlerMapping</code> 的子类。<code>RequestMappingInfoHandlerMapping</code> 实现了 <code>getHandlerInternal</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	request.removeAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">super</span>.getHandlerInternal(request);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		ProducesRequestCondition.clearMediaTypesAttribute(request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RequestMappingInfoHandlerMapping</code> 并没有做什么具体的操作，他只是调用父类 <code>AbstractHandlerMethodMapping</code> 的 <code>getHandlerInternal</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">	request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line">	<span class="built_in">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> lookupHandlerMethod(lookupPath, request);</span><br><span class="line">		<span class="keyword">return</span> (handlerMethod != <span class="literal">null</span> ? handlerMethod.createWithResolvedBean() : <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码比较重要的是 <code>lookupHandlerMethod</code> 方法调用，它负责寻找 handler 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerMethod <span class="title function_">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	List&lt;Match&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="comment">// 先通过 url 找到匹配项</span></span><br><span class="line">	List&lt;T&gt; directPathMatches = <span class="built_in">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">	<span class="comment">// 接着添加匹配的映射（根据具体条件，如 HTTP Method 等）</span></span><br><span class="line">	<span class="keyword">if</span> (directPathMatches != <span class="literal">null</span>) &#123;</span><br><span class="line">		addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">		<span class="comment">// No choice but to go through all mappings...</span></span><br><span class="line">		addMatchingMappings(<span class="built_in">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">		<span class="type">Match</span> <span class="variable">bestMatch</span> <span class="operator">=</span> matches.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果匹配项不止 1 个</span></span><br><span class="line">		<span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;	</span><br><span class="line">			Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> <span class="title class_">MatchComparator</span>(getMappingComparator(request));</span><br><span class="line">			<span class="comment">// 排序，取出第 0 个</span></span><br><span class="line">			matches.sort(comparator);</span><br><span class="line">			bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(matches.size() + <span class="string">&quot; matching mappings: &quot;</span> + matches);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">				<span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">Match</span> <span class="variable">secondBestMatch</span> <span class="operator">=</span> matches.get(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bestMatch.handlerMethod.getMethod();</span><br><span class="line">				<span class="type">Method</span> <span class="variable">m2</span> <span class="operator">=</span> secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">				<span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">				<span class="comment">// 无法决定最佳匹配，抛异常！！！</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">						<span class="string">&quot;Ambiguous handler methods mapped for &#x27;&quot;</span> + uri + <span class="string">&quot;&#x27;: &#123;&quot;</span> + m1 + <span class="string">&quot;, &quot;</span> + m2 + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置一些属性等</span></span><br><span class="line">		request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);</span><br><span class="line">		handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line">		<span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> handleNoMatch(<span class="built_in">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码具体做的就是找到一个最佳匹配 handlerMethod 并返回，如果有两个并列的最佳匹配 handlerMethod，则抛出异常，Spring 无法决定选择哪个，因此，建议不要定义具有歧义的 handler。</p>
<h3 id="RouterFunctionMapping"><a href="#RouterFunctionMapping" class="headerlink" title="RouterFunctionMapping"></a>RouterFunctionMapping</h3><p>用于功能性端点的映射，可以阅读<a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn">官网</a></p>
<h3 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h3><p>尽管类名称叫 <code>SimpleUrlHandlerMapping</code>，但是其 beanName 为 <code>resourceHandlerMapping</code></p>
<p><code>SimpleUrlHandlerMapping</code> 是 <code>AbstractUrlHandlerMapping</code> 的子类，所有请求直接经过其父类 <code>getHandlerInternal</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 获得需要寻找的路径</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">	request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line">	<span class="comment">// 寻找 handler</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> lookupHandler(lookupPath, request);</span><br><span class="line">	<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// We need to care for the default handler directly, since we need to</span></span><br><span class="line">		<span class="comment">// expose the PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE for it as well.</span></span><br><span class="line">		<span class="type">Object</span> <span class="variable">rawHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(lookupPath)) &#123;</span><br><span class="line">			rawHandler = getRootHandler();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (rawHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">			rawHandler = getDefaultHandler();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (rawHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">			<span class="keyword">if</span> (rawHandler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) rawHandler;</span><br><span class="line">				rawHandler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">			&#125;</span><br><span class="line">			validateHandler(rawHandler, request);</span><br><span class="line">			handler = buildPathExposingHandler(rawHandler, lookupPath, lookupPath, <span class="literal">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">lookupHandler</span><span class="params">(String urlPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="comment">// 通过 map 直接匹配，可以自行通过 WebMvcConfigurer 注册更多项</span></span><br><span class="line">	<span class="comment">// 一般匹配不到，因为我们几乎都是通过 ** 等通配符配置</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerMap.get(urlPath);  <span class="comment">// 1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">		<span class="comment">// 如果匹配到...</span></span><br><span class="line">		<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">			handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">		&#125;</span><br><span class="line">		validateHandler(handler, request);</span><br><span class="line">		<span class="keyword">return</span> buildPathExposingHandler(handler, urlPath, urlPath, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pattern match?</span></span><br><span class="line">	<span class="comment">// 没有直接匹配到，进行模式匹配</span></span><br><span class="line">	List&lt;String&gt; matchingPatterns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String registeredPattern : <span class="built_in">this</span>.handlerMap.keySet()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (getPathMatcher().match(registeredPattern, urlPath)) &#123;</span><br><span class="line">			matchingPatterns.add(registeredPattern);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (useTrailingSlashMatch()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!registeredPattern.endsWith(<span class="string">&quot;/&quot;</span>) &amp;&amp; getPathMatcher().match(registeredPattern + <span class="string">&quot;/&quot;</span>, urlPath)) &#123;</span><br><span class="line">				matchingPatterns.add(registeredPattern + <span class="string">&quot;/&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">bestMatch</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	Comparator&lt;String&gt; patternComparator = getPathMatcher().getPatternComparator(urlPath);</span><br><span class="line">	<span class="keyword">if</span> (!matchingPatterns.isEmpty()) &#123;</span><br><span class="line">		<span class="comment">// 排序</span></span><br><span class="line">		matchingPatterns.sort(patternComparator);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled() &amp;&amp; matchingPatterns.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Matching patterns &quot;</span> + matchingPatterns);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 认为第一个是最好的匹配</span></span><br><span class="line">		bestMatch = matchingPatterns.get(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bestMatch != <span class="literal">null</span>) &#123;</span><br><span class="line">		handler = <span class="built_in">this</span>.handlerMap.get(bestMatch);</span><br><span class="line">		<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 匹配不到。这里是为了处理上面 useTrailingSlashMatch 的问题</span></span><br><span class="line">			<span class="comment">// 去除末尾斜杠</span></span><br><span class="line">			<span class="keyword">if</span> (bestMatch.endsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">				handler = <span class="built_in">this</span>.handlerMap.get(bestMatch.substring(<span class="number">0</span>, bestMatch.length() - <span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Could not find handler for best pattern match [&quot;</span> + bestMatch + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Bean name or resolved handler?</span></span><br><span class="line">		<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">			handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">		&#125;</span><br><span class="line">		validateHandler(handler, request);</span><br><span class="line">		<span class="type">String</span> <span class="variable">pathWithinMapping</span> <span class="operator">=</span> getPathMatcher().extractPathWithinPattern(bestMatch, urlPath);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// There might be multiple &#x27;best patterns&#x27;, let&#x27;s make sure we have the correct URI template variables</span></span><br><span class="line">		<span class="comment">// for all of them</span></span><br><span class="line">		<span class="comment">// 可能有多个最佳匹配，我们需要确定对于每个都有正确的 uri 模板变量</span></span><br><span class="line">		Map&lt;String, String&gt; uriTemplateVariables = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String matchingPattern : matchingPatterns) &#123;</span><br><span class="line">			<span class="comment">// 这里可能出现并列最佳匹配</span></span><br><span class="line">			<span class="keyword">if</span> (patternComparator.compare(bestMatch, matchingPattern) == <span class="number">0</span>) &#123;</span><br><span class="line">				Map&lt;String, String&gt; vars = getPathMatcher().extractUriTemplateVariables(matchingPattern, urlPath);</span><br><span class="line">				Map&lt;String, String&gt; decodedVars = getUrlPathHelper().decodePathVariables(request, vars);</span><br><span class="line">				uriTemplateVariables.putAll(decodedVars);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled() &amp;&amp; uriTemplateVariables.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;URI variables &quot;</span> + uriTemplateVariables);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> buildPathExposingHandler(handler, bestMatch, pathWithinMapping, uriTemplateVariables);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No handler found...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>useTrailingSlashMatch</strong></p>
<p>在以上代码的模式匹配部分，使用了 <code>useTrailingSlashMatch()</code> 方法判断是否使用尾部斜杠匹配。如果启用了，那么例如 <code>/users</code> 这样的 URL 模式匹配也可以匹配到 <code>/users</code>。默认是 <strong>false</strong>。</p>
<p>如果需要启用该选项，目前我能想到的方法是：在某一个 <code>@Configuration</code> 配置类中绑定字段类型 <code>HandlerMapping</code>，使用构造器后置处理修改其属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(WebMvcAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerMappingConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;resourceHandlerMapping&quot;)</span></span><br><span class="line">    HandlerMapping handlerMapping;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSimpleUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">        ((SimpleUrlHandlerMapping) handlerMapping).setUseTrailingSlashMatch(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>SimpleUrlHandlerMapping</code> 是在 <code>WebMvcAutoConfiguration</code> 注入到容器中的，因此需要使用 <code>@AutoConfigureAfter</code> 确保自动配置的顺序，防止找到 bean。</p>
<p>由于 <code>SimpleUrlHandlerMapping</code> 是以 <code>HandlerMapping</code> 类型注入到容器中的，因此无法使用基于类型绑定的 <code>@Autowired</code>，只能使用 <code>@Resource</code> 根据 bean name 进行绑定。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring Web MVC ViewResolver 笔记</title>
    <url>/2022/07/23/Spring-Framework/Spring-Web-MVC-ViewResolver-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Spring-Web-MVC-ViewResolver-笔记"><a href="#Spring-Web-MVC-ViewResolver-笔记" class="headerlink" title="Spring Web MVC ViewResolver 笔记"></a>Spring Web MVC ViewResolver 笔记</h1><p>默认情况下，Spring Boot 会注入以下几个 <code>ViewResolver</code>：</p>
<ul>
<li><code>ContentNegotiatingViewResolver</code></li>
<li><code>BeanNameViewResolver</code></li>
<li><code>ViewResolverComposite</code></li>
<li><code>InternalResourceViewResolver</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Spring 循环依赖</title>
    <url>/2022/07/10/Spring-Framework/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="Spring-循环依赖"><a href="#Spring-循环依赖" class="headerlink" title="Spring 循环依赖"></a>Spring 循环依赖</h1><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>singletonObjects<br>earlySingletonObjects<br>singletonFactories</p>
<p>对于 earlySingletonObjects 的使用场景存在于多循环依赖，比如 beanA 依赖于 beanB 和 beanC，beanB 和 beanC 分别依赖 beanA。在 beanB 进行属性注入 beanA 的时候，beanA 已经从 singletonFactories 构造出一个 earlySingletonObject 了，因此在 beanC 注入 beanA 的时候不必重复构造 beanA，只需从 earlySingletonObjects 中取得即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A-&gt;B-&gt;A</span><br><span class="line">A-&gt;C-&gt;A</span><br></pre></td></tr></table></figure>

<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设 beanA 依赖 beanB，beanB 依赖 beanA，以这种最朴素的场景为例</p>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>假设程序以 beanA 开始解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractApplicationContext.refresh()</span><br><span class="line">-&gt; AbstractApplicationContext.finishBeanFactoryInitialization(beanFactory)</span><br><span class="line">-&gt; DefaultLisableBeanFactory.preInstantiateSingletons()</span><br><span class="line">-&gt; AbstractBeanFactory.getBean(beanA)</span><br><span class="line">-&gt; AbstractBeanFactory.doGetBean(beanA)</span><br></pre></td></tr></table></figure>


<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ol>
<li>检查 singletonObjects 是否存在 beanA。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意第二个参数为 true</span></span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">// 此时 beanA 还没有开始创建，这里一定返回 null</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 由于 beanA 还没有开始创建，因此也不会存在于 singletonsCurrentlyInCreation</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开始创建 beanA</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是一个类似于 java.util.function.Supplier 的函数式接口</span></span><br><span class="line"><span class="comment">// 用于创建 beanA</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        destroySingleton(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationNotAllowedException</span>(beanName,</span><br><span class="line">                        <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该方法会将 beanA 添加到 singletonsCurrentlyInCreation</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 此处调用函数式接口进行 beanA 的创建</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="built_in">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>创建 beanA</li>
</ol>
<p>通过 getSingleton 传递的函数式接口调用链如下 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory.createBean()</span><br><span class="line">-&gt; AbstractAutowireCapableBeanFactory.doCreateBean(beanName, mbdToUse, args)</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>添加到 singletonFactories</li>
</ol>
<p><code>doCreateBean</code> 方法首先会进行 beanA 的实例化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br></pre></td></tr></table></figure>

<p>然后紧跟着将实例化的 beanA 以函数式接口 Supplier 的形式（实际上是 ObjectFactory）添加到 singletonFactories：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的参数 bean 是刚刚实例化完毕的 beanA</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure>


<ol start="5">
<li>开始填充 beanA 的属性</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure>


<p>在填充过程中会调用一些 <code>InstantiationAwareBeanPostProcessor</code> 进行 <code>postProcessProperties</code> 操作，</p>
<p>如果你使用的是 <code>@Autowired</code> 进行属性绑定，那么 <code>AutowiredAnnotationBeanPostProcessor</code> 会处理关于 beanB 的属性绑定问题。</p>
<ol start="6">
<li>解析依赖 beanB</li>
</ol>
<p><code>AutowiredAnnotationBeanPostProcessor</code> 的注入调用链如下，最终又会回到 beanFactory 的 getBean 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultListableBeanFactory.doResolveDependency()</span><br><span class="line">-&gt; DependencyDescriptor.resolveCandidate(<span class="string">&quot;beanB&quot;</span>, BeanB.class, beanFactory)</span><br><span class="line">-&gt; beanFactory.getBean(<span class="string">&quot;beanB&quot;</span>)</span><br></pre></td></tr></table></figure>


<ol start="7">
<li>与步骤 1 相同</li>
</ol>
<p>beanB 此时还没有创建，因此不会存在于 <code>singletonObjects</code> ，而且也不会存在于 <code>singletonsCurrentlyInCreation</code></p>
<ol start="8">
<li><p>将 beanB 添加到 <code>singletonsCurrentlyInCreation</code></p>
</li>
<li><p>实例化 beanB，将对象工程添加到 <code>singletonFactories</code></p>
</li>
<li><p>填充 beanB 属性，相关的 <code>InstantiationAwareBeanPostProcessor</code> 发挥作用。此时，发现 beanB 依赖 beanA，继续调用 beanFactory.getBean(“beanA”)</p>
</li>
<li><p>与步骤 1 类似</p>
</li>
</ol>
<p>由于 beanA 在创建前已经将自己放到 <code>singletonsCurrentlyInCreation</code> 中，而且将自己的对象工厂放到 <code>singletonFactories</code> 中了，因此会调用 <code>singletonFactories</code> 中的对象工厂方法获得一个 beanA，并且 beanA 的对象工厂会从 <code>singletonFactories</code> 移除，同时添加到 <code>earlySingletonObjects</code></p>
<blockquote>
<p>此时这个 beanA 属性还没有填充</p>
</blockquote>
<p>这时候 getBean(“beanA”) 返回得到一个还未填充属性的 beanA</p>
<ol start="12">
<li><p>回到 beanB 填充属性，将得到的 beanA 填充进自己的属性。接着，beanB 完成了自己的属性填充就可以将对象添加到 <code>singletonObjects</code> 中，并且移除 <code>singletonFactories</code> 和 <code>earlySingletonObjects</code> 相关的对象</p>
</li>
<li><p>回到 beanA 填充属性，将得到的 beanB 填充进自己的属性。接着，beanA 完成了自己的属性填充就可以将对象添加到 <code>singletonObjects</code> 中，并且移除 <code>singletonFactories</code> 和 <code>earlySingletonObjects</code> 相关的对象</p>
</li>
</ol>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 请求参数处理实践</title>
    <url>/2022/08/17/Spring-Framework/Spring-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>场景描述：请求 Content Type 为 <code>application/x-www-form-urlencoded</code>，即参数以键值对形式传递，其中有简单类型，如：数字，字符串，也有 JSON 类型，需要绑定到 Spring 的模型中，完成校验。</p>
<p>参数格式参考如下，为了便于显示，进行了换行: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lesson_date=2022-08-08</span><br><span class="line">&amp;lesson_period_id=1</span><br><span class="line">&amp;subject_id=1</span><br><span class="line">&amp;grade_id=1</span><br><span class="line">&amp;class_id=1</span><br><span class="line">&amp;teacher_id=1</span><br><span class="line">&amp;student_list=[&#123;<span class="string">&quot;x&quot;</span>:0,<span class="string">&quot;y&quot;</span>:0,<span class="string">&quot;speak_num&quot;</span>:0,<span class="string">&quot;distract_num&quot;</span>:0,<span class="string">&quot;is_special&quot;</span>:0&#125;]</span><br></pre></td></tr></table></figure>


<p>如何支持下划线传参映射到 Model 模型? 装饰器模式 Request</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiParamCaseRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String[]&gt; additionalParams;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MultiParamCaseRequest</span><span class="params">(HttpServletRequest request, Map&lt;String, String[]&gt; additionalParams)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(request);</span><br><span class="line">        <span class="built_in">this</span>.additionalParams = additionalParams;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Enumeration&lt;String&gt; <span class="title function_">getParameterNames</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> HashSet&lt;String&gt; parameterNames = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        parameterNames.addAll(getRequest().getParameterMap().keySet());</span><br><span class="line">        parameterNames.addAll(additionalParams.keySet());</span><br><span class="line">        <span class="keyword">return</span> Collections.enumeration(parameterNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getParameter</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">parameter</span> <span class="operator">=</span> <span class="built_in">super</span>.getParameter(name);</span><br><span class="line">        <span class="keyword">if</span> (parameter != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> parameter;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String[] parameterValues = additionalParams.get(name);</span><br><span class="line">        <span class="keyword">if</span> (parameterValues != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parameterValues.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parameterValues[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        <span class="keyword">final</span> String[] parameterValues = <span class="built_in">super</span>.getParameterValues(name);</span><br><span class="line">        <span class="keyword">if</span> (parameterValues != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> parameterValues;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> additionalParams.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamNameExtensionFilter</span> <span class="keyword">extends</span> <span class="title class_">HttpFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">underLinePattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;_(\\w)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; additionalParams = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Enumeration&lt;String&gt; parameterNames = request.getParameterNames();</span><br><span class="line">        <span class="keyword">final</span> Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">        <span class="keyword">while</span> (parameterNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> parameterNames.nextElement();</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">camelCaseParameterName</span> <span class="operator">=</span> <span class="built_in">this</span>.underLineToCamel(parameterName);</span><br><span class="line">            <span class="keyword">if</span> (parameterName.equals(camelCaseParameterName)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> String[] values = parameterMap.get(parameterName);</span><br><span class="line">            additionalParams.put(camelCaseParameterName, values);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">MultiParamCaseRequest</span> <span class="variable">multiParamCaseRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultiParamCaseRequest</span>(request, additionalParams);</span><br><span class="line">        chain.doFilter(multiParamCaseRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">underLineToCamel</span><span class="params">(<span class="keyword">final</span> String value)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.underLinePattern.matcher(value);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            m.appendReplacement(sb, m.group(<span class="number">1</span>).toUpperCase());</span><br><span class="line">        &#125;</span><br><span class="line">        m.appendTail(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Model 对象包含 <code>Collection</code>，需要定制 DataBinder:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@InitBinder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder dataBinder)</span> &#123;</span><br><span class="line">    dataBinder.registerCustomEditor(List.class, <span class="string">&quot;studentList&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertyEditorSupport</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAsText</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(text)) &#123;</span><br><span class="line">                setValue(Collections.EMPTY_LIST);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    setValue(objectMapper.readValue(text, <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;EvaluationVO.Student&gt;&gt;() &#123;</span><br><span class="line">                    &#125;));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Freemarker 使用笔记</title>
    <url>/2022/09/20/TemplateEngine/Freemarker-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.freemarker&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;freemarker&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;<span class="number">2.3</span><span class="number">.27</span>-incubating&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Thymeleaf 使用笔记</title>
    <url>/2022/09/20/TemplateEngine/Thymeleaf-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>如果使用 Spring Boot，默认模板引擎的路径是 <code>classpath:/template</code>，但是无法直接访问，需要通过控制器 &gt; 解析模板才可以访问。</p>
<blockquote>
<p>如果没有进行控制器跳转，那么 Spring Boot 将会使用 <code>ResourceHttpRequestHandler</code> 来处理你的请求；如果静态路径又找不到对应的资源，则返回 404.</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>数据文档生成器 screw</title>
    <url>/2022/07/18/Tool/%E6%95%B0%E6%8D%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8-screw/</url>
    <content><![CDATA[<h1 id="数据文档生成器-screw"><a href="#数据文档生成器-screw" class="headerlink" title="数据文档生成器 screw"></a>数据文档生成器 screw</h1><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://github.com/yihr/screw">https://github.com/yihr/screw</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247490367&idx=4&sn=33457d828191fc8717bf90e29d02aa5b&chksm=fbb292c1ccc51bd776a938e2a0aca306363c8ea526362c83a1ed0e7d2522d136a5482f529481&mpshare=1&scene=1&srcid=08075ho06D4MoWdvYI6HZGn2&sharer_sharetime=1596771975108&sharer_shareid=00de337ccf971170dff621a18a7fdda8&key=bbcde1cc2908d6bbca75f9126db113cba3e65212579f0c49d238ed98e48a07667ecea3754647040875027233e7254e03354cbcb58a82ff9c1b4f865e3e510b1759f8f013ff094835f46a0f3809a473f4&ascene=1&uin=MjE2Mjg4NzYz&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=A98TRXcX38ZaCSWR2WlBPus=&pass_ticket=/q1C0cKlfjbdKpTIM9MtXaZTfIIIRMMDAPgn/J8FuXo=">参考文章</a></p>
<h2 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.smallbun.screw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>screw-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JUnit-生成"><a href="#JUnit-生成" class="headerlink" title="JUnit 生成"></a>JUnit 生成</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBDocument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成文件配置</span></span><br><span class="line">        <span class="type">EngineConfig</span> <span class="variable">engineConfig</span> <span class="operator">=</span> EngineConfig.builder()</span><br><span class="line">            <span class="comment">/* 生成文件路径，本地路径 */</span></span><br><span class="line">            .fileOutputDir(<span class="string">&quot;D:/&quot;</span>)</span><br><span class="line">            <span class="comment">/* 是否打开输出的目录 */</span></span><br><span class="line">            .openOutputDir(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">/* 文件类型 */</span></span><br><span class="line">            .fileType(EngineFileType.HTML)</span><br><span class="line">            <span class="comment">/* 生成模板实现 */</span></span><br><span class="line">            .produceType(EngineTemplateType.freemarker)</span><br><span class="line">            .build();</span><br><span class="line">        <span class="comment">// 生成文档配置（包含以下自定义版本号、描述等配置连接）</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> Configuration.builder()</span><br><span class="line">            .version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;数据库文档&quot;</span>)</span><br><span class="line">            .dataSource(dataSource)</span><br><span class="line">            .engineConfig(engineConfig)</span><br><span class="line">            .produceConfig(getProcessConfig())</span><br><span class="line">            .build();</span><br><span class="line">        <span class="comment">// 执行生成</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DocumentationExecute</span>(config).execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置想要生成的表 + 配置想要忽略的表</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProcessConfig <span class="title function_">getProcessConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessConfig.builder()</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>screw</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 打包部署脚本</title>
    <url>/2022/07/18/Vue/Vue-%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="Vue-打包部署脚本"><a href="#Vue-打包部署脚本" class="headerlink" title="Vue 打包部署脚本"></a>Vue 打包部署脚本</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev scp2 cross-env ora@4.1.1 chalk</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scpClient = <span class="built_in">require</span>(<span class="string">&#x27;scp2&#x27;</span>);      <span class="comment">// 基于ssh2的纯javascript安全复制程序</span></span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">&#x27;ora&#x27;</span>);             <span class="comment">// 一个优雅的 Node.js 终端加载动画效果</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>);         <span class="comment">// 字体颜色插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spinner = <span class="title function_">ora</span>(<span class="string">&#x27;正在发布到 &#x27;</span> + process.<span class="property">env</span>.<span class="property">NODE_ENV</span> + <span class="string">&#x27; 服务器...\n&#x27;</span>);</span><br><span class="line">spinner.<span class="title function_">start</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_LIST</span> = &#123;</span><br><span class="line">    <span class="string">&#x27;development&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>,            <span class="comment">// ip</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">22</span>,                       <span class="comment">// 端口</span></span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>,               <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span>,                <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/opt/www&#x27;</span>                <span class="comment">// 发布至静态服务器的项目路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;production&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>,      <span class="comment">// ip</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">22</span>,                       <span class="comment">// 端口</span></span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>,               <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span>,                <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/opt/www&#x27;</span>                <span class="comment">// 发布至静态服务器的项目路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是公钥认证在这里创建私钥文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;C:\\Users\\Administrator\\.ssh\\id_rsa&#x27;</span></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFileSync</span>(path).<span class="title function_">toString</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="variable constant_">SERVER_LIST</span>[process.<span class="property">env</span>.<span class="property">NODE_ENV</span>];</span><br><span class="line">scpClient.<span class="title function_">scp</span>(</span><br><span class="line">    <span class="string">&#x27;dist/&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">host</span>: server.<span class="property">hostname</span>,</span><br><span class="line">        <span class="attr">port</span>: server.<span class="property">port</span>,</span><br><span class="line">        <span class="attr">username</span>: server.<span class="property">username</span>,</span><br><span class="line">        <span class="attr">password</span>: server.<span class="property">password</span>,</span><br><span class="line">        privateKey,</span><br><span class="line">        <span class="attr">path</span>: server.<span class="property">path</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        spinner.<span class="title function_">stop</span>();</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">red</span>(<span class="string">&#x27;发布失败.\n&#x27;</span>));</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">green</span>(<span class="string">&#x27;Success! 成功发布到&#x27;</span> + process.<span class="property">env</span>.<span class="property">NODE_ENV</span> + <span class="string">&#x27;服务器! \n&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>package.json</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">  <span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;npm run build &amp;&amp; cross-env NODE_ENV=development node ./deploy&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 笔记</title>
    <url>/2022/09/08/maven/Maven-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Maven-笔记"><a href="#Maven-笔记" class="headerlink" title="Maven 笔记"></a>Maven 笔记</h1><h2 id="Maven-是什么"><a href="#Maven-是什么" class="headerlink" title="Maven 是什么"></a>Maven 是什么</h2><p><a href="https://maven.apache.org/what-is-maven.html">官方介绍 What is  Maven?</a></p>
<p>Maven 是 Apache 软件基金会唯一维护的一款【自动化构建工具】。专注于 Java 平台的【项目构建】和【项目管理】</p>
<h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>Maven 为构建管理带来的强大的额外特性就是项目继承 (Inheritance) 的概念。</p>
<p>对于父工程和聚合 (多模块) 工程，<code>packaging</code> 类型必须是 <code>pom</code>。这些类型定义了绑定到一组生命周期阶段的目标。例如，如果 packaging 是 <code>jar</code>, 那么 <code>package</code> 阶段就会执行 <code>jar:jar</code> 目标。</p>
<p>请注意 <code>relativePath</code> 元素。它不是必需的，但是它可以作为一个指示器，告诉 Maven 在搜索本地以及远程仓库之前，首先搜索该工程的父工程给定的路径。</p>
<blockquote>
<p>个人感觉 <code>relativePath</code> 使用场景很小</p>
</blockquote>
<h2 id="构建项目的主要环节"><a href="#构建项目的主要环节" class="headerlink" title="构建项目的主要环节"></a>构建项目的主要环节</h2><ul>
<li>clean：清理，删除以前的编译结果</li>
<li>compile：编译，将 Java 源程序编译为字节码</li>
<li>test：对项目进行测试</li>
<li>package：将项目进行打包，以 jar 或 war 格式。</li>
<li>install：将打包的结果 jar 或者 war 安装到本地仓库。</li>
<li>deploy：将打包的结果部署到远程仓库或者 war 包部署到服务器上运行</li>
</ul>
<h2 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h2><p><code>mvn -version / mvn -v</code> 显示版本信息<br><code>mvn clean</code> 清理<br><code>mvn compile</code> 编译<br><code>mvn test</code> 编译并测试<br><code>mvn package</code> 生成 target 目录，编译、测试代码，生成测试报告，生成 jar&#x2F;war<br><code>mvn site</code> 生成项目相关信息的网站<br><code>mvn clean compile</code> 清理之后编译<br><code>mvn clean package</code> 清理之后打包<br><code>mvn clean install</code> 清理之后安装<br><code>mvn clean deploy</code> 清理之后发布</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h3 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h3><p>依赖范围 <code>&lt;scope&gt;</code> 控制哪些依赖在哪些 classpath 中可用，哪些依赖包含在一个应用中。</p>
<p>【compile】默认的范围；编译范围依赖在所有的 classpath 中可用，同时它们也会被打包。</p>
<p>【provided】provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的 Servlet API 来编译一个 servlet，但是你不会想要在打包好的 WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。</p>
<p>或者还有 lombok 的使用，打包完毕之后便不再需要包含这个 API。</p>
<p>【runtime】 runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC 驱动实现。</p>
<p>【test】 test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</p>
<p>【system】 system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构建应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个systemPath元素。注意该范围是不推荐使用的（建议尽量去从公共或定制的 Maven 仓库中引用依赖）。</p>
<p>【import】 import 仅支持在 <code>&lt;dependencyManagement&gt;</code> 中的类型依赖项上。该选项可以用来解决 Maven 的单继承。</p>
<p>通常，我们会使用 spring-boot-starter-parent 作为项目的父工程，因为其中进行了很多版本管理，同时我们也希望引入其他版本管理的工程，如 spring-cloud、spring-cloud-alibaba。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="lt-version-gt"><a href="#lt-version-gt" class="headerlink" title="&lt;version&gt;"></a><code>&lt;version&gt;</code></h3><ul>
<li><code>&lt;parent&gt;</code> 标签下的 <code>&lt;version&gt;</code></li>
</ul>
<p>Snapshot版本代表不稳定、尚处于开发中的版本  Release版本则代表稳定的版本<br>如果 deploy 到远程服务器 如果是 release 只能 deploy 一次，以后部署的话，就会报错冲突，因为是稳定版<br>但是如果是 snapshot 的话，你可以 deploy 多次，每一次都会冲掉原来的版本，表示不稳定</p>
<ul>
<li><code>&lt;dependency&gt;</code> 下的 <code>&lt;version&gt;</code></li>
</ul>
<p>显式设置依赖的版本</p>
<h3 id="lt-dependencyManagement-gt"><a href="#lt-dependencyManagement-gt" class="headerlink" title="&lt;dependencyManagement &gt;"></a><code>&lt;dependencyManagement &gt;</code></h3><p>Maven 使用 dependencyManagement 元素来提供一种管理<strong>依赖版本</strong>的方式。通常会在一个组织或项目的最顶层的父 POM 中看到。</p>
<p>使用 pom.xml 中的 <code>&lt;dependencyManagement &gt; </code>能让所有在子项目中引用一个依赖而不用显式地写 <code>&lt;version&gt;</code>，Maven 会沿着父子层次向上找，直到找到一个拥有 dependencyManagement 元素的项目，然后它就会使用这个版本号。</p>
<p>dependencyManagement 只是声明依赖，并不引入依赖，因此子项目需要显式进行依赖引入。</p>
<h3 id="lt-optional-gt"><a href="#lt-optional-gt" class="headerlink" title="&lt;optional&gt;"></a><code>&lt;optional&gt;</code></h3><p>默认为 false，optional 标签 设置为true 可以防止依赖继承到 jar 包，比如 spring-boot-devtools</p>
]]></content>
  </entry>
  <entry>
    <title>Java 线程池笔记</title>
    <url>/2022/09/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>ThreadPoolExecutor 继承了 AbstractExecutorService，成员变量 ctl 是一个 Integer 的原子变量，用来记录线程池状态和线程池中线程个数。</p>
<blockquote>
<p>高 3 位用来表示线程池状态，低 29 位用来记录线程池线程个数。即，线程池状态理论上可以至多拥有 8 种。</p>
</blockquote>
<p>实际上，线程池的状态如下：</p>
<table>
<thead>
<tr>
<th align="left">线程池状态</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RUNNING</td>
<td align="left">接收新任务并且处理阻塞队列里的任务</td>
</tr>
<tr>
<td align="left">SHUTDOWN</td>
<td align="left">拒绝新任务但是处理阻塞队列里的任务</td>
</tr>
<tr>
<td align="left">STOP</td>
<td align="left">拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务</td>
</tr>
<tr>
<td align="left">TIDYING</td>
<td align="left">所有任务都执行完（包含阻塞队列里面的任务）后当前线程池活动线程数位 0，将要调用 terminated 方法</td>
</tr>
<tr>
<td align="left">TERMINATED</td>
<td align="left">终止状态。terminated 方法调用完成以后的状态</td>
</tr>
</tbody></table>
<p>线程池参数：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">corePoolSize</td>
<td align="left">核心线程数，即使他们空闲也会保持在线程池中</td>
</tr>
<tr>
<td align="left">maximumPoolSize</td>
<td align="left">线程池中允许的最大线程数</td>
</tr>
<tr>
<td align="left">keepAliveTime</td>
<td align="left">保持存活时间，如果线程数超过核心线程数，而且超过的线程不在工作（空闲），他们允许有keepAliveTime 的时间存活，以便等待新任务。</td>
</tr>
<tr>
<td align="left">TimeUnit</td>
<td align="left">时长单位，用于 keepAliveTime</td>
</tr>
<tr>
<td align="left">workQueue</td>
<td align="left">用于保存等待执行的任务的阻塞队列</td>
</tr>
<tr>
<td align="left">threadFactory</td>
<td align="left">executor 用于创建线程的工厂</td>
</tr>
<tr>
<td align="left">RejectedExecutionHandler</td>
<td align="left">饱和策略，当队列满并且线程个数达到 maximunPoolSize 后采取的策略</td>
</tr>
</tbody></table>
<ul>
<li>keepAliveTime</li>
</ul>
<p>一般情况下，keepAliveTime 可以设置为 0，表示线程运行完毕立即销毁；keepAliveTime &lt; 0，初始化才会报错</p>
<p>如果调用了 allowCoreThreadTimeOut(true)，那么 keepAlive &lt;&#x3D; 0 就会报错，这表示允许核心线程等待任务超时，而不是常驻。</p>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><p><code>newFixedThreadPool</code> 创建一个核心线程个数和最大线程个数都为 nThreads 的线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//使用自定义线程创建工厂</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>keepAliveTime 为 0，说明只要线程个数比核心线程个数多并且当前空闲则回收。</p>
<p>这里传递了 <code>new LinkedBlockingQueue&lt;Runnable&gt;()</code> 作为阻塞队列，默认大小为 <code>Integer.MAX_VALUE</code>，因此可以认为是一个无界队列。</p>
<h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><p>创建一个核心线程数和最大线程数都为 1 的线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>


<p>有界队列禁止设置长度为 0，至少是 1，因此似乎没有办法做到仅固定线程活跃，其他任务拒绝：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            THREAD_POOL_SIZE, THREAD_POOL_SIZE, <span class="number">0L</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure>




<h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p>Executor &gt; ExecutorService &gt; AbstractExecutorService &gt; ThreadPoolExecutor</p>
<p>execute() 和 submit() 有什么区别？</p>
<ol>
<li><p>execute 无法返回值；submit 可以返回值</p>
</li>
<li><p>submit 底层调用了 execute</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">	<span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">	TimeUnit unit,</span></span><br><span class="line"><span class="params">	BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">	ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">	RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p>调用 shutdown 方法后，线程池就不会再接受新的任务了，但是工作队列里面的任务还是要执行的。该方法会立即返回，并不等待队列任务完成再返回。</p>
<h2 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h2><p>调用 shutdownNow 方法后，线程池就不会再接受新的任务了，并且会丢弃工作队列里面的任务，正在执行的任务会被中断，该方法会立即返回，并不等待激活的任务执行完成。</p>
<h1 id="org-springframework-scheduling-concurrent-ThreadPoolTaskExecutor"><a href="#org-springframework-scheduling-concurrent-ThreadPoolTaskExecutor" class="headerlink" title="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"></a>org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor</h1><p>创建一个 Spring 线程池 ThreadPoolTaskExecutor</p>
<p>它暴露了Executor的配置参数作为bean属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line"><span class="comment">//配置核心线程数</span></span><br><span class="line">executor.setCorePoolSize(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//配置最大线程数</span></span><br><span class="line">executor.setMaxPoolSize(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//配置队列大小</span></span><br><span class="line">executor.setQueueCapacity(<span class="number">2000000</span>);</span><br><span class="line"><span class="comment">//配置线程池中的线程的名称前缀</span></span><br><span class="line">executor.setThreadNamePrefix(<span class="string">&quot;mythread-&quot;</span>);</span><br><span class="line"><span class="comment">//线程执行时间</span></span><br><span class="line">executor.setKeepAliveSeconds(customPool.getKeepAliveSeconds());</span><br><span class="line"></span><br><span class="line"><span class="comment">// rejection-policy：当pool已经达到max size的时候，如何处理新任务</span></span><br><span class="line"><span class="comment">// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</span></span><br><span class="line">executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolRejectedPolicyHandler</span>());</span><br><span class="line"><span class="comment">//执行初始化</span></span><br><span class="line">executor.initialize();</span><br><span class="line"><span class="keyword">return</span> executor;</span><br></pre></td></tr></table></figure>


<h1 id="线程池-main-线程等待所有线程结束"><a href="#线程池-main-线程等待所有线程结束" class="headerlink" title="线程池 main 线程等待所有线程结束"></a>线程池 main 线程等待所有线程结束</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mainWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">    executor.setCorePoolSize(<span class="number">5</span>); <span class="comment">//核心池大小</span></span><br><span class="line">    executor.setMaxPoolSize(<span class="number">10</span>); <span class="comment">//最大线程数</span></span><br><span class="line">    executor.setQueueCapacity(<span class="number">10</span>); <span class="comment">//队列程度</span></span><br><span class="line">    executor.setThreadNamePrefix(<span class="string">&quot;sub-thread-&quot;</span>);<span class="comment">//线程前缀名称</span></span><br><span class="line">    executor.initialize(); <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 任务数量</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(count); <span class="comment">// 同步工具</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        executor.execute(() -&gt; task(countDownLatch));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;main 线程等待子线程完成...&quot;</span>);</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;main 线程工作结束.&quot;</span>);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">task</span><span class="params">(CountDownLatch countDownLatch)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 工作开始！&quot;</span>);</span><br><span class="line">        Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">2000</span>));</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 工作结束！&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>获取用户 IP</title>
    <url>/2022/07/28/%E5%B7%A5%E5%85%B7/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7-IP/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">getIp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	$ips = array();</span><br><span class="line">	<span class="keyword">if</span> ($_SERVER[<span class="string">&#x27;HTTP_CLIENT_IP&#x27;</span>]) &#123;</span><br><span class="line">		$ips[] = $_SERVER[<span class="string">&#x27;HTTP_CLIENT_IP&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ($_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>]) &#123;</span><br><span class="line">		$tmp = explode(<span class="string">&#x27;, &#x27;</span>, $_SERVER[<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>]);</span><br><span class="line">		$ips = array_merge($ips, $tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ($_SERVER[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]) &#123;</span><br><span class="line">		$ips[] = $_SERVER[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	$ip = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	foreach ($ips <span class="type">as</span> <span class="variable">$k</span> <span class="operator">=</span>&gt; $v) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^(10|172\.16|192\.168)\./&#x27;</span>, $v) &amp;&amp; strtolower($v) != <span class="string">&#x27;unknown&#x27;</span>) &#123;</span><br><span class="line">			$ip = $v;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> $ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/07/16/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>图解设计模式</p>
<h2 id="1-Iterator-模式"><a href="#1-Iterator-模式" class="headerlink" title="1. Iterator 模式"></a>1. Iterator 模式</h2><h2 id="2-Adapter-模式"><a href="#2-Adapter-模式" class="headerlink" title="2. Adapter 模式"></a>2. Adapter 模式</h2><p>Adapter 模式也被称为 Wrapper 模式。</p>
<h3 id="Adapter-模式角色"><a href="#Adapter-模式角色" class="headerlink" title="Adapter 模式角色"></a>Adapter 模式角色</h3><ul>
<li>Target</li>
</ul>
<p>该角色负责定义所需的方法。</p>
<ul>
<li>Adaptee（被适配者）</li>
</ul>
<p>Adaptee 是一个持有既定方法的角色</p>
<ul>
<li>Adapter（适配器）</li>
</ul>
<p>Adapter 模式的主人公。使用 Adaptee 的方法来满足 Target 的需求。在类适配器模式中，Adapter 通过继承来使用 Adaptee；在对象适配器模式中，Adapter 通过委托来使用 Adaptee 角色。</p>
<p>适配器和被适配者并不需要继承相同的抽象类或接口。</p>
<blockquote>
<p>如果在类适配器模式中，会让适配器实现被适配者，但似乎不如对象适配器的委托优雅。</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><table>
<thead>
<tr>
<th align="left">适配器</th>
<th align="left">被适配者</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>InputStreamReader</code></td>
<td align="left"><code>InputStream</code> 系列</td>
</tr>
<tr>
<td align="left"><code>OutputStreamWriter</code></td>
<td align="left"><code>OutputStream</code> 系列</td>
</tr>
<tr>
<td align="left"><code>FutureTask</code></td>
<td align="left"><code>Runnable</code></td>
</tr>
</tbody></table>
<blockquote>
<p>由于 <code>InputStream</code> 和 <code>OutputStream</code> 只能输入&#x2F;输出字节，需要经过一个适配过程，将字节转换为字符，这就是适配器模式。</p>
</blockquote>
<h2 id="7-Abstract-Factory-模式"><a href="#7-Abstract-Factory-模式" class="headerlink" title="7. Abstract Factory 模式"></a>7. Abstract Factory 模式</h2><p>父类决定实例的生成方式，但不决定所要生成的具体的类，具体的处理全部交给子类负责。</p>
<p><code>FileSystemProvider.newInputStream</code> 用于生成文件  <code>InputStream</code>，底层依赖于 <code>FileSystemProvider</code>，可能是 <code>WindowsFileSystem</code> 也可能是 <code>ZipFileSystem</code>。类似 <code>Abstract Factory</code> 的变体。</p>
<h2 id="11-Decorator-模式"><a href="#11-Decorator-模式" class="headerlink" title="11. Decorator 模式"></a>11. Decorator 模式</h2><p>装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。</p>
<h3 id="Decorator-模式中的角色"><a href="#Decorator-模式中的角色" class="headerlink" title="Decorator 模式中的角色"></a>Decorator 模式中的角色</h3><ul>
<li>Component</li>
</ul>
<p>增加功能时的核心角色</p>
<ul>
<li>ConcreteComponent</li>
</ul>
<p>实现了 Component 角色所定义的接口</p>
<ul>
<li>Decorator</li>
</ul>
<p>该角色具有与 Component 相同的接口，内部保存了被装饰的对象。</p>
<ul>
<li>ConcreteDecorator</li>
</ul>
<p>具体的 Decorator 角色</p>
<p>以 Java IO 库来说，<code>InputStream</code> 和 <code>OutputStream</code> 扮演 Component 角色。</p>
<p><code>FilterInputStream</code> 和 <code>FilterOutputStream</code> 扮演 Decorator</p>
<p>对于字节流来说， <code>FilterInputStream</code> （对应输入流）和 <code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code>InputStream</code> 和<code>OutputStream</code> 子类对象的功能。</p>
<p>我们常见的 <code>BufferedInputStream</code>、<code>DataInputStream</code> 等等都是<code>FilterInputStream</code> 的子类，<code>BufferedOutputStream</code>、<code>DataOutputStream</code> 等等都是 <code>FilterOutputStream</code> 的子类。</p>
<p>从 <code>BufferedInputStream</code> 的构造器参数也可以知道，传入一个 <code>InputStream</code> 对象，进而装饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BufferedInputStream</span><span class="params">(InputStream in, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(in);</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-Proxy-模式"><a href="#21-Proxy-模式" class="headerlink" title="21. Proxy 模式"></a>21. Proxy 模式</h2><h3 id="Proxy-模式中的角色"><a href="#Proxy-模式中的角色" class="headerlink" title="Proxy 模式中的角色"></a>Proxy 模式中的角色</h3><p>在 Proxy 模式中一般有以下角色：</p>
<ul>
<li>Subject（主体）</li>
</ul>
<p>Subject 定义了使 Proxy 和 RealSubject 之间具有一致性的接口。</p>
<ul>
<li>Proxy（代理人）</li>
</ul>
<p>Proxy 会尽量处理来自外界的请求。当自己不能处理时，才会将工作交给 RealSubject。Proxy 也要实现 Subject 定义的接口。</p>
<ul>
<li>RealSubject（实际主体）</li>
</ul>
<p>RealSubject 会在 Proxy 无法胜任工作时出场。它也会实现 Subject 接口。</p>
<h3 id="Proxy-模式变体"><a href="#Proxy-模式变体" class="headerlink" title="Proxy 模式变体"></a>Proxy 模式变体</h3><ul>
<li><p>Virtual Proxy（虚拟代理）<br>Virtual Proxy 就是上面呈现的 Proxy 模式。当真正需要 RealSubject 时，才生成和初始化实例。</p>
</li>
<li><p>Remote Proxy（远程代理）<br>Remote Proxy 可以让我们不必在意 RealSubject 是否在远程网络上，透明地使用它的功能。Java 的 RMI（Remote Method Invocation：远程方法调用）就相当于 Remote Proxy。</p>
</li>
<li><p>Access Proxy<br>Access Proxy 用于限制 RealSubject 的功能访问。例如，这种代理只允许访问特定的方法，当访问其他方法时则报错。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2022/07/24/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSorter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MergeSorter</span> <span class="variable">mergeSorter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MergeSorter</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        mergeSorter.sort();</span><br><span class="line">        System.out.println(Arrays.toString(mergeSorter.getArr()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MergeSorter</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getArr() &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span> &#123;</span><br><span class="line">        doSort(<span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        doSort(left, (left + right) / <span class="number">2</span>);</span><br><span class="line">        doSort((left + right) / <span class="number">2</span> + <span class="number">1</span>, right);</span><br><span class="line">        merge(left, (left + right) / <span class="number">2</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> middle, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 两个元素</span></span><br><span class="line">        <span class="keyword">if</span> (right - left == <span class="number">1</span> &amp;&amp; arr[left] &gt; arr[right]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = tmp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] merged = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// merged 数组的指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mergedPoint</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftPoint</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// left 指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightPoint</span> <span class="operator">=</span> middle + <span class="number">1</span>; <span class="comment">// right 指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (leftPoint &lt;= middle &amp;&amp; rightPoint &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> value;</span><br><span class="line">            <span class="keyword">if</span> (arr[leftPoint] &lt;= arr[rightPoint]) &#123;</span><br><span class="line">                value = arr[leftPoint++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = arr[rightPoint++];</span><br><span class="line">            &#125;</span><br><span class="line">            merged[mergedPoint++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (leftPoint &lt;= middle) &#123;</span><br><span class="line">            merged[mergedPoint++] = arr[leftPoint++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightPoint &lt;= right) &#123;</span><br><span class="line">            merged[mergedPoint++] = arr[rightPoint++];</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(merged, <span class="number">0</span>, arr, left, merged.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>数据结构——二叉树</title>
    <url>/2022/07/24/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="数据结构——二叉树"><a href="#数据结构——二叉树" class="headerlink" title="数据结构——二叉树"></a>数据结构——二叉树</h1><h2 id="树的递归遍历"><a href="#树的递归遍历" class="headerlink" title="树的递归遍历"></a>树的递归遍历</h2><p>递归遍历框架代码清单如下：</p>
<blockquote>
<p>也就是一个递归框架</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ⼆叉树遍历框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MQ 学习笔记</title>
    <url>/2022/07/22/%E9%9D%A2%E8%AF%95/MQ-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MQ-学习笔记"><a href="#MQ-学习笔记" class="headerlink" title="MQ 学习笔记"></a>MQ 学习笔记</h1><h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h2><ul>
<li>异步</li>
<li>解耦</li>
<li>削峰</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>提高系统的响应速度、吞吐量。</p>
<p><strong>场景一 异步处理播放记录</strong></p>
<p>空中课堂有很多点播模块，如：名师讲堂、抗议助学、互动课堂、同步课堂、家长课堂、苏e优课等。</p>
<p>通常这些模块需要：</p>
<ul>
<li>记录观看的用户信息</li>
<li>自增对应模块表的观看量</li>
<li>维护旧数据表的观看量（逻辑未完全迁移）</li>
<li>维护大屏统计表的数据量</li>
<li>……</li>
</ul>
<p>以上这一系列操作的业务可能有一定耗时（操作的数据库表较多），但对用户来说响应结果并不重要，使用 MQ 异步处理。</p>
<h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p><strong>场景一 VOD 的任务流</strong></p>
<p>VOD 用户上传的视频可能需要转码、截取封面图，这些操作不可能同步，通常会在视频上传之后开启一个任务流分步处理，并将结果回调给特定的地址。</p>
<p>扩展：通常 VOD 提供了两组通知模式，回调+主动拉取，回调并不可靠，可能会因为跨网络的原因导致消息丢失；通常选择可靠回调，定时主动拉取事件集，并在处理之后给出确认响应。</p>
<p><strong>场景二 企微事件回调</strong></p>
<p>在企微的人员架构变动之后，后台会接收到回调事件，接收事件的服务可能只是一个统计入口服务，比如自建代开发应用事件回调服务、第三方应用事件回调服务，并不希望将这些回调事件的处理逻辑混合到这些系统中，可以推送到 MQ 中供其他服务进行使用。</p>
<h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p><strong>场景一 校园安全人脸捕捉削峰</strong></p>
<p>门禁机设备推送抓拍信息（回调接口），如果返回错误码，或者网络原因超时（可配置），会一直重试。</p>
<blockquote>
<p>一定程度确保了消息不丢失</p>
</blockquote>
<p>这样可能会导致门禁机在网络不通的情况下一直调用，所以一般会<strong>取消离线发送</strong>。</p>
<p>离线发送：设备注册失败 or 心跳不正常，取消推送抓拍信息，直到恢复。</p>
<p>上述场景可能有个问题：学校整体网络都有问题，抓拍的图片堆积太多，如果等待网络恢复，瞬间发送大量的包含 base64 等信息的抓拍信息，会导致服务器压力较大！</p>
<p>引入 MQ，将 Capture 的信息先推送到消息队列，异步地匀速处理。</p>
<h2 id="2-如何保证消息幂等"><a href="#2-如何保证消息幂等" class="headerlink" title="2. 如何保证消息幂等"></a>2. 如何保证消息幂等</h2><p>RocketMQ 包含了一个 MessageID，但是消息多的情况下未必唯一。</p>
<p>自己带一个有业务标识的 MessageID</p>
<h2 id="3-消息有序"><a href="#3-消息有序" class="headerlink" title="3. 消息有序"></a>3. 消息有序</h2><p>全局有序、局部有序：MQ 只需要保证局部有序</p>
]]></content>
  </entry>
  <entry>
    <title>Redis 面试预备</title>
    <url>/2022/07/24/%E9%9D%A2%E8%AF%95/Redis-%E9%9D%A2%E8%AF%95%E9%A2%84%E5%A4%87/</url>
    <content><![CDATA[<h1 id="Redis-面试预备"><a href="#Redis-面试预备" class="headerlink" title="Redis 面试预备"></a>Redis 面试预备</h1><h2 id="为什么用-Redis"><a href="#为什么用-Redis" class="headerlink" title="为什么用 Redis"></a>为什么用 Redis</h2><ul>
<li>高并发</li>
<li>高可用</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存穿透: 缓存中查不到，数据库中也差不多</p>
<p>解决方案: 1. 对参数进行合法性校验 2. 将数据库中没有查到的也写入到缓存</p>
<p>为了防止缓存垃圾，这一类的缓存可以设置短一些</p>
<blockquote>
<p>BloomFilter ，MySQL 的 id 引入该过滤器。</p>
</blockquote>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li><p>缓存</p>
</li>
<li><p>记录用户在线人数</p>
</li>
</ol>
<p>使用 zSet 结构</p>
<p>用户每次调用接口，在鉴权的时候刷新一次该用户 user_id 对应的 score</p>
<p>定时脚本，删除过期的数据:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$redis</span>-&gt;<span class="title function_ invoke__">zRemRangeByScore</span>(REDIS_ONLINE_USER, <span class="number">0</span>, <span class="title function_ invoke__">time</span>() - <span class="number">5200</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB 日志</title>
    <url>/2022/07/11/InnoDB%20%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://blog.itpub.net/7728585/viewspace-2284045/">解析 roll_pointer</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/427911093">庖丁解牛 </a></p>
<p><a href="https://zhuanlan.zhihu.com/p/453169285">InnoDB之UNDO LOG介绍</a></p>
<h1 id="Undo-Logs"><a href="#Undo-Logs" class="headerlink" title="Undo Logs"></a>Undo Logs</h1><p>Undo Log 是一条或者多条 Undo Log Record 的集合，每一条 Undo Log Record 都与一个读写事务相关。每条 Undo Log 记录包含了有关如何撤销事务最新更改的信息<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-logs.html">[?]</a>。</p>
<h2 id="1-Undo-Tablespaces"><a href="#1-Undo-Tablespaces" class="headerlink" title="1. Undo Tablespaces"></a>1. Undo Tablespaces</h2><p>Undo Tablesapces 包含许多 Undo Log。</p>
<blockquote>
<p>MySQL 最多支持 127 个 Undo Tablespace。默认为 2 个。</p>
</blockquote>
<p>InnoDB 是一个多版本的存储引擎。它可以保留有关更改行的旧版本的信息，以支持事务功能，例如并发和回滚。此信息以一个称为回滚段的数据结构，存储于 undo 表空间。回滚段驻留在 undo 表空间和全局临时表空间中<a href="s">[1]</a>。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo-tablespace.png">


<h2 id="2-Rollback-Segment"><a href="#2-Rollback-Segment" class="headerlink" title="2. Rollback Segment"></a>2. Rollback Segment</h2><p>InnoDB 在 Undo Tablespace 中使用 Rollback Segment 来组织 Undo Log，最多支持 128 个 Rollback Segment。</p>
<p>其中第 0 号、33-127号针对普通表设计，1-32 号针对临时表设计。</p>
<blockquote>
<p>一个事务可能即操作了临时表，也操作了物理表，因此，一个事务是可以使用多个 Rollback Segment。</p>
</blockquote>
<h2 id="3-Rollback-Segment-Array-Header"><a href="#3-Rollback-Segment-Array-Header" class="headerlink" title="3. Rollback Segment Array Header"></a>3. Rollback Segment Array Header</h2><p>Undo Tablespace 文件中的第 3 个 Page 固定作为这 128 个 Rollback Segment 的目录，即 Rollback Segment Array Header</p>
<h2 id="4-Rollback-Segment-Header"><a href="#4-Rollback-Segment-Header" class="headerlink" title="4. Rollback Segment Header"></a>4. Rollback Segment Header</h2><p>通过 Rollback Segment Header 来管理 Rollback Segment，Rollback Segment Header 通常在 Rollback Segment 第 1 页。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/rollback_segment_header.png" width="300">

<table>
<thead>
<tr>
<th><div style="width:200px">字段</div></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Max Size</td>
<td>参数名 TRX_RSEG_MAX_SIZE， 回滚段可用的最大 Page 数</td>
</tr>
<tr>
<td>History Size</td>
<td>参数名 TRX_RSEG_HISTORY_SIZE，History List 包含的 Page 数</td>
</tr>
<tr>
<td>History List Base Node</td>
<td>参数名 TRX_RSEG_HISTORY</td>
</tr>
</tbody></table>
<p>History List 把所有已经提交，但还没有被 purge 的事务的 Undo Log 连接起来，purge 线程可以通过此 List 对已经没有事务使用的 Undo Log 进行 purge。</p>
<p>每个事务在需要记录 Undo Log 时都会申请 1 个或者 2 个 Slot（INSERT 和 UPDATE 分开），同时把事务的第一个 Undo Page 放入对应 Slot 中</p>
<h3 id="5-Undo-Page"><a href="#5-Undo-Page" class="headerlink" title="5. Undo Page"></a>5. Undo Page</h3><p>Undo Page 一般可以分为两种：Header Page 和 Normal Page。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo-page.png">


<p>Undo Header Page 是事务需要写 Undo Log 时申请的第一个 Undo Page</p>
<p>Undo Header Page 是当活跃事务产生的 Undo Record 超过 Undo Header Page 容量后，单独分配的 Undo Page</p>
<h3 id="6-Undo-Page-Header"><a href="#6-Undo-Page-Header" class="headerlink" title="6. Undo Page Header"></a>6. Undo Page Header</h3><img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo-page-header.png" width="400">

<table>
<thead>
<tr>
<th><div style="width:200px">字段</div></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Undo Page Type</td>
<td>TRX_UNDO_PAGE_TYPE，使用该页事务的类型<br>可选值: TRX_UNDO_INSERT、TRX_UNDO_UPDATE</td>
</tr>
<tr>
<td>Latest Log Record Offset</td>
<td>最新事务开始记录 Undo Log 的位置</td>
</tr>
<tr>
<td>Free Space Offset</td>
<td>页内空闲空间起始地址，在此之后可记录 Undo Log</td>
</tr>
<tr>
<td>Undo Page List Node</td>
<td>undo page list节点，可以把同一个事务所用到的所有undo page双向串联起来</td>
</tr>
</tbody></table>
<h3 id="6-Undo-Segment"><a href="#6-Undo-Segment" class="headerlink" title="6. Undo Segment"></a>6. Undo Segment</h3><p>InnoDB 中的 Undo Tablespace 中准备了大量的 Undo Segment 槽位，默认按照 1024 一组划分为 Rollback Segment。</p>
<blockquote>
<p>每个 Undo Tablespace 最多会包含128 个 Rollback Segment。1 个 Undo Slot 对应 1 个 Undo Segment</p>
</blockquote>
<p>每个写事务开始写操作之前都需要持有一个 Undo Segment。在任何时刻，每个 Undo Segment 都是被一个事务独占的。</p>
<p>对于较大的 Undo Log 随着不断地写入，按需分配足够多的 Undo Page 分散承载。</p>
<p>每个 Undo Segment  至少持有 1 个 Undo Page，每个 Undo Page 会在开头 38 - 56 字节记录 Undo Page Header。</p>
<blockquote>
<p>Rollback Segment 中 Undo Slot 具体的数值是 $\frac {Page Size}{16}$，见<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-logs.html">15.6.6 Undo Logs</a>。因为默认 Page Size &#x3D; 16 KB，因此默认以 1024 一组划分为一个 Rollback Segment。</p>
</blockquote>
<h3 id="7-Undo-Segment-Header"><a href="#7-Undo-Segment-Header" class="headerlink" title="7. Undo Segment Header"></a>7. Undo Segment Header</h3><p>Undo Segment 中的第 1 个 Undo Page 还会在 56~86 字节记录 Undo Segment Header。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo-segment-header.png" style="width: 400px">

<table>
<thead>
<tr>
<th><div style="width:200px">字段</div></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>State</td>
<td>TRX_UNDO_STATE，Undo Segment 的状态</td>
</tr>
<tr>
<td>Last Log Offset</td>
<td>TRX_UNDO_LAST_LOG，当前页最后一个 Undo Log Header 的位置</td>
</tr>
<tr>
<td>Undo Segment FSEG Entry</td>
<td>TRX_UNDO_FSEG_HEADER，segment对应的inode的（space_id，page_no，offset等）</td>
</tr>
<tr>
<td>Undo Segment Page List Base Node</td>
<td>TRX_UNDO_PAGE_LIST,undo page list的Base Node，对于同一个事务下的undo header page和undo normal page构成双向链表</td>
</tr>
</tbody></table>
<p>TRX_UNDO_PAGE_LIST：对于一般事务来说，不会出现一页写不下的情况，所以，对于大多数事务该链表长度是 1。</p>
<p>在事务结束 (commit &#x2F; rollback) 的时候，会依次检查一些条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trx_undo_set_state_at_finish()</span></span><br><span class="line"><span class="keyword">if</span> (undo-&gt;size == <span class="number">1</span> &amp;&amp; mach_read_from_2(page_hdr + TRX_UNDO_PAGE_FREE) &lt; </span><br><span class="line">TRX_UNDO_PAGE_REUSE_LIMIT) &#123;</span><br><span class="line">    <span class="comment">// 如果占用 Page == 1，而且本页使用空间偏移量小于 3 / 4</span></span><br><span class="line">    <span class="comment">// 那么，标记为 TRX_UNDO_CACHED</span></span><br><span class="line">    state = TRX_UNDO_CACHED;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (undo-&gt;type == TRX_UNDO_INSERT) &#123;</span><br><span class="line">    <span class="comment">// 如果类型为 INSERT</span></span><br><span class="line">    <span class="comment">// 那么，标记为 TRX_UNDO_TO_FREE</span></span><br><span class="line">    state = TRX_UNDO_TO_FREE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 最后就是类型为 UPDATE 而且占用空间较多</span></span><br><span class="line">    state = TRX_UNDO_TO_PURGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于标记为 <code>TRX_UNDO_CACHED</code> 的 Undo Segment 会在 <code>trx_undo_insert_cleanup</code> &#x2F; <code>trx_undo_update_cleanup</code> 中添加到 insert cached list &#x2F; update cached list 头部。</p>
<p>对于 INSERT 类型的清理在 <code>trx_commit_in_memory()</code> 会直接释放掉标记为 <code>TRX_UNDO_TO_FREE</code> 的 Undo Segment。</p>
<p>UPDATE 类型的 Undo Segment 会等待 Purge 完毕回收。</p>
<h3 id="8-Undo-Log-Header"><a href="#8-Undo-Log-Header" class="headerlink" title="8. Undo Log Header"></a>8. Undo Log Header</h3><p>每个写事务会修改一些数据记录，对应产生一些 Undo Log Record。这些 Undo Log Record 连接在一起形成该事务的 Undo Log。这些 Undo Log Record 开头存在一个 Undo Log Header 记录一些信息。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo_log_header.png" width="300">


<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">占用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Transaction ID</td>
<td align="left">8</td>
<td align="left">事务 ID</td>
</tr>
<tr>
<td align="left">Delete Mark</td>
<td align="left">2</td>
<td align="left">表示该 Undo Log 是否存在 TRX_UNDO_DEL_MARK_REC 类型的 Undo Log Record，避免 Purge 时不必要的扫描</td>
</tr>
<tr>
<td align="left">Log Start Offset</td>
<td align="left">2</td>
<td align="left">记录 Undo Log Header 的结束位置，便于之后 Header 增加内容时的兼容</td>
</tr>
<tr>
<td align="left">Next Undo Log</td>
<td align="left">2</td>
<td align="left">后一个 Undo Log</td>
</tr>
<tr>
<td align="left">Prev Undo</td>
<td align="left">2</td>
<td align="left">前一个 Undo Log</td>
</tr>
</tbody></table>
<h3 id="8-Undo-Log-Record-结构"><a href="#8-Undo-Log-Record-结构" class="headerlink" title="8. Undo Log Record 结构"></a>8. Undo Log Record 结构</h3><p>主要分为两大类：</p>
<ul>
<li>insert undo log record</li>
<li>update undo log record<br>其中，update undo log record 还有其他更多的类别</li>
</ul>
<h4 id="8-1-Insert-Undo-Log-Record"><a href="#8-1-Insert-Undo-Log-Record" class="headerlink" title="8.1. Insert Undo Log Record"></a>8.1. Insert Undo Log Record</h4><p>TRX_UNDO_INSERT_REC</p>
<table>
<thead>
<tr>
<th align="left">TRX_UNDO_INSERT_REC</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">next (2)</td>
<td align="left">下一个 undo log 的位置</td>
</tr>
<tr>
<td align="left">type_cmpl (1)</td>
<td align="left">Undo 类型，TRX_UNDO_INSERT_REC: 11</td>
</tr>
<tr>
<td align="left">Undo Number</td>
<td align="left">在一个事务中从 0 开始递增</td>
</tr>
<tr>
<td align="left">Table ID</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Key Field 1 Length</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Key Field 1 Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">…</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Key Field n Length</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Key Field n Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">start</td>
<td align="left">undo 开始的位置</td>
</tr>
</tbody></table>
<blockquote>
<p>INSERT 操作的 undo log record 在事务提交后就可以删除</p>
</blockquote>
<h4 id="8-2-Update-Undo-Log-Record"><a href="#8-2-Update-Undo-Log-Record" class="headerlink" title="8.2. Update Undo Log Record"></a>8.2. Update Undo Log Record</h4><p>该类别的 Undo Log Record 可以再分为三种：</p>
<ul>
<li>TRX_UNDO_DEL_MARK_REC</li>
<li>TRX_UNDO_UPD_DEL_REC</li>
<li>TRX_UNDO_UPD_EXIST_REC</li>
</ul>
<p>TRX_UNDO_UPD_EXIST_REC</p>
<table>
<thead>
<tr>
<th align="left"><div style="width: 200px">字段</div></th>
<th align="left">占用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">end of record</td>
<td align="left">2</td>
<td align="left">本页中，该记录的末尾偏移量。只有当记录完全写完才能写入，事先不知道大小。</td>
</tr>
<tr>
<td align="left">type_cmpl</td>
<td align="left">1</td>
<td align="left">TRX_UNDO_UPD_EXIST_REC</td>
</tr>
<tr>
<td align="left">undo_no</td>
<td align="left"></td>
<td align="left">在一个事务中从 0 开始递增</td>
</tr>
<tr>
<td align="left">table id</td>
<td align="left"></td>
<td align="left">表 ID</td>
</tr>
<tr>
<td align="left">info bits</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">trx_id</td>
<td align="left">压缩</td>
<td align="left">旧记录的 trx_id</td>
</tr>
<tr>
<td align="left">roll_pointer</td>
<td align="left">压缩</td>
<td align="left">旧记录的 roll_pointer</td>
</tr>
<tr>
<td align="left">clustered index 1 length</td>
<td align="left"></td>
<td align="left">聚簇索引 1 长度</td>
</tr>
<tr>
<td align="left">clustered index 1 value</td>
<td align="left"></td>
<td align="left">聚簇索引 1 值</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">clustered index n length</td>
<td align="left"></td>
<td align="left">聚簇索引 n 长度</td>
</tr>
<tr>
<td align="left">clustered index n value</td>
<td align="left"></td>
<td align="left">聚簇索引 n 值</td>
</tr>
<tr>
<td align="left">n_updated</td>
<td align="left"></td>
<td align="left">共有多少个列被更新了</td>
</tr>
<tr>
<td align="left">len of index_col_info</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">索引列各列信息</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">start of record</td>
<td align="left">2</td>
<td align="left">本页中，该记录的起始偏移量</td>
</tr>
</tbody></table>
<p>TRX_UNDO_DEL_MARK_REC</p>
<table>
<thead>
<tr>
<th align="left"><div style="width: 200px">字段</div></th>
<th align="left">占用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">end of record (2)</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Type and Flags (1)</td>
<td align="left"></td>
<td align="left">TRX_UNDO_DEL_MARK_REC</td>
</tr>
<tr>
<td align="left">Undo Number</td>
<td align="left"></td>
<td align="left">在一个事务中从 0 开始递增</td>
</tr>
<tr>
<td align="left">Table ID</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Info Bits</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">trx_id</td>
<td align="left"></td>
<td align="left">旧记录的 trx_id</td>
</tr>
<tr>
<td align="left">roll_pointer</td>
<td align="left"></td>
<td align="left">旧记录的 roll_pointer</td>
</tr>
<tr>
<td align="left">clustered index 1 length</td>
<td align="left"></td>
<td align="left">聚簇索引 1 长度</td>
</tr>
<tr>
<td align="left">clustered index 1 value</td>
<td align="left"></td>
<td align="left">聚簇索引 1 值</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">clustered index n length</td>
<td align="left"></td>
<td align="left">聚簇索引 n 长度</td>
</tr>
<tr>
<td align="left">clustered index n value</td>
<td align="left"></td>
<td align="left">聚簇索引 n 值</td>
</tr>
<tr>
<td align="left">start of record</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">事务中 DELETE 仅将记录的 deleted_flag 标识设置为 1</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">当对每一条数据记录进行 delete mark 操作前，需要把该数据记录的 trx_id 和 roll_pointer 的旧值记录到 undo log record，再将 trx_id 和 roll_pointer 更新。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>撤销日志是为了实现事务原子性而出现的产物。事务处理过程中，如果出现了错误或者用户执行了 rollback 语句，MySQL 可以利用 undo log 中的信息将数据恢复到事务开始之前的状态<br>撤销日志在 MySQL InnoDB 存储引擎中还用来实现多版本并发控制。</p>
</blockquote>
<p>在全局临时表空间中的 Undo Log 用于事务修改用户定义的临时表中的数据。这些 Undo Log 不会记录 Redo Log，因为崩溃恢复不需要它们。它们仅在服务器运行时用于回滚。这种类型的 Undo Log 通过避免 Redo 日志 I&#x2F;O 对性能有帮助。<br>每个 undo 表空间和全局临时表空间最多支持 128 个回滚段。<code>innodb_rollback_segments</code> 变量定义了回滚段的数量。<br>事务最多分配 4 个 undo 日志，每个对应下面的操作类型：</p>
<ol>
<li><code>INSERT</code> 用户定义的表</li>
<li><code>UPDATE</code> 和 <code>DELETE</code> 用户定义的表</li>
<li><code>INSERT</code> 用户定义的临时表</li>
<li><code>UPDATE</code> 和 <code>DELETE</code> 用户定义的临时表<br>根据需要分配 undo 日志。例如，执行常规表和临时表上的 <code>INSERT</code>，<code>UPDATE</code>，以及 <code>DELETE</code> 操作的事务需要完全分配 4 个 undo 日志；仅在常规表上执行 <code>INSERT</code> 操作的事务只需要 1 个 undo 日志。</li>
</ol>
<ul>
<li>如果每个事务执行 <code>INSERT</code> 或者 <code>UPDATE</code> 或者 <code>DELETE</code> 操作之一，那么 InnoDB 可以支持的并发独写事务数是：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(innodb_page_size / 16) * innodb_rollback_segments * number of undo tablespaces</span><br></pre></td></tr></table></figure></li>
<li>如果每个事务执行 <code>INSERT</code> 加上 <code>UPDATE</code> 或者 <code>DELETE</code> 操作之一，那么 InnoDB 可以支持的并发独写事务数是：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(innodb_page_size / 16 / 2) * innodb_rollback_segments * number of undo tablespaces</span><br></pre></td></tr></table></figure></li>
<li>如果每个事务都在临时表上执行 <code>INSERT</code> 操作，那么 InnoDB 可以支持的并发独写事务数是：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(innodb_page_size / 16) * innodb_rollback_segments</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Undo-Log-分配"><a href="#Undo-Log-分配" class="headerlink" title="Undo Log 分配"></a>Undo Log 分配</h3><p>当开启一个事务的时候，会调用 <code>trx_assign_rseg_durable</code> 分配一个 Rollback Segment。<br>只读事务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trx_assign_rseg_temp();</span><br><span class="line">-&gt; get_next_temp_rseg();</span><br><span class="line">-&gt; trx_sys-&gt;tmp_rsegs</span><br></pre></td></tr></table></figure>
<p>读写事务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trx_assign_rseg_durable() </span><br><span class="line">-&gt; get_next_redo_rseg()</span><br><span class="line">    -&gt;get_next_redo_rseg_from_trx_sys() -&gt; (trx_sys-&gt;rsegs)</span><br><span class="line">      get_next_redo_rseg_from_undo_spaces() -&gt; (undo_space-&gt;rsegs())</span><br></pre></td></tr></table></figure>
<p>当 InnoDB 没有配置独立 Undo Tablespace 时， trx_sys-&gt;regs 为读写事务分配回滚段；否则从 undo_spaces-&gt;regs() 分配回滚段<br>当第一次真正产生修改需要写 Undo Log Record 的时候，调用 <code>trx_undo_assign_undo</code> 来获得一个 Undo Segment</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trx_undo_assign_undo(*trx. *undo_ptr, type) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     尝试获取缓存中可用的 Undo Log</span></span><br><span class="line"><span class="comment">     1. 对于 type == TRX_UNDO_INSERT</span></span><br><span class="line"><span class="comment">          从 rseg-&gt;insert_undo_cached 链表上获取 Undo Log 对象，并从链表移除</span></span><br><span class="line"><span class="comment">          之后调用 trx_undo_insert_header_reuse 重新初始化 Undo Page Header</span></span><br><span class="line"><span class="comment">     2. 对于 type == TRX_UNDO_UPDATE</span></span><br><span class="line"><span class="comment">          从 rseg-&gt;update_undo_cached 链表上获取 Undo Log 对象，并从链表移除</span></span><br><span class="line"><span class="comment">          之后调用 trx_undo_header_create 创建新的 Undo Log Header</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">          </span><br><span class="line">    undo = trx_undo_reuse_cached();</span><br><span class="line">    <span class="keyword">if</span> (undo == nullptr) &#123;</span><br><span class="line"><span class="comment">// 如果没有缓存的 Undo Log 对象，调用 trx_undo_create 从回滚段上分配一个空闲的 Undo Slot</span></span><br><span class="line">        trx_undo_create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Undo-Log-写入"><a href="#Undo-Log-写入" class="headerlink" title="Undo Log 写入"></a>Undo Log 写入</h3><h4 id="1-分配回滚段"><a href="#1-分配回滚段" class="headerlink" title="1. 分配回滚段"></a>1. 分配回滚段</h4><p>事务从调用 <code>trx_start_low</code> 函数开始。</p>
<p>当该事务被判定为读写模式时，会分配 TRX_ID 以及回滚段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来自 trx_start_low 片段</span></span><br><span class="line"><span class="keyword">if</span> (!trx-&gt;read_only &amp;&amp;</span><br><span class="line">      (trx-&gt;mysql_thd == nullptr || read_write || trx-&gt;ddl_operation)) &#123;</span><br><span class="line">    <span class="comment">// 分配 Rollback Segment</span></span><br><span class="line">    trx_assign_rseg_durable(trx);</span><br><span class="line">    <span class="comment">// 分配 TRX_ID</span></span><br><span class="line">    trx-&gt;id = trx_sys_allocate_trx_id();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当写事务开始时，会先调用 <code>trx_assign_rseg_durable</code>  分配一个 Rollback Segment。</p>
<p>分配策略：依次尝试下一个活跃的 Rollback Segment。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ Assign a durable rollback segment to a transaction in a round-robin</span><br><span class="line">fashion.</span><br><span class="line">@param[in,out]	trx	transaction that involves a durable write. */</span><br><span class="line"><span class="type">void</span> <span class="title function_">trx_assign_rseg_durable</span><span class="params">(<span class="type">trx_t</span> *trx)</span> &#123;</span><br><span class="line">  ut_ad(trx-&gt;rsegs.m_redo.rseg == nullptr);</span><br><span class="line"></span><br><span class="line">  trx-&gt;rsegs.m_redo.rseg = srv_read_only_mode ? nullptr : get_next_redo_rseg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用回滚段"><a href="#2-使用回滚段" class="headerlink" title="2. 使用回滚段"></a>2. 使用回滚段</h4><p>当第一次真正产生修改需要写 Undo Record 的时候，会从 <code>trx_undo_report_row_operation</code> 进入，接着调用 <code>trx_undo_assign_undo</code> 获得一个 Undo Segment。优先复用 <code>trx_rseg_t</code> 上 Cached List 中的 trx_undo_t，也就是已经分配出来但没有被正在使用的 Undo Segment。</p>
<p>如果没有缓存的 Undo Segment，才调用 <code>trx_undo_create</code> 创建新的 Undo Segment，<code>trx_undo_create</code> 会轮询选择当前 Rollback Segment 中可用的 Slot，申请新的 Undo Page，初始化 Undo Page Header，Undo Segment Header</p>
<h4 id="3-写入"><a href="#3-写入" class="headerlink" title="3. 写入"></a>3. 写入</h4><p>对于 INSERT UNDO LOG 写入的入口函数 <code>trx_undo_page_report_insert</code></p>
<p>对于 UPDATE UNDO LOG 写入的入口函数 <code>trx_undo_page_report_modify</code></p>
<p>在写入过程中，可能出现 Undo Page 空间不足的情况，当出现这种情况，会调用 <code>trx_undo_erase_page_end</code> 来清除刚刚写入的区域，然后调用 <code>trx_undo_add_page</code> 申请一个新的 Undo Page 加入到 Undo Page List，同时 undo-&gt;last_page_no 指向新的 Undo Page，重新尝试写入。</p>
<h1 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h1><h2 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h2><p>The System Tablespace</p>
<p>系统表空间是更改缓冲区的存储区域。如果在系统表空间中创建表，而不是每张表一个文件或者常规表空间，它也可能包含表和索引数据。在过于的版本中，系统表空间包含 InnoDB 的数据字典。在 MySQL 8.0 中，InnoDB 将元数据存储在数据字典中。<br>系统表空间可以有一个或者多个数据文件。默认地，会在数据文件夹下创建一个系统表空间数据文件，名为 <code>ibdata</code>。系统表空间的大小和数量由 innodb_data_file_path 启动项定义。</p>
<h2 id="File-Per-Table-Tablespaces"><a href="#File-Per-Table-Tablespaces" class="headerlink" title="File-Per-Table Tablespaces"></a>File-Per-Table Tablespaces</h2><p>对于单个 InnoDB 表，file-per-table 表空间包含了该表的数据以及索引，并存储于文件系统的单个文件中</p>
<h1 id="Redo-Log-重做日志用来实现事务的持久性"><a href="#Redo-Log-重做日志用来实现事务的持久性" class="headerlink" title="Redo Log 重做日志用来实现事务的持久性"></a>Redo Log 重做日志用来实现事务的持久性</h1><p>Redo Log 是在崩溃期间使用的基于磁盘的数据结构，以纠正不完整事务写入的数据。<br>在正常操作期间，Redo Log 将那些来自于 SQL 语句或者低级 API 调用的表数据修改操作请求进行编码。<br>在初始化并接受连接之前，那些由于无法预期的关闭导致未能将数据文件更新的修改操作会被重新执行。</p>
<blockquote>
<p>重做日志用来实现事务的持久性<br>默认地，Redo Log 在物理上表现为磁盘上两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 的文件。MySQL 以循环的方式写入 Redo Log 文件。根据受影响的记录，Redo Log 将它们编码；这些数据统称为 redo。</p>
</blockquote>
<h2 id="Changing-the-Number-or-Size-of-Redo-Log-Files"><a href="#Changing-the-Number-or-Size-of-Redo-Log-Files" class="headerlink" title="Changing the Number or Size of Redo Log Files"></a>Changing the Number or Size of Redo Log Files</h2><p>如果要修改 Redo Log 的大小数量，需要执行以下步骤：</p>
<ol>
<li>停止 MySQL Server 并确保它没有错误关闭</li>
<li>编辑 my.cnf 更改日志文件配置。要更改日志文件大小，配置 <code>innodb_log_file_size</code>。为了增加日志文件的数量，需配置 <code>innodb_log_files_in_group</code></li>
<li>再次启动 MySQL 服务<h2 id="Group-Commit-for-Redo-Log-Flushing"><a href="#Group-Commit-for-Redo-Log-Flushing" class="headerlink" title="Group Commit for Redo Log Flushing"></a>Group Commit for Redo Log Flushing</h2>与其他符合 ACID 数据库引擎一样，InnoDB 在提交事务之前会刷写（flush） Redo Log。InnoDB 使用组提交功能，将多个 flush 请求组合在一起，以避免为每个提交进行一次 flush 操作。使用组提交，InnoDB 向日志文件发出单个的写入，用于为同一时间的多个用户事务执行提交动作，这可以显著提高吞吐量。<h2 id="Redo-Log-Archiving"><a href="#Redo-Log-Archiving" class="headerlink" title="Redo Log Archiving"></a>Redo Log Archiving</h2>复制 Redo Log 记录的备份工具有时候可能会在进行备份操作时无法跟上 Redo Log 的生成速度，导致由于这些记录被覆盖而导致 Redo Log 记录丢失。在备份操作期间，存在着显著的 MySQL 服务活动，并且 Redo Log 文件存储介质比备份存储介质更快的速度运行时，最常常发生此问题。在 MySQL 8.0.17 中引入的重做记录归档功能，通过在 Redo Log 文件之外将 Redo Log 记录顺序写入归档文件来解决此事。<h2 id="Performance-Considerations"><a href="#Performance-Considerations" class="headerlink" title="Performance Considerations"></a>Performance Considerations</h2><img src="https://img-blog.csdnimg.cn/55d9b5977dcd478b9035dc0faee7a8fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA572Q6KOF6Z2i5YyF,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></li>
</ol>
<h1 id="Undo-Tablespaces"><a href="#Undo-Tablespaces" class="headerlink" title="Undo Tablespaces"></a>Undo Tablespaces</h1><p>撤销表空间包含 undo 日志，这些记录是包含有关如何撤销事务的最新的更改的信息。<br>InnoDB 是一个多版本的存储引擎。它可以保留有关更改行的旧版本的信息，以支持事务功能，例如并发和回滚。此信息以一个称为回滚段的数据结构，存储于 undo 表空间。回滚段驻留在 undo 表空间和全局临时表空间中。</p>
<h2 id="Default-Undo-Tablespaces"><a href="#Default-Undo-Tablespaces" class="headerlink" title="Default Undo Tablespaces"></a>Default Undo Tablespaces</h2><p>初始化 MySQL 实例的时候，会创建两个默认的 undo 表空间。<br>默认 undo 表空间的创建位置由 innodb_undo_directory 变量定义。如果 innodb_undo_directory 变量未定义，则再数据目录中创建默认的 undo 表空间。默认 undo 表空间数据文件名为 <code>undo_001</code> 和 <code>undo_002</code>。数据字典中定义的相应的 undo 表空间名称是 innodb_undo_001 和 innodb_undo_002</p>
<h2 id="Undo-Tablespace-Size"><a href="#Undo-Tablespace-Size" class="headerlink" title="Undo Tablespace Size"></a>Undo Tablespace Size</h2><p>在 MySQL 8.0.23 之前，undo 表空间的大小取决于 innodb_page_size。对于默认的 16K 页大小，初始 undo 表空间是 10MB。</p>
<h2 id="Dropping-Undo-Tablespaces"><a href="#Dropping-Undo-Tablespaces" class="headerlink" title="Dropping Undo Tablespaces"></a>Dropping Undo Tablespaces</h2><p>MySQL 8.0.14 可以使用 <code>DROP UNDO TABLESPACES</code> 语法在运行时删除使用 <code>CREATE UNDO TABLESPACES</code> 语法创建的表空间。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>ReadView，每个事务在读取数据的时候都会被分配一个视图，通过视图就可以判断其他事务对数据的可见性。</p>
<p>分配：通过 <code>trx_assign_read_view()</code> 分配视图</p>
<p>回收：事务结束时，会通过 <code>view_close()</code> 对其视图进行回收。</p>
<p><code>m_low_limit_id</code>：读取行为不应该看到 <code>trx_id</code> &gt;&#x3D; <code>m_low_limit_id</code> 的事务，即高水位。分配时取 <code>trx_sys::max_trx_id</code>，即当前还没有被分配的事务最大 ID</p>
<p><code>m_up_limit_id</code>：读取行为应该可以看到所有 trx_id &lt; <code>m_up_limit_id</code> 的事务，即低水位。低水位，如果m_ids不为空，取其最小值，否则取trx_sys::max_trx_id，即与高水位相等。</p>
<blockquote>
<p>关于 <code>m_low_limit_id</code> 和 <code>m_up_limit_id</code> 的解释以及高水位和低水位的比喻均来自于源码注释。</p>
</blockquote>
<p><code>m_ids</code>：在此视图初始化时，通过 <code>copy_trx_ids()</code> 从 <code>trx_sys::rw_trx_ids</code> 拷贝一份活跃事务ID(不包含当前事务ID)。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring Boot 整合 MyBatis 启动原理</title>
    <url>/2022/07/15/MyBatis/Spring-Boot-%E6%95%B4%E5%90%88-MyBatis-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Spring-Boot-整合-MyBatis-启动原理"><a href="#Spring-Boot-整合-MyBatis-启动原理" class="headerlink" title="Spring Boot 整合 MyBatis 启动原理"></a>Spring Boot 整合 MyBatis 启动原理</h1><p>需要知道，MyBatis 是通过 JDK 动态代理技术创建 Mapper 接口的代理类的。</p>
<p>MyBatis 整合 Spring Boot 需要解决的是如何将自己创建的代理对象（<code>java.lang.reflect.Proxy</code>）交给 Spring 容器管理，这与将一个类（Class）交给 Spring 管理有所不同。</p>
<blockquote>
<p>将对象交给 Spring 容器管理，我们可以选择注入 Bean Definition，然后让 Spring 完成对象构造、配置、初始化等操作，然后放到 <code>singletonObjects</code> 单例池中，也可以选择直接放到单例池中，也就是不构造 Bean Definition，也不会存在于 <code>beanDefinitionMap</code>，这就是下面提及的 <code>SingletonBeanRegistry.registerSingleton</code> 方式</p>
</blockquote>
<p>将自定义的对象交给 Spring 容器管理，一般考虑的方式是：</p>
<ul>
<li>@Bean</li>
<li>factory method</li>
<li>SingletonBeanRegistry.registerSingleton</li>
<li>FactoryBean</li>
</ul>
<p>对于 <code>@Bean</code> 方式，我们可以使用这种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserMapper <span class="title function_">videoMapper</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到 MapperRegistry.knownMappers，否则 SqlSession.getMapper 会抛出异常</span></span><br><span class="line">    sqlSession.getConfiguration().addMapper(UserMapper.class);</span><br><span class="line">    <span class="keyword">return</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方式的确可行，但是我们每定义一个 Mapper 就需要写一个 <code>@Bean</code> 方法，还是比较麻烦的。</p>
<p>factory method 注入的方式与 <code>@Bean</code> 大同小异。</p>
<p>MyBatis 整合进 Spring 选择的是 <code>FactoryBean</code> 方式，通过向容器注入 <code>FactoryBean</code> 这种特殊的 Bean Definitnion，进而注入 <code>Mapper</code></p>
<p>比较朴素的想法是，对于每个 <code>Mapper</code> 我们都为它定义一个 <code>FactoryBean</code>，但是这样工作量太大，MyBatis 通过动态 Class 实现了只需要一个 <code>MapperFactoryBean</code> 就可以构造出不同的 <code>Mapper</code> 实例</p>
<blockquote>
<p>底层对应 <code>MapperFactoryBean</code> 的类属性 <code>mapperInterface</code>，表示不同的 <code>Mapper</code> 接口的 <code>Class</code> 对象</p>
</blockquote>
<p>在使用 Spring 整合 MyBatis 的时候，通常会使用如下配置，这也是官网 <a href="http://mybatis.org/spring/getting-started.html">Getting Started</a> 提供的案例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.spring.sample.mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis Spring Boot Starter 为了解决上述这种按需配置 <code>MapperFactoryBean</code> 的繁琐步骤，引入了 Spring 类路径扫描机制。</p>
<h2 id="Spring-Boot-加载-Mapper"><a href="#Spring-Boot-加载-Mapper" class="headerlink" title="Spring Boot 加载 Mapper"></a>Spring Boot 加载 Mapper</h2><ol>
<li>Spring Boot 启动过程中，会调用 <code>AbstractApplicationContext</code> 的 <code>refresh</code> 方法，其中一个过程是 <code>invokeBeanFactoryPostProcessors</code>，它会调用 <code>ConfigurationClassPostProcessor</code> 后置处理器加载具有 <code>@Configuration</code> 注解的 Bean。</li>
<li><code>ConfigurationClassPostProcessor</code> 关注的是 <code>@Configuration</code> 类型的 Bean，它会判断该 Bean 是否包含 <code>@Import</code> 注解。假设我们将 <code>@MapperScan</code> 添加在主启动类上（一般是具有 <code>@SpringBootApplication</code> 注解），那么将会读取主启动类注解，发现具有 <code>@MapperScan</code>，而 <code>@MapperScan</code> 嵌套了 <code>@Import</code> 注解，value 为 <code>MapperScannerRegistrar.class</code>，因此，将会构造<code>MapperScannerRegistrar</code> Bean Definition 进入 Spring 容器</li>
</ol>
<p>当 <code>@Configuration</code> 类解析完毕加载到容器后，就会执行 <code>load</code> 方法，用于加载这些 <code>@Configuration</code> 类相关的 Bean、Resource 等（如 <code>@Import</code>, <code>@ImportResource</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses)</span><br></pre></td></tr></table></figure>

<p>当 <code>load</code> 完毕，此时 <code>MapperScannerRegistrar</code> 已经加载到 Spring 容器，而且 <code>load</code> 会主动触发 <code>MapperScannerRegistrar</code> 的回调方法 <code>registerBeanDefinitions</code>。</p>
<p><code>MapperScannerRegistrar</code> 是 <code>ImportBeanDefinitionRegistrars</code> 的子类，其关键方法 <code>registerBeanDefinitions</code> 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得 @MapperScan 的全部属性</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">mapperScanAttrs</span> <span class="operator">=</span> AnnotationAttributes</span><br><span class="line">        .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    <span class="keyword">if</span> (mapperScanAttrs != <span class="literal">null</span>) &#123;</span><br><span class="line">        registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,</span><br><span class="line">            generateBaseBeanName(importingClassMetadata, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在底层构造了一个 <code>MapperScannerConfigurer</code> Bean Definitnion，并注册到容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造 MapperScannerConfigurer Bean Definition</span></span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;processPropertyPlaceHolders&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass = annoAttrs.getClass(<span class="string">&quot;annotationClass&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;annotationClass&quot;</span>, annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">&quot;markerInterface&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;markerInterface&quot;</span>, markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; generatorClass = annoAttrs.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;nameGenerator&quot;</span>, BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">MapperFactoryBean</span>&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">&quot;factoryBean&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;mapperFactoryBeanClass&quot;</span>, mapperFactoryBeanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlSessionTemplateRef</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;sqlSessionTemplateRef&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(sqlSessionTemplateRef)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;sqlSessionTemplateBeanName&quot;</span>, annoAttrs.getString(<span class="string">&quot;sqlSessionTemplateRef&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlSessionFactoryRef</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;sqlSessionFactoryRef&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(sqlSessionFactoryRef)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span>, annoAttrs.getString(<span class="string">&quot;sqlSessionFactoryRef&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集 basePackage</span></span><br><span class="line">    List&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    basePackages.addAll(</span><br><span class="line">        Arrays.stream(annoAttrs.getStringArray(<span class="string">&quot;value&quot;</span>)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(<span class="string">&quot;basePackages&quot;</span>)).filter(StringUtils::hasText)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)).map(ClassUtils::getPackageName)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">        basePackages.add(getDefaultBasePackage(annoMeta));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">lazyInitialization</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;lazyInitialization&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;lazyInitialization&quot;</span>, lazyInitialization);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultScope</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;defaultScope&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!AbstractBeanDefinition.SCOPE_DEFAULT.equals(defaultScope)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;defaultScope&quot;</span>, defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 basePackage 属性，用逗号(,)分隔</span></span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;basePackage&quot;</span>, StringUtils.collectionToCommaDelimitedString(basePackages));</span><br><span class="line"></span><br><span class="line">    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MapperScannerConfigurer</code> 是 <code>BeanDefinitionRegistryPostProcessor</code> 的实现类，也就说其调用时机在 refresh 方法的 <code>invokeBeanFactoryPostProcessors</code> 中，它执行了类路径扫描，并注册了相关的 Mapper，关键方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">        processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建扫描器</span></span><br><span class="line">    <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">    scanner.setAddToConfig(<span class="built_in">this</span>.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(<span class="built_in">this</span>.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(<span class="built_in">this</span>.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(<span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(<span class="built_in">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(<span class="built_in">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(<span class="built_in">this</span>.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">        scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(defaultScope)) &#123;</span><br><span class="line">        scanner.setDefaultScope(defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将之前用逗号(,)分隔的 basePackage 字符串分解成 String[]</span></span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassPathBeanDefinitionScanner</code> 的 scan 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">beanCountAtScanStart</span> <span class="operator">=</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line">    doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassPathBeanDefinitionScanner</code> 的 doScan 方法如下，它返回扫描到的所有 <code>BeanDefinitionHolder</code> 的集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">                definitionHolder =</span><br><span class="line">                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis 覆盖了原来的 <code>doScan</code> 方法，因为我们不能把扫描到的 <code>Mapper</code> 接口交给 Spring 容器，否则后续的实例化将无法进行。因此，MyBatis 在调用 <code>super.doScan()</code> 方法得到扫描到的 <code>Set&lt;BeanDefinitionHolder&gt;</code> 之后又进行后置处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 Spring 内置提供的 doScan 方法</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">            + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 后置处理</span></span><br><span class="line">        processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis 的 <code>ClassPathMapperScanner</code> 后置处理方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> &#123; AbstractBeanDefinition definition;</span><br><span class="line">    <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry();</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">        definition = (AbstractBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">scopedProxy</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ScopedProxyFactoryBean.class.getName().equals(definition.getBeanClassName())) &#123;</span><br><span class="line">            definition = (AbstractBeanDefinition) Optional</span><br><span class="line">                .ofNullable(((RootBeanDefinition) definition).getDecoratedDefinition())</span><br><span class="line">                .map(BeanDefinitionHolder::getBeanDefinition).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;The target bean definition of scoped proxy bean not found. Root bean definition[&quot;</span> + holder + <span class="string">&quot;]&quot;</span>));</span><br><span class="line">            scopedProxy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扫描到的 Mapper 接口，因此这里获取到的应该是形如 UserMapper 之类的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> definition.getBeanClassName();</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Creating MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + beanClassName</span><br><span class="line">            + <span class="string">&quot;&#x27; mapperInterface&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mapper 接口是 Bean 原始的类型，但是实际类型是 MapperFactoryBean</span></span><br><span class="line">        <span class="comment">// 将原始类型（Mapper）作为构造器参数传入</span></span><br><span class="line">        definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <span class="comment">// issue #59</span></span><br><span class="line">        <span class="comment">// 将 BeanClass 强制修改为 MapperFactoryBean 类型</span></span><br><span class="line">        definition.setBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line"></span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;addToConfig&quot;</span>, <span class="built_in">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attribute for MockitoPostProcessor</span></span><br><span class="line">        <span class="comment">// https://github.com/mybatis/spring-boot-starter/issues/475</span></span><br><span class="line">        definition.setAttribute(FACTORY_BEAN_OBJECT_TYPE, beanClassName);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">explicitFactoryUsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">            LOGGER.warn(</span><br><span class="line">                () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">            LOGGER.warn(</span><br><span class="line">                () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        definition.setLazyInit(lazyInitialization);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (scopedProxy) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ConfigurableBeanFactory.SCOPE_SINGLETON.equals(definition.getScope()) &amp;&amp; defaultScope != <span class="literal">null</span>) &#123;</span><br><span class="line">        definition.setScope(defaultScope);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!definition.isSingleton()) &#123;</span><br><span class="line">        <span class="type">BeanDefinitionHolder</span> <span class="variable">proxyHolder</span> <span class="operator">=</span> ScopedProxyUtils.createScopedProxy(holder, registry, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (registry.containsBeanDefinition(proxyHolder.getBeanName())) &#123;</span><br><span class="line">            registry.removeBeanDefinition(proxyHolder.getBeanName());</span><br><span class="line">        &#125;</span><br><span class="line">        registry.registerBeanDefinition(proxyHolder.getBeanName(), proxyHolder.getBeanDefinition());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="AutoConfiguredMapperScannerRegistrar"><a href="#AutoConfiguredMapperScannerRegistrar" class="headerlink" title="AutoConfiguredMapperScannerRegistrar"></a>AutoConfiguredMapperScannerRegistrar</h3><p>如果没有发现 <code>MapperScannerConfigurer</code> 就会导入 <code>AutoConfiguredMapperScannerRegistrar</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="meta">@Import(AutoConfiguredMapperScannerRegistrar.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123; MapperFactoryBean.class, MapperScannerConfigurer.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">&quot;Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AutoConfiguredMapperScannerRegistrar</code> 的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguredMapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, ImportBeanDefinitionRegistrar &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!AutoConfigurationPackages.has(<span class="built_in">this</span>.beanFactory)) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Could not determine auto-configuration package, automatic mapper scanning disabled.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.debug(<span class="string">&quot;Searching for mappers annotated with @Mapper&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; packages = AutoConfigurationPackages.get(<span class="built_in">this</span>.beanFactory);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        packages.forEach(pkg -&gt; logger.debug(<span class="string">&quot;Using auto-configuration base package &#x27;&#123;&#125;&#x27;&quot;</span>, pkg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;processPropertyPlaceHolders&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;annotationClass&quot;</span>, Mapper.class);</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;basePackage&quot;</span>, StringUtils.collectionToCommaDelimitedString(packages));</span><br><span class="line">        <span class="type">BeanWrapper</span> <span class="variable">beanWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(MapperScannerConfigurer.class);</span><br><span class="line">        Set&lt;String&gt; propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">        <span class="keyword">if</span> (propertyNames.contains(<span class="string">&quot;lazyInitialization&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Need to mybatis-spring 2.0.2+</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;lazyInitialization&quot;</span>, <span class="string">&quot;$&#123;mybatis.lazy-initialization:false&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (propertyNames.contains(<span class="string">&quot;defaultScope&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Need to mybatis-spring 2.0.6+</span></span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;defaultScope&quot;</span>, <span class="string">&quot;$&#123;mybatis.mapper-default-scope:&#125;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;`</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>实现了 <code>BeanFactoryAware</code> 接口，因此该 Bean 在构造的过程中会自动调用 <code>setBeanFactory</code> 方法，使得该 Bean 获得 beanFactory 的引用</p>
<p>实现了 <code>ImportBeanDefinitionRegistrar</code> 接口，</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth 2.0 Client 设计</title>
    <url>/2022/08/04/Security/OAuth-2.0-Client-%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring boot web starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.oltu.oauth2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>org.apache.oltu.oauth2.client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul>
<li><p>AuthorizationServerConfig<br>接口，提供各个授权服务器的基本配置</p>
</li>
<li><p>AuthorizationServerToken<br>接口，提供各个授权服务器的 token 访问</p>
</li>
<li><p>AuthorizationServer<br>实体类，实现了 token 访问和基本信息访问</p>
</li>
</ul>
<p><code>AuthorizationServer.java</code> 用于表示该客户端接入的某一个授权服务器。</p>
<p>考虑到客户端可能接入多个授权服务器，因此需要维护客户端在不同授权服务器中的基础信息。</p>
<p>基础信息包括：</p>
<ul>
<li>name, 标识不同授权服务器</li>
<li>client_id, 该授权服务器中的 client_id</li>
<li>client_secret, 该授权服务器中 client_secret</li>
<li>access_token_uri, 该授权服务器暴露的 token 获取端点</li>
<li>user_info_uri, 该资源服务器暴露的 user_info 获取端点</li>
<li>redirect_uri, 跳转地址</li>
<li>…</li>
</ul>
<h4 id="AuthorizationServerConfig"><a href="#AuthorizationServerConfig" class="headerlink" title="AuthorizationServerConfig"></a>AuthorizationServerConfig</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiangchunbo.oauth2.client.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthorizationServerConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回授权服务器的唯一标识，如 baidu、tencent</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权服务器的 authorize 端点地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> authorize_uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getAuthorizeUri</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权服务器的 scope</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> scope</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getScope</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权地址额外的自定义参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> params</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getCustomParams</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * access_token 获取地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> access_token_uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getAccessTokenUri</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该授权服务器中的 client_id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client_id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getClientId</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该授权服务器中 client_secret</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client_secret</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getClientSecret</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳转地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> redirect_uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getRedirectUri</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户信息地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> user_info_uri</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getUserInfoUri</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AuthorizationServerToken"><a href="#AuthorizationServerToken" class="headerlink" title="AuthorizationServerToken"></a>AuthorizationServerToken</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jiangchunbo.oauth2.client.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthorizationServerToken</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回存储的 access token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> access token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getAccessToken</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回存储的 refresh token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> refresh token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getRefreshToken</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回存储的 access token 过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> access token 过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getAccessTokenExpire</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回存储的 refresh token 过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> refresh token 过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getRefreshTokenExpire</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AuthorizationServer"><a href="#AuthorizationServer" class="headerlink" title="AuthorizationServer"></a>AuthorizationServer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServer</span> <span class="keyword">implements</span> <span class="title class_">AuthorizationServerConfig</span>, AuthorizationServerToken &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String authorizeUri;</span><br><span class="line">    <span class="keyword">private</span> String scope;</span><br><span class="line">    <span class="keyword">private</span> String customParams;</span><br><span class="line">    <span class="keyword">private</span> String accessTokenUri;</span><br><span class="line">    <span class="keyword">private</span> String clientId;</span><br><span class="line">    <span class="keyword">private</span> String clientSecret;</span><br><span class="line">    <span class="keyword">private</span> String redirectUri;</span><br><span class="line">    <span class="keyword">private</span> String userInfoUri;</span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="keyword">private</span> String refreshToken;</span><br><span class="line">    <span class="keyword">private</span> String accessTokenExpire;</span><br><span class="line">    <span class="keyword">private</span> String refreshTokenExpire;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCustomParams</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> customParams;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCustomParams</span><span class="params">(String customParams)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customParams = customParams;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getScope</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setScope</span><span class="params">(String scope)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.scope = scope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccessTokenUri</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accessTokenUri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessTokenUri</span><span class="params">(String accessTokenUri)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accessTokenUri = accessTokenUri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClientId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClientId</span><span class="params">(String clientId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clientId = clientId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClientSecret</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClientSecret</span><span class="params">(String clientSecret)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clientSecret = clientSecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRedirectUri</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redirectUri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedirectUri</span><span class="params">(String redirectUri)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redirectUri = redirectUri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserInfoUri</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userInfoUri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserInfoUri</span><span class="params">(String userInfoUri)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userInfoUri = userInfoUri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthorizeUri</span><span class="params">(String authorizeUri)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authorizeUri = authorizeUri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthorizeUri</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.authorizeUri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccessToken</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessToken</span><span class="params">(String accessToken)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accessToken = accessToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRefreshToken</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRefreshToken</span><span class="params">(String refreshToken)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.refreshToken = refreshToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccessTokenExpire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accessTokenExpire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessTokenExpire</span><span class="params">(String accessTokenExpire)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accessTokenExpire = accessTokenExpire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRefreshTokenExpire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> refreshTokenExpire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRefreshTokenExpire</span><span class="params">(String refreshTokenExpire)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.refreshTokenExpire = refreshTokenExpire;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="授权服务器配置-Bean"><a href="#授权服务器配置-Bean" class="headerlink" title="授权服务器配置 Bean"></a>授权服务器配置 Bean</h3><p>创建 Bean 时调用 init 方法从数据库加载所有配置到内存</p>
<blockquote>
<p>也可以考虑从配置文件加载</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServerConfigProperties</span> <span class="keyword">extends</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, AuthorizationServerConfig&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AuthorizationServerMapper authorizationServerMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;AuthorizationServerConfig&gt; configs = authorizationServerMapper.selectAllConfig();</span><br><span class="line">        <span class="keyword">if</span> (configs != <span class="literal">null</span> &amp;&amp; !configs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (AuthorizationServerConfig config : configs) &#123;</span><br><span class="line">                <span class="built_in">this</span>.put(config.getName(), config);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DAO-Mapper"><a href="#DAO-Mapper" class="headerlink" title="DAO(Mapper)"></a>DAO(Mapper)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthorizationServerMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依据授权服务器的标识符从数据库访问信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 授权服务器标识符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 基本配置信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AuthorizationServerConfig <span class="title function_">selectConfigByName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库取出所有的授权服务器配置信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 授权服务器配置信息列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;AuthorizationServerConfig&gt; <span class="title function_">selectAllConfig</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 依据授权服务器的标识符从数据库取出信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 授权服务器标识符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 授权服务器信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AuthorizationServer <span class="title function_">selectByName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据主键 Id 更新存储的授权服务器 token 信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authorizationServer token 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id                  主键 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">updateTokenById</span><span class="params">(<span class="meta">@Param(&quot;authorizationServer&quot;)</span> AuthorizationServer authorizationServer, <span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.jiangchunbo.oauth2.client.mapper.AuthorizationServerMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateTokenById&quot;</span>&gt;</span></span><br><span class="line">        update `authorization_server`</span><br><span class="line">        set `access_token`=#&#123;authorizationServer.accessToken&#125;,</span><br><span class="line">            `access_token_expire`=#&#123;authorizationServer.accessTokenExpire&#125;,</span><br><span class="line">            `refresh_token`=#&#123;authorizationServer.refreshToken&#125;,</span><br><span class="line">            `refresh_token_expire` = #&#123;authorizationServer.refreshTokenExpire&#125;</span><br><span class="line">        where `id` = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectConfigByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.jiangchunbo.oauth2.client.entity.AuthorizationServer&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from `authorization_server`</span><br><span class="line">        where `name` = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.jiangchunbo.oauth2.client.entity.AuthorizationServer&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from `authorization_server`</span><br><span class="line">        where `name` = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAllConfig&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.jiangchunbo.oauth2.client.entity.AuthorizationServer&quot;</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from `authorization_server` where `is_del`=0</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthorizationServerService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新 token 相关信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authorizationServer token 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id                  主键 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 影响函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">updateTokenById</span><span class="params">(AuthorizationServer authorizationServer, Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 code 请求 access_token；如果缓存 token 未过期，则使用缓存 token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token code token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> access_token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getAccessToken</span><span class="params">(OAuthCodeToken token)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServerServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthorizationServerService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AuthorizationServerMapper authorizationServerMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">updateTokenById</span><span class="params">(AuthorizationServer authorizationServer, Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> authorizationServerMapper.updateTokenById(authorizationServer, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccessToken</span><span class="params">(OAuthCodeToken token)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> token.getName();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AuthorizationServer</span> <span class="variable">server</span> <span class="operator">=</span> authorizationServerMapper.selectByName(name);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;未找到 &quot;</span> + name + <span class="string">&quot; 相关的配置&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(server.getAccessToken()) &amp;&amp; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).parse(server.getAccessTokenExpire()).after(<span class="keyword">new</span> <span class="title class_">Date</span>())) &#123;</span><br><span class="line">            <span class="keyword">return</span> server.getAccessToken();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> token.getCode();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">OAuthClientRequest</span> <span class="variable">accessTokenRequest</span> <span class="operator">=</span> OAuthClientRequest.tokenLocation(server.getAccessTokenUri())</span><br><span class="line">                .setGrantType(GrantType.AUTHORIZATION_CODE)</span><br><span class="line">                .setClientId(server.getClientId())</span><br><span class="line">                .setClientSecret(server.getClientSecret())</span><br><span class="line">                .setCode(code)</span><br><span class="line">                .setRedirectURI(server.getRedirectUri())</span><br><span class="line">                .buildQueryMessage();</span><br><span class="line">        <span class="type">OAuthClient</span> <span class="variable">oAuthClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OAuthClient</span>(<span class="keyword">new</span> <span class="title class_">URLConnectionClient</span>());</span><br><span class="line">        <span class="type">OAuthAccessTokenResponse</span> <span class="variable">oAuthResponse</span> <span class="operator">=</span> oAuthClient.accessToken(accessTokenRequest, OAuth.HttpMethod.GET);</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> oAuthResponse.getAccessToken();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">refreshToken</span> <span class="operator">=</span> oAuthResponse.getRefreshToken();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">expiresIn</span> <span class="operator">=</span> oAuthResponse.getExpiresIn();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">accessTokenExpire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line">                .format(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expiresIn * <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">refreshTokenExpire</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line">                .format(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + <span class="number">10L</span> * <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AuthorizationServer</span> <span class="variable">authorizationServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthorizationServer</span>();</span><br><span class="line">        authorizationServer.setAccessToken(accessToken);</span><br><span class="line">        authorizationServer.setRefreshToken(refreshToken);</span><br><span class="line">        authorizationServer.setAccessTokenExpire(accessTokenExpire);</span><br><span class="line">        authorizationServer.setRefreshTokenExpire(refreshTokenExpire);</span><br><span class="line">        <span class="built_in">this</span>.updateTokenById(authorizationServer, server.getId());</span><br><span class="line">        <span class="keyword">return</span> accessToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Shiro-相关的准备"><a href="#Shiro-相关的准备" class="headerlink" title="Shiro 相关的准备"></a>Shiro 相关的准备</h3><h3 id="Shiro-配置类"><a href="#Shiro-配置类" class="headerlink" title="Shiro 配置类"></a>Shiro 配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;shiro.web.enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Realm <span class="title function_">baiduOAuthRealm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">BaiduOAuthRealm</span> <span class="variable">baiduOAuthRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaiduOAuthRealm</span>();</span><br><span class="line">        baiduOAuthRealm.setAuthenticationTokenClass(OAuthCodeToken.class);</span><br><span class="line">        <span class="keyword">return</span> baiduOAuthRealm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;oauth2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> OAuth2AuthenticationFilter <span class="title function_">oAuth2AuthenticationFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OAuth2AuthenticationFilter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FilterRegistrationBean&lt;OAuth2AuthenticationFilter&gt; <span class="title function_">oAuth2AuthenticationFilterRegistrationBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> FilterRegistrationBean&lt;OAuth2AuthenticationFilter&gt; registrationBean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();</span><br><span class="line">        registrationBean.setFilter(oAuth2AuthenticationFilter());</span><br><span class="line">        registrationBean.setEnabled(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 chain definition</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> chainDefinition</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">protected</span> ShiroFilterChainDefinition <span class="title function_">shiroFilterChainDefinition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultShiroFilterChainDefinition</span> <span class="variable">chainDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShiroFilterChainDefinition</span>();</span><br><span class="line">        chainDefinition.addPathDefinition(<span class="string">&quot;/index.html&quot;</span>, <span class="string">&quot;oauth2&quot;</span>);</span><br><span class="line">        chainDefinition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chainDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AuthenticatingFilter"><a href="#AuthenticatingFilter" class="headerlink" title="AuthenticatingFilter"></a>AuthenticatingFilter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuth2AuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">AuthenticatingFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">CODE_PARAM</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">NAME_PARAM</span> <span class="operator">=</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当 isAccessDenied 返回 true 时，回退到该方法，该方法一般会执行 login 逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否继续</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception executeLogin 抛出的一些异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> getSubject(request, response);</span><br><span class="line">        <span class="keyword">if</span> (!subject.isAuthenticated() &amp;&amp; !StringUtils.isEmpty(request.getParameter(CODE_PARAM))) &#123;</span><br><span class="line">            <span class="keyword">return</span> executeLogin(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 login 逻辑的时候创建的 token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行 login 的 token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationToken <span class="title function_">createToken</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> request.getParameter(CODE_PARAM);</span><br><span class="line">        code = !StringUtils.isEmpty(code) ? code : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(NAME_PARAM);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OAuthCodeToken</span>(name, code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录失败的逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token    token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e        异常信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否继续过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onLoginFailure</span><span class="params">(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> OAuthResponse.errorResponse(HttpServletResponse.SC_BAD_REQUEST)</span><br><span class="line">                    .setError(<span class="string">&quot;错误&quot;</span>)</span><br><span class="line">                    .setErrorDescription(e.getMessage())</span><br><span class="line">                    .buildJSONMessage().getBody();</span><br><span class="line">            response.setContentType(MediaType.APPLICATION_JSON_VALUE);</span><br><span class="line">            response.setCharacterEncoding(StandardCharsets.UTF_8.name());</span><br><span class="line">            response.getWriter().print(body);</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | OAuthSystemException ex) &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="AuthenticationToken"><a href="#AuthenticationToken" class="headerlink" title="AuthenticationToken"></a>AuthenticationToken</h3><p>存储 code 以及 name 标识授权服务器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OAuthCodeToken</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationToken</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个授权服务器方的名字标识，如: baidu、tencent</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OAuthCodeToken</span><span class="params">(String name, String code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getPrincipal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getCredentials</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p><code>OAuthRealm</code> 提供基本的 OAuth2 获取用户名的流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OAuthRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthenticatingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AuthorizationServerConfigProperties authorizationServerProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    AuthorizationServerService authorizationServerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">// 确保 token 中的 credential 与 authentication info 的 credentials 一致，否则后面验证会出错</span></span><br><span class="line">        <span class="type">OAuthCodeToken</span> <span class="variable">codeToken</span> <span class="operator">=</span> (OAuthCodeToken) token;</span><br><span class="line">        <span class="type">SimpleAuthenticationInfo</span> <span class="variable">authenticationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> extractUsername(codeToken);</span><br><span class="line">            authenticationInfo.setPrincipals(<span class="keyword">new</span> <span class="title class_">SimplePrincipalCollection</span>(username, getName()));</span><br><span class="line">            authenticationInfo.setCredentials(codeToken.getCode());</span><br><span class="line">            <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">extractUsername</span><span class="params">(OAuthCodeToken codeToken)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BaiduOAuthRealm</code> 实现了 <code>OAuthRealm</code>，返回 netdisk_name 名称</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaiduOAuthRealm</span> <span class="keyword">extends</span> <span class="title class_">OAuthRealm</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">extractUsername</span><span class="params">(OAuthCodeToken codeToken)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">OAuthClient</span> <span class="variable">oAuthClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OAuthClient</span>(<span class="keyword">new</span> <span class="title class_">URLConnectionClient</span>());</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">accessToken</span> <span class="operator">=</span> authorizationServerService.getAccessToken(codeToken);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AuthorizationServerConfig</span> <span class="variable">serverConfig</span> <span class="operator">=</span> authorizationServerProperties.get(codeToken.getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存 access_token 和 expires in</span></span><br><span class="line">            <span class="type">OAuthClientRequest</span> <span class="variable">userInfoRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OAuthBearerClientRequest</span>(serverConfig.getUserInfoUri())</span><br><span class="line">                    .setAccessToken(accessToken)</span><br><span class="line">                    .buildQueryMessage();</span><br><span class="line">            <span class="type">OAuthResourceResponse</span> <span class="variable">resourceResponse</span> <span class="operator">=</span> oAuthClient.resource(userInfoRequest, OAuth.HttpMethod.GET, OAuthResourceResponse.class);</span><br><span class="line">            <span class="keyword">final</span> Map&lt;String, Object&gt; data = JSONUtils.parseJSON(resourceResponse.getBody());</span><br><span class="line">            <span class="keyword">return</span> data.get(<span class="string">&quot;netdisk_name&quot;</span>).toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OAuthSystemException | OAuthProblemException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Spring Cloud Config</title>
    <url>/2022/07/17/Spring-Cloud/Spring-Cloud-Config/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/">Spring Cloud Config</a></h1><h2 id="1-Quick-Start"><a href="#1-Quick-Start" class="headerlink" title="1. Quick Start"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_quick_start">1. Quick Start</a></h2><blockquote>
<p>该章是官网的一个体验案例</p>
</blockquote>
<p>首先，启动服务，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> spring-cloud-config-server</span><br><span class="line">$ ../mvnw spring-boot:run</span><br></pre></td></tr></table></figure>
<p>服务是一个 Spring Boot 程序，你也可以从 IDE 运行。</p>
<p>接下来，试验一下客户端，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8888/foo/development</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;master&quot;</span>,<span class="string">&quot;propertySources&quot;</span>:[</span><br><span class="line">  &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;https://github.com/scratches/config-repo/foo-development.properties&quot;</span>,<span class="string">&quot;source&quot;</span>:&#123;<span class="string">&quot;bar&quot;</span>:<span class="string">&quot;spam&quot;</span>&#125;&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;https://github.com/scratches/config-repo/foo.properties&quot;</span>,<span class="string">&quot;source&quot;</span>:&#123;<span class="string">&quot;foo&quot;</span>:<span class="string">&quot;bar&quot;</span>&#125;&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure>

<p>定位属性资源的默认策略是去克隆一个 git 存储库（位于 <code>spring.cloud.config.server.git.uri</code>），并使用它去实例化一个迷你的 <code>SpringApplication</code>。</p>
<p>HTTP 服务以下格式的资源：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>

<h3 id="1-1-Client-Side-Usage"><a href="#1-1-Client-Side-Usage" class="headerlink" title="1.1. Client Side Usage"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_client_side_usage">1.1. Client Side Usage</a></h3><p>为了在应用程序中使用这些功能，你可以将其构建为依赖于 <code>spring-cloud-config-client</code> 的Spring Boot 项目。最简便的方法是使用 Spring Boot 启动器 <code>org.springframework.cloud:spring-cloud-starter-config</code>。对于 maven 用户以及 Gradle 和 Spring CLI 用户的 Spring IO 版本管理属性文件，也有一个父 POM 和 BOM（spring-cloud-starter-parent）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>现在，你可以创建一个标准的 Spring Boot 应用，就像下面的 HTTP 服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当这个 HTTP 服务启动的时候，它会从默认的监听于本地端口 8888 配置服务（如果启动了）获取外部配置。如果想修改默认行为，你可以修改 bootstrap.properties 中的配置服务的位置，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring.cloud.config.uri: http://myconfigserver.com</span><br></pre></td></tr></table></figure>

<p>默认地，如果应用名称没有设置，则会使用 <code>application</code>。如果要修改默认行为，可以使用 <code>spring.application.name</code> 进行修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name:</span> <span class="string">myapp</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>设置属性 <code>$&#123;spring.application.name&#125;</code> 不要使用保留字 <code>application-</code> 作为应用名前缀，防止无法解析出正确的资源。</li>
</ul>
</blockquote>
<h2 id="2-Spring-Cloud-Config-Server"><a href="#2-Spring-Cloud-Config-Server" class="headerlink" title="2. Spring Cloud Config Server"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_spring_cloud_config_server">2. Spring Cloud Config Server</a></h2><p>Spring Cloud Config Server 提供了一个用于外部配置的 HTTP 资源 API。通过使用 <code>@EnableConfigServer</code> 注解，服务就能嵌入到 Spring Boot 应用中。因此，下面的应用就是一个配置服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigServer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(ConfigServer.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和所有的 Spring Boot 应用一样，它默认运行在 8080 端口，但你可以将其切换到约定好的 8888 端口。最简单的方式是，通过配置 <code>spring.config.name=configserver</code> 来启动应用，这同时也设置了默认的存储库类型。</p>
<blockquote>
<p>注意，这种配置方式的依据是 Config Server jar 包下的 configserver.yml 文件。实际并没有作用，引用的是 github 上面的样本地址。</p>
</blockquote>
<p>另一种方式是使用你自己的 <code>application.properties</code>，如下所示：</p>
<p><strong>application.properties</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring.cloud.config.server.git.uri:</span> <span class="string">file://$&#123;user.home&#125;/config-repo</span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>$&#123;user.home&#125;/config-repo</code> 是一个包含 YAML 以及属性文件的 git 存储库。</p>
<blockquote>
<p>在 Windows 上，如果 git 存储库是一个绝对驱动的前缀，你需要再加一个 “&#x2F;“，例如：<code>file:///$&#123;user.home&#125;/config-repo)</code></p>
</blockquote>
<h3 id="2-1-Environment-Repository"><a href="#2-1-Environment-Repository" class="headerlink" title="2.1. Environment Repository"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_environment_repository">2.1. Environment Repository</a></h3><p>在什么地方存储配置服务的配置数据？管理此行为的策略是 <code>EnvironmentRepository</code>，服务 <code>Environment</code> 对象。这个 <code>Environment</code> 是 Spring Environment 的浅拷贝（包括 <code>propertySources</code> 作为主要功能）。<code>Environment</code> 资源是三个变量的参数化：</p>
<ul>
<li><code>&#123;application&#125;</code>，映射到 <code>spring.application.name</code></li>
<li><code>&#123;profile&#125;</code>，在客户端映射到 <code>spring.profiles.active</code></li>
<li><code>&#123;label&#125;</code></li>
</ul>
<p>存储库的实现通常表现得像一个 Spring Boot 程序，它从 <code>spring.config.name</code> 等于 <code>&#123;application&#125;</code> 以及 <code>spring.profiles.active</code> 等于 <code>&#123;profiles&#125;</code> 中加载配置文件。配置文件的优先规则也与常规的 Spring Boot 程序相同：激活的配置文件优先于默认值，如果又多个配置文件，则选择最后一个（类似向 Map 添加条目）。</p>
<p>如果存储库是基于文件的，那么服务器将从 application.yml 和 foo.yml 中创建一个 <code>Environment</code>。如果 YAML 文件在它们内部有指向 Spring 配置文件的文档，那么会使用更高的优先级。如果有特定的配置 YAML 文件，那么这些文件也以比默认值更高的优先级而使用。高优先级转换为在 <code>Environment</code> 中提前列出的 <code>PropertySource</code>。</p>
<h4 id="2-1-1-Git-Backend"><a href="#2-1-1-Git-Backend" class="headerlink" title="2.1.1. Git Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_git_backend">2.1.1. Git Backend</a></h4><p>默认的 <code>EnvironmentRepository</code> 的实现使用 Git 后端，这对于管理升级和物理环境，以及对于跟踪变化非常方便。要更改存储库的位置，你可以在 Config Server（例如在 <code>application.yml</code> 中）中设置 <code>spring.cloud.config.server.git.uri</code> 配置属性。如果你用一个 <code>file:</code> 前缀进行设置，则应从本地存储库工作，以便于你可以在没有服务器的情况下快速启动。但是，在这种情况下，服务直接在本地存储库上操作而无需克隆（无论是否是裸仓库都无关紧要，因为 Config Server 永远不会更改 “remote” 存储库）。为了扩展 Config Server 并使其高度可用，你需要将所有服务实例指向相同的存储库，因此只有共享文件系统才能起作用。甚至在这种情况下，最好将 <code>ssh:</code> 协议用于共享文件系统存储库，以便于服务可以克隆它，并将本地工作副本作为缓存。</p>
<h5 id="Skipping-SSL-Certificate-Validation"><a href="#Skipping-SSL-Certificate-Validation" class="headerlink" title="Skipping SSL Certificate Validation"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_skipping_ssl_certificate_validation">Skipping SSL Certificate Validation</a></h5><p>通过将 <code>git.skipSslValidation</code> 属性设置为 <code>true</code>（默认为 <code>false</code>），可以禁用配置服务器对 Git 服务器的 SSSL 证书校验：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://example.com/my/repo</span></span><br><span class="line">          <span class="attr">skipSslValidation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="Setting-HTTP-Connection-Timeout"><a href="#Setting-HTTP-Connection-Timeout" class="headerlink" title="Setting HTTP Connection Timeout"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_setting_http_connection_timeout">Setting HTTP Connection Timeout</a></h5><h4 id="2-1-3-File-System-Backend"><a href="#2-1-3-File-System-Backend" class="headerlink" title="2.1.3. File System Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_file_system_backend">2.1.3. File System Backend</a></h4><p>Config Server 中拥有一个 <code>native</code> profile，该配置不使用 Git，而是从本地类路径或者文件系加载配置文件。为了使用本地配置，以 <code>spring.profiles.active=native</code> 启动 Config Server。</p>
<p>搜索路径可以包含占位符 <code>&#123;application&#125;</code>, <code>&#123;profile&#125;</code>, <code>&#123;label&#125;</code>。通过这种方式，你可以在路径中分离目录并选择一个对你有意义的策略。</p>
<p>如果你没有在搜索路径中使用占位符，存储库还会将 <code>&#123;label&#125;</code> 参数追加到存储路径末尾，因此属性文件会从每个搜索路径，以及有一个 label 后缀的子目录去加载。因此，没有占位符的默认行为与在搜索路径末尾添加 <code>/&#123;label&#125;/</code> 相同。举个例子，<code>file:/tmp/config</code> 与 <code>file:/tmp/config,file:/tmp/config/&#123;label&#125;</code> 相同。这个行为可以通过设置 <code>spring.cloud.config.server.native.addLabelLocations=false</code> 从而禁用。</p>
<blockquote>
<ul>
<li>默认添加 label 后缀的行为很单纯，例如，你设置了 <code>spring.cloud.config.server.native.search-locations=file:///f:/profiles/application</code>，同时 label 参数为 dev，那么还会搜索的路径就是 <code>file:///f:/profiles/applicationdev</code>，并不会帮你自动添加路径分隔符 <code>/</code>，至少在 2.2.8.RELEASE 测试是如此。</li>
</ul>
</blockquote>
<h4 id="2-1-6-Sharing-Configuration-With-All-Applications"><a href="#2-1-6-Sharing-Configuration-With-All-Applications" class="headerlink" title="2.1.6. Sharing Configuration With All Applications"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_sharing_configuration_with_all_applications">2.1.6. Sharing Configuration With All Applications</a></h4><h5 id="2-1-6-1-File-Based-Repositories"><a href="#2-1-6-1-File-Based-Repositories" class="headerlink" title="2.1.6.1. File Based Repositories"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#spring-cloud-config-server-file-based-repositories">2.1.6.1. File Based Repositories</a></h5><p>使用基于文件的存储库，在所有客户端应用之间共享文件名为 <code>application*</code> 的资源（<code>application.properties</code>, <code>application.yml</code>, <code>application-*.properties</code> 等）。你可以使用具有这些文件名的资源来进行全局默认配置，并且根据需要让它们被应用特定的文件覆盖。</p>
<p>属性覆盖功能也可以用于设置全局默认，应用程序允许在本地覆盖它们。</p>
<blockquote>
<p>使用 native 配置文件（本地文件系统后端），你应该使用不属于服务自己的配置的指定搜索路径。否则，位于默认搜索路径中的 <code>application*</code> 资源会被移除，因为它们是服务的一部分。</p>
</blockquote>
<h4 id="2-1-7-JDBC-Backend"><a href="#2-1-7-JDBC-Backend" class="headerlink" title="2.1.7. JDBC Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_jdbc_backend">2.1.7. JDBC Backend</a></h4><p>Spring Cloud Config 服务支持 JDBC 作为配置属性的后端。你可以通过添加 <code>spring-jdbc</code> 到类路径，并使用 <code>jdbc</code> 配置，或者添加 <code>JdbcEnvironmentRepository</code> 该 bean 来启用此功能。</p>
<p>你可以通过设置 <code>spring.cloud.config.server.jdbc.enabled=false</code> 来禁用 <code>JdbcEnvironmentRepository</code> 的自动配置。</p>
<blockquote>
<p>至少 Spring Cloud Config 2.2.8.RELEASE 开始支持 enabled 属性</p>
</blockquote>
<p>数据库需要有一个名为 <code>PROPERTIES</code> 的表，列为 <code>APPLICATION</code>, <code>PROFILE</code>, <code>LABEL</code>, <code>KEY</code>, <code>VALUE</code>。所有的字段都是 Java 的 String 类型，因此你可以定义为 <code>VARCHAR</code>。属性值表现与它们来自 Spring Boot 属性文件 <code>&#123;application&#125;-&#123;profile&#125;.properties</code> 相同，包括所有的编码与解码，这些稍后会进行处理（即不会直接再存储库实现中）。</p>
<blockquote>
<p>默认的 SQL 为 <code>SELECT KEY, VALUE from PROPERTIES where APPLICATION=? and PROFILE=? and LABEL=?</code>，但这对于 MySQL 并不管用，因为 KEY 为关键字，应当被反引号包裹，否则在执行过程中报错。</p>
</blockquote>
<h4 id="2-1-8-Redis-Backend"><a href="#2-1-8-Redis-Backend" class="headerlink" title="2.1.8. Redis Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_redis_backend">2.1.8. Redis Backend</a></h4><h4 id="2-1-11-Composite-Environment-Repositories"><a href="#2-1-11-Composite-Environment-Repositories" class="headerlink" title="2.1.11 Composite Environment Repositories"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#composite-environment-repositories">2.1.11 Composite Environment Repositories</a></h4><p>从多个环境存储库提取配置数据。</p>
<h3 id="2-2-Health-Indicator"><a href="#2-2-Health-Indicator" class="headerlink" title="2.2.  Health Indicator"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_health_indicator">2.2.  Health Indicator</a></h3><p>配置服务器附带一个健康指示器，用于检查配置的 <code>EnvironmentRepository</code> 是否正常工作。默认地，它会请求 <code>EnvironmentRepository</code> 一个名为 <code>app</code> 的应用，<code>default</code> 的配置，由 <code>EnvironmentRepository</code> 实现提供的默认标签。</p>
<p>通过 <code>health.config.enabled=false</code>，你可以禁用健康指示器。</p>
<h3 id="2-3-Security"><a href="#2-3-Security" class="headerlink" title="2.3. Security"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_security">2.3. Security</a></h3><p>你可以以任何对你有意义的方法保护 Config Server（从物理网络安全到 OAuth2 持票人令牌），Spring Security 和 Spring Boot 提供了许多安全性的功能。</p>
<p>为了使用默认的 Spring Boot 配置 HTTP Basic 安全，需要包含 Spring Security 到类路径。默认具有一个名为 <code>user</code> 的用户名和随机生成的密码。实践中，随机密码并没有太大用处，推荐配置密码并加密。</p>
<blockquote>
<ul>
<li>需要包含 <code>spring-boot-starter-security</code> 依赖，以使用 Spring 的自动配置化的 HTTP Basic 安全</li>
<li>通过设置 <code>spring.security.user.password</code> 配置密码</li>
<li>客户端注意设置用户名和密码</li>
</ul>
</blockquote>
<h3 id="2-4-Encryption-and-Decryption"><a href="#2-4-Encryption-and-Decryption" class="headerlink" title="2.4. Encryption and Decryption"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_encryption_and_decryption">2.4. Encryption and Decryption</a></h3><blockquote>
<p>为了使用加密和解密功能，旧版本 JDK 需要下载完全的 <a href="https://www.oracle.com/java/technologies/javase-jce-all-downloads.html">JCD</a></p>
</blockquote>
<p>如果远程属性资源包含加密内容（以 <code>&#123;cipher&#125;</code> 开头），则先解密再通过 HTTP 发送。该设置的优点是：当属性值 “静止” 时，不需要以纯文本方式展示。如果值无法被解密，将会从属性源中删除它，并添加一个额外的有相同键的属性，但是具有 <code>invalid</code> 前缀，值意味着不适用。这主要是为了加密文本用作密码，有可能意外泄漏。</p>
<h3 id="2-5-Key-Management"><a href="#2-5-Key-Management" class="headerlink" title="2.5. Key Management"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_key_management">2.5. Key Management</a></h3><p>Config Server 可以使用对称加密或者非对称加密（RSA 密钥对）。选择不对称加密在安全性方面更优越，但使用对称密钥通常更方便，因为它是在 <code>bootstrap.properties</code> 中配置的单个属性值。</p>
<p>要配置对称密钥，你需要设置 <code>encryt.key</code> 为密钥字符串（或者使用 <code>ENCRYPT_KEY</code> 环境变量，可以脱离纯文本配置文件）。</p>
<h3 id="2-6-Creating-a-Key-Store-for-Testing"><a href="#2-6-Creating-a-Key-Store-for-Testing" class="headerlink" title="2.6. Creating a Key Store for Testing"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_creating_a_key_store_for_testing">2.6. Creating a Key Store for Testing</a></h3><p>使用 JDK 自带的 <code>keytool</code> 工具创建密钥库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ keytool -genkeypair -<span class="built_in">alias</span> mytestkey -keyalg RSA \</span><br><span class="line">  -dname <span class="string">&quot;CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US&quot;</span> \</span><br><span class="line">  -keypass changeme -keystore server.jks -storepass letmein</span><br></pre></td></tr></table></figure>

<p>将生成的 <code>server.jks</code> 文件放到类路径下，然后在 <code>bootstrap.yml</code> 进行配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">keyStore:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:/server.jks</span> <span class="comment"># keystore 文件存储路径</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">letmein</span> <span class="comment"># storepass 密钥仓库</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">mytestkey</span> <span class="comment"># 密钥对别名</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">changeme</span> <span class="comment"># keypass 用来保护所生成密钥对中的私钥</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-Using-Multiple-Keys-and-Key-Rotation"><a href="#2-7-Using-Multiple-Keys-and-Key-Rotation" class="headerlink" title="2.7. Using Multiple Keys and Key Rotation"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_using_multiple_keys_and_key_rotation">2.7. Using Multiple Keys and Key Rotation</a></h3><h3 id="2-8-Serving-Encrypted-Properties"><a href="#2-8-Serving-Encrypted-Properties" class="headerlink" title="2.8. Serving Encrypted Properties"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_serving_encrypted_properties">2.8. Serving Encrypted Properties</a></h3><p>有时候，你往客户端自行解密配置，而不是在配置中心解密完毕再传送过来。在这种情况下，如果你提供了 <code>encrypt.*</code> 相关配置来定位 key，你还是可以具有 <code>/encrypt</code> 和 <code>/decrypt</code> 端点，但是你需要在 <code>boostrap.[yml|properties]</code> 设置 <code>spring.cloud.config.server.encrypt.enabled=false</code> 来显式关闭传出属性的解密功能。如果你不关心端点，那么如果你没有配置 key 或者 enabled 标志，就能起作用了。</p>
<h2 id="3-Serving-Alternative-Formats"><a href="#3-Serving-Alternative-Formats" class="headerlink" title="3. Serving Alternative Formats"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_serving_alternative_formats">3. Serving Alternative Formats</a></h2><p>来自环境端点的默认 JSON 格式是完美被 Spring 应用消费的，因为它直接映射到 <code>Environment</code> 抽象上。如果你愿意，你也可以通过增加一个后缀（”.yml”, “.yaml” 或者 “.properties”）以 YAML 或者 Java 属性消费相同的数据。这对于那些不关心 JSON 端点的结构，或者额外元数据的应用来消费是非常有用的（例如，未使用 Spring 的应用可能会受益于此方法的简单性）。</p>
<h2 id="4-Serving-Plain-Text"><a href="#4-Serving-Plain-Text" class="headerlink" title="4. Serving Plain Text"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_serving_plain_text">4. Serving Plain Text</a></h2><p>不使用 <code>Environment</code> 抽象，你的应用可能需要对其环境量身定制的通用普通文本配置文件。Config Server 通过一个位于 <code>/&#123;application&#125;/&#123;profile&#125;/&#123;label&#125;/&#123;path&#125;</code> 的额外端点提供这些，其中，<code>application</code>，<code>profile</code>，<code>label</code> 与常规的环境端点有相同含义，但是 <code>path</code> 是一个文件名的路径（例如 log.xml）。此端点的源文件以与环境端点相同的方式定位。相同的搜索路径被用于 properties 和 YAML 文件。但是，仅返回第一个被匹配的资源，而不是聚合所有资源。</p>
<p>在资源被定位之后，以常规格式的占位符（<code>$&#123;...&#125;</code>）会被使用提供的 application name，profile，label 解析。以这种方式，资源端点与环境端点紧密集成。</p>
<h2 id="5-Embedding-the-Config-Server"><a href="#5-Embedding-the-Config-Server" class="headerlink" title="5. Embedding the Config Server"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_embedding_the_config_server">5. Embedding the Config Server</a></h2><p>配置服务最好以独立应用运行。但是，如果你需要，你也可以将其嵌入到另一个应用中。使用 <code>@EnableConfigServer</code> 注解，一个可选的属性 <code>spring.cloud.config.server.bootstrap</code> 在这种情况下是有用的。这是一个标记，指示该服务是否应该从它自己的远程存储库配置自己。默认地，该标记是关闭的，因为它可以延迟启动。但是，当嵌入另一个应用中时，将与任何其他应用程序以一样的方式启动是有意义的。将 <code>spring.cloud.config.server.bootstrap</code> 设置为 <code>true</code> 时，还必须使用符合环境存储库配置。</p>
<h2 id="6-Push-Notifications-and-Spring-Cloud-Bus"><a href="#6-Push-Notifications-and-Spring-Cloud-Bus" class="headerlink" title="6. Push Notifications and Spring Cloud Bus"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_push_notifications_and_spring_cloud_bus">6. Push Notifications and Spring Cloud Bus</a></h2><p>许多源代码存储库提供者（如 Github，Gitlab，Gitea, Gitee, Gogs, 或者 Bitbucket）通过 webhook 通知你存储库中的更改。你可以通过提供者的用户接口以一个 URL 和一组你感兴趣的事件配置 webhook。如果你添加了 <code>spring-cloud-config-monitor</code> 依赖，并且在你的配置中心激活了 Spring Cloud Bus，那么 <code>/monitor</code> 端点会被启用。</p>
<p>当 webhook 被激活时，配置服务会针对它认为可能已经更改的应用程序发送 <code>RefreshRemoteApplicationEvent</code> 。变更检测是策略化的。但是，默认地，它会寻找与应用程序名称匹配的文件中地变更。</p>
<h2 id="7-Spring-Cloud-Config-Client"><a href="#7-Spring-Cloud-Config-Client" class="headerlink" title="7. Spring Cloud Config Client"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_spring_cloud_config_client">7. Spring Cloud Config Client</a></h2><p>Spring Boot 应用可以立即使用 Spring Config 服务。</p>
<h3 id="7-1-Config-First-Bootstrap"><a href="#7-1-Config-First-Bootstrap" class="headerlink" title="7.1. Config First Bootstrap"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#config-first-bootstrap">7.1. Config First Bootstrap</a></h3><p>类路径上拥有 Spring Cloud Config Client 的应用程序，默认的行为是：当配置客户端启动时，它会绑定到 Config Server（通过 <code>spring.cloud.config.uri</code> 引导配置属性），并使用远程属性源初始化 Spring 的 <code>Environment</code>。</p>
<p>此行为的最终结果是，所有希望消费 Config Server 的客户端需要一个 <code>bootstrap.yml</code>，其中需要在 <code>spring.cloud.config.uri</code> 中配置好服务地址（默认是 <code>http://localhost:8888</code>）。</p>
<h3 id="7-2-Discovery-First-Bootstrap"><a href="#7-2-Discovery-First-Bootstrap" class="headerlink" title="7.2. Discovery First Bootstrap"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#discovery-first-bootstrap">7.2. Discovery First Bootstrap</a></h3><h3 id="7-3-Config-Client-Fail-Fast"><a href="#7-3-Config-Client-Fail-Fast" class="headerlink" title="7.3. Config Client Fail Fast"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#config-client-fail-fast">7.3. Config Client Fail Fast</a></h3><h3 id="7-4-Config-Client-Retry"><a href="#7-4-Config-Client-Retry" class="headerlink" title="7.4. Config Client Retry"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#config-client-retry">7.4. Config Client Retry</a></h3><h3 id="7-5-Locating-Remote-Configuration-Resources"><a href="#7-5-Locating-Remote-Configuration-Resources" class="headerlink" title="7.5. Locating Remote Configuration Resources"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_locating_remote_configuration_resources">7.5. Locating Remote Configuration Resources</a></h3><p>Config Service 从 <code>/&#123;application&#125;/&#123;profile&#125;/&#123;label&#125;</code> 供应属性源，在客户端应用中<strong>默认</strong>的绑定如下：</p>
<ul>
<li>“application”&#x3D;<code>$&#123;spring.application.name&#125;</code></li>
<li>“profile”&#x3D;<code>$&#123;spring.profiles.active&#125;</code></li>
<li>“label”&#x3D;”master”</li>
</ul>
<p>你可以通过设置 <code>spring.cloud.config.*</code> 来覆盖它们（此处 <code>*</code> 表示 <code>name</code>, <code>profile</code>, <code>label</code>）。</p>
<p><code>label</code> 对于回滚到之前的配置版本比较有用，使用默认的 Config Server 实现，它可以是 git label，分支名，commit ID。</p>
<p><code>label</code> 也可以用逗号分隔的列表表示，在这种情况下，列表中的项目会逐个尝试，直至成功（即只有一个有效）。当工作在功能分支上时，此行为可能比较有用，例如，你可能希望将 <code>label</code> 与你的分支对齐，但使其可选，在这种情况下，你可以使用 <code>spring.cloud.config.label=myfeature,develop</code>。</p>
<h3 id="7-6-Specifying-Multiple-Urls-for-the-Config-Server"><a href="#7-6-Specifying-Multiple-Urls-for-the-Config-Server" class="headerlink" title="7.6. Specifying Multiple Urls for the Config Server"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_specifying_multiple_urls_for_the_config_server">7.6. Specifying Multiple Urls for the Config Server</a></h3><h3 id="7-7-Configuring-Timeouts"><a href="#7-7-Configuring-Timeouts" class="headerlink" title="7.7. Configuring Timeouts"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_configuring_timeouts">7.7. Configuring Timeouts</a></h3><p>配置超时阈值：</p>
<ul>
<li>读取超时：<code>spring.cloud.config.request-read-timeout</code></li>
<li>连接超时：<code>spring.cloud.config.request-connect-timeout</code></li>
</ul>
<h3 id="7-8-Security"><a href="#7-8-Security" class="headerlink" title="7.8. Security"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_security_2">7.8. Security</a></h3><p>如果你使用 HTTP Basic 安全验证，客户端需要知晓密码（如果不是默认的，还需要用户名）。你可以通过配置服务的 URI 指定用户名和密码，或者通过 <code>username</code> 和 <code>password</code> 属性：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">     <span class="attr">uri:</span> <span class="string">https://user:secret@myconfig.mycompany.com</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">     <span class="attr">uri:</span> <span class="string">https://myconfig.mycompany.com</span></span><br><span class="line">     <span class="attr">username:</span> <span class="string">user</span></span><br><span class="line">     <span class="attr">password:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>spring.cloud.config.username</code> 和 <code>spring.cloud.config.password</code> 会覆盖 URI 里的值</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Netflix</title>
    <url>/2022/07/12/Spring-Cloud/Spring-Cloud-Netflix/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/">Spring Cloud Netflix</a></h1><h2 id="1-Service-Discovery-Eureka-Clients"><a href="#1-Service-Discovery-Eureka-Clients" class="headerlink" title="1. Service Discovery: Eureka Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#service-discovery-eureka-clients">1. Service Discovery: Eureka Clients</a></h2><p>服务发现是微服务架构的关键原则之一。手工配置每个客户端或基于某种约定是非常脆弱的。Eureka 是 Netflix 服务发现服务端和客户端。服务可以被配置和部署，变得高可用，每个服务都会复制其他已经注册服务的状态。</p>
<h3 id="1-1-How-to-Include-Eureka-Client"><a href="#1-1-How-to-Include-Eureka-Client" class="headerlink" title="1.1. How to Include Eureka Client"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-eureka-client-starter">1.1. How to Include Eureka Client</a></h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-Registering-with-Eureka"><a href="#1-2-Registering-with-Eureka" class="headerlink" title="1.2. Registering with Eureka"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#registering-with-eureka">1.2. Registering with Eureka</a></h3><p>当 Eureka Client 注册 Eureka Server 时，它会提供自己的元数据，比如：主机，端口，健康指示器 URL，主页等详细信息。Eureka Server 接收属于某个服务的每个实例的心跳消息。如果心跳在可配置的时间表上失败，则通常从注册表中删除实例。</p>
<p>以下实例展示了最小的 Eureka Client 应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(Application.class).web(<span class="literal">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>请注意，前面的示例展示了一个普通的 Spring Boot 应用。通过包含 <code>spring-cloud-starter-netflix-eureka-client</code> 于类路径，你的应用会自动注册到 Eureka Server。需要配置的就是定位 Eureka Server，如下示例所示：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>在前面的示例中，<code>defaultZone</code> 是一个魔术字符串备用值，它为任何没有表示首选项的客户端提供服务 URL（换句话说，这是一个有用的默认值）。</p>
<blockquote>
<p><code>defaultZone</code> 属性是大小写敏感，并且需要驼峰格式，因为 <code>serviceUrl</code> 属性是一个 <code>Map&lt;String, String&gt;</code>。因此，<code>defaultZone</code> 属性不遵循通常的 Spring Boot 蛇形约定 <code>default-zone</code>。</p>
</blockquote>
<p>默认的应用名（即，服务 ID），虚拟机主机名，以及非安全端口（从 <code>Environment</code> 中获取）分别是 <code>$&#123;spring.application.name&#125;</code>，<code>$&#123;spring.application.name&#125;</code>，以及 <code>$&#123;server.port&#125;</code>。</p>
<h3 id="1-3-Authenticating-with-the-Eureka-Server"><a href="#1-3-Authenticating-with-the-Eureka-Server" class="headerlink" title="1.3. Authenticating with the Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#authenticating-with-the-eureka-server">1.3. Authenticating with the Eureka Server</a></h3><p>如果 eureka.client.serviceUrl.defaultZone 之一有凭证嵌入其中，则会自动把 HTTP basic 认证添加到 eureka 客户端。</p>
<p><strong>注意</strong> 这里并不是给 URL 添加凭证，只是激活 HTTP basic 用于请求的认证。</p>
<h3 id="1-4-Status-Page-and-Health-Indicator"><a href="#1-4-Status-Page-and-Health-Indicator" class="headerlink" title="1.4. Status Page and Health Indicator"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#status-page-and-health-indicator">1.4. Status Page and Health Indicator</a></h3><h3 id="1-5-Registering-a-Secure-Application"><a href="#1-5-Registering-a-Secure-Application" class="headerlink" title="1.5. Registering a Secure Application"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#registering-a-secure-application">1.5. Registering a Secure Application</a></h3><p>如果你的应用希望通过 HTTPS 连接，你可以在 <code>EurekaInstanceConfig</code> 设置两个标记：</p>
<ul>
<li><code>eureka.instance.[nonSecurePortEnabled]=[false]</code></li>
<li><code>eureka.instance.[securePortEnabled]=[true]</code></li>
</ul>
<h3 id="1-6-Eureka’s-Health-Checks"><a href="#1-6-Eureka’s-Health-Checks" class="headerlink" title="1.6. Eureka’s Health Checks"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#eurekas-health-checks">1.6. Eureka’s Health Checks</a></h3><h3 id="1-7-Eureka-Metadata-for-Instances-and-Clients"><a href="#1-7-Eureka-Metadata-for-Instances-and-Clients" class="headerlink" title="1.7. Eureka Metadata for Instances and Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#eureka-metadata-for-instances-and-clients">1.7. Eureka Metadata for Instances and Clients</a></h3><h4 id="1-7-1-Using-Eureka-on-Cloud-Foundry"><a href="#1-7-1-Using-Eureka-on-Cloud-Foundry" class="headerlink" title="1.7.1. Using Eureka on Cloud Foundry"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-eureka-on-cloud-foundry">1.7.1. Using Eureka on Cloud Foundry</a></h4><h4 id="1-7-2-Using-Eureka-on-AWS"><a href="#1-7-2-Using-Eureka-on-AWS" class="headerlink" title="1.7.2. Using Eureka on AWS"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-eureka-on-aws">1.7.2. Using Eureka on AWS</a></h4><p>如果你计划将应用程序部署到 AWS 云上，则必须将 Eureka 实例配置为 AWS-aware。你可以通过自定义 <code>EurekaInstanceConfigBean</code> 来做到这一点，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&quot;!default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> EurekaInstanceConfigBean <span class="title function_">eurekaInstanceConfig</span><span class="params">(InetUtils inetUtils)</span> &#123;</span><br><span class="line">  <span class="type">EurekaInstanceConfigBean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EurekaInstanceConfigBean</span>(inetUtils);</span><br><span class="line">  <span class="type">AmazonInfo</span> <span class="variable">info</span> <span class="operator">=</span> AmazonInfo.Builder.newBuilder().autoBuild(<span class="string">&quot;eureka&quot;</span>);</span><br><span class="line">  b.setDataCenterInfo(info);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-3-Changing-the-Eureka-Instance-ID"><a href="#1-7-3-Changing-the-Eureka-Instance-ID" class="headerlink" title="1.7.3. Changing the Eureka Instance ID"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#changing-the-eureka-instance-id">1.7.3. Changing the Eureka Instance ID</a></h3><p>一般地，NetFlix Eureka 实例以 host name 注册为其主机名。Spring Cloud Eureka 提供了一个明确的默认值：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$&#123;spring.cloud.client.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>例如：<code>myhost:myappname:8080</code></p>
<p>在 Spring Cloud 中，你可以通过提供唯一标识符 <code>eureka.instance.instanceId</code> 来覆盖该值：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instanceId:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;vcap.application.instance_id:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-Using-the-EurekaClient"><a href="#1-8-Using-the-EurekaClient" class="headerlink" title="1.8. Using the EurekaClient"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-the-eurekaclient">1.8. Using the EurekaClient</a></h3><p>一旦你拥有一个发现客户端的应用程序，你可以使用它从 Eureka Server 发现服务实例。这样做的一种方法是使用本地 <code>com.netflix.discovery.EurekaClient</code></p>
<h2 id="1-9-Alternatives-to-the-Native-Netflix-EurekaClient"><a href="#1-9-Alternatives-to-the-Native-Netflix-EurekaClient" class="headerlink" title="1.9. Alternatives to the Native Netflix EurekaClient"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#alternatives-to-the-native-netflix-eurekaclient">1.9. Alternatives to the Native Netflix EurekaClient</a></h2><p>你无需使用原生的 NetFlix 的 <code>EurekaClient</code>。而且，在某种形式的包装之后通常会更容易使用它。通过逻辑 eureka 服务标识符（VIPs）而不是物理 URL，Spring Cloud 支持 Feign（一个 REST 客户端构建器）以及 Spring RestTemplate。</p>
<h2 id="1-10-Why-Is-It-so-Slow-to-Register-a-Service"><a href="#1-10-Why-Is-It-so-Slow-to-Register-a-Service" class="headerlink" title="1.10. Why Is It so Slow to Register a Service?"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#why-is-it-so-slow-to-register-a-service">1.10. Why Is It so Slow to Register a Service?</a></h2><p>作为一个实例，还涉及到向注册中心（通过 client 的 serviceUrl）的定期心跳，默认时间为 30 秒。一个服务，直到该实例，注册中心，客户端缓存中都有相同的元数据（因此需要 3 个心跳），客户端才能发现其不可用。你可以通过设置 <code>eureka.instance.leaseRenewalIntervalInSeconds</code> 来更改周期。将其设置为小于 30 的值，可以加快客户端连接到其他服务的进程。在生产中，由于注册中心的内部计算对租赁续期做了假设，因此最好坚持使用默认值。</p>
<h1 id="2-Service-Discovery-Eureka-Server"><a href="#2-Service-Discovery-Eureka-Server" class="headerlink" title="2. Service Discovery: Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server">2. Service Discovery: Eureka Server</a></h1><p><a href="https://gitee.com/jiang_chun_bo/cannedbread-parent/tree/master/cannedbread-eureka-server">参考配置</a></p>
<h2 id="2-1-How-to-Include-Eureka-Server"><a href="#2-1-How-to-Include-Eureka-Server" class="headerlink" title="2.1. How to Include Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-eureka-server-starter">2.1. How to Include Eureka Server</a></h2><p>要在你的项目中包含 Eureka Server，请使用 group ID 为 <code>org.springframework.cloud</code> 以及 artifact ID 为 <code>spring-cloud-starter-netflix-eureka-server</code> 的 starter。参见 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</a></p>
<h2 id="2-2-How-to-Run-a-Eureka-Server"><a href="#2-2-How-to-Run-a-Eureka-Server" class="headerlink" title="2.2. How to Run a Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-running-eureka-server">2.2. How to Run a Eureka Server</a></h2><p>服务端有一个主页和 HTTP API （在 &#x2F;eureka&#x2F;* 下）。</p>
<p>&amp;nbsp;</p>
<h2 id="2-3-High-Availability-Zones-and-Regions"><a href="#2-3-High-Availability-Zones-and-Regions" class="headerlink" title="2.3. High Availability, Zones and Regions"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-zones-and-regions">2.3. High Availability, Zones and Regions</a></h2><p>Eureka 服务端并没有后端存储，但是注册表中的服务实例都必须发送心跳，来保持它们的注册最新（这可以在内存中完成）。客户端还有一个内存中的 Eureka 注册缓存，因此对于每个服务的请求，不必跳转到注册表。</p>
<p>默认情况下，每个 Eureka 服务端也是 Eureka 客户端，至少需要一个服务 URL 来定位对等体。如果没有提供服务 URL，服务跑起来并开始工作，就会填充大量的噪音到日志中（无法与对等体注册的异常）。</p>
<p>&amp;nbsp;</p>
<h2 id="2-4-Standalone-Mode"><a href="#2-4-Standalone-Mode" class="headerlink" title="2.4. Standalone Mode"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-standalone-mode">2.4. Standalone Mode</a></h2><p>双缓存和心跳机制，两者组合可以让独立 Eureka Server 对于失败具有相当的弹性，只要有某种监视器或者弹性的运行时间保持存活。在独立模式下，你可能更希望关闭客户端行为，避免不断尝试并无法达到对等体的错误。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> serviceUrl 需要指向本地实例相同的主机。</p>
<h2 id="2-5-Peer-Awareness"><a href="#2-5-Peer-Awareness" class="headerlink" title="2.5. Peer Awareness"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-peer-awareness">2.5. Peer Awareness</a></h2><p>通过运行多个实例，并让他们互相注册，eureka 可以变得更具有弹性和可用性。实际上，这是默认的行为，所以你只需要向对等体添加有效的 serviceUrl 即可。</p>
<p>为了在单个主机上体验对等感知，可以操作 <code>/etc/hosts</code> 文件来解析主机名。实际上，如果运行在一台已知主机名的机器上时，没有必要配置 <code>eureka.instance.hostname</code>。默认地，会使用 <code>java.net.InetAddress</code> 寻找。</p>
<p>你可以向一个系统添加多个对等体，只要它们通过至少边缘彼此连接，它们之间就会同步注册信息。如果对等体物理分离，那么系统原则上存在脑裂的问题。</p>
<h2 id="2-6-When-to-Prefer-IP-Address"><a href="#2-6-When-to-Prefer-IP-Address" class="headerlink" title="2.6. When to Prefer IP Address"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-prefer-ip-address">2.6. When to Prefer IP Address</a></h2><p>在某些情况下，eureka 更偏向于建议使用服务的 IP 而不是主机名。设置 <code>eureka.instance.preferIpAddress</code> 为 true，那么当应用注册到 eureka 时，将会使用 IP 地址而不是主机名。</p>
<blockquote>
<p>如果 Java 无法确定 hostname，那么就会发送 IP 地址给 eureka。</p>
</blockquote>
<h2 id="2-8-Disabling-Ribbon-with-Eureka-Server-and-Client-starters"><a href="#2-8-Disabling-Ribbon-with-Eureka-Server-and-Client-starters" class="headerlink" title="2.8. Disabling Ribbon with Eureka Server and Client starters"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#disabling-ribbon-with-eureka-server-and-client-starters">2.8. Disabling Ribbon with Eureka Server and Client starters</a></h2><p><code>spring-cloud-starter-netflix-eureka-server</code> 和 <code>spring-cloud-starter-netflix-eureka-client</code> y与 <code>spring-cloud-starter-netflix-ribbon</code> 一起出现。由于 Ribbon 负载均衡处于维护模式，因此我们建议切换使用 Spring Cloud LoadBalancer，也包含在 Eureka starter 中。</p>
<p>为此，你可以将 <code>spring.cloud.loadbalancer.ribbon.enabled</code> 属性设置为 <code>false</code>。</p>
<p>然后，你还可以从构建文件中地 Eureka starter 中排除 ribbon 相关的依赖，像这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Circuit-Breaker-Spring-Cloud-Circuit-Breaker-With-Hystrix"><a href="#3-Circuit-Breaker-Spring-Cloud-Circuit-Breaker-With-Hystrix" class="headerlink" title="3. Circuit Breaker: Spring Cloud Circuit Breaker With Hystrix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix">3. Circuit Breaker: Spring Cloud Circuit Breaker With Hystrix</a></h2><h3 id="3-1-Disabling-Spring-Cloud-Circuit-Breaker-Hystrix"><a href="#3-1-Disabling-Spring-Cloud-Circuit-Breaker-Hystrix" class="headerlink" title="3.1. Disabling Spring Cloud Circuit Breaker Hystrix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#disabling-spring-cloud-circuit-breaker-hystrix">3.1. Disabling Spring Cloud Circuit Breaker Hystrix</a></h3><p>你可以通过设置 <code>spring.cloud.circuitbreaker.hystrix.enabled</code> 为 <code>false</code> 来禁用自动配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.cloud.circuitbreaker.hystrix.enabled=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-Configuring-Hystrix-Circuit-Breakers"><a href="#3-2-Configuring-Hystrix-Circuit-Breakers" class="headerlink" title="3.2. Configuring Hystrix Circuit Breakers"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#configuring-hystrix-circuit-breakers">3.2. Configuring Hystrix Circuit Breakers</a></h3><h4 id="3-2-1-Default-Configuration"><a href="#3-2-1-Default-Configuration" class="headerlink" title="3.2.1. Default Configuration"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#default-configuration">3.2.1. Default Configuration</a></h4><p>为了给您所有的断路器提供默认配置，请创建传递一个 <code>HystrixCircuitBreakerFactory</code> 或者 <code>ReactiveHystrixCircuitBreakerFactory</code> 的 <code>Customize</code> Bean。<code>configureDefault</code> 方法可用于提供默认配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;HystrixCircuitBreakerFactory&gt; <span class="title function_">defaultConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configureDefault(id -&gt; HystrixCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))</span><br><span class="line">            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">            .withExecutionTimeoutInMilliseconds(<span class="number">4000</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Reactive-Example"><a href="#Reactive-Example" class="headerlink" title="Reactive Example"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#reactive-example">Reactive Example</a></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;ReactiveHystrixCircuitBreakerFactory&gt; <span class="title function_">defaultConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configureDefault(id -&gt; HystrixObservableCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))</span><br><span class="line">            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                    .withExecutionTimeoutInMilliseconds(<span class="number">4000</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-Specific-Circuit-Breaker-Configuration"><a href="#3-2-2-Specific-Circuit-Breaker-Configuration" class="headerlink" title="3.2.2. Specific Circuit Breaker Configuration"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#specific-circuit-breaker-configuration">3.2.2. Specific Circuit Breaker Configuration</a></h4><p>类似于提供默认配置，您可以传递一个 <code>HystrixCircuitBreakerFactory</code> 创建一个 <code>Customize</code> Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;HystrixCircuitBreakerFactory&gt; <span class="title function_">customizer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configure(builder -&gt; builder.commandProperties(</span><br><span class="line">                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(<span class="number">2000</span>)), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Reactive-Example-1"><a href="#Reactive-Example-1" class="headerlink" title="Reactive Example"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#reactive-example-2">Reactive Example</a></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;ReactiveHystrixCircuitBreakerFactory&gt; <span class="title function_">customizer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configure(builder -&gt; builder.commandProperties(</span><br><span class="line">                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(<span class="number">2000</span>)), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Circuit-Breaker-Hystrix-Clients"><a href="#4-Circuit-Breaker-Hystrix-Clients" class="headerlink" title="4. Circuit Breaker: Hystrix Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#circuit-breaker-hystrix-clients">4. Circuit Breaker: Hystrix Clients</a></h2><p>Netflix 已经创建了一个名为 Hystrix 的库，该库实现了 <a href="https://martinfowler.com/bliki/CircuitBreaker.html">circuit breaker pattern</a>（熔断器模式）。在微服务体系结构中，通常具有多层服务调用，如下示例所示：</p>
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/main/docs/src/main/asciidoc/images/Hystrix.png">

<p><strong>Figure 1. Microservice Graph</strong></p>
<p>较低级别的服务失败可能导致级联失败，直至用户。当对特定服务调用超过 <code>circuitBreaker.requestVolumeThreshold</code>（默认是 20 次请求），并且，在一个由 <code>metrics.rollingStats.timeInMilliseconds</code> 定义滑动窗口（默认为 10 秒）内，失败百分比大于 <code>circuitBreaker.errorThresholdPercentage</code>（默认 &gt;50%）， 熔断器会打开，并且不进行调用。在出错并且熔断器打开的情况下，开发者可以提供一个 fallback。</p>
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/main/docs/src/main/asciidoc/images/HystrixFallback.png">

<p><strong>Figure 2. Hystrix fallback prevents cascading failures</strong></p>
<h2 id="4-1-How-to-Include-Hystrix"><a href="#4-1-How-to-Include-Hystrix" class="headerlink" title="4.1. How to Include Hystrix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#how-to-include-hystrix">4.1. How to Include Hystrix</a></h2><p>若要在你的项目中包含 Hystrix，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-netflix-hystrix</code> 的 starter。</p>
<p>下面示例展示了一个极简的带有 Hystrix 熔断器的 Eureka 服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(Application.class).web(<span class="literal">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoreIntegration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getStores</span><span class="params">(Map&lt;String, Object&gt; parameters)</span> &#123;</span><br><span class="line">        <span class="comment">//do stuff that might fail</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">defaultStores</span><span class="params">(Map&lt;String, Object&gt; parameters)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/* something useful */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>@HystrixCommand</code> 由名为 <a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica">“javanica”</a> 的 Netflix contrib 库提供。Spring Cloud 以代理的方式包装具有该注解的 Spring Bean，用于连接到 Hystrix 熔断器。熔断器计算何时打开和关闭回路，以及在失败的情况下做什么。</p>
<p>要配置 <code>@HystrixCommand</code>，你可以以 <code>@HystrixProperty</code> 注解列表的形式使用 <code>commandProperties</code> 属性。有关更多详情，请参见<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration">此处</a>。有关可用属性的详细信息，参见 <a href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix wiki</a></p>
<h2 id="4-2-Propagating-the-Security-Context-or-Using-Spring-Scopes"><a href="#4-2-Propagating-the-Security-Context-or-Using-Spring-Scopes" class="headerlink" title="4.2. Propagating the Security Context or Using Spring Scopes"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-hystrix-starter">4.2. Propagating the Security Context or Using Spring Scopes</a></h2><p>如果你希望一些线程的本地上下文传播到 <code>@HystrixCommand</code>，默认声明并不起作用，因为它在线程池中执行命令（在超时情况下）。你可以通过配置或者直接在注解上，请求 Hystrix 使用不同的 “Isolation Strategy”，切换 Hystrix 使用相同的线程作为调用者。以下示例演示了在注解中设置线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;stubMyService&quot;,</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;</span></span><br><span class="line"><span class="meta">      @HystrixProperty(name=&quot;execution.isolation.strategy&quot;, value=&quot;SEMAPHORE&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Health-Indicator"><a href="#4-3-Health-Indicator" class="headerlink" title="4.3. Health Indicator"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#health-indicator">4.3. Health Indicator</a></h3><p>连接熔断器的状态也可以暴露在调用应用的 <code>/health</code> 端点上，如下示例所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hystrix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;openCircuitBreakers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;StoreIntegration::getStoresByLocationLink&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CIRCUIT_OPEN&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-Hystrix-Metrics-Stream"><a href="#4-4-Hystrix-Metrics-Stream" class="headerlink" title="4.4. Hystrix Metrics Stream"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#hystrix-metrics-stream">4.4. Hystrix Metrics Stream</a></h3><p>若要启动 Hystrix metrics stream，请包含关于 <code>spring-boot-starter-actuator</code> 的依赖，并设置 <code>management.endpoints.web.exposure.include=hystrix.stream</code>。这样做会暴露 <code>/actuator/hystrix.stream</code> 作为管理端点，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-Circuit-Breaker-Hystrix-Dashboard"><a href="#5-Circuit-Breaker-Hystrix-Dashboard" class="headerlink" title="5. Circuit Breaker: Hystrix Dashboard"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#circuit-breaker-hystrix-dashboard">5. Circuit Breaker: Hystrix Dashboard</a></h2><p>只需要引入以下依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置类添加以下注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure>


<h2 id="6-Hystrix-Timeouts-And-Ribbon-Clients"><a href="#6-Hystrix-Timeouts-And-Ribbon-Clients" class="headerlink" title="6. Hystrix Timeouts And Ribbon Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#hystrix-timeouts-and-ribbon-clients">6. Hystrix Timeouts And Ribbon Clients</a></h2><p>当使用 Hystrix command 包装你希望的 Ribbon 客户端时，确保你的 Hystrix 配置的 timeout 比 Ribbon 配置的 timeout 更长，包括任何可能的重试。例如，如果你的 Ribbon 连接 timeout 是 1 秒，并且 Ribbon 客户端可能重试请求 3 次，那么你的 Hystrix 超时时间应该略高于 3 秒。</p>
<blockquote>
<p><strong>作者的话</strong> 如果上述示例配置低于 3 秒，那么 Ribbon 可能还未完成 3 次重试就已经结束，并不满足配置预期。</p>
</blockquote>
<h3 id="6-1-How-to-Include-the-Hystrix-Dashboard"><a href="#6-1-How-to-Include-the-Hystrix-Dashboard" class="headerlink" title="6.1. How to Include the Hystrix Dashboard"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#netflix-hystrix-dashboard-starter">6.1. How to Include the Hystrix Dashboard</a></h3><p>若要在你的项目包含 Hystrix Dashboard，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-netflix-hystrix-dashboard</code> 的 starter。</p>
<p>若要运行 Hystrix Dashboard，请使用 <code>@EnableHystrixDashboard</code> 注解你的 Spring Boot 主类。然后访问 <code>/hystrix</code>，并将 dashboard 指向一个实例在 Hystrix 客户端应用中的 <code>/hystrix.stream</code> 端点。</p>
<h2 id="7-Client-Side-Load-Balancer-Ribbon"><a href="#7-Client-Side-Load-Balancer-Ribbon" class="headerlink" title="7. Client Side Load Balancer: Ribbon"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-ribbon">7. Client Side Load Balancer: Ribbon</a></h2><p>Ribbon 是一个客户端的负载均衡，可以对 HTTP 和 TCP 客户端行为进行大量控制。Feign 已经使用了 Ribbon，因此，如果你使用 <code>@FeignClient</code>，这部分也会使用。</p>
<blockquote>
<p>Ribbon 是一个进程内 LB</p>
</blockquote>
<p>Ribbon 的核心概念是有名客户端。每个负载均衡器都是组件集合的一部分，组件们在一起工作，按需要连接到远程服务器，并且整体有一个名字，这是你作为开发者赋予的名字。根据需要，Spring Cloud 通过使用 <code>RibbonClientConfiguration</code> 以 <code>ApplicationContext</code> 为每个有名客户端创建一个新的整体。这包含一个 <code>ILoadBalancer</code>，一个 <code>RestClient</code>，以及一个 <code>ServerListFiter</code>。</p>
<h3 id="7-1-How-to-Include-Ribbon"><a href="#7-1-How-to-Include-Ribbon" class="headerlink" title="7.1. How to Include Ribbon"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-ribbon-starter">7.1. How to Include Ribbon</a></h3><p>要在你的项目使用 ribbon，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-netflix-ribbon</code> 的 starter。有关使用当前 Spring Cloud Release Train 设置你的构建系统详情见 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</a></p>
<blockquote>
<p>如果你依赖了 eureka，则 ribbon 也会同时引入，无需显式引入</p>
</blockquote>
<h3 id="7-2-Customizing-the-Ribbon-Client"><a href="#7-2-Customizing-the-Ribbon-Client" class="headerlink" title="7.2. Customizing the Ribbon Client"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#customizing-the-ribbon-client">7.2. Customizing the Ribbon Client</a></h3><p>你可以通过使用 <code>&lt;client&gt;.ribbon.*</code> 之中的外部属性配置 Ribbon 客户端的一些部分，这类似于使用原生的 Netflix API，但你可以使用 Spring Boot 配置文件。原生选项可以在 <a href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java"><code>CommonClientConfigKey</code></a>  （ribbon-core 的一部分）以静态字段查看。</p>
<p>Spring Cloud 还让你通过使用 <code>@RibbonClient</code> 声明额外配置（除了 <code>RibbonClientConfiguration</code>）来完全控制客户端，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;custom&quot;, configuration = CustomConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个案例中，客户端由已经存在于 <code>RibbonClientConfiguration</code> 的组件，以及在 <code>CustomConfiguration</code> （后者通常覆盖前者）中的一些组成。</p>
<blockquote>
<p><code>CustomConfiguration</code> 类必须是 <code>@Configuration</code> 类，但是注意，不要放在主应用上下文的 <code>@ComponentScan</code> 中。否则，它将被所有的 <code>@RibbonClients</code> 共享。如果你使用 <code>@ComponentScan</code>（或者 <code>@SpringBootApplication</code>），你需要采取一些方法以避免将其包括在内（例如，你可以将其放入分开的，不重叠的包中，或者在 <code>@ComponentScan</code> 中指定要明确扫描的包）。</p>
</blockquote>
<h3 id="7-3-Customizing-the-Default-for-All-Ribbon-Clients"><a href="#7-3-Customizing-the-Default-for-All-Ribbon-Clients" class="headerlink" title="7.3. Customizing the Default for All Ribbon Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#customizing-the-default-for-all-ribbon-clients">7.3. Customizing the Default for All Ribbon Clients</a></h3><p>可以通过使用 <code>@RibbonClients</code> 注解，注册一个默认的配置，为所有的 Ribbon 客户端提供默认配置，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonClientDefaultConfigurationTestsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BazServiceList</span> <span class="keyword">extends</span> <span class="title class_">ConfigurationBasedServerList</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BazServiceList</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.initWithNiwsConfig(config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultRibbonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">ribbonRule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BestAvailableRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IPing <span class="title function_">ribbonPing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PingUrl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerList&lt;Server&gt; <span class="title function_">ribbonServerList</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RibbonClientDefaultConfigurationTestsConfig</span>.BazServiceList(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerListSubsetFilter <span class="title function_">serverListFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServerListSubsetFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerListSubsetFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-Customizing-the-Ribbon-Client-by-Setting-Properties"><a href="#7-4-Customizing-the-Ribbon-Client-by-Setting-Properties" class="headerlink" title="7.4. Customizing the Ribbon Client by Setting Properties"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#customizing-the-ribbon-client-by-setting-properties">7.4. Customizing the Ribbon Client by Setting Properties</a></h3><p>从 1.2.0 开始，Spring Cloud Netflix 现在支持通过设置兼容 <a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers#components-of-load-balancer">Ribbon documentation</a> 属性来定制化 Ribbon 客户端。</p>
<p>这使你可以在不同环境中更改启动时行为。</p>
<p>下面的列表展示了支持的属性：</p>
<ul>
<li><code>&lt;clientName&gt;.ribbon.NFLoadBalancerClassName</code>：应该实现了 <code>ILoadBalancer</code></li>
<li><code>&lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName</code>：应该实现了 <code>IRule</code></li>
<li><code>&lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName</code>：应该实现了 <code>IPing</code></li>
<li><code>&lt;clientName&gt;.ribbon.NIWSServerListClassName</code>：应该实现了 <code>ServerList</code></li>
<li><code>&lt;clientName&gt;.ribbon.NIWSServerListFilterClassName</code>：应该实现了 <code>ServerListFilter</code></li>
</ul>
<blockquote>
<p>这些属性中定义的类，相较于使用 <code>@RibbonClient(configuration=MyRibbonConfig.class)</code> 定义的 Bean，以及由 Spring Cloud Netflix 提供的默认值，具有更高优先级</p>
</blockquote>
<p>要设置名为 <code>users</code> 的服务名的 <code>IRule</code></p>
<h3 id="7-6-Example-How-to-Use-Ribbon-Without-Eureka"><a href="#7-6-Example-How-to-Use-Ribbon-Without-Eureka" class="headerlink" title="7.6. Example: How to Use Ribbon Without Eureka"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-ribbon-without-eureka">7.6. Example: How to Use Ribbon Without Eureka</a></h3><p>Eureka 是一种便捷的方式，它抽象化远程服务的发现，因此你不必在客户端中进行硬编码。但是，如果你不想使用 Eureka，Ribbon 和 Feign 也可以工作。假设你已经声明了 “stores” 的 <code>@RibbonClient</code>，并且 Eureka 没有使用（甚至不在类路径）。Ribbon 客户端默认到配置好的服务列表。你可以按如下方式提供配置：</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stores:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">listOfServers:</span> <span class="string">example.com,google.com</span></span><br></pre></td></tr></table></figure>

<h3 id="7-7-Example-Disable-Eureka-Use-in-Ribbon"><a href="#7-7-Example-Disable-Eureka-Use-in-Ribbon" class="headerlink" title="7.7. Example: Disable Eureka Use in Ribbon"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#example-disable-eureka-use-in-ribbon">7.7. Example: Disable Eureka Use in Ribbon</a></h3><p>将 <code>ribbon.eureka.enabled</code> 属性设置为 <code>false</code>，显式地禁用 Ribbon 中 Eureka 的使用，如下示例所示：</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eureka:</span></span><br><span class="line">   <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<h3 id="7-8-Using-the-Ribbon-API-Directly"><a href="#7-8-Using-the-Ribbon-API-Directly" class="headerlink" title="7.8. Using the Ribbon API Directly"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-the-ribbon-api-directly">7.8. Using the Ribbon API Directly</a></h3><p>你也可以直接使用 <code>LoadBalanceClient</code>，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStuff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> loadBalancer.choose(<span class="string">&quot;stores&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">storesUri</span> <span class="operator">=</span> URI.create(String.format(<span class="string">&quot;https://%s:%s&quot;</span>, instance.getHost(), instance.getPort()));</span><br><span class="line">        <span class="comment">// ... do something with the URI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Netflix</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 垃圾回收笔记</title>
    <url>/2022/07/20/JVM/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="JVM-垃圾回收笔记"><a href="#JVM-垃圾回收笔记" class="headerlink" title="JVM 垃圾回收笔记"></a>JVM 垃圾回收笔记</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">JVM 规范</a></p>
<p><a href="https://blogs.oracle.com/jonthecollector/our-collectors">https://blogs.oracle.com/jonthecollector/our-collectors</a></p>
<p>关于 minor gc 和 full gc 的名词，从该文章可以获取</p>
<p><a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">Java Hotspot 内存管理白皮书</a></p>
<h2 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h2><h3 id="标记-清除算法-Mark-Sweep"><a href="#标记-清除算法-Mark-Sweep" class="headerlink" title="标记-清除算法(Mark Sweep)"></a>标记-清除算法(Mark Sweep)</h3><p>Mark-Sweep 算法，在 1960 年由 Lisp 之父 John McCarthy 所提出。分为 “标记” 和 “清除” 两个阶段：</p>
<ul>
<li>标记：标记出所有需要回收的对象，或者标记存活的对象</li>
<li>清除：标记完成后统一回收需要回收的对象</li>
</ul>
<p>不足之处主要有两点：</p>
<ul>
<li>效率问题：执行效率不稳定，如果堆中包含大量对象，且其中大部分对象都需要被回收，这时必须进行大量标记和清除动作。</li>
<li>空间问题：内存碎片</li>
</ul>
<h3 id="标记-复制算法-Copying"><a href="#标记-复制算法-Copying" class="headerlink" title="标记-复制算法(Copying)"></a>标记-复制算法(Copying)</h3><p>常被简称为 “复制算法”。为了解决标记-清除算法面对大量可回收对象时执行效率低的问题。1969 年 Fenichel 提出一种称为 “半区复制”（Semispace Copying）垃圾回收算法，将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，再把已使用过的内存空间一次清理掉。</p>
<blockquote>
<p>如果内存中的多数对象都是存活的，这种算法会产生大量的复制开销。但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是有序复制到另一块内存，分配内存时也就不用考虑空间碎片的情况。</p>
</blockquote>
<p>经过研究，大部分新生代的对象是 “朝生夕死” 的，也就是只有极少的的对象会存活下来。在 1989 年，Andrew Appel 针对这个特点，提出了一种更优化的半区复制分代策略，现在称为 “Appel 式回收”。HotSpot VM 的 Serial、ParNew 等新生代回收器均采用了这种策略来设计新生代的内存布局。Appel 式回收的具体做法时把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Servivor。发生 GC 时，将 Eden 和 Servivor 中仍然存活的对象一次性复制到另外一块 Servivor 空间上，然后清理掉 Eden 和已经使用过的那块 Survivor 空间。</p>
<p>HotSpot VM 将新生代划分为 Eden 和 2 个 Survivor Space，Eden 和 Survivor 的比例为 8:1，也就是新生代中可用内存为总容量的 90% （80% + 10%），只有 10% 会被浪费。</p>
<blockquote>
<p>考虑到最极端的情况，90% 的对象都是存活的，显然 10% 的 Survivor Space 不够用，需要依赖其他内存（老年代）进行分配担保，多出来的对象直接通过分配担保机制进入老年代。</p>
</blockquote>
<h3 id="标记-压缩算法-Mark-Compact"><a href="#标记-压缩算法-Mark-Compact" class="headerlink" title="标记-压缩算法(Mark Compact)"></a>标记-压缩算法(Mark Compact)</h3><p>有些地方也叫标记-整理算法。</p>
<p>复制算法在对象存活率较高时，就要进行较多的复制，效率就会变低。所以，老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，1974 年 Edward Lueders 提出了另外一种有针对性的 “标记-整理”（Mark-Compact）算法。标记过程与 “标记-清除” 算法一样，但后续不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<h2 id="对象存活的判定"><a href="#对象存活的判定" class="headerlink" title="对象存活的判定"></a>对象存活的判定</h2><h3 id="引用计数法-Reference-Count"><a href="#引用计数法-Reference-Count" class="headerlink" title="引用计数法(Reference Count)"></a>引用计数法(Reference Count)</h3><p>对象持有一个引用计数器，每当有一个地方引用它时，值加1；引用失效时，值减 1。当计数器值为 0 时，对象就是不可能再被使用。</p>
<p>主流 JVM 都没有选用引用计数法，最主要原因是难以解决对象之间循环引用的问题。</p>
<h3 id="可达性分析算法-Root-Searching"><a href="#可达性分析算法-Root-Searching" class="headerlink" title="可达性分析算法(Root Searching)"></a>可达性分析算法(Root Searching)</h3><p>基本思想：通过一系列称为 ”GC Roots“ 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用恋，当一个对象到 GC Roots 没有任何引用链相连，则此对象时不可用的。</p>
<p>在 Java 中，可以当做 GC roots 的对象有以下几种：</p>
<ul>
<li>栈帧中的本地变量表中引用的对象</li>
<li>方法区中的静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>本地方法栈中 JNI（一般说的Native方法）引用的对象</li>
</ul>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p>即使在可达性分析算法中不可达的对象，也不是非死不可。认为一个对象死亡，至少要经历两次标记过程：如果在可达性分析后发现没有与 GC Roots 相连的引用链，那么会第一次标记并筛选，筛选的条件时此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为 “没有必要执行”。</p>
<p>如果对象被判定有必要执行 finalize() 方法，那么这个对象将会放置在一个叫 F-Queue 的队列之中，并在稍后由 Finalizer 线程去执行。但是这里，虚拟机只是会触发这个方法并不承诺会等待它运行结束，这样做的原因是，如果一个对象在 finalize() 方法中执行缓慢，或者发生死循环，可能导致 F-Queue 队列中其他对象永久等待。</p>
<blockquote>
<p>任何一个对象的 finalize() 方法都只会被系统自动调用一次</p>
</blockquote>
<p>建议：尽量避免使用 finalize()，因为它不是 C&#x2F;C++ 中的析构函数，而是 Java 刚诞生时为了使 C&#x2F;C++ 程序员更容易接受它所做出的妥协。有些教材中描述它适合做 “关闭外部资源” 之类的工作，完全是对该方法用途的自我安慰。finalize() 能做的所有工作，使用 try-finally 或者其他方式都可以做的更好、更及时。所以建议忘掉该方法的存在。</p>
<h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>将遍历对象图的过程中，对象分为三种颜色：</p>
<ul>
<li>白色：表示对象尚未被垃圾回收器访问过。显然，在可达性分析刚开始的时候，所有对象都是白色的，若在分析结束的阶段，对象仍然是白色，表示不可达（垃圾）。</li>
<li>灰色：表示对象已经被垃圾回收器访问过，但这个对象上至少存在一个引用还没有被扫描过。灰色可能直接引用着白色对象。</li>
<li>黑色：表示对象以及它的所有引用都已经扫描过。黑色的对象代表存活的。如果有其他对象引用了黑色对象，也无需重新扫描一遍。黑色对象不可能 “直接” 指向某个白色对象。</li>
</ul>
<h4 id="可达性分析的并发"><a href="#可达性分析的并发" class="headerlink" title="可达性分析的并发"></a>可达性分析的并发</h4><p>GC Roots 相比起整个 Java 堆中的全部对象还算极少数，且在各种优化技巧（如 OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定。但是，从 GC Roots 再继续往下遍历对象图，这个过程的停顿时间必定与 Java 堆容量成正比例关系。如果能够削减这部分停顿时间，收益将会是系统性的。</p>
<p>如果用户线程和回收器并发工作，用户线程也在修改引用关系，可能出现两种后果：</p>
<ul>
<li>把原本死亡的对象错误标记为存活。这不是好事，但可以容忍，不过是产生了浮动垃圾。</li>
<li>把原本存活的对象标记为死亡。这样后果非常致命，出现 “对象消失” 问题，程序肯定会出错。</li>
</ul>
<p><span id="对象消失">对象消失</span>：1994 年，Wilson 在理论上证明了，当且仅当下面两个条件同时满足，才会产生 “对象消失” 的问题：</p>
<ul>
<li>用户线程插入了一条或多条从黑色对象到白色对象的新引用</li>
<li>用户线程删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ul>
<p>为了避免对象消失的现象，只需要破坏这两个条件任意一个即可。由此产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，STAB）。</p>
<p>增量更新是破坏第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象以跟，重新扫描一次。可以理解为，黑色对象一旦新插入了指向白色对象的引用关系之后，它就变成灰色对象了。</p>
<p>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再以这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p>
<blockquote>
<p>虚拟机针对以上的记录操作都是通过写屏障实现的。在 HotSpot VM 中，CMS 时基于增量更新来做并发标记的，G1 是用原始快照来实现的。</p>
</blockquote>
<h2 id="垃圾收集器（G1）"><a href="#垃圾收集器（G1）" class="headerlink" title="垃圾收集器（G1）"></a>垃圾收集器（G1）</h2><h3 id="堆布局"><a href="#堆布局" class="headerlink" title="堆布局"></a>堆布局</h3><p>G1 将堆划分为一组大小相等的堆 Region（区域），每个区域都是连续的虚拟机内存范围，如下图所示。区域是内存分配和回收的单位。</p>
<img src="https://img-blog.csdnimg.cn/img_convert/e9d5353d9062d194fc1edcf97a6179f8.png">

<blockquote>
<ul>
<li>用户可以随意设置 Region 的大小，但是内部会将用户的值向上调整为 2 的指数幂（$2^{n}$）；设置 G1 堆区域大小：<code>-XX:G1HeapRegionSize=n</code>，默认 n &#x3D; 2M，可选值 1M、2M、4M、8M、16M、32M</li>
<li>空闲区域是通过链表管理的</li>
</ul>
</blockquote>
<p>显然，在任何给定时间，每个区域可以是空的（灰色），或者年轻代，或者老年代。</p>
<p>年轻代区域可以再细分为两类：创建区域、存活区域。</p>
<ul>
<li>创建区域：用来存放刚刚生成、一次也没有被转移过的对象。可以认为是 Eden。</li>
<li>存活区域：用来存放被转移过至少一次的对象。可以认为是 Survivor Space。</li>
</ul>
<p>老年代区域可以再细分为两类：普通老年代、Humongous 区域</p>
<ul>
<li>普通老年代：用来存放年轻达到阈值的对象</li>
<li>Humongous 区域：用来存放巨大对象</li>
</ul>
<p>当内存请求到来时，内存管理器会拿出空闲区域，将它们分配给某个代。</p>
<blockquote>
<p>未必就直接分配给年轻代（创建区域），如果对象过大，则直接分配给老年代（Humongous 区域）。</p>
</blockquote>
<p>在年轻代没有达到最大空间前，G1 GC 会根据 Java 应用对象分配速率，从空闲空间里面挑选出区域加入年轻代。当 Eden 区间分配内存失败，一次年轻代 GC 就被触发，它的工作是释放一些内存，属于一次轻量级操作。</p>
<p>随着年轻代回收，大对象分配等操作方式，越来越多的对象从年轻代进入到了老年代，年轻区域和老年区域可以同时被垃圾回收。这称为 <em>mixed collection</em>（混合回收）。</p>
<p>垃圾回收是一种压缩回收，它将存活对象拷贝到选定的、最初为空的区域。</p>
<blockquote>
<p>跟 CMS 回收器不同，G1 对老年代的回收是压缩回收。</p>
</blockquote>
<p>根据幸存对象的年龄，可以将对象复制到幸存区域（标记为 “S”）或者老年区域（图上暂未具体显示）。标有 “H” 的区域包含大于半个区域并经过特殊处理的巨大对象。</p>
<blockquote>
<ul>
<li>与传统的连续堆内存不同，G1 的内存布局以 Region 进行划分。</li>
<li>“H” 区域存储那些大小 &gt;&#x3D; 0.5 倍 Region 的大型对象。</li>
</ul>
</blockquote>
<h4 id="标记位图"><a href="#标记位图" class="headerlink" title="标记位图"></a>标记位图</h4><p>每个区域都带有两个标记位图：next 和 prev。”位” 即 bit。</p>
<ul>
<li>next：本次标记的标记位图</li>
<li>prev：上次标记的标记位图，保存了上次标记的结果。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/6ba5828839774d319ffd7b0612a679b4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70#pic_center">


<p>标记位图中每个 bit 都对应着关联区域内的对象的开头部分。</p>
<blockquote>
<ul>
<li>之所以是开头部分，是因为一个对象如果占用多个 bit 位置，那么只标记它的起始 bit。</li>
<li>黑色的地方表示比特值为 1（存活对象），白色的地方表示比特值是 0（带 “X” 的死亡对象）。</li>
</ul>
</blockquote>
<p>标记位图中 4 个指针的含义：</p>
<ul>
<li>bottom：众多对象的末尾。</li>
<li>top：众多对象的开头。</li>
<li>nextTAMS：next Top At Marking Start，标记开始时的 top，每次并发标记开始时会移动到与 top 相同的位置，下面会细说。</li>
<li>prevTAMS：prev Top At Marking Start，上次标记开始时 top。</li>
</ul>
<blockquote>
<p>每 8 个字节对应标记位图中的 1 个比特。所以，上图中对象 C 虽然占用多个位置，但是 next 位图只记录了对象头所在的位置。</p>
</blockquote>
<h3 id="垃圾回收周期"><a href="#垃圾回收周期" class="headerlink" title="垃圾回收周期"></a>垃圾回收周期</h3><p>G1 回收器在两个阶段之间交替。在 young-only 阶段包含垃圾回收，即逐渐用老年代中的对象填充当前可用内存。在 space-reclamation 阶段，G1 除了处理年轻代之外，还逐步回收老年代的空间。然后，周期从 young-only 重新开始。</p>
<ul>
<li><p>Young-only 阶段：这个阶段从一些 young-only 集合开始，将对象晋升到老年代。当老年代占用达到某个阈值（即初始堆占用阈值）时，将会从 young-only 阶段过渡到 space-reclamation 阶段。此时，G1 调度 initial mark（初始标记） young-only 集合，而不是一个常规的 young-only 收集了。</p>
<ul>
<li>Initial Mark：除了执行一个常规的 young-only 回收之外，这种回收还开始标记过程。并发标记确定所有当前老年代区域可达的存活对象，以便保留给接下来的 space-reclamation 阶段。当标记还没完全结束的时候，可能发生常规的年轻回收。标记结束之后，随之而来的是两个 stop-the-world 阶段：Remark 和 Cleanup。</li>
<li>Remark：此暂停完成标记本身，并执行全局引用处理和类卸载。在 Remark 和 Cleanup 之间 G1 会并发地计算一个存活信息的摘要，该摘要确定之后会在 Cleanup 暂停中使用来更新内部数据结构。</li>
<li>Cleanup：此暂停还会回收完全空的区域，并确定是否 space-reclamation 阶段会真的到来。如果接下来是 space-reclamation 阶段，young-only 阶段以单个 young-only 回收完成。</li>
</ul>
</li>
<li><p>Space-reclamation 阶段：这个阶段由多个 mixed collections 组成，除了年轻代区域外，还转移老年代区域的存活对象。当 G1 确定回收更多的老年代区域不会产生足够的可用空间时，space-reclamation 阶段结束。</p>
</li>
</ul>
<p>在 space-reclamation 之后，回收周期从另一个 young-only 阶段重新开始。作为后备，如果应用程序在收集存活信息时内存不足，G1 会像其他回收器一样执行就地的 STW 全堆压缩（Full GC）。</p>
<h3 id="G1-总体执行过程"><a href="#G1-总体执行过程" class="headerlink" title="G1 总体执行过程"></a>G1 总体执行过程</h3><p>G1GC 主要有以下两个功能：</p>
<ul>
<li>并发标记（concurrent marking）</li>
<li>转移（evacuation），也有人叫疏散</li>
</ul>
<p>并发标记：基本能和 mutator 并发执行，会针对区域内所有存活的对象进行标记。</p>
<p>转移：选择区域，如果该区域有存活对象，则将它们复制到其他空闲区域中。对象复制完成之后，只剩下死亡对象的区域会被重置（回收）为空闲区域以便复用。</p>
<blockquote>
<p>并发标记和转移在处理上是相互独立的。并发标记的结果信息对转移来说并不是必须的。因此，转移处理可能发生在并发标记开始之前，也可能发生在并发标记的过程中。</p>
</blockquote>
<h3 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h3><p>并发标记包括以下 5 个步骤：</p>
<p>① 初始标记阶段<br>② 并发标记阶段<br>③ 最终标记阶段<br>④ 存活对象计数<br>⑤ 收尾工作</p>
<h5 id="步骤-①-初始标记阶段"><a href="#步骤-①-初始标记阶段" class="headerlink" title="步骤 ① 初始标记阶段"></a>步骤 ① 初始标记阶段</h5><p>该阶段有两个过程：</p>
<ul>
<li>创建标记位图：与 mutator 并发执行</li>
<li>根扫描：标记可由根 “直接引用” 的对象。</li>
</ul>
<img src="https://img-blog.csdnimg.cn/a41c527ed0d047c990003c0668db53f7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<p>在初始标记阶段，GC 线程首先会创建标记位图 next。指针 nextTAMS 指向标记开始时 top 所在的位置。在创建位图时，其大小也和 top 对齐，为 (top - bottom) &#x2F; 8 字节。</p>
<blockquote>
<p>上述处理都是和 mutator 并发进行的。</p>
</blockquote>
<p>等所有区域的标记位图都创建完成之后，就可以开始进行根扫描了。</p>
<blockquote>
<p>根扫描，指可由根 “直接引用” 的对象进行标记的过程。</p>
</blockquote>
<p>为了防止在根扫描的过程中根被修改，在这个过程中 mutator 是暂停执行的。</p>
<blockquote>
<p>虽然 G1GC 采用的写屏障可以获知对象的修改，但是大多数根不是对象。而且，根需要频繁的修改，与其频繁地通过写屏障去获取修改，不如直接暂停 mutator 进行根扫描性能更好。</p>
</blockquote>
<p>如果一个对象本身被标记了，但其子对象并没有被扫描，称它为未扫描对象（灰色）。上图中，对象 C 已经在根扫描中被标记，但由于根扫描不会扫描子对象，对象 C 又持有对象 A 和 E 的引用，所以对象 C 被认为是未扫描对象，表示为灰色。</p>
<p>完成根扫描后，mutator 会再次开启执行。</p>
<h5 id="步骤-②-并发标记阶段"><a href="#步骤-②-并发标记阶段" class="headerlink" title="步骤 ② 并发标记阶段"></a>步骤 ② 并发标记阶段</h5><p>在并发标记阶段，GC 线程继续扫描在初始标记阶段被标记过的对象（根直接引用对象），完成堆大部分存活对象的标记。</p>
<p>下图表示并发标记阶段结束后的区域状态。对象 C 和子对象 A 和 E 都被标记了。</p>
<img src="https://img-blog.csdnimg.cn/d5287491ab114c0299b26f75041a9f4c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">


<p>并发标记阶段地一个重要特点是 GC 线程和 mutator 是并发执行的。因此，mutator 在执行的过程中可会会改变对象之间的引用关系，所以，采用一般的标记方法，可能会发生 “标记遗漏”。因此，必须使用写屏障技术来记录对象间引用关系的变化。</p>
<h6 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h6><p>SATB（Snapshot At The Beginning，初始快照）是一种将并发标记阶段开始时对象间的引用关系，以逻辑快照的形式进行保存的手段。</p>
<p>在 SATB 中，标记过程中新生成的对象会被看作 “已完成扫描和标记”，因此其子对象不会被标记。</p>
<blockquote>
<ul>
<li>因为 SATB 记录的是并发标记阶段开始时的对象间引用关系，而标记过程中新生成的对象与其他对象间的引用关系在标记开始时并不存在，因此其子对象不会被标记。</li>
<li>如上图所示，nextTAMS 和 top 之间的对象 J 和 K 就是在标记过程中新生成的对象。因为它们的引用关系在标记开始时并不存在，所以它们都会被当成存活对象。</li>
<li>此外，标记位图也不会记录对象 J 和 K</li>
</ul>
</blockquote>
<p>如果在并发标记的过程中对象的域发生了写操作（被修改），就必须以某种方式记录下被改写之前的引用关系。</p>
<img src="https://img-blog.csdnimg.cn/832f67c0e19a42d396171a3d75112cf6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<p>参数 field 表示被写入对象的域（类属性），参数 newobj 表示被写入域的值。</p>
<p>第 2 行的 GC_CONCURRENT_MARK 用来表示并发标记阶段的标志位（flag）。</p>
<p>第 4 行会检查当前处于并发标记且被写入之前 field 的域的值是不是 Null，因为如果为 Null，代表之前的引用关系并不存在，无需记录。</p>
<p>第 5 行将 oldobj 添加到 $current_thread.stab_local_queue 中。</p>
<p>第 7 行进行实际的写入操作。</p>
<p>在并发标记阶段，GC 线程会定期检查 SATB 队列集合大小。如果发生其中由队列，则会对队列中的全部对象进行标记和扫描。</p>
<p>SATB 本地队列在装满（默认大小为 1 KB）之后，会被添加到全局的 SATB 队列集合中。这些被添加的 SATB 本地队列，都是并发标记阶段的待标记对象。</p>
<h5 id="步骤-③-最终标记阶段"><a href="#步骤-③-最终标记阶段" class="headerlink" title="步骤 ③ 最终标记阶段"></a>步骤 ③ 最终标记阶段</h5><p>最终标记阶段的处理是暂停处理，需要暂停 mutator 的运行。</p>
<blockquote>
<p>因为 SATB 本地队列中的数据会被 mutator 操作，所以不能和 mutator 并发执行。</p>
</blockquote>
<p>因为未装满的 SATB 本地队列不会被添加到 SATB 队列集合中，所以在并发标记阶段结束后，各个线程 SATB 本地队列中可能仍然存在待扫描的对象。而最终标记阶段就会扫描这些 “残留的 SATB 本地队列”。</p>
<p>队列中保存了对象 G 和 H 的引用。因此在扫描 SATB 本地队列之后，对象 G 和 H，以及对象 H 的子对象都会被标记。<br><img src="https://img-blog.csdnimg.cn/fc57958090ae4219aef11f68b652956c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70"><br>本步骤结束后，所有的存活对象都已被标记。因此，此时所有不带标记的对象都可以判定为死亡对象。</p>
<h5 id="步骤-④-存活对象计数"><a href="#步骤-④-存活对象计数" class="headerlink" title="步骤 ④ 存活对象计数"></a>步骤 ④ 存活对象计数</h5><p>计数处理和 mutator 是并发执行的。</p>
<blockquote>
<p>不过，计数过程中操作的对象可能会被转移的记忆集合线程使用，因此需要先停掉记忆集合线程。</p>
</blockquote>
<p>这个步骤会扫描各个区域的标记位图 next，统计区域内存活对象的字节数，然后将其存入 Region 内的 next_marked_bytes 中。<br><img src="https://img-blog.csdnimg.cn/53c8eba0bcf64133aad67ab245d28b27.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<ul>
<li>在计数过程中新创建了对象 L 和 M。由于 nextTAMS 和 top 之间的对象都会被当做存活对象来处理，所以不会特意计数。</li>
<li>prev_marked_bytes 存放了上次标记结束时存活对象的字节数。因为该 Region 在此之前未曾进行过标记，因此值为 0。</li>
</ul>
</blockquote>
<h5 id="步骤-⑤-收尾工作"><a href="#步骤-⑤-收尾工作" class="headerlink" title="步骤 ⑤ 收尾工作"></a>步骤 ⑤ 收尾工作</h5><p>收尾工作所操作的数据有些是和 mutator 共享的，因此需要暂停 mutator 的运行。</p>
<p>在此期间，GC 线程会逐个扫描每个区域，将标记位图 next 中的并发标记结果移动到标记位图 prev 中，再对并发标记中使用过的标记值进行重置，为下次并发标记做好准备。</p>
<p>此外，对没有存活对象的区域进行回收的工作。可以理解为以区域为单位的清除。</p>
<p>在扫描过程中还会计算每个区域的转移效率，并按照该效率对区域进行降序排序。</p>
<p><img src="https://img-blog.csdnimg.cn/00fa127e22dc49daab598e43cb302225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>收尾工作结束后的几个状态变化：</p>
<ul>
<li>next.next_marked_bytes 中的值被转移到 prev.prev_marked_bytes</li>
<li>prevTAMS 被移动到 nextTAMS 之前的位置</li>
<li>next.next_marked_bytes 被重置</li>
<li>nextTAMS 移动到 bottom 的位置，nextTAMS 会在下次并发标记开始时，移动到 top 的最新位置</li>
</ul>
<p>收尾工作结束后，整个并发标记结束。并发标记线程一直处于等待状态，直到下次并发标记开始。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>并发标记结束后，转移处理可以得到以下信息</p>
<p>① 并发标记完成时存活对象和死亡对象的区分（标记位图 prev）</p>
<p>② 存活对象的字节数（prev_marked_bytes）</p>
<p>这些信息在并发标记阶段不会被改变，因此，即使并发标记阶段开始了，进行转移处理也没有问题。</p>
<h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><p>通过转移，所选区域内的所有存活对象都会被转移到空闲区域。这样一来，被转移区域就只剩下死亡对象。重置之后，该区域就会称为空闲区域，能够再次利用。</p>
<p>下图表示了转移开始前后的状态。转移结束后，可从 GC Root 到达的存活对象 a、b、c 会被转移到空闲区域 C，而死亡对象 d、e 不会被转移，整个区域 A、B 会被重置以再次利用。</p>
<img src="https://img-blog.csdnimg.cn/683d2548395e4e6f8319036f7bc699da.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<h4 id="转移专用记忆集合"><a href="#转移专用记忆集合" class="headerlink" title="转移专用记忆集合"></a>转移专用记忆集合</h4><p>除了可以从根和并发标记的结果发现存活对象之外，转移功能还可以通过转移专用记忆集合来发现对象。转移专用记忆集合用来记录区域之间的引用关系。</p>
<blockquote>
<p>对比：SATB 队列集合主要用来标记过程中对象之间引用关系的变化</p>
</blockquote>
<p>为了简化表达，下面可能会使用 Remember Set（或者 RSet）表示转移专用记忆集合</p>
<img src="https://img-blog.csdnimg.cn/1979c2328b354ada953f7a27a12ef4d5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<blockquote>
<ul>
<li>每个区域都有自己的 RSet，RSet 中记录了来自其他区域的引用，无需扫描所有区域内的对象，就可以确定待转移对象所在区域内的对象被其他区域引用的对象，从而简化单个区域的转移处理。</li>
<li>G1GC 是通过卡表（Card Table）来实现转移专用记忆集合的。</li>
</ul>
</blockquote>
<h5 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h5><p>卡表是一个字节数组，如下图。卡表里的元素称为卡片。堆中一定大小的存储空间（卡页）会对应卡表中的一个元素（字节 &#x2F; 卡片）。</p>
<p>堆中的对象所对应的卡片在卡表中的索引值可以通过以下公式快速计算出：</p>
<center><code>（对象的地址 - 堆的头部地址）/ 512</code></center>

<img src="https://img-blog.csdnimg.cn/5a626af8bee0454b9b759a93413393e2.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<blockquote>
<p>一般来说，卡页的大小都是 2 的 N 次幂。HotSpot 的卡页大小为 2 的 9 次幂，即 512 字节。因此，如果堆大小为 1 GB 时，那么被分为 2 M 个卡页，卡表的数组长度为 2 M，大小为 2 MB。</p>
</blockquote>
<h5 id="转移专用记忆集合的构造"><a href="#转移专用记忆集合的构造" class="headerlink" title="转移专用记忆集合的构造"></a>转移专用记忆集合的构造</h5><img src="https://img-blog.csdnimg.cn/cd194a4f9f1c491ca4d66d51461d5333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<blockquote>
<p>RSet 是通过散列表实现的，可以理解为 Java 的 Map，key 是区域的地址，值是卡片索引的数组。图中对象 b 引用了对象 a，因此对象 b 对应卡片的索引（2048）就被记录在区域 A 的转移专用记忆集合中。</p>
</blockquote>
<h5 id="转移专用写屏障"><a href="#转移专用写屏障" class="headerlink" title="转移专用写屏障"></a>转移专用写屏障</h5><p>当对象的域被修改时，被修改对象所对应的卡片会被转移专用写屏障记录到 RSet 中。</p>
<p>每个 mutator 线程都持有一个名为转移专用记忆集合日志的缓冲区，其中存放的是卡片索引的数组。当对象 b 的域被修改时，写屏障就会感知，并会将对象 b 所对应的卡片索引添加到转移专用记忆集合日志中。<br><img src="https://img-blog.csdnimg.cn/6d98bdcc19a14ca6a130537c98232093.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当转移专用记忆集合日志写满之后，它会被添加到转移专用集合日志的集合（可以认为是 Set&lt;转移专用集合日志&gt;）中。</p>
<h4 id="转移总体步骤"><a href="#转移总体步骤" class="headerlink" title="转移总体步骤"></a>转移总体步骤</h4><p>① 选择回收集合：参考并发标记提供的信息来选择被转移的区域。被选中的区域称为回收集合（Collection Set）。</p>
<p>② 根转移：将回收集合内由根直接引用的对象，以及被其他区域引用的对象转移到空闲区域。</p>
<p>③ 转移：以 ② 中转移的对象为起点，扫描其子孙对象，将所有存活对象一并转移。</p>
<p>当 ③ 结束之后，回收集合内的所有存活对象就转移完成了。</p>
<p>这 3 个步骤都是暂停处理的。在转移开始后，即使并发标记正在进行也会先中断，而有限进行转义处理。</p>
<p>另外，② 和 ③ 都是可以多线程并行执行的。</p>
<h4 id="步骤-①-选择回收集合"><a href="#步骤-①-选择回收集合" class="headerlink" title="步骤 ① 选择回收集合"></a>步骤 ① 选择回收集合</h4><p>选择回收集合的标准简单来说有 2 个：</p>
<ul>
<li>转移效率高</li>
<li>转移的预测暂停时间在用户的容忍范围内</li>
</ul>
<p>在选择回收集合时，堆中的区域按照转移效率降序排列。接下来，按照排好的顺序依次计算各个区域的预测暂停时间，并选择回收集合。当所有已选区域预测暂停时间的总和快要超过用户的容忍范围时，后续选择就会停止。</p>
<h4 id="步骤-②-根转移"><a href="#步骤-②-根转移" class="headerlink" title="步骤 ② 根转移"></a>步骤 ② 根转移</h4><p>根转移的转移对象包含以下 3 类：</p>
<ul>
<li>GC Root 直接引用对象</li>
<li>并发标记处理中的对象</li>
<li>由其他区域对象直接引用的回收集合内的对象</li>
</ul>
<p>根转移伪代码：</p>
<img src="https://img-blog.csdnimg.cn/f8a858d64c9b43779c98c585cd055499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">


<p>代码清单第 2 ~ 4 行先是把被根引用的位于回收集合内的对象转移到其他的空闲区域。</p>
<blockquote>
<p>被根引用却不在回收集合内的对象会被直接忽略。<br>$roots 中还包含 SATB 本地队列和 SATB 队列集合中的引用</p>
</blockquote>
<p>第 4 行的 evacuate_obj() 是用于转移对象的函数，它的返回值是转移后对象的地址。</p>
<p>第 6 行中的 force_update_rs() 的作用是将未被转移专用记忆集合维护线程扫描的脏卡片更新到转移专用记忆集合中。</p>
<h5 id="对象转移"><a href="#对象转移" class="headerlink" title="对象转移"></a>对象转移</h5><img src="https://img-blog.csdnimg.cn/3271341455034b00a534ea6ce3eabfd4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<p>① 将对象 a 转移到空闲区域<br>② 将对象 a 在空闲区域中的新地址写入到转移前所在区域中的旧地址。<br>③ 将对象 a 引用的所有位于回收集合内的对象都添加到转移队列中。转移队列是用来临时保存待转移对象的引用放。图中 a’.field1 引用了对象 b，而且 b 所在的区域在回收集合中。因为 a’ 是存活对象，所以 a’ 引用的对象 b 也是存活对象。<br>④ 针对对象 a 引用的位于回收集合外的对象，更新转移专用记忆集合。图中 a’.field2 引用了对象 c，而 c 所在的区域不在回收集合中。c 所在的转移专用记忆集合中虽然记录了 a.field2 对应的卡片，但是 a 被转移到了 a’，所以有必要更新转移专用记忆集合。<br>⑤ 针对对象 a 的引用放，更新转移专用记忆集合。对象转移时只有 1 个引用放能够以参数的形式进行传递。图中 a 的引用方是 d.field1。d.field1 指向的是 a 的地址，但是 a 被转移到 a’，所以有必要让 d.field1 指向 a 的新地址 a’。如图中所示，d.field1 对应的卡片被添加到了 a’ 所在区域的转移专用记忆集合中。<br>⑥ 这一步并非转移的处理内容，只是补充说明。对象转移最终返回额是转移后的地址。在调用转移的地方，返回的地址会被赋值给引用放。图中 d.field1 的地址被替换成了对象 a’ 的地址</p>
<h4 id="步骤-③-转移"><a href="#步骤-③-转移" class="headerlink" title="步骤 ③ 转移"></a>步骤 ③ 转移</h4><p>完成根转移之后，那些被转移队列引用的对象会依次转移。直到转移队列被清空，转移就完成。至此，回收集合内所有的存活对象都被成功转移。</p>
<h4 id="Card-Tables-and-Concurrent-Phases"><a href="#Card-Tables-and-Concurrent-Phases" class="headerlink" title="Card Tables and Concurrent Phases"></a>Card Tables and Concurrent Phases</h4><p>如果垃圾回收器没有回收整个堆（增量回收），则垃圾回收器需要知道从堆的未回收的部分到正在回收的堆的部分的指针在哪。这通常用于分代垃圾回收器，其中，堆的未回收部分通常是老年代，而堆的回收部分是年轻代。保存这些信息的数据结构（指向年轻代对象的老年代指针）是一个 Remembered Set（记忆集）。Card Table（卡表）是一种特殊类型的记忆集。Java HotSpot VM 使用字节数组作为卡表。每个字节称为一张卡。一张卡对应于堆中的一系列地址。Dirtying a card（脏卡）意思是将字节的值更改为一个 dirty value（脏值）。一个脏值可能包含一个从老年代到年轻代，卡所覆盖地址的指针。</p>
<p>Processing a card 意味着检查卡片，看看是否有一个老年代到年轻代的指针，并且可能对这些信息做一些事情，比如将其转移到另一个数据结构。</p>
<h5 id="热卡片"><a href="#热卡片" class="headerlink" title="热卡片"></a>热卡片</h5><p>频繁发生修改的存储空间所对应的卡片称为热卡片（hot card）。热卡片可能会多次被转移专用记忆集合线程处理成脏卡片，从而加重转移专用记忆集合线程的负担，因此需要特别处理。</p>
<p>要想发现热卡片，需要用到卡片计数器，它记录了卡片变成脏卡片的次数。卡片计数器记录了自上次转移以来哪些卡片变成了脏卡片，以及变成脏卡片的次数，其内容会在下次转移时被清空。</p>
<p>变成脏卡片的次数超过阈值（默认是 4）的卡片会被当成热卡片，在被处理为脏卡片后添加到热队列尾部。热队列的大小是固定的（默认是 1 KB）。如果队列满了，则从队列头部取出老卡片，给新的卡片腾出位置。取出的卡片由转移专用记忆集合维护线程当成普通卡片处理。</p>
<p>热队列的卡片不会被转移专用记忆集合维护线程处理，因为即使处理了，它也有可能马上又变成脏卡片。因此，热队列中的卡片会被留到转移的时候再处理。</p>
<h4 id="分代-G1GC-模式"><a href="#分代-G1GC-模式" class="headerlink" title="分代 G1GC 模式"></a>分代 G1GC 模式</h4><p>G1GC 中存在 “纯 G1GC 模式”（pure garbage-first mode）和 “分代 G1GC 模式”（generational garbage-first mode） 两种模式。实际上，OpenJDK 虽然实现了纯 G1GC 模式，但是并没有将这种模式开放给用户。用户们使用的都是分代 G1GC 模式。</p>
<p>分代 G1GC 模式也分为新生代 GC 和老年代 GC。G1GC 中的新生代 GC 称为完全新生代 GC（fully-young collection），老年代 GC 称为部分新生代 GC（partially-young collection）。</p>
<p>完全新生代 GC 和部分新生代 GC 的主要区别在于回收集合的选择：</p>
<ul>
<li>完全新生代 GC 将所有新生代区域选入回收集合</li>
<li>部分新生代 GC 将所有新生代区域，以及一部分老年代区域选入回收集合</li>
</ul>
<blockquote>
<p>注意：所有新生代区域都会被选入回收集合</p>
</blockquote>
<h5 id="完全新生代-GC-的执行过程"><a href="#完全新生代-GC-的执行过程" class="headerlink" title="完全新生代 GC 的执行过程"></a>完全新生代 GC 的执行过程</h5><p>完全新生代 GC 不会选择老年代区域，而是将所有新生代区域（创建区域、存活区域）都选入回收集合，然后转移回收集合内的存活对象。晋升的对象会被转移到老年代，其余对象则被转移到存活区域。</p>
<img src="https://img-blog.csdnimg.cn/cd986d759bca4581819bf99db59e87ed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<center>完全新生代 GC 的执行过程</center>

<p>部分新生代 GC 则是除了所有新生代区域外，还会选择一部分老年代区域进入回收集合。除了回收集合的选择方式，部分新生代 GC 和完全新生代 GC 的执行过程是一样的。</p>
<img src="https://img-blog.csdnimg.cn/8f49e4c49f164e299135fb912a6fc10d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MjkxOTE5,size_16,color_FFFFFF,t_70">

<center>部分新生代 GC 的执行过程</center>


<h3 id="Allocation-Evacuation-Failure"><a href="#Allocation-Evacuation-Failure" class="headerlink" title="Allocation Evacuation Failure"></a><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#allocation_evacuation_failure">Allocation Evacuation Failure</a></h3><p>与 CMS 一样，G1 与应用程序并发执行，并且存在应用程序分配对象的速度比垃圾回收器恢复可用空间速度快的风险。</p>
<blockquote>
<p>这种会导致回收过程中反而内存扩大</p>
</blockquote>
<p>在 G1 中，Java 堆耗尽的问题可能发生在 G1 将存活数据从一个区域复制到另一个区域的过程中。如果在垃圾回收区域的疏散期间无法找到闲置的区域，则会发生分配失败，并且将会执行一个 stop-the-world 的 full collection。</p>
<h3 id="浮动垃圾"><a href="#浮动垃圾" class="headerlink" title="浮动垃圾"></a>浮动垃圾</h3><p>对象可能会在 G1 回收期间死亡，且不会被回收。G1 使用一种称为 snapshot-at-the-beginning (SATB) 的技术来保证垃圾回收器找到所有存活对象。SATB 声明任何在并发标记（整个堆上的标记）开始的时候处于存活状态的对象都被认为是存活的，以便回收。SATB 允许浮动垃圾，以类似于 CMS 增量更新的方式。</p>
<h3 id="Pauses"><a href="#Pauses" class="headerlink" title="Pauses"></a>Pauses</h3><p>G1 暂停应用程序以将活动对象复制到新区域。这些暂停可以是仅回收年轻区域的年轻回收暂停，也可以是疏散年轻和老年区域的混合回收暂停。与 CMS 一样，当应用程序停止时，有一个最终标记或注释暂停来完成标记。CMS 也有初始标记暂停，而 G1 将初始标记工作作为疏散暂停的一部分。G1 在回收结束时有一个清理阶段，它是部分 STW，部分并发的。清理阶段的 STW 部分识别空区域，并确定作为下一次回收候选的老年区域。</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 官方文档翻译笔记</title>
    <url>/2022/07/15/MyBatis/MyBatis-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><a href="https://mybatis.org/mybatis-3/">MyBatis</a></h1><hr>
<h2 id="1-Getting-started"><a href="#1-Getting-started" class="headerlink" title="1. Getting started"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Getting_started">1. Getting started</a></h2><h3 id="1-1-Installation"><a href="#1-1-Installation" class="headerlink" title="1.1. Installation"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Installation">1.1. Installation</a></h3><p>进行最基本的 MyBatis 应用开发需要导入的依赖，最新版本可以参考<a href="https://github.com/mybatis/mybatis-3/releases">github</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-2-Building-SqlSessionFactory-from-XML"><a href="#1-2-Building-SqlSessionFactory-from-XML" class="headerlink" title="1.2. Building SqlSessionFactory from XML"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Building_SqlSessionFactory_from_XML">1.2. Building SqlSessionFactory from XML</a></h3><p>从 XML 构建 SqlSessionFactory。所有 mybatis 应用程序围绕 <code>SqlSessionFactory</code> 实例。可以通过 <code>SqlSessionFactoryBuilder</code> 获取到 <code>SqlSessionFactory</code> 实例。<code>SqlSessionFactoryBuilder</code> 可以从以下几个来源进行构建：</p>
<ul>
<li>Mybatis configuration xml</li>
<li>Configuration object</li>
</ul>
<p>从 XML 文件构建 <code>SqlSessionFactory</code> 实例，建议使用<strong>类路径资源</strong>，但实际上也可以使用 InputStream。</p>
<p><strong>mybatis-config.xml</strong> 可以参考<a href="https://mybatis.org/mybatis-3/getting-started.html">官网</a></p>
<h3 id="1-3-Building-SqlSessionFactory-without-XML"><a href="#1-3-Building-SqlSessionFactory-without-XML" class="headerlink" title="1.3. Building SqlSessionFactory without XML"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Building_SqlSessionFactory_without_XML">1.3. Building SqlSessionFactory without XML</a></h3><p>可以参考官网的案例。但是，并不支持这种做法，因为高级映射仍然需要 XML 的支持。</p>
<h3 id="1-4-Acquiring-a-SqlSession-from-SqlSessionFactory"><a href="#1-4-Acquiring-a-SqlSession-from-SqlSessionFactory" class="headerlink" title="1.4. Acquiring a SqlSession from SqlSessionFactory"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Acquiring_a_SqlSession_from_SqlSessionFactory">1.4. Acquiring a SqlSession from SqlSessionFactory</a></h3><p>通过以下代码可以创建一个 Session（注意关闭）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>


<h3 id="1-5-Exploring-Mapped-SQL-Statements"><a href="#1-5-Exploring-Mapped-SQL-Statements" class="headerlink" title="1.5. Exploring Mapped SQL Statements"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Exploring_Mapped_SQL_Statements">1.5. Exploring Mapped SQL Statements</a></h3><p>语句可以由 XML 或者 Annotation 定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述例子，在命名空间 <code>org.mybatis.example.BlogMapper</code> 中，定义了名为 <code>selectBlog</code> 的映射语句，允许你通过完全限定名称 <code>org.mybatis.example.BlogMapper.selectBlog</code> 来调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<p>这与在完全限定的 Java 类上调用一个方法是非常类似的，这也是如此设计的原因。使用与映射的 select 语句在名称，参数，返回类型相匹配的方法，可以直接映射到与命名空间名称相同的 Mapper 类。这允许你简单地将方法调用在映射器接口上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure>
<p>第二种方法有很多优势。首先，它不依赖字符串，更安全。其次，如果你的 IDE 由代码补全，可以利用它跳转到你映射的 SQL 语句。</p>
<p><strong>Namespaces</strong><br>以前版本的 MyBatis 命名空间是可选的，现在强制需要命名空间，具有隔离语句的目的。</p>
<p>命名空间让接口进行绑定，并且，即使你现在并不认为你会使用，你也应该遵循这种实践，防止你改变想法。一旦使用命名空间，把它放到正确的 Java 包命名空间下能清理你的代码，并且长期内提高 MyBatis 的可用性</p>
<p>对于简单的语句，可以使用注解方式定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">  Blog <span class="title function_">selectBlog</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过，对于复杂的语句，建议使用 XML 方式定义，否则显得混乱。</p>
</blockquote>
<h2 id="2-Configuration-XML"><a href="#2-Configuration-XML" class="headerlink" title="2. Configuration XML"></a><a href="https://mybatis.org/mybatis-3/configuration.html">2. Configuration XML</a></h2><h3 id="2-1-properties"><a href="#2-1-properties" class="headerlink" title="2.1. properties"></a><a href="https://mybatis.org/mybatis-3/configuration.html#properties">2.1. properties</a></h3><p><code>&lt;properties&gt;</code> 除了支持嵌入内置属性，还支持引入外部 Java 属性文件，只需通过 resource 或者 url 属性设置即可。resource 是以类路径为基础路径的相对路径，url 为标准的路径位置，如 file:&#x2F;&#x2F;&#x2F;。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong> </p>
<ul>
<li>resource 和 url 不可以同时设置，否则抛出异常。</li>
<li>如果配置了相同的属性，则后面的会覆盖前面的；如果是分散在属性文件和子元素属性中，那么由于属性文件后加载，因此属性文件会覆盖子元素属性。</li>
<li><code>&lt;properties&gt;</code> 标签必需位于 <code>configuration</code> 子元素第一个</li>
</ul>
<p>属性配置完，可以在配置文件中使用属性，以替代需要动态配置的值。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性的来源也可以是由程序传递给 SqlSessionFactoryBuilder.build() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, props);</span><br><span class="line"><span class="comment">// ... or ...</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>.build(reader, environment, props);</span><br></pre></td></tr></table></figure>



<h3 id="2-2-settings"><a href="#2-2-settings" class="headerlink" title="2.2. settings"></a><a href="https://mybatis.org/mybatis-3/configuration.html#settings">2.2. settings</a></h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cacheEnabled</td>
<td align="left">全局启用或禁用此配置下任何映射器中的任何缓存</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">lazyLoadingEnabled</td>
<td align="left">全局懒加载。该值可以被 <code>fetchType</code> 取代。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">aggressiveLazyLoading</td>
<td align="left">启用后，任何方法调用都会加载对象的延迟属性。否则，每个属性按需加载。具体见 <code>lazyLoadTriggerMethods</code></td>
<td align="left"></td>
<td align="left">false (true in ≤3.4.1)</td>
</tr>
<tr>
<td align="left">useColumnLabel</td>
<td align="left">使用列标签而不是列名。不同的驱动表现不同。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">mapUnderscoreToCamelCase</td>
<td align="left">下划线到驼峰转换</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">autoMappingBehavior</td>
<td align="left">是否自动映射，Spring MyBatis 默认为 PARTIAL，注意。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">defaultExecutorType</td>
<td align="left">配置默认的执行器。SIMPLE REUSE BATCH</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">localCacheScope</td>
<td align="left">本地缓存的作用域</td>
<td align="left">SESSION | STATEMENT</td>
<td align="left">SESSION</td>
</tr>
<tr>
<td align="left">logImpl</td>
<td align="left">指定 MyBatis 应该使用的日志实现。如果未设置，则自动发现。</td>
<td align="left">SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</td>
<td align="left">Not set</td>
</tr>
</tbody></table>
<h3 id="2-3-typeAliases"><a href="#2-3-typeAliases" class="headerlink" title="2.3. typeAliases"></a><a href="https://mybatis.org/mybatis-3/configuration.html#typeAliases">2.3. typeAliases</a></h3><p>别名是 Java 类型的短名称，可以简单地减少完全限定类名的冗余输入。支持 <code>&lt;typeAlias&gt;</code> 和 <code>&lt;package&gt;</code> 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>指定 MyBatis 搜索 bean 的包，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在包中的<strong>所有 bean</strong>，都会使用 bean 的小写非限定类名作为别名。其中，<code>domain.blog.Author</code> 将被注册为 <code>author</code>。特殊地，如果发现 @Alias 注解，则其值将用作别名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有许多内置的 Java 类型的别名。它们都是大小写不敏感的。具体参见类 <code>TypeAliasRegistry</code></p>
<h3 id="2-4-typeHandlers"><a href="#2-4-typeHandlers" class="headerlink" title="2.4. typeHandlers"></a><a href="https://mybatis.org/mybatis-3/configuration.html#typeHandlers">2.4. typeHandlers</a></h3><p>typeHandler 用于两个地方：</p>
<ul>
<li>当 MyBatis 在 PreparedStatement 设置参数时。参见 <code>DefaultParameterHandler</code></li>
<li>从 ResultSet 检索值。参见 <code>DefaultResultSetHandler</code></li>
</ul>
<blockquote>
<p>自从  3.4.5, MyBatis 默认支持 JSR-310 (Date and Time API)</p>
</blockquote>
<p>在 MyBatis 中，存在一个 <code>TypeHandlerRegistry</code> 组件，其维护了一个 Map 结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>该 Map 的 key 是 <code>java.lang.reflect.Type</code> 类型对象，value 又是一个 Map（称为 sub map），通常用于传入一个 Class 对象，得到 Jdbc 类型支持的类型处理器，sub map 通常还会存储一个 key 为 null 的键值对，用于匹配默认的处理器。</p>
<blockquote>
<p>typeHandlers 几乎很少自己定义扩展，但少部分情况还是比较有效的，例如：不涉及查询的一对多关系、setString 的乱码问题。</p>
</blockquote>
<h3 id="2-5-Handling-Enums"><a href="#2-5-Handling-Enums" class="headerlink" title="2.5. Handling Enums"></a><a href="https://mybatis.org/mybatis-3/configuration.html#Handling_Enums">2.5. Handling Enums</a></h3><h3 id="2-6-objectFactory"><a href="#2-6-objectFactory" class="headerlink" title="2.6. objectFactory"></a><a href="https://mybatis.org/mybatis-3/configuration.html#objectFactory">2.6. objectFactory</a></h3><p>使用 ObjectFactory 进行创建结果对象的新实例。不仅支持无参构造器的创建，也支持有参构造器创建。</p>
<h3 id="2-7-plugins"><a href="#2-7-plugins" class="headerlink" title="2.7. plugins"></a><a href="https://mybatis.org/mybatis-3/configuration.html#plugins">2.7. plugins</a></h3><h3 id="2-8-environments"><a href="#2-8-environments" class="headerlink" title="2.8. environments"></a><a href="https://mybatis.org/mybatis-3/configuration.html#environments">2.8. environments</a></h3><p>MyBatis 可以配置多个环境。这有助于你以任何原因将 SQL 映射到不同的数据库。例如，你可能对于开发，测试和生产环境由不同的配置。或者，你可能有多个表结构相同的生产数据库，并且你希望为两者使用相同的 SQL 映射。</p>
<p><strong>注意</strong> 尽管你可以配置多个环境，但是你只可以为每个 SqlSessionFactory 选择一个。因此，如果要连接到多个数据库，则需要为每个数据库创建一个 SqlSessionFactory。</p>
<ul>
<li><strong>每个数据库一个 SqlSessionFactory 实例</strong></li>
</ul>
<p>传递给 build() 方法参数 environment 可以指定环境，否则使用 default 环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment, properties);</span><br></pre></td></tr></table></figure>


<p><strong>transactionManager</strong></p>
<p>MyBatis 包含了两种事务管理器，JDBC | MANAGED</p>
<p><strong>dataSource</strong></p>
<p>dataSource 元素使用标准 JDBC DataSource 接口配置 JDBC Connection 对象。</p>
<p>大多数 MyBatis 应用程序将根据示例中配置 dataSource。但是，它不是必需的。但是，要促进懒加载，数据源是需要的。</p>
<p>有三种内置的数据源类型，UNPOOLED | POOLED | JNDI</p>
<p><strong>UNPOOLED</strong> 每次请求时，数据源都是简单地打开和关闭一个链接。虽然它有点慢，但是对于不需要立即可用连接地简单应用来说，是个不错地选择。不同的数据库也不同，因此对于一些池化不太重要的数据库，该配置会是比较理想的。UNPOOLED 数据源具有以下属性需要配置：</p>
<ul>
<li><code>driver</code> </li>
<li><code>url</code></li>
<li><code>username</code></li>
<li><code>password</code></li>
<li><code>defaultTransactionIsolationLevel</code> 连接的默认事务隔离级别</li>
<li><code>defaultNetworkTimeout</code> 默认网络超时值，以等待数据库操作完成，单位毫秒</li>
</ul>
<p><strong>POOLED</strong> DataSource 池化 JDBC Connection 对象，以避免创建新连接实例所需要的初始化和认证时间。这是一种当前 web 应用中流行的方式，可以获得最快的响应。</p>
<p>除了上面的（UNPOOLED）属性之外，还有许多属性可用于配置 POOLED 数据源：</p>
<ul>
<li><code>poolMaximumActiveConnections</code></li>
<li><code>poolMaximumIdleConnections</code></li>
<li><code>poolMaximumCheckoutTime</code></li>
<li><code>poolTimeToWait</code></li>
<li><code>poolMaximumLocalBadConnectionTolerance</code></li>
<li><code>poolPingQuery</code> ping 查询被发送到数据库以验证连接处于良好的工作状态，并且已准备好接受请求。默认值：”NO PING QUERY SET”，这回引起大多数数据库驱动以错误信息产生失败。</li>
<li><code>poolPingEnabled</code> 开启或禁用 ping 查询。如果开启，你必须用一个有效的 SQL 语句（最好很快）设置 <code>poolPingQuery</code> 属性。默认：false</li>
<li><code>poolPingConnectionsNotUsedFor</code></li>
</ul>
<p><strong>JNDI</strong> 此 DataSource 的实现旨在与容器（如 EJB 或者应用服务器）一起使用，该数据源可以配置内部或外部数据源，并且在 JNDI 上下文中对其进行引用。该数据源配置只需要两个属性：</p>
<ul>
<li>initial_context</li>
<li>data_source</li>
</ul>
<h3 id="2-9-databaseIdProvider"><a href="#2-9-databaseIdProvider" class="headerlink" title="2.9. databaseIdProvider"></a><a href="https://mybatis.org/mybatis-3/configuration.html#databaseIdProvider">2.9. databaseIdProvider</a></h3><h3 id="2-10-mappers"><a href="#2-10-mappers" class="headerlink" title="2.10. mappers"></a><a href="https://mybatis.org/mybatis-3/configuration.html#mappers">2.10. mappers</a></h3><p>定义映射的 SQL 语句，首先，我们需要告诉 MyBatis 在哪里找到他们，你可以使用：</p>
<ul>
<li>类路径相对资源引用</li>
<li>完全限定 url 引用，包括 <code>file:///</code></li>
<li>类名</li>
<li>包名</li>
</ul>
<h4 id="方式1-类路径相对资源引用"><a href="#方式1-类路径相对资源引用" class="headerlink" title="方式1 类路径相对资源引用"></a>方式1 类路径相对资源引用</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式2-完全限定-url-引用"><a href="#方式2-完全限定-url-引用" class="headerlink" title="方式2 完全限定 url 引用"></a>方式2 完全限定 url 引用</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式3-类名"><a href="#方式3-类名" class="headerlink" title="方式3 类名"></a>方式3 类名</h4><p>注册的配置结构如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注册源码分析</strong></p>
<p>依靠组件 <code>MapperRegistry</code> 进行注册。不需要尝试配置两个一样的类，否则你会得到异常。</p>
<p>依靠 <code>MapperAnnotationBuilder</code> 解析注解。注解解析部分，通过反射 Class.getMethod() 获取到接口所有的方法。</p>
<p>MapperAnnotationBuilder 会委派内部的 MapperBuilderAssistant 进行语句添加，还会缓存到 MapperBuilderAssistant  中</p>
<h4 id="方式4-包名"><a href="#方式4-包名" class="headerlink" title="方式4 包名"></a>方式4 包名</h4><p>注册该包下所有接口为 mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>你在指定非 package 的配置时，只能配置 url，name，resource 之一的属性，否则你会得到异常。</p>
<h2 id="3-Mapper-XML-Files"><a href="#3-Mapper-XML-Files" class="headerlink" title="3. Mapper XML Files"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#">3. Mapper XML Files</a></h2><h3 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1. select"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#select">3.1. select</a></h3><p>对于形如 <code>#&#123;id&#125;</code> 这样的标记，这告诉 MyBatis 需要创建一个 PreparedStatement 的参数。使用 JDBC，这样的参数会在 SQL 中识别为 “?”，传递给 PreparedStatement。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">在该 namesapce 下的唯一标识符，可以用于引用该语句，即 Statement ID。</td>
</tr>
<tr>
<td align="left">parameterType</td>
<td align="left">将传递到此语句的参数的完全限定类名或别名。可选，因为 MyBatis 可以通过传递给语句的实际参数得到 <code>TypeHandler</code></td>
</tr>
<tr>
<td align="left">resultType</td>
<td align="left">从此语句返回的预期类型的完全限定类名或别名。在集合的情况下，这应该是集合包含的类型，而不是集合类型。使用 <code>resultType</code> 或者 <code>resultMap</code>，不可以都用。</td>
</tr>
<tr>
<td align="left">resultMap</td>
<td align="left">外部 <code>resultMap</code> 的引用。使用 <code>resultMap</code> 或者 <code>resultType</code>，不可以都用。</td>
</tr>
<tr>
<td align="left">flushCache</td>
<td align="left">设置为 true 将导致当调用此语句时会刷新 Local 和 2 级缓存。对于 select 默认是 false</td>
</tr>
<tr>
<td align="left">useCache</td>
<td align="left">设置为 true 将导致该语句的结果缓存在 2 级缓存。对于 select 语句默认为: <code>true</code></td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">驱动等待数据库返回数据，在抛出异常之前的超时时间，默认 <code>unset</code>（驱动决定）</td>
</tr>
<tr>
<td align="left">fetchSize</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">statementType</td>
<td align="left">可选值：STATEMENT, PREPARED, CALLABLE。默认值：PREPARED</td>
</tr>
<tr>
<td align="left">resultSetType</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">databaseId</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">resultOrdered</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">resultSets</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="3-2-insert-update-and-delete"><a href="#3-2-insert-update-and-delete" class="headerlink" title="3.2. insert, update and delete"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#insert.2C_update_and_delete">3.2. insert, update and delete</a></h3><p>MyBatis 加载 Mapper 的时候会将读取到的语句信息都存储到 Configuration 的属性 <code>mappedStatements</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, MappedStatement&gt; mappedStatements;</span><br></pre></td></tr></table></figure>

<p>其中，<code>MappedStatement</code> 又能够获取 <code>BoundSql</code></p>
<h3 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h3><ul>
<li>collection</li>
</ul>
<p>支持分步查询和关联查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.cannedbread.dictionary.pojo.domain.DictionaryTypeDO&quot;</span> <span class="attr">id</span>=<span class="string">&quot;doctionaryType&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;t_type&quot;</span> <span class="attr">property</span>=<span class="string">&quot;type&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;t_description&quot;</span> <span class="attr">property</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;dictionaryTypeList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.cannedbread.dictionary.pojo.domain.DictionaryValueDO&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;v_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;v_label&quot;</span> <span class="attr">property</span>=<span class="string">&quot;label&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;v_value&quot;</span> <span class="attr">property</span>=<span class="string">&quot;value&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="3-3-Parameters"><a href="#3-3-Parameters" class="headerlink" title="3.3. Parameters"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Parameters">3.3. Parameters</a></h3><p>参数，指传递给语句的参数。参数可以认为有 2 种：</p>
<ul>
<li><p>简易（原始）数据类型。 Integer、String 等没有属性的值。</p>
</li>
<li><p>复合数据类型。可以理解为是由简易数据类型组合而成的类。</p>
</li>
</ul>
<p>通常，我们使用 <code>#&#123;id&#125;</code> 这种方式引用参数。但是，参数可以更具体地引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#&#123;property,javaType=<span class="type">int</span>,jdbcType:NUMBERIC&#125;</span><br></pre></td></tr></table></figure>
<p><code>javaType</code> 基本可以总是从参数对象中确定，除非该对象是 <code>HashMap</code>，那么需要显式指定 <code>javaType</code> 确保使用正确的 TypeHandler。</p>
<ul>
<li>传入 List</li>
</ul>
<p>引用名称必须为 <code>list</code>，获取长度：<code>list.size</code>，获取第 n 个元素：list[n]</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;list != null and list.size != 0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span>&gt;</span>#&#123;item&#125;<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>传入多个值</li>
</ul>
<p>多个参数会封装成 Map，key 为 param1, param2, …</p>
<p>引用方式：<code>#&#123;param1&#125;</code>、<code>#&#123;param2.password&#125;</code></p>
<ul>
<li>传入 Map</li>
</ul>
<p>对 XML 中映射的语句进行解析之后，能够得到一个 <code>List&lt;ParameterMapping&gt;</code>，其中收集所有 <code>#&#123;&#125;</code> 占位符。</p>
<p>这些结构之后会传递给 <code>StatementHandler</code>，通常是 <code>PreparedStatementHandler</code>，之后通过 handler 进行参数设置。</p>
<h3 id="3-4-Result-Maps"><a href="#3-4-Result-Maps" class="headerlink" title="3.4. Result Maps"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Result_Maps">3.4. Result Maps</a></h3><p>对于如下映射语句例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据 <code>resultType</code> 属性所指定的，这样的语句会简单地将所有地列自动映射到 <code>HashMap</code> 的 key 上。但是，在大多数场景下，<code>HashMap</code>并不是一个好的领域模型。应用程序更有可能使用 Java Bean 或者 POJO。考虑如下的 Java Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String hashedPassword;</span><br><span class="line">  <span class="comment">// Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于 Java Bean 规范，上面的类有 3 个属性：id, username, hashedPassword。这些与 SELECT 语句中的列名<strong>完全匹配</strong>。这样，Java Bean 可以像 HashMap 一样，简单地映射到 ResultSet。</p>
<p>在这些情况下，MyBatis 自动在幕后创建 ResultMap 以将列名基于名称地自动映射到 Java Bean 的属性。</p>
<p><strong>列名与属性名不匹配的情况如何处理 ?</strong></p>
<ul>
<li>标准 SQL 语法，SELECT 语句别名</li>
<li>使用自定义 <code>&lt;Result Map&gt;</code></li>
</ul>
<h4 id="3-4-1-Advanced-Result-Maps"><a href="#3-4-1-Advanced-Result-Maps" class="headerlink" title="3.4.1. Advanced Result Maps"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Advanced_Result_Maps">3.4.1. Advanced Result Maps</a></h4><p>Result Map 是 MyBatis 强大的工具，可以自由映射结果。</p>
<h4 id="3-4-2-resultMap"><a href="#3-4-2-resultMap" class="headerlink" title="3.4.2. resultMap"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#resultMap">3.4.2. resultMap</a></h4><p><code>&lt;resultMap&gt;</code> 元素的概览：</p>
<ul>
<li><code>&lt;constructor&gt;</code> 用于在实例化时将结果注入类的构造函数<ul>
<li><code>idArg</code> ID 参数，标识 ID 将有助于提升整体性能</li>
<li><code>arg</code> 普通结果参数注入</li>
</ul>
</li>
<li><code>&lt;id&gt;</code> 一个 ID 结果，标识 ID 将会提高整体性能</li>
<li><code>&lt;result&gt;</code> 普通结果参数</li>
<li><code>&lt;association&gt;</code> 复合类型关联，许多结果会汇总到该类型<ul>
<li>嵌套结果映射 - association 本身就是 <code>resultMap</code>，或者可以引用其他的 <code>resultMap</code></li>
</ul>
</li>
<li><code>&lt;collection&gt;</code> 复合类型的集合<ul>
<li>嵌套结果映射 - collection 本身就是 <code>resultMap</code>，或者可以引用其他的 <code>resultMap</code></li>
</ul>
</li>
<li><code>&lt;discriminator&gt;</code> 使用结果的值来确定要使用的 <code>resultMap</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">当前命名空间下引用此 result map 的唯一标识符</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">Java 的完全限定名，或者别名</td>
</tr>
<tr>
<td align="left">autoMapping</td>
<td align="left">如果存在该属性，MyBatis 会为该 result map 启用或禁用自动映射</td>
</tr>
</tbody></table>
<h4 id="3-4-3-id-amp-result"><a href="#3-4-3-id-amp-result" class="headerlink" title="3.4.3. id &amp; result"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#id_.26_result">3.4.3. id &amp; result</a></h4><p>id 和 result 都可以映射一个列的值到一个简单数据类型的字段（String,int,double,Date,…）</p>
<h4 id="association"><a href="#association" class="headerlink" title="association"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#association">association</a></h4><p>association 元素处理 “has-one” 类型关系。例如，一个博客有一个作者。<code>&lt;association&gt;</code> 映射像其他 <code>&lt;result&gt;</code> 一样工作。你可以指定 <code>property</code>, <code>javaType</code>, <code>jdbcType</code>, <code>typeHandler</code>。</p>
<p>association 不同之处在于，你需要告诉 MyBatis 如何加载关联数据，支持 2 种方式：</p>
<ul>
<li>Nested Select：嵌套查询，或者嵌套子查询。通过执行另一个映射 SQL 语句返回所需的<strong>复合类型</strong>。</li>
<li>Nested Results：嵌套结果。通过使用嵌套的结果映射来处理 join 结果的重复子集。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">property</td>
<td align="left">字段或属性。如果给定名称存在 Java Bean 匹配的属性，则会使用。否则，MyBatis 会寻找给定名称的字段。</td>
</tr>
<tr>
<td align="left">javaType</td>
<td align="left">完全限定的 Java 类名（或者 alias）。如果你映射到 Java Bean，MyBatis 会弄清楚类型。如果你映射到 HashMap，你需要指定 javaType 以确保所需的行为。</td>
</tr>
<tr>
<td align="left">jdbcType</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">typeHandler</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="Nested-Select-for-Association"><a href="#Nested-Select-for-Association" class="headerlink" title="Nested Select for Association"></a>Nested Select for Association</h4><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">column</td>
<td align="left">将要传递给嵌套语句的列名或者别名。<strong>可以确定唯一一条记录。</strong><br>注意：为了处理复合键，可以使用语法 <code>column=&quot;prop1=col1,prop2=col2&quot;</code> 指定多个列名传递给嵌套的 select 语句</td>
</tr>
<tr>
<td align="left">select</td>
<td align="left">映射语句的 ID，将会加载需要的复杂类型</td>
</tr>
<tr>
<td align="left">fetchType</td>
<td align="left">可选。有效值是 lazy 和 eager。如果存在，它会覆盖全局配置参数 <code>lazyLoadingEnabled</code></td>
</tr>
</tbody></table>
<blockquote>
<p>嵌套 SELECT 必须确保结果集的数量小于等于 1 个，否则你会得到异常：<br>org.apache.ibatis.executor.ExecutorException: Statement returned more than one row, where no more than one was expected.</p>
</blockquote>
<p><strong>官方提示</strong> 虽然这种方式比较简单，但是，对于大量数据集或者列表性能并不好。这种问题也被称之为 “N + 1 Select 问题”。简而言之，N + 1 Select 问题是由类似如下引起的：</p>
<ul>
<li>你执行单个 SQL 检索出一个记录列表（+1）</li>
<li>对于每个返回的记录，你执行 select 语句来加载每个的细节（N）</li>
</ul>
<p>该问题会导致大量 SQL 执行，并不是可取的。MyBatis 可以拦截在这些查询语句，因此你可能会忽略这些语句的开销。但是，如果你加载这样的列表，然后立即迭代它访问嵌套数据，则会调用所有延迟加载，因此性能可能非常糟糕。</p>
<blockquote>
<p>这也是在开发过程中比较忌讳的，在循环体中发起 SQL 查询</p>
</blockquote>
<h4 id="Nested-Results-for-Association"><a href="#Nested-Results-for-Association" class="headerlink" title="Nested Results for Association"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Nested_Results_for_Association">Nested Results for Association</a></h4><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">resultMap</td>
<td align="left">ID</td>
</tr>
<tr>
<td align="left">columnPrefix</td>
<td align="left">当 join 多张表时，你往往会使用别名来避免结果重复列名。指定 <code>columnPrefix</code> 允许你在映射时添加统一的前缀</td>
</tr>
<tr>
<td align="left">notNullColumn</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">autoMapping</td>
<td align="left">如果该属性存在，MyBatis 在映射该属性时，将会启用或者禁用自动映射</td>
</tr>
</tbody></table>
<h4 id="Multiple-ResultSets-for-Association"><a href="#Multiple-ResultSets-for-Association" class="headerlink" title="Multiple ResultSets for Association"></a>Multiple ResultSets for Association</h4><h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><ul>
<li>嵌套 select</li>
<li>使用 join + 嵌套结果</li>
</ul>
<h4 id="Nested-Select-for-Collection"><a href="#Nested-Select-for-Collection" class="headerlink" title="Nested Select for Collection"></a>Nested Select for Collection</h4><p><code>&lt;collection&gt;</code> 元素将会使用新的属性 <code>ofType</code>，该属性适用于区分 Java Bean 属性类型和 collection 包含的类型。</p>
<h4 id="Nested-Results-for-Collection"><a href="#Nested-Results-for-Collection" class="headerlink" title="Nested Results for Collection"></a>Nested Results for Collection</h4><p>需要注意 collection 子元素 id 的重要性。</p>
<h4 id="Multiple-ResultSets-for-Collection"><a href="#Multiple-ResultSets-for-Collection" class="headerlink" title="Multiple ResultSets for Collection"></a>Multiple ResultSets for Collection</h4><h4 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h4><h3 id="Auto-mapping"><a href="#Auto-mapping" class="headerlink" title="Auto-mapping"></a>Auto-mapping</h3><p>MyBatis 可以自动映射结果，你也可以自己构建 result map，你甚至可以结合两种。</p>
<p>通常，数据库列使用大写字母且单词之间用下划线，而 Java 属性通常遵循驼峰命名约定。可以设置 <code>mapUnderscoreToCamelCase </code> 为 true 完成自动映射。</p>
<p>即使存在 <code>resultMap</code>，自动映射也会发生。对于每个结果映射，在结果集中但没有进行手工映射的列，将会被自动映射，之后进行手工映射。</p>
<p>有 3 个映射级别：</p>
<ul>
<li><code>NONE</code> 禁用自动映射。即，只会赋值手动映射属性。</li>
<li><code>PARTIAL</code> 除了其中定义的嵌套结果映射，其他都会自动映射</li>
<li><code>FULL</code> 自动映射所有</li>
</ul>
<h2 id="3-6-cache"><a href="#3-6-cache" class="headerlink" title="3.6. cache"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#cache">3.6. cache</a></h2><p>默认地，只有 Local Cache 是启用的，用于缓存会话的数据。要启用全局二级缓存，你只需添加一行文字到你的 SQL Mapper 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>二级缓存需要配置 <code>cacheEnabled</code> 为 <code>true</code> 才会开启，一般默认是开启的，但建议显式设置。另外，使用二级缓存，还需要实体类实现 <code>Serializable</code> 接口，否则将会抛出异常。</p>
</blockquote>
<p>这个简单的语句效果如下：</p>
<ul>
<li>缓存所有映射语句文件中 SELECT 语句的结果</li>
<li>所有 insert, update, delete 语句将刷新缓存</li>
<li>缓存将使用最近最少使用（LRU）算法进行驱逐</li>
<li>缓存不会以基于计划的时间顺序刷新</li>
<li>缓存将存储 1024 个列表或对象的引用（无论方法返回什么）</li>
<li>缓存会被视为读&#x2F;写缓存，这意味，被检索的对象不会被共享，可以被调用者安全的修改，不会干扰其他线程可能的修改</li>
</ul>
<h3 id="Using-a-Custom-Cache"><a href="#Using-a-Custom-Cache" class="headerlink" title="Using a Custom Cache"></a>Using a Custom Cache</h3><p>实现 Cache 接口，并在 Mapper 文件中指定 type：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="cache-ref"><a href="#cache-ref" class="headerlink" title="cache-ref"></a>cache-ref</h3><p>在不同 namespace 之间共享相同的缓存配置和实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;com.someone.application.data.SomeMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="5-Java-API"><a href="#5-Java-API" class="headerlink" title="5. Java API"></a><a href="https://mybatis.org/mybatis-3/java-api.html">5. Java API</a></h2><h3 id="5-2-SqlSessions"><a href="#5-2-SqlSessions" class="headerlink" title="5.2. SqlSessions"></a><a href="https://mybatis.org/mybatis-3/java-api.html#sqlSessions">5.2. SqlSessions</a></h3><p>通过 <code>SqlSession</code>，你可以执行命令，获得 Mapper，管理事务。<code>SqlSession</code> 由 <code>SqlSessionFactory</code> 创建。</p>
<h4 id="5-2-1-SqlSessionFactoryBuilder"><a href="#5-2-1-SqlSessionFactoryBuilder" class="headerlink" title="5.2.1. SqlSessionFactoryBuilder"></a>5.2.1. SqlSessionFactoryBuilder</h4><p><code>SqlSessionFactoryBuilder</code> 有 5 个 build() 方法，每个方法允许你从不同来源构建 <code>SqlSessionFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String env, Properties props)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span></span><br></pre></td></tr></table></figure>

<p><code>environment</code> MyBatis 将会使用的环境，如果没有调用包含 environment 参数的方法，则使用默认环境。</p>
<p><code>properties</code> MyBatis 将会加载的属性，可使用 <code>$&#123;propName&#125;</code> 进行配置</p>
<p><strong>关于 properties 加载的顺序</strong> </p>
<ul>
<li>首先，读取 properties 元素主体中指定的属性</li>
<li>其次，加载于 properties 元素的 resource 类路径资源或者 url 属性指定的资源将会被读取</li>
<li>最后，作为方法参数传递的 properties 最后读取</li>
</ul>
<p>后加载的属性会覆盖前者</p>
<h4 id="5-2-2-SqlSessionFactory"><a href="#5-2-2-SqlSessionFactory" class="headerlink" title="5.2.2. SqlSessionFactory"></a>5.2.2. SqlSessionFactory</h4><p>SqlSessionFactory 有 6 种方法用于创建 SqlSession 实例。一般地，当你选择用哪个方法时，需要考虑以下事情：</p>
<ul>
<li><strong>Transaction</strong>：你是否希望为 session 使用事务范围，或者使用 auto-commit（这通常意味着数据库或 JDBC 没有事务）？</li>
<li><strong>Connection</strong>：从 MyBatis 配置好的数据源获取还是自己提供</li>
<li><strong>Execution</strong>：重用 PreparedStatement 还是批处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">()</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(Connection connection)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, <span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span></span><br><span class="line">Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>默认地，无参的 openSession() 将会创建具有如下特征的 SqlSession：</p>
<ul>
<li>启动事务，即不会 auto commit</li>
<li>Connection 对象从 DataSource 中获取</li>
<li>事务隔离级别是驱动或者数据源使用的默认值</li>
<li>不会重用 PreparedStatements，不会批量更新</li>
</ul>
<p>ExecutorType 参数定义了 3 个可选值：</p>
<ul>
<li>ExecutorType.SIMPLE：朴素的执行器。为每个执行语句创建一个 PreparedStatement。</li>
<li>ExecutorType.REUSE：这种类型会重用 PreparedStatement。</li>
<li>ExecutorType.BATCH：批量更新，同时，如果执行语句之间有 SELECT 语句，也会在必要的地方划清。</li>
</ul>
<h4 id="5-2-3-SqlSession"><a href="#5-2-3-SqlSession" class="headerlink" title="5.2.3. SqlSession"></a><a href="https://mybatis.org/mybatis-3/java-api.html#SqlSession">5.2.3. SqlSession</a></h4><h5 id="5-2-3-1-Statement-Execution-Methods"><a href="#5-2-3-1-Statement-Execution-Methods" class="headerlink" title="5.2.3.1. Statement Execution Methods"></a><a href="https://mybatis.org/mybatis-3/java-api.html#Statement_Execution_Methods">5.2.3.1. Statement Execution Methods</a></h5><p>SqlSession 具有许多方法，用于执行 SQL 映射文件中定义的 SELECT, INSERT, UPDATE, DELETE 语句。每个方法都有一个 <code>statement</code> 参数（Statement ID），并且可以有 parameter 参数，参数可以是原始类型（自动装箱），或者 Java Bean，POJO，Map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement)</span>;</span><br><span class="line">&lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement)</span>;</span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement)</span>;</span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line">&lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, String mapKey)</span>;</span><br><span class="line">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span>;</span><br><span class="line">&lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, ResultHandler handler)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, Object parameter, ResultHandler handler)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>selectOne</code> 和 <code>selectList</code> 不同点在于， <code>selectOne</code> 必须返回一个对象或者 null（没有对象）。如果超过一个对象，则抛出异常。</li>
</ul>
</blockquote>
<p>如果你不知道有多少对象，使用 <code>selectList</code> 总是安全的。</p>
<p>如果你想检查对象是否存在，你最好返回一个计数值（0 或 1）。</p>
<p><code>selectMap</code> 是一个特殊的情况，它会基于结果中的某个属性，将结果列表转换为一个 Map。</p>
<p>因为不是所有方法都需要参数，因此这些方法都有一个无参数的重载方法。</p>
<p><code>insert</code>, <code>update</code>, <code>delete</code> 的返回值表示的是影响行数。</p>
<p>有几种高级的 <code>select</code> 方法，它们允许你限制要返回的行范围，或者提供自定义的结果处理逻辑（ResultHandler），通常用于非常大的数据集（MySQL 几乎不使用）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span><br><span class="line">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowbounds)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span> <span class="params">(String statement, Object parameter, ResultHandler&lt;T&gt; handler)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler)</span></span><br></pre></td></tr></table></figure>
<p><code>RowBounds</code> 参数会让 MyBatis 跳过指定的记录数，同时限制要返回的记录数。</p>
<blockquote>
<ul>
<li>在这里，不同的驱动能够获得不同的效率。为了最佳性能，需要使用结果集类型为 <code>SCROLL_SENSITIVE </code> 或者 <code>SCROLL_INSENSITIVE </code></li>
</ul>
</blockquote>
<p><code>ResultHandler</code> 参数允许你按照你的方式处理每一行。你可以把它添加到 List，创建一个 Map，Set，或者抛出买个结果，而只保留计算的计算的总数。你可以使用 ResultHandler 做任何事情，这就是 MyBatis 内部使用来构造结果集列表的。</p>
<p>ResultHandler 接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResultHandler</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(ResultContext&lt;? extends T&gt; context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ResultContext</code> 参数用于访问结果对象本身，这是被创建的结果对象的数量计数，以及你可以使用 <code>stop()</code> 方法停止 MyBatis 加载更多结果。</p>
<p>使用 <code>ResultHandler</code> 有两点你应该了解：</p>
<ul>
<li>使用 <code>ResultHandler</code> 调用的方法种的数据不会被缓存</li>
<li>当使用高级 <code>resultMap</code> 时，MyBatis 有可能需要多行来构建 1 个对象。如果使用 <code>ResultHandler</code>，可能会给你一个关联或者集合未被填充的对象。</li>
</ul>
<h5 id="Local-Cache"><a href="#Local-Cache" class="headerlink" title="Local Cache"></a><a href="https://mybatis.org/mybatis-3/java-api.html#Local_Cache">Local Cache</a></h5><p>MyBatis 使用了 2 个缓存，Local Cache 和 二级缓存。</p>
<p>每次 MyBatis 创建新的会话时，也会创建一个 Local Cache 附加到会话中。在<strong>本次会话</strong>中执行的任何查询都将存储在本地缓存中，因此具有相同输入参数的相同查询，以后都不会查询数据库。当 update, commit, rollback 和 close 时，Local Cache 会清除。</p>
<h6 id="1-Local-Cache-原理-👇"><a href="#1-Local-Cache-原理-👇" class="headerlink" title="1. Local Cache 原理 👇"></a>1. Local Cache 原理 👇</h6><p>一般地，执行查询方法的时候都是调用 BaseExecutor 的 query() 方法，其方法内部会先考虑是否从 Local Cache 中获取数据，如果不从缓存中获取，则调用内部的 doQuery() 方法</p>
<h6 id="Local-Cache-的-Key-🐱"><a href="#Local-Cache-的-Key-🐱" class="headerlink" title="Local Cache 的 Key 🐱"></a>Local Cache 的 Key 🐱</h6><p>org.apache.ibatis.cache.CacheKey 是 Local Cache 的 key</p>
<h6 id="何时可能会失效-Local-Cache（失效）？-🐌"><a href="#何时可能会失效-Local-Cache（失效）？-🐌" class="headerlink" title="何时可能会失效 Local Cache（失效）？ 🐌"></a>何时可能会失效 Local Cache（失效）？ 🐌</h6><ul>
<li>不同的会话</li>
</ul>
<p>不同的 Session 本身不共享 Local Cache。我并不认为这是失效的原因。这反而是一种使用错误的方式。</p>
<ul>
<li>执行 update 操作</li>
</ul>
<p>如果执行了更新操作会清空 Local Cache</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>手动调用 DefaultSqlSession.clearCache()</li>
</ul>
<p>底层会调用 executor 的 clearLocalCache() 方法</p>
<ul>
<li><p>设置了语句属性 <code>flushCache</code> 为 <code>true</code>，缓存全清</p>
</li>
<li><p>设置 flushCacheRequired</p>
</li>
<li><p>配置 localCacheScope 为 STATEMENT</p>
</li>
<li><p>commit 和 rollback</p>
</li>
</ul>
<h5 id="Ensuring-that-SqlSession-is-Closed"><a href="#Ensuring-that-SqlSession-is-Closed" class="headerlink" title="Ensuring that SqlSession is Closed"></a>Ensuring that SqlSession is Closed</h5><p>你必须确保关闭所有你打开的会话。推荐方式是使用 try 包裹资源。</p>
<h5 id="Using-Mappers"><a href="#Using-Mappers" class="headerlink" title="Using Mappers"></a>Using Mappers</h5><h5 id="Mapper-Annotations"><a href="#Mapper-Annotations" class="headerlink" title="Mapper Annotations"></a>Mapper Annotations</h5><table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">目标</th>
<th align="left">XML 等价物</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@CacheNamespace</td>
<td align="left">Class</td>
<td align="left"><code>&lt;cache&gt;</code></td>
<td align="left">为给定的命名空间配置缓存</td>
</tr>
<tr>
<td align="left">@CacheNamespaceRef</td>
<td align="left">Class</td>
<td align="left"><code>&lt;cacheRef&gt;</code></td>
<td align="left">引用其他命名空间的缓存。注意：xml mapper 文件声明的缓存是隔离的</td>
</tr>
<tr>
<td align="left">@MapKey</td>
<td align="left">Method</td>
<td align="left"></td>
<td align="left">用于返回类型是 Map 的方法。基于对象的属性将结果 List 转换为 Map。注解的属性 <code>value</code> 作为 Map 的 key</td>
</tr>
</tbody></table>
<h1 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a><a href="https://mp.baomidou.com/">MyBatisPlus</a></h1><hr>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.cannedbread.dictionary.mapper&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><hr>
<ul>
<li>PageHelper</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用方法：<br>(1) PageHelper.start()，传入 pageNum 当前页码，pageSize 每页显示数目。<br>(2) 调用 Mapper 方法查询<br>(3) 使用 pageInfo 构造器传入查询结果集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PageInfo&lt;ProjectArea&gt; <span class="title function_">listPageByExample</span><span class="params">(<span class="type">int</span> pageNum, <span class="type">int</span> pageSize, ProjectArea example)</span> &#123;</span><br><span class="line">	PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">	List&lt;ProjectArea&gt; result = projectAreaMapper.selectList(example);</span><br><span class="line">	PageInfo&lt;ProjectArea&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(result);</span><br><span class="line">	<span class="keyword">return</span> pageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="各种-Logger"><a href="#各种-Logger" class="headerlink" title="各种 Logger"></a>各种 Logger</h2><ul>
<li>PreparedStatementLogger</li>
<li>ConnectionLogger</li>
</ul>
<h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><h3 id="PreparedStatementHandler"><a href="#PreparedStatementHandler" class="headerlink" title="PreparedStatementHandler"></a>PreparedStatementHandler</h3><p>执行 SQL 的时候会将 statement 强制转换为 PreparedStatement 类型，并进行执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">	<span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">	ps.execute();</span><br><span class="line">	<span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SqlSource"><a href="#SqlSource" class="headerlink" title="SqlSource"></a>SqlSource</h2><ul>
<li>RawSqlSource</li>
<li>DynamicSqlSource</li>
<li>StaticSqlSource，生成 BoundSQL</li>
</ul>
<h3 id="RawSqlSource"><a href="#RawSqlSource" class="headerlink" title="RawSqlSource"></a>RawSqlSource</h3><p>RawSqlSource 拥有一个 SqlSource 的属性，它是 StaticSqlSource：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RawSqlSource</span> <span class="keyword">implements</span> <span class="title class_">SqlSource</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SqlSource sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>如何判断一个 SqlNode 是否是动态的 ?</strong></p>
<ul>
<li>如果是纯文本节点，且存在 <code>$&#123;&#125;</code>，认为是动态</li>
<li>如果是元素节点，则一定是动态</li>
</ul>
<p>具体代码见 XMLScriptBuilder.parseDynamicTags &gt; TextSqlNode.isDynamic</p>
<p><strong>为什么 RawSqlSource、DynamicSqlSource 不直接生成 BoundSQL，反而通过   StaticSqlSource 生成?</strong></p>
<p>设计的问题</p>
<p>DynamicSqlSource 解析是对 SqlNode 的解析，其中会存储根节点 rootSqlNode，节点可以认为是类似 DOM 的节点。</p>
<p><code>rootSqlNode.apply(context);</code> 即遍历 SqlNode 树进行解析，最终生成 context。</p>
<h2 id="SqlNode"><a href="#SqlNode" class="headerlink" title="SqlNode"></a>SqlNode</h2><ul>
<li>MixedSqlNode</li>
</ul>
<p>SQL 语法树从结构来看是树形，但是 MyBatis 会将同一层的所有节点用 MixedSqlNode 包装，因此，从节点的角度看，是一个链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    contents.forEach(node -&gt; node.apply(context));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>StaticTextSqlNode 静态文本</p>
</li>
<li><p>TextSqlNode 包含了表达式的文本，如：select * from ${table}</p>
</li>
<li><p>IfSqlNode</p>
</li>
</ul>
<p>计算表达式的值，如果为 true，则继续解析，一般 if 表达式下面就是静态文本了，所以大部分情况则是直接追加 SQL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">        contents.apply(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ForEachNode</li>
</ul>
<p>解析完毕之后会生成特定的序列，其中每个每个</p>
<p>该解析一定会添加 open 与 close，所以如果在拼接 in 语句的时候没有元素，可能导致 SQL 错误</p>
<ul>
<li>TrimSqlNode</li>
</ul>
<p>从进入该节点开始，将会使用 <code>FilteredDynamicContext</code> 包装原来的 context，之后的结果会缓存在 <code>FilteredDynamicContext</code> 的 <code>sqlBuffer</code> 中，直至该节点解析完毕，最后使用 filteredDynamicContext.applyAll() 真正进行应用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    TrimSqlNode.<span class="type">FilteredDynamicContext</span> <span class="variable">filteredDynamicContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrimSqlNode</span>.FilteredDynamicContext(context);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> contents.apply(filteredDynamicContext);</span><br><span class="line">    filteredDynamicContext.applyAll();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么加这一个缓存 ?</strong></p>
<p>如果直接追加 SQL 到最终的结果上，最后还需要做一步 trim，此时已经不方便 trim 了。</p>
<ul>
<li>WhereSqlNode</li>
</ul>
<p>将会删除特定的前缀，并追加前缀 WHERE</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; prefixList = Arrays.asList(<span class="string">&quot;AND &quot;</span>,<span class="string">&quot;OR &quot;</span>,<span class="string">&quot;AND\n&quot;</span>, <span class="string">&quot;OR\n&quot;</span>, <span class="string">&quot;AND\r&quot;</span>, <span class="string">&quot;OR\r&quot;</span>, <span class="string">&quot;AND\t&quot;</span>, <span class="string">&quot;OR\t&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhereSqlNode</span> <span class="keyword">extends</span> <span class="title class_">TrimSqlNode</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">WhereSqlNode</span><span class="params">(Configuration configuration, SqlNode contents)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(configuration, contents, <span class="string">&quot;WHERE&quot;</span>, prefixList, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="rootSqlNode-apply-context"><a href="#rootSqlNode-apply-context" class="headerlink" title="rootSqlNode.apply(context)"></a>rootSqlNode.apply(context)</h2><h2 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h2><p>MapperProxy 是 MyBatis 中 InvacationHandler 的实现类。其中，包含一个 SqlSessionTemplate，SqlSessionTemplate 内部又包含一个 DefaultSqlSession </p>
<p><strong>为什么 SqlSessionTemplate 又使用代理对象 sqlSessionProxy 去执行方法？</strong></p>
<p>为了实现拦截操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; SqlSession.class &#125;, <span class="keyword">new</span> <span class="title class_">SqlSessionInterceptor</span>());</span><br></pre></td></tr></table></figure>




<h2 id="CachingExecutor-的执行"><a href="#CachingExecutor-的执行" class="headerlink" title="CachingExecutor 的执行"></a>CachingExecutor 的执行</h2><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>(1) 获得 BoundSql</p>
<p>BoundSql </p>
<p>(2) 创建缓存 key</p>
<p>创建是由 BaseExecutor 完成的，其中影响因素有：</p>
<ul>
<li>MappedStatement.id，即方法全限定名</li>
<li>rowBounds.offset</li>
<li>rowBounds.limit</li>
<li>boundSql.sql</li>
<li>parameterMappings 的参数值</li>
<li>parameterMappings.environment.id</li>
</ul>
<p>(3) flushCacheIfRequired<br>(4) 使用代理 Executor 执行查询</p>
<h2 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h2><h3 id="queryFromDatabase"><a href="#queryFromDatabase" class="headerlink" title="queryFromDatabase"></a>queryFromDatabase</h3><p>(1) 获取 Configuration<br>(2) 创建 StatementHandler<br>(3) prepareStatement<br>(4) StatementHandler.query</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>AbstractContext refresh 方法流程</title>
    <url>/2022/07/22/Spring-Framework/AbstractContext-refresh-%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="AbstractContext-refresh-方法流程"><a href="#AbstractContext-refresh-方法流程" class="headerlink" title="AbstractContext refresh 方法流程"></a>AbstractContext refresh 方法流程</h1><h2 id="1-refresh-总体流程"><a href="#1-refresh-总体流程" class="headerlink" title="1. refresh 总体流程"></a>1. refresh 总体流程</h2><p>IoC 容器刷新的方法是由 <code>AbstractApplicationContext.refresh</code> 实现，方法如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 1. 为 refresh 准备上下文（与 finish 相对）</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        <span class="comment">// 2. 通知子类，refresh 其内部的 beanFactory</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        <span class="comment">// 3. 准备 Bean Factory</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            <span class="comment">// 4. 在 Context 的子类中可以后置处理 Bean Factory</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            <span class="comment">// 5. 调用以 Bean 形式注册在 Context 中的 BeanFactoryPostProcessor</span></span><br><span class="line">            <span class="comment">// 官方这句注释有些不准确，因为其中会调用 AbstractContext 内部的几个 internal BeanFactoryPostProcessor</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            <span class="comment">// 6. 注册 bean post processor</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            <span class="comment">// 7. 为 context 初始化消息资源</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            <span class="comment">// 8. 为 Context 初始化时间多播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            <span class="comment">// 9. 在特定的 context 子类中初始化其他的特殊 bean</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            <span class="comment">// 10. 检查 Listener Bean 并注册</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            <span class="comment">// 11. 实例化所有剩下来的单例</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            <span class="comment">// 12. 最后一步：发布相关事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">            <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-refresh-步骤"><a href="#2-refresh-步骤" class="headerlink" title="2. refresh 步骤"></a>2. refresh 步骤</h2><h2 id="2-1-prepareRefresh"><a href="#2-1-prepareRefresh" class="headerlink" title="2.1. prepareRefresh"></a>2.1. prepareRefresh</h2><p>该方法执行的是 refresh 之前的预处理操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 设置值、状态</span></span><br><span class="line">    <span class="built_in">this</span>.startupDate = System.currentTimeMillis(); <span class="comment">// 记录启动时间为当前时间</span></span><br><span class="line">    <span class="built_in">this</span>.closed.set(<span class="literal">false</span>); <span class="comment">// 记录关闭状态为 false</span></span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">true</span>); <span class="comment">// 记录启动状态为 true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化属性资源的空方法，留给子类覆盖</span></span><br><span class="line">    <span class="comment">// 在上下文环境中初始化一些占位符属性资源</span></span><br><span class="line">    <span class="comment">// 该方法 AbstractApplicationContext 是一个空实现，留给子类去自定义实现</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建并获取 Environment 对象，验证需要的属性文件</span></span><br><span class="line">    <span class="comment">// 验证被标记为 required 的属性</span></span><br><span class="line">    <span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 早期事件的集合</span></span><br><span class="line">    <span class="comment">// 一旦多转换器可用，就发布</span></span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 Web 环境，会覆盖这种行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 清除缓存</span></span><br><span class="line">    <span class="built_in">this</span>.scanner.clearCache();</span><br><span class="line">    <span class="built_in">super</span>.prepareRefresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-obtainFreshBeanFactory"><a href="#2-1-obtainFreshBeanFactory" class="headerlink" title="2.1. obtainFreshBeanFactory"></a>2.1. obtainFreshBeanFactory</h2><p>通知子类，refresh 其内部的 beanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 该方法是个抽象类，由子类实现</span></span><br><span class="line">    <span class="comment">// 1. 对于 GenericApplicationContext，仅仅是设置了一个序列化 ID</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 该方法是个抽象类，有子类实现</span></span><br><span class="line">    <span class="comment">// 2. 对于 GenericApplicationContext，将内部的 DefaultListableBeanFactory 返回</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子类是 <code>GenericApplicationContext</code>，实现的代码清单如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">    <span class="comment">// 设置刷新标记</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                <span class="string">&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一个序列 ID</span></span><br><span class="line">    <span class="built_in">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>AbstractApplicationContext</code><ul>
<li><code>AbstractRefreshableApplicationContext</code><ul>
<li><code>AbstractXmlApplicationContext</code><ul>
<li><code>ClassPathXmlApplicationContext</code></li>
<li><code>FileSystemXmlApplicationContext</code></li>
</ul>
</li>
</ul>
</li>
<li><code>GenericApplicationContext</code><ul>
<li><code>ServletWebServerApplicationContext</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-3-prepareBeanFactory"><a href="#2-3-prepareBeanFactory" class="headerlink" title="2.3. prepareBeanFactory"></a>2.3. prepareBeanFactory</h2><p>源码注解上有一句话：Configure the factory’s standard context characteristics, such as the context’s ClassLoader and post-processors —— 配置工程的标准上下文特性，例如上下文的类加载器以及后置处理器（<code>BeanPostProcessor</code>）。包括：</p>
<ul>
<li>设置 Bean <code>ClassLoader</code></li>
<li>设置 <code>BeanExpressionResolver</code></li>
<li>设置 <code>PropertyEditorRegistrar</code></li>
<li>添加 <code>BeanPostProcessor</code></li>
<li>设置忽略的依赖接口</li>
<li>注册可解析依赖</li>
<li>注册 Bean</li>
<li>…</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span></span><br><span class="line">    <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="comment">// 表达式解析器</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">    <span class="comment">// 添加部分的 bean 后置处理器</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置忽略的依赖接口，即这些接口的实现类不会通过接口类型自动注入</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    <span class="comment">// 注册可以解析的依赖</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register default environment beans.</span></span><br><span class="line">    <span class="comment">// 注册 Environment</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册 SystemProperties，一个 Map&lt;String, Object&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册 SystemEnvironment，一个 Map&lt;String, Object&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-postProcessBeanFactory"><a href="#2-4-postProcessBeanFactory" class="headerlink" title="2.4. postProcessBeanFactory"></a>2.4. postProcessBeanFactory</h2><p><code>AbstractApplicationContext</code> 提供了一个空实现，留给子类具体实现</p>
<p>以下是  <code>ServletWebServerApplicationContext</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加 BeanPostProcessor</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">WebApplicationContextServletContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">    <span class="comment">// 忽略依赖接口，不会自动绑定</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">    registerWebApplicationScopes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-5-invokeBeanFactoryPostProcessors"><a href="#2-5-invokeBeanFactoryPostProcessors" class="headerlink" title="2.5. invokeBeanFactoryPostProcessors"></a>2.5. invokeBeanFactoryPostProcessors</h2><p>调用 <code>BeanFactoryPostProcessor</code>。总体来看调用逻辑分为两块：先处理 <code>BeanDefinitionRegistryPostProcessor</code>，然后处理 <code>BeanFactoryPostProcessor</code>。</p>
<blockquote>
<p><code>BeanDefinitionRegistryPostProcessor</code> 也属于 <code>BeanFactoryPostProcessor</code></p>
</blockquote>
<p>例如，这里会调用 <code>ConfigurationClassPostProcessor</code> 处理 <code>@Configuration</code> 类。</p>
<blockquote>
<p><code>ConfigurationClassPostProcessor</code> 属于 <code>BeanDefinitionRegistryPostProcessor</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// Bean Factory 后置处理器注册的委托组件</span></span><br><span class="line">    <span class="comment">// 委托其调用后置处理器</span></span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">    <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是 <code>PostProcessorRegistrationDelegate</code> 调用逻辑:</p>
<p>参数 beanFactoryPostProcessors 一般是：</p>
<ul>
<li><code>CachingMetadataReaderFactoryPostProcessor</code></li>
<li><code>ConfigurationWarningsPostProcessor</code></li>
<li><code>PropertySourceOrderingPostProcessor</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    <span class="comment">// 首先调用 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">    <span class="comment">// 即 Bean Definition 注册表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个数据结构 processedBeans 用于存储已经处理过的 Bean，防止重复处理</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                <span class="comment">// 进行后置处理</span></span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">        <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">        <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">        <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个数据结构 currentRegistryProcessors 用于存储每一波的 Processor</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得所有的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 首先，调用实现了 PriorityOrdered 的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                <span class="comment">// 防止重复处理</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 然后，类似地，调用实现了 Ordered 接口的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// 由于 PriorityOrdered 也是 Ordered，因此这里需要借助 processedBeans 结构防止重复处理</span></span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">        <span class="comment">// 3. 最后调用所有其他 BeanDefinitionRegistryPostProcessor 直到没有一个</span></span><br><span class="line">        <span class="comment">// 因为有可能 BeanDefinitionRegistryPostProcessor 还会注册 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="literal">false</span>;</span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    <span class="comment">// 假设这里 BeanDefinitionRegistryPostProcessor 的会注册新的 BeanDefinitionRegistryPostProcessor</span></span><br><span class="line">                    <span class="comment">// 因此需要重新迭代</span></span><br><span class="line">                    reiterate = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最后一次迭代，currentRegistryProcessors 空的</span></span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">        <span class="comment">// 现在调用 postProcessBeanFactory（上面调用的都是 postProcessBeanDefinitionRegistry）</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里开始处理 BeanFactoryPostProcessor</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">            <span class="comment">// 跳过，因为 BeanDefinitionRegistryPostProcessor 就是 BeanFactoryPostProcessor，已经在前面处理过了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 首先，调用实现了 PriorityOrdered 的 BeanFactoryPostProcessors</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 接下来，调用实现了 Ordered 的 BeanFactoryPostProcessors</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 最后，调用所有其他的 BeanFactoryPostProcessor</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">    <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-registerBeanPostProcessors"><a href="#2-6-registerBeanPostProcessors" class="headerlink" title="2.6. registerBeanPostProcessors"></a>2.6. registerBeanPostProcessors</h2><p>注册 <code>BeanPostProcessor</code>。最终实际会注册到 <code>BeanFactory</code>（<code>AbstractBeanFactory</code>）的 <code>beanPostProcessors</code> 结构中，该数据类型为一个 <code>List&lt;BeanPostProcessor&gt;</code>：</p>
<blockquote>
<p>不同类型的 <code>BeanPostProcessor</code> 在 <code>getBean</code> 的执行时机是不是一样的。</p>
</blockquote>
<p><code>MergedBeanDefinitionPostProcessor</code> 存放在 <code>internalPostProcessors</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 委托注册</span></span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得所有的 BeanPostProcessor</span></span><br><span class="line">    <span class="comment">// 默认的可能有：</span></span><br><span class="line">    <span class="comment">// 1. org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span></span><br><span class="line">    <span class="comment">// 2. org.springframework.context.annotation.internalCommonAnnotationProcessor</span></span><br><span class="line">    <span class="comment">// 3. org.springframework.context.annotation.internalPersistenceAnnotationProcessor</span></span><br><span class="line">    <span class="comment">// 4. org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor</span></span><br><span class="line">    <span class="comment">// 5. configurationPropertiesBeans</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register BeanPostProcessorChecker that logs an info message when</span></span><br><span class="line">    <span class="comment">// a bean is created during BeanPostProcessor instantiation, i.e. when</span></span><br><span class="line">    <span class="comment">// a bean is not eligible for getting processed by all BeanPostProcessors.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">    <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的 BeanPostProcessor</span></span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            <span class="comment">// 如果实现了 PriorityOrdered 接口, getBean 触发创建 bean</span></span><br><span class="line">            <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            <span class="comment">// 如果实现了 Ordered 接口</span></span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 首先，注册实现了 PriorityOrdered 接口的 BeanPostProcessor</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 接下来，注册实现了 Ordered 接口的 BeanPostProcessors</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 注册所有常规的 BeanPostProcessor，即没有实现任何优先级接口</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">// 4. 最终，重新注册所有内部的 BeanPostProcessor</span></span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">    <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">    <span class="comment">// 注册 ApplicationListenerDetector</span></span><br><span class="line">    <span class="comment">// 作用：</span></span><br><span class="line">    <span class="comment">// 在 Bean 创建完成后检查是否是 ApplicationListener</span></span><br><span class="line">    <span class="comment">// 如果是，则添加到容器的 applicationListeners 中</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-initMessageSource"><a href="#2-7-initMessageSource" class="headerlink" title="2.7. initMessageSource"></a>2.7. initMessageSource</h2><p>国际化功能；消息绑定；消息解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initMessageSource</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">	<span class="comment">// 检查是否包含 &quot;messageSource&quot; 的 bean</span></span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="built_in">this</span>.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line">		<span class="comment">// Make MessageSource aware of parent MessageSource.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.messageSource <span class="keyword">instanceof</span> HierarchicalMessageSource) &#123;</span><br><span class="line">			<span class="type">HierarchicalMessageSource</span> <span class="variable">hms</span> <span class="operator">=</span> (HierarchicalMessageSource) <span class="built_in">this</span>.messageSource;</span><br><span class="line">			<span class="keyword">if</span> (hms.getParentMessageSource() == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Only set parent context as parent MessageSource if no parent MessageSource</span></span><br><span class="line">				<span class="comment">// registered already.</span></span><br><span class="line">				hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Using MessageSource [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Use empty MessageSource to be able to accept getMessage calls.</span></span><br><span class="line">		<span class="type">DelegatingMessageSource</span> <span class="variable">dms</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingMessageSource</span>();</span><br><span class="line">		dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">		<span class="built_in">this</span>.messageSource = dms;</span><br><span class="line">		beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, <span class="built_in">this</span>.messageSource);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;No &#x27;&quot;</span> + MESSAGE_SOURCE_BEAN_NAME + <span class="string">&quot;&#x27; bean, using [&quot;</span> + <span class="built_in">this</span>.messageSource + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-8-initApplicationEventMulticaster"><a href="#2-8-initApplicationEventMulticaster" class="headerlink" title="2.8. initApplicationEventMulticaster"></a>2.8. initApplicationEventMulticaster</h2><p>初始化事件派发器。一般情况下都是容器给我们默认创建一个 <code>SimpleApplicationEventMulticaster</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">	<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">		<span class="built_in">this</span>.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 不存在则创建一个 SimpleApplicationEventMulticaster</span></span><br><span class="line">		<span class="built_in">this</span>.applicationEventMulticaster = <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>(beanFactory);</span><br><span class="line">		beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="built_in">this</span>.applicationEventMulticaster);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-9-onRefresh"><a href="#2-9-onRefresh" class="headerlink" title="2.9. onRefresh"></a>2.9. onRefresh</h2><p><code>AbstractApplicationContext</code> 的空实现，留给子类个性化实现</p>
<h2 id="2-10-registerListeners"><a href="#2-10-registerListeners" class="headerlink" title="2.10. registerListeners"></a>2.10. registerListeners</h2><p>注册 <code>ApplicationListener</code>，向之前初始化的 <code>ApplicationEventMulticaster</code> 中注册大量的监听器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">    <span class="comment">// 首先，静态地注册特定的 Listener</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="built_in">this</span>.earlyApplicationEvents;</span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">            getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-11-finishBeanFactoryInitialization"><a href="#2-11-finishBeanFactoryInitialization" class="headerlink" title="2.11. finishBeanFactoryInitialization"></a>2.11. finishBeanFactoryInitialization</h2><p>初始化所有剩下的（非懒加载）单例 Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="comment">// 值解析器</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    <span class="comment">// 实例化所有剩余的（非懒加载）单例</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的方法对剩余的 bean 进行了创建，其实 getBean 就是隐式包含一种对 bean 的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    <span class="comment">// 所有的 Bean Definition 信息</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">// 必须是非抽象、单例、非懒加载</span></span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是 FactoryBean（是否实现了 FactoryBean）</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">                    FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">                    <span class="type">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = AccessController.doPrivileged(</span><br><span class="line">                                (PrivilegedAction&lt;Boolean&gt;) ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                                getAccessControlContext());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                        getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="comment">// 后置初始化回调所有的 Bean</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="type">SmartInitializingSingleton</span> <span class="variable">smartSingleton</span> <span class="operator">=</span> (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-12-finishRefresh"><a href="#2-12-finishRefresh" class="headerlink" title="2.12. finishRefresh"></a>2.12. finishRefresh</h2><p>完成 refresh 执行的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">    clearResourceCaches();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">    getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布容器刷新完毕的事件</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot Features</title>
    <url>/2022/07/07/Spring-Boot/Spring-Boot-Features/</url>
    <content><![CDATA[<h1 id="Spring-Boot-Features"><a href="#Spring-Boot-Features" class="headerlink" title="Spring Boot Features"></a>Spring Boot Features</h1><h2 id="1-SpringApplication"><a href="#1-SpringApplication" class="headerlink" title="1. SpringApplication"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-application">1. SpringApplication</a></h2><p><code>SpringApplication</code> 类提供了一种简单的方式来引导 Spring 应用程序从 main 方法中启动。在许多情况下，你可以委托给静态的 <code>SpringApplication.run</code> 方法，就像下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(MySpringConfiguration.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你的应用启动时，你应该会看到类似的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::   v2.3.12.RELEASE</span><br><span class="line"></span><br><span class="line">2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)</span><br><span class="line">2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy</span><br><span class="line">2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080</span><br><span class="line">2019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</span><br></pre></td></tr></table></figure>
<h3 id="1-1-Startup-Failure"><a href="#1-1-Startup-Failure" class="headerlink" title="1.1. Startup Failure"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-startup-failure">1.1. Startup Failure</a></h3><p>如果你的应用程序未能启动，则注册的 <code>FailureAnalyzers</code> 将有机会提供专用的错误消息以及具体操作来解决该问题。例如，如果你在端口 <code>8080</code> 启动一个 Web 项目，并且该端口已经被占用，你应该能看到类似以下消息的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that&#x27;s listening on port 8080 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot 提供了许多 <code>FailureAnalyzer</code> 实现，你可以添加自己的实现。</p>
</blockquote>
<h3 id="1-4-Customizing-SpringApplication"><a href="#1-4-Customizing-SpringApplication" class="headerlink" title="1.4. Customizing SpringApplication"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-customizing-spring-application">1.4. Customizing SpringApplication</a></h3><p>如果 <code>SpringApplication</code> 的默认值不符合你的口味，那么你可以取而代之地创建一个本地实例并自定义它。例如，关闭 banner，你可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(MySpringConfiguration.class);</span><br><span class="line">    app.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">    app.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>传递给 <code>SpringApplication</code> 地构造器参数是用于 Spring Bean 地配置源。在大多数情况下，这些是 <code>@Configuration</code> 类地引用，但它们也可以引用 XML 配置或者应该扫描的包。</p>
</blockquote>
<p>也可以使用 <code>application.properties</code> 文件来配置 <code>SpringApplication</code>。有关详细信息，参见 <a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config">Externalized Configuration</a></p>
<h3 id="1-5-Fluent-Builder-API"><a href="#1-5-Fluent-Builder-API" class="headerlink" title="1.5. Fluent Builder API"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-fluent-builder-api">1.5. Fluent Builder API</a></h3><p>如果你需要构建 <code>ApplicationContext</code> 层次结构（具有父子关系的多上下文）或者你更喜欢用 “fluent” 构造器 API，你可以使用 <code>SpringApplicationBuilder</code>。</p>
<p><code>SpringApplicationBuilder</code> 使你可以将多个方法连接在一起，并且包含 <code>parent</code> 和 <code>child</code> 方法，可以让你创建一个层次结构，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class="line">        .sources(Parent.class)</span><br><span class="line">        .child(Application.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>

<h3 id="1-7-Application-Events-and-Listeners"><a href="#1-7-Application-Events-and-Listeners" class="headerlink" title="1.7. Application Events and Listeners"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners">1.7. Application Events and Listeners</a></h3><p>除了通常的 Spring Framework 事件，例如 <code>ContextRefreshedEvent</code>，一个 <code>SpringApplication</code> 还会发送一些其他应用事件。</p>
<blockquote>
<p>实际上，在 <code>ApplicationContext</code> 创建之前一些事件就已经被触发了，因此你无法以 <code>@Bean</code>的方式在上面注册监听器。你可以用 <code>SpringApplication.addListeners(...)</code> 方法或者 <code>SpringApplicationBuilder.listeners(...)</code> 方法注册它们。<br>如果你希望这些监听器自动注册，无论应用程序的创建方式如何，你可以添加一个 <code>META-INF/spring.factories</code> 文件到你的项目中，并通过使用 <code>org.springframework.context.ApplicationListener</code> key 引用你的监听器，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">com.example.project.MyListener</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-8-Web-Environment"><a href="#1-8-Web-Environment" class="headerlink" title="1.8. Web Environment"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-web-environment">1.8. Web Environment</a></h3><p><code>SpringApplication</code> 试图在你的立场上创建正确的 <code>ApplicationContext</code> 类型。决定一个 <code>WebApplicationType</code> 的算法如下：</p>
<ul>
<li>如果 Spring MVC 存在，使用 <code>AnnotationConfigServletWebServerApplicationContext</code></li>
<li>如果 Spring MVC 不存在，Spring WebFlux 存在，使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
<li>否则，使用 <code>AnnotationConfigApplicationContext</code></li>
</ul>
<p>这意味着，如果你在同一个应用使用 Spring MVC 以及来自 Spring WebFlux 的新 <code>WebClient</code>，默认使用 Spring MVC。你可以通过调用 <code>setWebApplicationType(WebApplicationType)</code> 轻易覆盖这一点。</p>
<h3 id="1-9-Accessing-Application-Arguments"><a href="#1-9-Accessing-Application-Arguments" class="headerlink" title="1.9. Accessing Application Arguments"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-application-arguments">1.9. Accessing Application Arguments</a></h3><p>如果你需要访问传递给 <code>SpringApplication.run(...)</code> 的参数，那么你可以注入一个 <code>org.springframework.boot.ApplicationArguments</code> 的 bean。<code>ApplicationArguments</code> 接口提供了对原始 String[] 参数的访问，以及被解析的 option 和 non-option 参数，正如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(ApplicationArguments args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> args.containsOption(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class="line">        <span class="comment">// if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-11-Application-Exit"><a href="#1-11-Application-Exit" class="headerlink" title="1.11. Application Exit"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-application-exit">1.11. Application Exit</a></h3><p>每个 <code>SpringApplication</code> 都会在 JVM 上注册一个关闭钩子，以确保 <code>ApplicationContext</code> 在退出时优雅地关闭。所有标准的 Spring 生命周期回调（例如 <code>DisposableBean</code> 接口或者 <code>@PreDestroy</code> 注解）都可以使用。</p>
<p>此外，如果希望当 <code>SpringApplication.exit()</code> 调用时返回特定的结束码，Bean 可以实现 <code>org.springframework.boot.ExitCodeGenerator</code> 接口。然后可以将此退出码传递给 <code>System.exit()</code>，以一个状态码的形式返回，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExitCodeApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ExitCodeGenerator <span class="title function_">exitCodeGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication.class, args)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-Externalized-Configuration"><a href="#2-Externalized-Configuration" class="headerlink" title="2. Externalized Configuration"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config">2. Externalized Configuration</a></h2><h3 id="2-1-Configuring-Random-Values"><a href="#2-1-Configuring-Random-Values" class="headerlink" title="2.1. Configuring Random Values"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-random-values">2.1. Configuring Random Values</a></h3><p><code>RandomValuePropertySource</code> 可用于注入随机值（例如，secret 或者测试用例）。它可以产生 integer，long，uuid，或者 string，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="attr">my.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="attr">my.bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="attr">my.uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="attr">my.number.less.than.ten</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="attr">my.number.in.range</span>=<span class="string">$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-Application-Property-Files"><a href="#2-3-Application-Property-Files" class="headerlink" title="2.3. Application Property Files"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-application-property-files">2.3. Application Property Files</a></h3><p><code>SpringApplication</code> 在以下位置的 <code>application.properties</code> 文件中加载属性，并将它们添加到 Spring <code>Environment</code>：</p>
<ol>
<li>当前目录的一个 <code>/config</code> 子目录</li>
<li>当前文件夹</li>
<li>类路径 <code>/config</code> 包</li>
<li>类路径根</li>
</ol>
<h2 id="2-7-Using-YAML-Instead-of-Properties"><a href="#2-7-Using-YAML-Instead-of-Properties" class="headerlink" title="2.7. Using YAML Instead of Properties"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-yaml">2.7. Using YAML Instead of Properties</a></h2><p>YAML 是 JSON 的超集，因此，也是一种指定层次配置数据的方便格式。<code>SpringApplication</code> 类自动支持 YAML 作为 properties 的替代品，只需要在类路径添加 SnakeYAML 库支持。</p>
<p>如果你使用 “starter”，SnakeYAML 将由 <code>spring-boot-starter</code> 自动提供。</p>
<h3 id="2-7-1-Loading-YAML"><a href="#2-7-1-Loading-YAML" class="headerlink" title="2.7.1. Loading YAML"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-loading-yaml">2.7.1. Loading YAML</a></h3><p>Spring Framework 提供了两个方便的类，可以用于加载 YAML 文档。<code>YamlPropertiesFactoryBean</code> 将 YAML 加载作为 <code>Properties</code>，而 <code>YamlMapFactoryBean</code> 将 YAML 加载作为 <code>Map</code>。</p>
<p>例如，考虑如下 YAML 文档：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line">    <span class="attr">dev:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">https://dev.example.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line">    <span class="attr">prod:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">https://another.example.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>
<p>前面的示例将转换为以下属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">environments.dev.url</span>=<span class="string">https://dev.example.com</span></span><br><span class="line"><span class="attr">environments.dev.name</span>=<span class="string">Developer Setup</span></span><br><span class="line"><span class="attr">environments.prod.url</span>=<span class="string">https://another.example.com</span></span><br><span class="line"><span class="attr">environments.prod.name</span>=<span class="string">My Cool App</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-4-YAML-Shortcomings"><a href="#2-7-4-YAML-Shortcomings" class="headerlink" title="2.7.4. YAML Shortcomings"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-yaml-shortcomings">2.7.4. YAML Shortcomings</a></h3><p>YAML 文件不能使用 <code>@PropertySource</code> 注解加载。因此，以这种方式加载值，你需要使用 properties 文件。</p>
<p>在特定 profile 的 YAML 文件中使用多 YAML 文档语法可能导致不可预测的行为。例如，考虑如下文件配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">&quot;!test&quot;</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;secret&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你以参数 <code>--spring.profiles.active=dev</code> 运行应用，你可能期望 <code>security.user.password</code> 设置为 “secret”，但是事实并非如此。</p>
<p>嵌套文档将被过滤，因为主文件名为 <code>application-dev.yml</code>。它已经被认为是特定于配置文件的，并且嵌套的文档将会被忽略。</p>
<blockquote>
<p>我们建议你不要将特定 profile 的 YAML 文件和多 YAML 文档混合。坚持使用其一。</p>
</blockquote>
<h2 id="2-8-Type-safe-Configuration-Properties"><a href="#2-8-Type-safe-Configuration-Properties" class="headerlink" title="2.8. Type-safe Configuration Properties"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-typesafe-configuration-properties">2.8. Type-safe Configuration Properties</a></h2><h3 id="2-8-1-JavaBean-properties-binding"><a href="#2-8-1-JavaBean-properties-binding" class="headerlink" title="2.8.1. JavaBean properties binding"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-java-bean-binding">2.8.1. JavaBean properties binding</a></h3><p>如下示例所示，可以绑定声明标准 JavaBean 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AcmeProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Security</span> <span class="variable">security</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Security</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> InetAddress <span class="title function_">getRemoteAddress</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRemoteAddress</span><span class="params">(InetAddress remoteAddress)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Security <span class="title function_">getSecurity</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Security</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Collections.singleton(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getRoles</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 POJO 定义了以下属性：</p>
<ul>
<li><code>acme.enabled</code>，具有默认值 <code>false</code></li>
<li><code>acme.remote-address</code>，具有可以从 <code>String</code> 强转的类型</li>
<li><code>acme.security.username</code>，具有一个嵌套的 “security” 对象，其名称由属性名决定。特别注意，返回类型这里根本没有使用，有可能是 <code>SecurityProperties</code></li>
<li><code>acme.security.password</code></li>
<li><code>acme.security.roles</code> 带有默认为 <code>USER</code> 的 <code>String</code> 集合</li>
</ul>
<p>一般需要提供一个无参构造器，并且 getter 和 setter 是强制地，除了一些情况：</p>
<ul>
<li>Map，只要被实例化过了，只需要一个 getter 无需 setter</li>
<li>Collection 和 Array，可以使用索引或者逗号分隔来访问。后者需要 setter。始终建议添加 setter。如果自己初始化，确保它是 not immutable</li>
<li>嵌套属性无需 setter。如果希望默认构造器能够创建该嵌套属性地实例，需要 setter。</li>
</ul>
<p>有人使用 Lombok，确保其不会为属性类生成任何特定地构造函数，因为容器会自动使用它来实例化对象。</p>
<p>只考虑标准 Java Bean，不支持静态属性绑定。</p>
<h3 id="2-8-3-Enabling-ConfigurationProperties-annotated-types"><a href="#2-8-3-Enabling-ConfigurationProperties-annotated-types" class="headerlink" title="2.8.3. Enabling @ConfigurationProperties-annotated types"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-enabling">2.8.3. Enabling @ConfigurationProperties-annotated types</a></h3><p>Spring Boot 提供了绑定 <code>@ConfigurationProperties</code> 类型并将其注册为 Bean 的基础架构。你可以在一个一个的类上启用配置属性，或者启用配置属性扫描，这以类似于组件扫描的方式工作。</p>
<p>有时候，<code>@ConfigurationProperties</code> 可能不适合总是被扫描。例如，如果你正在开发自己的 auto-configuration，或者你需要有条件的启用它们。在这些情况下，使用 <code>@EnableConfiguratonProperties</code> 注解指定要处理的类列表。这可以在任何 <code>@Configuration</code> 类上完成，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AcmeProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用配置属性扫描，请将 <code>@ConfigurationPropertiesScan</code> 注解添加到你的应用。通常，会将其添加到用 <code>@SpringBootApplication</code> 注解的主应用类中，但也可以添加到任何 <code>@Configuration</code> 类。默认情况下，将从声明注解的类所在的包开始扫描。如果你想定义特定的包扫描，你可以像下面示例这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ConfigurationPropertiesScan(&#123; &quot;com.example.app&quot;, &quot;org.acme.another&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>当使用配置属性扫描或者 @EnableConfigurationProperties 注册 @ConfigurationProperties bean 时，bean 有一个约定名称：<code>&lt;prefix&gt;-&lt;fqn&gt;</code>，<code>&lt;prefix&gt;</code> 是 @ConfigurationProperties 的 prefix 属性，<code>&lt;fqn&gt;</code> 是 bean 的全限定名。如果注解没有提供任何前缀，则使用 bean 的完全限定名称。</p>
</blockquote>
<h2 id="3-Profiles"><a href="#3-Profiles" class="headerlink" title="3. Profiles"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-profiles">3. Profiles</a></h2><p>Spring 配置文件提供了一种方式，可以分离应用配置的一部分，并使其仅在某些环境中可用。任何 <code>@Component</code>，<code>@Configuration</code>，或者 <code>@ConfigurationProperties</code> 都可以用 <code>@Profile</code> 标记以限制何时加载，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>spring.profiles.active</code> <code>Environment</code> 属性来指定哪些配置文件处于激活状态。你可以以本章前面描述的任何方式指定属性。例如，你可以在你的 <code>application.properties</code> 中包含，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev,hsqldb</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用以下开关在命令行上指定：<code>--spring.profiles.active=dev.hsqldb</code></p>
<p>如果没有配置文件处于激活状态。则启用默认配置文件。默认配置文件的名称为 <code>default</code>，并且可以使用 <code>spring.profiles.default</code> <code>Environment</code> 属性进行调整，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.default</span>=<span class="string">none</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Logging"><a href="#4-Logging" class="headerlink" title="4. Logging"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-logging">4. Logging</a></h2><p>Spring Boot 使用 Commons Logging 用于所有内部的日志记录，但是保持底层的日志实现开放。为 Java Util Logging，Log4J2，以及 Logback 提供了默认配置。在每种情况下，日志记录器是预先配置使用控制台输出，同事可选的文件输出也是可用的。</p>
<p>默认情况下，如果你使用 “starter”，则使用 Logback 进行日志记录。适当的 Logback 路由也会被包括进来，确保使用 Java Util Logging，Commons Logging，Log4J，或者 SLF4J 的独立库都能正常工作。</p>
<blockquote>
<p>Java 有很多可供选择的日志框架。如果上面的清单似乎令人困惑，但不用担心。通常，你无需更改日志依赖项，Spring Boot 默认项工作就好。</p>
</blockquote>
<h3 id="4-1-Log-Format"><a href="#4-1-Log-Format" class="headerlink" title="4.1. Log Format"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-logging-format">4.1. Log Format</a></h3><p>Spring Boot 的默认日志输出类似于以下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class="line">2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: &#x27;dispatcherServlet&#x27; to [/]</span><br><span class="line">2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: &#x27;hiddenHttpMethodFilter&#x27; to: [/*]</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Console-Output"><a href="#4-2-Console-Output" class="headerlink" title="4.2. Console Output"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-logging-console-output">4.2. Console Output</a></h3><p>默认的日志配置在写入时会将信息回显到控制台。默认地，<code>ERROR</code> 级别，<code>WARN</code> 级别，以及 <code>INFO</code> 级别的信息会被记录。你还可以通过使用 <code>--debug</code> 标记启动应用，开启 “debug” 模式。</p>
<h3 id="4-3-File-Output"><a href="#4-3-File-Output" class="headerlink" title="4.3. File Output"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-logging-file-output">4.3. File Output</a></h3><p>默认情况下，Spring Boot 日志仅仅输出到控制台，并不会写到日志文件。如果你希望除了输出到控制台还能写到日志文件，你需要设置 <code>logging.file.name</code> 或者 <code>logging.file.path</code> 属性（例如，在你的 <code>application.properties</code>）。</p>
<p>下表一起展示了如何使用 <code>logging.*</code> 属性：</p>
<p>|<code>logging.file.name</code>|<code>logging.file.path</code>|Example|Description|<br>|(none)|(none)||仅控制台记录|<br>|特定文件|(none)|my.log|写到特定日志文件。名称可以是精确的位置或者相对于当前文件夹|<br>|(none)|Specific directory|&#x2F;var&#x2F;log|写 <code>spring.log</code> 到特定文件夹。名字可以是一个精确的位置或者相对于当前文件夹|</p>
<p>日志文件达到 10MB 时旋转，并且与控制台输出一样，默认记录了 <code>ERROR</code> 级别，<code>WARN</code> 级别，以及 <code>INFO</code> 级别的信息。可以使用 <code>logging.file.max-size</code> 属性修改大小限制。默认情况下，保留最后7天的轮转日志文件，除非设置 <code>logging.file.max-history</code>。可以使用 <code>logging.file.total-size-cap</code> 属性限制日志归档的总大小。当日志归档的总大小超过该阈值的时候，将删除备份。要在应用程序启动时强制执行日志归档清理，请使用 <code>logging.file.clean-history-on-start</code> 属性。</p>
<blockquote>
<p>日志属性与实际日志基础架构无关。结果就是，Spring Boot 不会管理特定的配置键（例如，对于 Logback 的 <code>logback.configurationFile</code>）。</p>
</blockquote>
<h3 id="4-4-Log-Levels"><a href="#4-4-Log-Levels" class="headerlink" title="4.4. Log Levels"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-custom-log-levels">4.4. Log Levels</a></h3><p>所有支持的日志系统都可以通过使用 <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code> 在 Spring <code>Environment</code> 中（例如，在 <code>application.properties</code>）设置日志级别，其中 <code>level</code> 是 TRACE，DEBUG，INFO，WARN，ERROR，FATAL，或者 OFF 之一。可以使用 <code>logging.level.root</code> 配置 <code>root</code> 记录器。</p>
<p>以下示例展示了 <code>application.properties</code> 中的可能的日志设置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.level.root</span>=<span class="string">warn</span></span><br><span class="line"><span class="attr">logging.level.org.springframework.web</span>=<span class="string">debug</span></span><br><span class="line"><span class="attr">logging.level.org.hibernate</span>=<span class="string">error</span></span><br></pre></td></tr></table></figure>

<p>也可以使用环境变量设置日志级别。例如，<code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code> 将设置 <code>org.springframework.web</code> 为 <code>DEBUG</code>。</p>
<h3 id="4-7-Custom-Log-Configuration"><a href="#4-7-Custom-Log-Configuration" class="headerlink" title="4.7. Custom Log Configuration"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-custom-log-configuration">4.7. Custom Log Configuration</a></h3><p>可以通过在类路径上包含适当的库来激活各种日志系统，并可以通过提供合适的配置文件进行进一步的定制化，配置文件可以在类路径的根或者由下面 Spring <code>Environment</code> 属性：<code>logging.config</code> 指定位置。</p>
<p>你可以使用 <code>org.springframework.boot.logging.LoggingSystem</code> 系统属性强制 Spring Boot 使用特定的日志系统。该值必须是 <code>LoggingSystem</code> 实现的完全限定类名。你也可以使用 <code>none</code> 值完全禁用 Spring Boot 的日志配置。</p>
<blockquote>
<p>由于 logging 是在 <code>ApplicationContext</code> 创建之前初始化的，因此不可能从 <code>@Configuration</code> 文件中的 <code>@PropertySources</code> 控制日志。更改日志系统或者完全禁用唯一的方式是通过系统属性。</p>
</blockquote>
<p>根据你的日志系统，加载下面的文件：</p>
<table>
<thead>
<tr>
<th align="left">Logging System</th>
<th align="left">Customization</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Logback</td>
<td align="left"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, 或者 <code>logback.groovy</code></td>
</tr>
<tr>
<td align="left">Log4j2</td>
<td align="left"><code>log4j2-spring.xml</code>，或者 <code>log4j2.xml</code></td>
</tr>
<tr>
<td align="left">JDK (Java Util Logging)</td>
<td align="left"><code>logging.properties</code></td>
</tr>
</tbody></table>
<h2 id="5-Internationalization"><a href="#5-Internationalization" class="headerlink" title="5. Internationalization"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-internationalization">5. Internationalization</a></h2><h2 id="6-JSON"><a href="#6-JSON" class="headerlink" title="6. JSON"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-json">6. JSON</a></h2><h2 id="7-Developing-Web-Applications"><a href="#7-Developing-Web-Applications" class="headerlink" title="7. Developing Web Applications"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-developing-web-applications">7. Developing Web Applications</a></h2><h3 id="7-1-The-“Spring-Web-MVC-Framework”"><a href="#7-1-The-“Spring-Web-MVC-Framework”" class="headerlink" title="7.1. The “Spring Web MVC Framework”"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc">7.1. The “Spring Web MVC Framework”</a></h3><h4 id="7-1-1-Spring-MVC-Auto-configuration"><a href="#7-1-1-Spring-MVC-Auto-configuration" class="headerlink" title="7.1.1. Spring MVC Auto-configuration"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-auto-configuration">7.1.1. Spring MVC Auto-configuration</a></h4><p>Spring Boot 为 Spring MVC 提供了自动配置 <code>WebMvcAutoConfiguration</code>。</p>
<ul>
<li>WebMvcAutoConfigurationAdapter</li>
</ul>
<p>如果希望保持 Spring Boot MVC 的定制，并作出更多 MVC 自定义的话，只需要添加自己的 <code>WebMvcConfigurer</code>，并添加 <code>@Configuration</code> 类，而不要使用 <code>@EnableWebMvc</code>。</p>
<p><code>@EnableWebMvc</code> 导致 Spring Boot 自动配置失效原因：<code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code></p>
<p>如果向完全控制 Spring MVC，可以添加带有 <code>@EnableWebMvc</code> 的 <code>@Configuration</code>，或者添加自己的 @Configuration 的 <code>DelegatingWebMvcConfiguration</code></p>
<h3 id="7-1-2-HttpMessageConverters"><a href="#7-1-2-HttpMessageConverters" class="headerlink" title="7.1.2. HttpMessageConverters"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters">7.1.2. HttpMessageConverters</a></h3><p>Spring MVC 使用 <code>HttpMessageConverter</code> 接口来转换 HTTP 请求和响应。开箱即用地包含一些合理的默认项。例如，可以自动地将对象转换为 JSON（通过使用 Jackson 库）或者 XML（通过使用 Jackson XML 扩展，如果可用，或者如果 Jackson XML 扩展不可用就是用 JAXB）。</p>
<p>如果需要添加 converter，可以使用 Spring Boot 的 HttpMessageConverters：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HttpMessageConverters <span class="title function_">customConverters</span><span class="params">()</span> &#123;</span><br><span class="line">        HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">        HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpMessageConverters</span>(additional, another);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-3-Custom-JSON-Serializers-and-Deserializers"><a href="#7-1-3-Custom-JSON-Serializers-and-Deserializers" class="headerlink" title="7.1.3. Custom JSON Serializers and Deserializers"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-json-components">7.1.3. Custom JSON Serializers and Deserializers</a></h3><p>使用 @JsonComponent 自定义序列化和反序列化</p>
<p>&amp;nbsp;</p>
<h3 id="7-1-5-Static-Content"><a href="#7-1-5-Static-Content" class="headerlink" title="7.1.5. Static Content"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content">7.1.5. Static Content</a></h3><p>默认地，Spring Boot 提供静态资源的路径（见 <code>ResourceProperties.CLASSPATH_RESOURCE_LOCATIONS</code>）：</p>
<ul>
<li>classpath:&#x2F;static</li>
<li>classpath:&#x2F;public</li>
<li>classpath:&#x2F;resources</li>
<li>classpath:&#x2F;META-INF&#x2F;resources</li>
<li>servletContext 根路径</li>
</ul>
<p>Spring Boot 使用 Spring MVC 的 <code>ResourceHttpRequestHandler</code> 处理静态资源，可以通过添加自己的 <code>WebMvcConfigurer</code> 并覆盖 <code>addResourceHandlers</code> 方法修改此行为。</p>
<p>&amp;nbsp;<br>默认地，静态资源资源映射在 &#x2F;**，可以使用如下配置调整：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加一个固定前缀 resources</span></span><br><span class="line">spring.mvc.static-path-pattern=/resources/**</span><br></pre></td></tr></table></figure>

<p>&amp;nbsp;<br>修改默认的静态资源搜寻路径，支持数组（上面描述的 4 个 classpath 路径会失效）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Servlet Context 的根路径会自动添加</span></span><br><span class="line"><span class="comment"># 注意末尾需要添加 /</span></span><br><span class="line">spring.resources.static-locations=classpath:/res/</span><br></pre></td></tr></table></figure>


<p><strong>官方提示</strong> 如果应用程序预计打包为 jar，不要使用 src&#x2F;main&#x2F;webapp 目录。虽然这是一个通用标准，但只是在 war 包上，如果生成 jar，会被大多数构建工具忽略。</p>
<h3 id="7-1-6-Welcome-Page"><a href="#7-1-6-Welcome-Page" class="headerlink" title="7.1.6. Welcome Page"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-welcome-page">7.1.6. Welcome Page</a></h3><p>Spring Boot 支持静态和模板的欢迎页面。Spring Boot 首先在配置静态内容位置中寻找 <code>index.html</code> 文件。如果一个都没找到，那么它会寻找一个 <code>index</code> 模板。如果找到了某一个模板，模板将会自动使用作为应用的欢迎页。</p>
<h3 id="7-1-7-Custom-Favicon"><a href="#7-1-7-Custom-Favicon" class="headerlink" title="7.1.7. Custom Favicon"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon">7.1.7. Custom Favicon</a></h3><p>在配置的静态内容位置寻找 favicon.ico，如果存在自动作为应用的图标（不可以增加静态资源前缀）。</p>
<h3 id="7-1-11-Error-Handling"><a href="#7-1-11-Error-Handling" class="headerlink" title="7.1.11. Error Handling"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-error-handling">7.1.11. Error Handling</a></h3><p>默认地，Spring Boot 提供一个 <code>/error</code> 的 mapping 以明智的方式来处理所有的错误，并且它被注册为一个 Servlet 容器“全局”错误页面。对于机器客户端，它会产生一个具有错误详情，HTTP 状态码，异常信息的 JSON 响应。对于浏览器客户端，有一个白页错误视图，以 HTML 的格式渲染相同的数据（要定制它，需要添加一个解析到 <code>error</code> 的视图）。</p>
<p>如果你要自定义默认的错误处理行为，则可以设置许多 <code>server.error</code> 属性。参见附录的 <a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/appendix-application-properties.html#common-application-properties-server">“Server Properties”</a></p>
<p>为了完全替换默认行为，你可以实现 <code>ErrorController</code> 并注册该类型的 Bean Definition，或者添加类型为 <code>ErrorAttributes</code> 的 Bean，以使用现存的机制，但是替换内容。</p>
<p>你还可以定义一个以 <code>@ControllerAdvice</code> 注解的类，来自定义 JSON 格式，用于特定的 Controller 或者异常类型，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(basePackageClasses = AcmeController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AcmeControllerAdvice</span> <span class="keyword">extends</span> <span class="title class_">ResponseEntityExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(YourException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">        <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> getStatus(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CustomErrorType</span>(status.value(), ex.getMessage()), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpStatus <span class="title function_">getStatus</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">statusCode</span> <span class="operator">=</span> (Integer) request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (statusCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>&amp;nbsp;</p>
<ul>
<li>@ResponseStatus 注解的异常类</li>
</ul>
<p>通过处理过程抛出特定的异常，该异常类被 @ResponseStatus 注解</p>
<p>&amp;nbsp;<br>在 Spring 中，HandlerExceptionResolverComposite 也是一个 HandlerExceptionResolver，而且它是多个 HandlerExceptionResolver 的组合。默认地，它以如下的顺序包含多个 HandlerExceptionResolver：</p>
<p>(1) ExceptionHandlerExceptionResolver<br>(2) ResponseStatusExceptionResolver<br>(3) DefaultHandlerExceptionResolver，垫底处理，实现 Ordered 接口，并且 order &#x3D; Ordered.LOWEST_PRECEDENCE</p>
<h4 id="Custom-Error-Pages"><a href="#Custom-Error-Pages" class="headerlink" title="Custom Error Pages"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-error-handling-custom-error-pages">Custom Error Pages</a></h4><p>对于给定的 HTTP 状态码，自定义 HTML 错误页面，可以添加文件到 &#x2F;error 路径。错误页面可以是静态 HTML 或者使用模板引擎。</p>
<p>页面名称应该是精确的状态码或一系列掩码，如：404.html, 5xx.html。</p>
<h3 id="7-4-Embedded-Servlet-Container-Support"><a href="#7-4-Embedded-Servlet-Container-Support" class="headerlink" title="7.4. Embedded Servlet Container Support"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container">7.4. Embedded Servlet Container Support</a></h3><p>Spring Boot 包含对内嵌的 Tomcat，Jetty，以及 Undertow 服务器的支持。大多数开发者使用适当的 “starter” 获得完整的配置实例。默认的，内嵌的服务器在端口 8080 上监听 HTTP 请求。</p>
<h4 id="7-4-1-Servlets-Filters-and-listeners"><a href="#7-4-1-Servlets-Filters-and-listeners" class="headerlink" title="7.4.1. Servlets, Filters, and listeners"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container-servlets-filters-listeners">7.4.1. Servlets, Filters, and listeners</a></h4><p>当使用内嵌的 Servlet 容器时，你可以通过使用 Spring Bean 或者通过扫描 Servlet 组件的方式注册来自于 Servlet 规范的 Servlet，Filter，以及所有的 Listener（例如 <code>HttpSessionListener</code>）</p>
<h5 id="Registering-Servlets-Filters-and-Listeners-as-Spring-Beans"><a href="#Registering-Servlets-Filters-and-Listeners-as-Spring-Beans" class="headerlink" title="Registering Servlets, Filters, and Listeners as Spring Beans"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container-servlets-filters-listeners-beans">Registering Servlets, Filters, and Listeners as Spring Beans</a></h5><p>任何作为一个 Spring Bean 的 <code>Servlet</code>，<code>Filter</code>，或者 servlet <code>*Listener</code> 实例都会注册到内嵌的容器中。如果你想在配置期间引用一个来自于你 <code>application.properties</code> 的值，这是极其方便的。</p>
<p>默认情况下，如果上下文仅包含一个 Servlet，则将其映射到 <code>/</code>。在多 Servlet Bean 场景下，Bean Name 用于路径前缀。过滤器映射到 <code>/*</code>。</p>
<p>如果基于约定的映射不够灵活，你可以使用 <code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>，以及 <code>ServletListenerRegistrationBean</code> 类获得完全控制。</p>
<p>通常，保持 Filter Bean 无序是安全的。如果需要特定的 order，你应该用 <code>@Order</code> 注解 <code>Filter</code> 或者使其实现 <code>Ordered</code>。你无法通过用 <code>@Order</code> 注解其 bean 方法配置 <code>Filter</code> 的 order。如果你无法更改 Filter 类以添加 <code>@Order</code> 或者实现 <code>Ordered</code>，你必须定义为该 <code>Filter</code> 定义一个 <code>FilterRegistrationBean</code> 并使用 <code>setOrder(int)</code> 方法设置注册 Bean 的 order。避免配置在 <code>Ordered.HIGEST_PRECEDENCE</code> 读取请求体的过滤器，因为它可能与你应用的字符编码配置违背。如果 Servlet filter 包装请求，则应使用小于等于 <code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code> 的 order 值。</p>
<h4 id="7-4-2-Servlet-Context-Initialization"><a href="#7-4-2-Servlet-Context-Initialization" class="headerlink" title="7.4.2. Servlet Context Initialization"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container-context-initializer">7.4.2. Servlet Context Initialization</a></h4><p>嵌入式 Servlet 容器不会直接执行 Servlet 3.0+ 的 <code>javax.servlet.ServletContainerInitializer</code> 接口或者是 Spring 的 <code>org.springframework.web.WebApplicationInitializer</code> 接口。这是一个故意的设计决定，旨在降低被设计在 war 中运行的第三方包可能破坏 Spring Boot 应用的风险。</p>
<p>如果你需要在 Spring Boot 应用中执行 Servlet Context 初始化，你应该注册一个实现了 <code>org.springframework.boot.web.servlet.ServletContextInitializer</code> 接口的 Bean。单个 <code>onStartup</code> 方法提供了对 <code>ServletContext</code> 的访问，并且如果有必要，可以轻松地用作现存的 <code>WebApplicationInitializer</code> 的适配器。</p>
<h4 id="Scanning-for-Servlets-Filters-and-listeners"><a href="#Scanning-for-Servlets-Filters-and-listeners" class="headerlink" title="Scanning for Servlets, Filters, and listeners"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container-servlets-filters-listeners-scanning">Scanning for Servlets, Filters, and listeners</a></h4><p>当使用嵌入式容器时，可以通过使用 <code>@ServletComponentScan</code> 自动注册被 <code>@WebServlet</code>，<code>@WebFilter</code>，以及 <code>@WebListener</code> 注解的类。</p>
<h2 id="8-Graceful-shutdown"><a href="#8-Graceful-shutdown" class="headerlink" title="8. Graceful shutdown"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-graceful-shutdown">8. Graceful shutdown</a></h2><h2 id="11-Working-with-SQL-Databases"><a href="#11-Working-with-SQL-Databases" class="headerlink" title="11. Working with SQL Databases"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-sql">11. Working with SQL Databases</a></h2><p>Spring Framework 为使用 SQL 数据库提供了广泛支持，从使用 <code>JdbcTemplate</code> 直接进行 JDBC 访问，到完成 “object relational mapping” 技术，例如 Hibernate。Spring Data 提供了更多功能级别：从你的接口中直接创建 <code>Repository</code> 实现，并使用约定从你的方法名称中生成查询。</p>
<h3 id="11-1-Configure-a-DataSource"><a href="#11-1-Configure-a-DataSource" class="headerlink" title="11.1. Configure a DataSource"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-configure-datasource">11.1. Configure a DataSource</a></h3><p>Java 的 <code>javax.sql.DataSource</code> 接口提供了一种使用数据库连接的标准方法。传统上，一个 ‘DataSource’ 使用 <code>URL</code> 以及一些凭证来建立数据库连接。</p>
<h4 id="11-1-1-Embedded-Database-Support"><a href="#11-1-1-Embedded-Database-Support" class="headerlink" title="11.1.1. Embedded Database Support"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-database-support">11.1.1. Embedded Database Support</a></h4><p>通常，使用一个内存嵌入式数据库开发应用很方便。显然，内存数据库不提供持久化存储。当你的应用程序启动时，你需要填充你的数据库，并在应用结束时准备好丢掉数据。</p>
<p>Spring Boot 可以自动配置嵌入式 H2，HSQL，以及 Derby 数据库。你不需要提供任何连接 URL。你只需要对要使用的嵌入式数据库包含一个构建依赖。</p>
<h4 id="11-1-2-Connection-to-a-Production-Database"><a href="#11-1-2-Connection-to-a-Production-Database" class="headerlink" title="11.1.2. Connection to a Production Database"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-connect-to-production-database">11.1.2. Connection to a Production Database</a></h4><p>生产数据库连接也可以通过池化 <code>DataSource</code> 自动配置。Spring Boot 使用下面的算法选择特定的实现：</p>
<ol>
<li>我们更喜欢 HikariCP 的性能和并发。如果 HikariCP 可用，我们始终会选择它</li>
<li>否则，如果 Tomcat 池化 <code>DataSource</code> 可用，我们将使用它</li>
<li>如果 HikariCP 和 Tomcat 池化数据源都不可用，并且 Commons DBCP2 可用，我们会使用它</li>
</ol>
<p>如果你使用 <code>spring-boot-starter-jdbc</code> 或者 <code>spring-boot-starter-data-jpa</code> “starter”，你会自动获得 <code>HikariCP</code> 的依赖。</p>
<p>DataSource 的配置由 <code>spring.datasource.*</code> 之中的外部配置属性控制。例如，你可以在 <code>application.properties</code> 中声明如下部分：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">dbuser</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">dbpass</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>你应该至少通过设置 <code>spring.datasource.url</code> 属性来指定 URL。否则，Spring Boot 将尝试自动配置嵌入式数据库。</p>
</blockquote>
<blockquote>
<p>你通常不需要指定 <code>driver-class-name</code>，因为 Spring Boot 可以从 <code>url</code> 中推导得到大多数数据库。</p>
</blockquote>
<h3 id="11-2-Using-JdbcTemplate"><a href="#11-2-Using-JdbcTemplate" class="headerlink" title="11.2. Using JdbcTemplate"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-using-jdbc-template">11.2. Using JdbcTemplate</a></h3><p>Spring 的 <code>JdbcTemplate</code> 和 <code>NamedParameterJdbcTemplate</code> 类是自动配置的，你可以将它们直接 <code>@Autowire</code> 进自己的 Bean，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 上面的例子其实不必在构造器上加 <code>@Autowired</code>，因为这是 Spring 的默认行为</p>
</blockquote>
<h3 id="11-3-JPA-and-Spring-Data-JPA"><a href="#11-3-JPA-and-Spring-Data-JPA" class="headerlink" title="11.3. JPA and Spring Data JPA"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-jpa-and-spring-data">11.3. JPA and Spring Data JPA</a></h3><p>Java Persistence API 是一种标准技术，可以让你映射对象到关系型数据库。<code>spring-boot-starter-data-jpa</code> POM 提供了一种快速入门的方法。它提供了如下几个关键依赖：</p>
<ul>
<li>Hibernate：最流行的 JPA 实现之一</li>
<li>Spring Data JPA：帮你实现基于 JPA 的存储库</li>
<li>Spring ORM：为 Spring Framework 提供核心 ORM 支持</li>
</ul>
<h4 id="11-3-1-Entity-Classes"><a href="#11-3-1-Entity-Classes" class="headerlink" title="11.3.1. Entity Classes"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-entity-classes">11.3.1. Entity Classes</a></h4><p>传统上，JPA 实体类在 <code>persistence.xml</code> 文件中指定。使用 Spring Boot，不需要此文件，而是使用 “实体扫描”。默认情况下，在你主应用类（注解了 <code>@EnableAutoConfiguration</code> 以及 <code>@SpringBootApplication</code> 的类）下的所有包都会被搜索。</p>
<p>使用 <code>@Entity</code>，<code>@Embeddable</code>，或者 <code>@MappedSuperclass</code> 注解的类都会被纳入。一个典型的实体类类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">City</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional members, often include @OneToMany mappings</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">City</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// no-args constructor required by JPA spec</span></span><br><span class="line">        <span class="comment">// this one is protected since it shouldn&#x27;t be used directly</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">City</span><span class="params">(String name, String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... etc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-3-2-Spring-Data-JPA-Repositories"><a href="#11-3-2-Spring-Data-JPA-Repositories" class="headerlink" title="11.3.2. Spring Data JPA Repositories"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-data-jpa-repositories">11.3.2. Spring Data JPA Repositories</a></h4><p>Spring Data JPA repository 是一些接口，你可以定义其用于访问数据。JPA 查询从你的方法名称自动创建。例如，一个 <code>CityRepository</code> 接口可能声明了一个 <code>findAllByState(String state)</code> 方法，用于找到给定 state 的所有 city。</p>
<p>有关更复杂的查询，你可以使用 Spring Data 的 <code>Query</code> 注解来注解你的方法。</p>
<p>通常，Spring Data repository 从 <code>Repository</code> 或者 <code>CrudRepository</code> 接口扩展。如果你使用自动配置，将会从包含主配置类（被 <code>@EnableAutoConfiguration</code> 或者 <code>@SpringBootApplication</code> 注解的类）的包下面搜索 repository。</p>
<p>以下示例展示了一个典型的 Spring Data repository 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CityRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;City, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;City&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">    City <span class="title function_">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Data JPA repository 支持三种不同的自我引导模式：default，deferred，以及 lazy。要启动 deferred 或者 lazy 自启，请将分别将 <code>spring.data.jpa.repositories.bootstrap-mode</code> 属性设置为 <code>deferred</code> 或者 <code>lazy</code>。当使用 deferred 或者 lazy 引导模式时，自动配置的 <code>EntityManagerFactoryBuilder</code> 将会使用上下文的 <code>AsyncTaskExecutor</code>（如果有的话）作为引导的执行器。如果存在多个，将会使用名为 <code>applicationTaskExecutor</code> 的那个。</p>
<h3 id="11-4-Spring-Data-JDBC"><a href="#11-4-Spring-Data-JDBC" class="headerlink" title="11.4. Spring Data JDBC"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-data-jdbc">11.4. Spring Data JDBC</a></h3><p>Spring Data 包含对 JDBC 支持的 repository，并将自动为 <code>CrudRepository</code> 上的方法生成 SQL。对于更高级的查询，提供了一个 <code>@Query</code> 注解。</p>
<p>当必要的依赖在类路径上时，Spring Boot 将自动配置 Spring Data 的 JDBC repository。使用仅仅一个依赖 <code>spring-boot-starter-data-jdbc</code>，就可以将它们添加到你的项目。如果有必要，你可以通过添加 <code>@EnableJdbcRepositories</code> 注解或者 <code>JdbcConfiguration</code> 子类到你的应用来控制 Spring Data JDBC 的配置。</p>
<h3 id="11-5-Using-H2’s-Web-Console"><a href="#11-5-Using-H2’s-Web-Console" class="headerlink" title="11.5. Using H2’s Web Console"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-sql-h2-console">11.5. Using H2’s Web Console</a></h3><p>H2 数据库提供了一个基于浏览器的控制台，Spring Boot 可以为你自动配置。当满足如下条件时，将自动配置控制台：</p>
<ul>
<li>你正在开发一个基于 Servlet 的 Web 应用</li>
<li><code>com.h2database:h2</code> 在类路径</li>
<li>你正在使用 Spring Boot’s developer tools</li>
</ul>
<p>如果你没有使用 Spring Boot developer tools，但仍然希望使用 H2 的控制台，你可以配置 <code>spring.h2.console.enabled</code> 属性值为 <code>true</code></p>
<h4 id="11-5-1-Changing-the-H2-Console’s-Path"><a href="#11-5-1-Changing-the-H2-Console’s-Path" class="headerlink" title="11.5.1. Changing the H2 Console’s Path"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-sql-h2-console-custom-path">11.5.1. Changing the H2 Console’s Path</a></h4><p>默认情况下，控制台在 <code>/h2-console</code> 可以获得。你可以使用 <code>spring.h2.console.path</code> 属性自定义控制台路径。</p>
<h2 id="12-Working-with-NoSQL-Technologies"><a href="#12-Working-with-NoSQL-Technologies" class="headerlink" title="12. Working with NoSQL Technologies"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-nosql">12. Working with NoSQL Technologies</a></h2><h3 id="12-5-Elasticsearch"><a href="#12-5-Elasticsearch" class="headerlink" title="12.5. Elasticsearch"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-elasticsearch">12.5. Elasticsearch</a></h3><h3 id="12-1-Redis"><a href="#12-1-Redis" class="headerlink" title="12.1. Redis"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-redis">12.1. Redis</a></h3><h2 id="13-Caching"><a href="#13-Caching" class="headerlink" title="13. Caching"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-caching">13. Caching</a></h2><p>Spring Framework 为透明地将缓存添加到应用提供了支持。从其核心，抽象将缓存应用于方法，从而根据缓存中可用的信息减少了执行次数。缓存逻辑是透明地应用的，不会对调用者进行任何干扰。只要通过 <code>@EnableCaching</code> 注解启用缓存支持，Spring Boot 就会自动配置缓存基础架构。</p>
<p>简而言之，为了将缓存添加到服务的操作中，将相关的注解添加到其方法中，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(&quot;piDecimals&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computePiDecimal</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例证明了在可能高成本的操作中使用缓存。在调用 <code>computePiDecimal</code>，抽象在 <code>piDecimals</code> 缓存中匹配 <code>i</code> 参数的条目。如果找到条目，则立即将缓存中的内容返回给调用者，并且该方法不会调用。否则，将调用方法，在返回该值之前更新缓存。</p>
<blockquote>
<p>你还可以透明地使用标准 JSR-107(JCache) 注解（例如 <code>@CacheResult</code>）。但是，我们强烈建议你不要混合并匹配 Spring Cache 和 JCache 注解。</p>
</blockquote>
<p>如果你没有添加任何特定的缓存库，Spring Boot 自动配置一个在内存的使用 concurrent map 的 simple provider。当需要缓存（例如在前面例子中的 <code>piDecimals</code>）时，该 provider 就会为你创建一个。实际上，并不建议将 simple provider 用于生产，但是它非常适合入门，以及确保你了解这些功能。当你决定要使用 cache provider 时，请确保阅读其文档，以找出如何配置应用程序使用的缓存。几乎所有的 provider 都要求你显式配置每个你在应用中使用的缓存。有些提供一种自定义默认缓存的方法，通过定义 <code>spring.cache.cache-names</code> 属性。</p>
<blockquote>
<p>也可以透明地更新或从缓存中驱逐数据</p>
</blockquote>
<h3 id="13-1-Supported-Cache-Providers"><a href="#13-1-Supported-Cache-Providers" class="headerlink" title="13.1. Supported Cache Providers"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-caching-provider">13.1. Supported Cache Providers</a></h3><p>缓存抽象并不提供实际的存储，并依赖于由 <code>org.springframework.cache.Cache</code> 和 <code>org.springframework.cache.CacheManager</code> 接口实现的抽象。</p>
<p>如果你没有定义 <code>CacheManager</code> 类型的 Bean 或者名为 <code>cacheResolver</code> 的 <code>CacheResolver</code>，Spring Boot 会尝试检测以下 provider（按照指示的顺序）：</p>
<ol>
<li>Generic</li>
<li>JCache (JSR-107)(EhCache 3, Hazelcast, Infinispan, and others)</li>
<li>EhCache 2.x</li>
<li>Hazelcast</li>
<li>Infinispan</li>
<li>Couchbase</li>
<li>Redis</li>
<li>Caffeine</li>
<li>Simple</li>
</ol>
<h4 id="13-1-1-Generic"><a href="#13-1-1-Generic" class="headerlink" title="13.1.1. Generic"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-caching-provider-generic">13.1.1. Generic</a></h4><p>如果上下文定义了至少一个 <code>org.springframework.cache.Cache</code> Bean，则使用 Generic 缓存。将会创建一个 <code>CacheManager</code> 包裹所有该类型的 Bean。</p>
<h4 id="13-1-2-JCache-JSR-107"><a href="#13-1-2-JCache-JSR-107" class="headerlink" title="13.1.2. JCache (JSR-107)"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-caching-provider-jcache">13.1.2. JCache (JSR-107)</a></h4><p>通过类路径包含一个 <code>javax.cache.spi.CachingProvider</code> 会自动引导 JCache，并且 <code>spring-boot-starter-cache</code> “starter” 提供 <code>JCacheCacheManager</code>。可以获得各种符合条件的库，Spring 为 Ehcache 3，Hazelcast 和 Infinispan 提供依赖管理。也可以添加任何其他符合条件的库。</p>
<p>有可能出现多个 provider，在这种情况下，provider 必须显式指定。即使 JSR-107 标准没有强制一种标准的方式定义配置文件的路径，Spring Boot 尽力容纳使用实现细节配置一个缓存，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Only necessary if more than one provider is present</span></span><br><span class="line"><span class="attr">spring.cache.jcache.provider</span>=<span class="string">com.acme.MyCachingProvider</span></span><br><span class="line"><span class="attr">spring.cache.jcache.config</span>=<span class="string">classpath:acme.xml</span></span><br></pre></td></tr></table></figure>

<p>有两种方法可以自定义底层的 <code>javax.cache.cacheManager</code>:</p>
<ul>
<li>可以通过启动时设置 <code>spring.cache.cache-names</code> 属性创建缓存。如果定义了自定义的 <code>javax.cache.configuration.Configuration</code>，则将用于定制化缓存。</li>
<li>使用 <code>CacheManager</code> 引用调用 <code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> Bean，获得完整定制化。</li>
</ul>
<h4 id="13-1-3-EhCache-2-x"><a href="#13-1-3-EhCache-2-x" class="headerlink" title="13.1.3. EhCache 2.x"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-caching-provider-ehcache2">13.1.3. EhCache 2.x</a></h4><p>如果在类路径的根路径下能够找到名为 <code>ehcache.xml</code> 的文件，那么 EhCache 2.x 会被使用。如果找到 EhCache 2.x，那么由 <code>spring-boot-starter-cache</code> “starter” 提供的 <code>EhCacheCacheManager</code> 将用于引导 cache manager。也可以提供可替代的配置文件，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cache.ehcache.config</span>=<span class="string">classpath:config/another-config.xml</span></span><br></pre></td></tr></table></figure>

<h4 id="13-1-4-Hazelcast"><a href="#13-1-4-Hazelcast" class="headerlink" title="13.1.4. Hazelcast"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-caching-provider-hazelcast">13.1.4. Hazelcast</a></h4><p>Spring Boot 对 Hazelcast 有一般支持。如果 <code>HazelcastInstance</code> 已经自动配置了，那么它将自动包裹进 <code>CacheManager</code>。</p>
<h4 id="13-1-5-Infinispan"><a href="#13-1-5-Infinispan" class="headerlink" title="13.1.5. Infinispan"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-caching-provider-infinispan">13.1.5. Infinispan</a></h4><h4 id="13-1-7-Redis"><a href="#13-1-7-Redis" class="headerlink" title="13.1.7. Redis"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-caching-provider-redis">13.1.7. Redis</a></h4><p>如果 Redis 可用且已配置，<code>RedisCacheManager</code> 就会自动配置。可以通过设置 <code>spring.cache.cache-names</code> 属性在启动时创建额外的缓存，以及通过使用 <code>spring.cache.redis.*</code> 属性配置缓存默认值。例如，以下配置创建了 <code>cache</code> 和 <code>cache2</code> 缓存，并具有 10 分钟的存活时间: </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="attr">spring.cache.redis.time-to-live</span>=<span class="string">600000</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tips</strong> 需要依赖 <code>spring-boot-starter-data-redis</code> 才能引入 <code>RedisCacheManager</code></p>
</blockquote>
<blockquote>
<p>默认情况下，添加了一个 key 前缀，这是为了，如果两个分开的缓存使用相同的 key，redis 没有重叠的 key，且无法返回无效值。我们强烈建议你在创建自己的 <code>RedisCacheManager</code> 时启用该设置。</p>
</blockquote>
<h2 id="21-Quartz-Scheduler"><a href="#21-Quartz-Scheduler" class="headerlink" title="21. Quartz Scheduler"></a><a href="">21. Quartz Scheduler</a></h2><h2 id="26-Testing"><a href="#26-Testing" class="headerlink" title="26. Testing"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-testing">26. Testing</a></h2><p>Spring Boot 在测试你的应用程序时提供了许多工具和注解。由两个模块提供测试支持：<code>spring-boot-test</code> 包含核心项目，<code>spring-boot-test-autoconfigure</code> 包含测试的自动配置。</p>
<p>大多数开发者使用 <code>spring-boot-starter-test</code> “starter”，该测试不仅导入了 Spring Boot 测试模块，而且还导入了 JUnit Jupiter，AssertJ，Hamcrest，以及许多其他有用的库。</p>
<blockquote>
<p>starter 还引入了 vintage 引擎，因此你既可以运行 JUnit 4 也可以运行 JUnit 5 的测试。如果你已经将测试迁移到 JUnit 5，你应该排除 JUnit 4 的支持，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/&gt; artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-vintage-engine&lt;/&gt; artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="26-1-Test-Scope-Dependencies"><a href="#26-1-Test-Scope-Dependencies" class="headerlink" title="26.1. Test Scope Dependencies"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-test-scope-dependencies">26.1. Test Scope Dependencies</a></h3><h2 id="29-Creating-Your-Own-Auto-configuration"><a href="#29-Creating-Your-Own-Auto-configuration" class="headerlink" title="29. Creating Your Own Auto-configuration"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-developing-auto-configuration">29. Creating Your Own Auto-configuration</a></h2><h3 id="29-1-Understanding-Auto-configured-Beans"><a href="#29-1-Understanding-Auto-configured-Beans" class="headerlink" title="29.1. Understanding Auto-configured Beans"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-understanding-auto-configured-beans">29.1. Understanding Auto-configured Beans</a></h3><p>表层之下 ，使用标准 <code>@Configuration</code> 类实现自动配置。当使用自动配置时，需要使用额外的 <code>@Conditional</code> 注解进行约束。通常，自动配置类使用 <code>@ConditionalOnClass</code> 以及 <code>@ConditionalOnMissingBean</code> 注解。这样可以确保仅当找到相关的类，以及未声明自己的 <code>@Configuration</code> 时才使用自动配置。</p>
<p>你可以浏览 <code>spring-boot-autoconfigure</code> 源码，查看 Spring 提供的 <code>@Configuration</code> 类（见 <code>META-INF/spring.factories</code> 文件）。</p>
<h3 id="29-2-Locating-Auto-configuration-Candidates"><a href="#29-2-Locating-Auto-configuration-Candidates" class="headerlink" title="29.2. Locating Auto-configuration Candidates"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-locating-auto-configuration-candidates">29.2. Locating Auto-configuration Candidates</a></h3><p>Spring Boot 检查你已发布的 jar 中是否存在 <code>META-INF/spring.factories</code> 文件。该文件应在 <code>EnableAutoConfiguration</code> key 下列出你的配置类，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<h2 id="29-3-Condition-Annotations"><a href="#29-3-Condition-Annotations" class="headerlink" title="29.3. Condition Annotations"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-condition-annotations">29.3. Condition Annotations</a></h2><h3 id="29-3-1-Class-Conditions"><a href="#29-3-1-Class-Conditions" class="headerlink" title="29.3.1. Class Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-class-conditions">29.3.1. Class Conditions</a></h3><ul>
<li>@ConditionalConClass</li>
<li>@ConditionalOnMissingClass</li>
</ul>
<h3 id="29-3-2-Bean-Conditions"><a href="#29-3-2-Bean-Conditions" class="headerlink" title="29.3.2. Bean Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-bean-conditions">29.3.2. Bean Conditions</a></h3><ul>
<li>@ConditionalOnBean</li>
<li>@ConditionalOnMissingBean</li>
</ul>
<h3 id="29-3-3-Property-Conditions"><a href="#29-3-3-Property-Conditions" class="headerlink" title="29.3.3. Property Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-property-conditions">29.3.3. Property Conditions</a></h3><ul>
<li>@ConditionalOnProperty</li>
</ul>
<h3 id="29-3-4-Resource-Conditions"><a href="#29-3-4-Resource-Conditions" class="headerlink" title="29.3.4. Resource Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-resource-conditions">29.3.4. Resource Conditions</a></h3><ul>
<li>@ConditionalOnResource</li>
</ul>
<h3 id="29-3-5-Web-Application-Conditions"><a href="#29-3-5-Web-Application-Conditions" class="headerlink" title="29.3.5. Web Application Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-web-application-conditions">29.3.5. Web Application Conditions</a></h3><ul>
<li>@ConditionalOnWebApplication</li>
<li>@ConditionalOnNotWebApplication</li>
</ul>
<h3 id="29-3-6-SpEL-Expression-Conditions"><a href="#29-3-6-SpEL-Expression-Conditions" class="headerlink" title="29.3.6. SpEL Expression Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spel-conditions">29.3.6. SpEL Expression Conditions</a></h3>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework Web Servlet</title>
    <url>/2022/05/09/Spring-Framework/Spring-Framework-Web-Servlet/</url>
    <content><![CDATA[<h1 id="Web-on-Servlet-Stack"><a href="#Web-on-Servlet-Stack" class="headerlink" title="Web on Servlet Stack"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html">Web on Servlet Stack</a></h1><h2 id="1-Spring-Web-MVC"><a href="#1-Spring-Web-MVC" class="headerlink" title="1. Spring Web MVC"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc">1. Spring Web MVC</a></h2><p>Spring Web MVC 是基于 Servlet API 的原始 Web 框架，从很早的时候就包含在 Spring Framework 之中。正式名称 —— Spring Web MVC，来源于它的源模块名称（<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a>），但通常称之为 “Spring MVC”。</p>
<p>与 Spring Web MVC 平行，Spring Framework 5.0 引入了一个响应式栈 web 框架，其名称为 “Spring WebFlux”，也是基于其源模块（<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a>）。本节涵盖 Spring Web MVC。<a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web-reactive.html#spring-web-reactive">下一节</a>涵盖 Spring WebFlux。</p>
<p>有关基线信息以及与 Servlet 容器和 Java EE 版本范围的兼容性，请参见 Spring Framework <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">Wiki</a>。</p>
<h3 id="1-1-DispatcherServlet"><a href="#1-1-DispatcherServlet" class="headerlink" title="1.1. DispatcherServlet"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet">1.1. DispatcherServlet</a></h3><p><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web-reactive.html#webflux-dispatcher-handler">WebFlux</a></p>
<p>与许多其他 Web 框架一样，Spring MVC 围绕着前端控制器模式设计，其中首要的 <code>Servlet</code> —— <code>DispatcherServlet</code> 为请求处理提供了一组共享的算法，而实际的工作则由可配置的代理组件执行。这种模型灵活，并且支持各种工作流。</p>
<blockquote>
<p><strong>作者的话</strong> 简单来说，<code>DispatcherServlet</code> 为所有请求提供统一的处理流程（<code>doDispatch</code>），但是细节部分由各个组件实现，而且并不是每个组件在处理每个请求时都会发挥作用。</p>
</blockquote>
<p>正如任何 <code>Servlet</code> 一样，<code>DispatcherServlet</code> 也需要根据 Servlet 规范进行声明以及映射（路径），可以通过 Java 配置或者在 <code>web.xml</code> 中声明以及映射。反过来，<code>DispatcherServlet</code> 使用 Spring 配置，去发现它所需要的委托组件，比如用于请求映射，视图解析，异常处理的组件，等等。</p>
<p>下面是有关于 Java 配置注册以及初始化 <code>DispatcherServlet</code> 的示例，这会被 Servlet 容器自动检测（参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-container-config">Servlet Config</a>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load Spring web application configuration</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        context.register(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create and register the DispatcherServlet</span></span><br><span class="line">        <span class="type">DispatcherServlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(context);</span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addServlet(<span class="string">&quot;app&quot;</span>, servlet);</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/app/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了直接使用 ServletContext API，你还可以继承 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 并覆盖特定的方法（见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-context-hierarchy">Context Hierarchy</a> 下面的例子）。</p>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> 不必太关心这里，只有基于外部容器部署的时候才会加载 <code>WebApplicationInitializer</code></p>
</blockquote>
<p>以下示例是 <code>web.xml</code> 配置注册以及初始化 <code>DispatcherServlet</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot 遵循一种不同的初始化顺序。Spring Boot 并不是直接挂载到 Servlet 容器的生命周期，而是使用 Spring 配置来引导自身以及内嵌的 Servlet 容器。<code>Filter</code> 和 <code>Servlet</code> 的声明以 Spring 配置的方式被检测到，并注册到 Servlet 容器。</p>
</blockquote>
<h4 id="1-1-1-Context-Hierarchy"><a href="#1-1-1-Context-Hierarchy" class="headerlink" title="1.1.1. Context Hierarchy"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-container-config">1.1.1. Context Hierarchy</a></h4><p><code>DispatcherServlet</code> 期望一个 <code>WebApplicationContext</code>（继承于简单 <code>ApplicationContext</code>） 用于自己的配置。<code>WebApplicationContext</code> 持有 <code>ServletContext</code> 的引用，并且持有相关的 <code>Servlet</code> 的引用。<code>WebApplicationContext</code> 也会绑定到 <code>ServletContext</code>，以便于应用程序在需要的时候可以通过 <code>RequestContextUtiles</code> 的静态方法找到 <code>WebApplicationContext</code>。</p>
<blockquote>
<p><strong>作者的话</strong> 上面这句话简单来看就是 <code>WebApplicationContext</code> 和 <code>ServletContext</code> 相互引用。<code>ServletContext</code> 绑定 <code>WebApplicationContext</code> 方式是设置为请求的属性。</p>
</blockquote>
<p>对于许多应用程序而言，具有单个的 <code>WebApplicationContext</code> 是简易且足够用了。也有可能，有一种上下文结构，其中，根 <code>WebApplicationContext</code> 被多个 <code>DispatcherServlet</code> 实例共享（或者其他 <code>Servlet</code>），每个 <code>Servlet</code> 又有自己的子 <code>WebApplicationContext</code> 配置。有关上下文层次结构功能的更多信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-introduction"> Additional Capabilities of the <code>ApplicationContext</code></a></p>
<p>root <code>WebApplicationContext</code> 通常包含基于架构 Bean，例如数据仓库和业务服务，它们需要在多个 <code>Servlet</code> 实例上共享。这些 Bean 被有效继承，并且可以在特定于 Servlet 的子 <code>WebApplicationContext</code> 中覆盖，这通常包含给定的本地 <code>Servlet</code> Bean。下图展示了这种关系：</p>
<img src="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png">

<p>下面的示例配置了一个 <code>WebApplicationContext</code> 层次结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; RootConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; App1Config.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/app1/*&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不需要应用程序上下文的层次结构，应用程序可以通过 <code>getRootConfigClasses()</code> 返回所有的配置，并且在 <code>getServletConfigClasses()</code> 返回 <code>null</code>。</p>
</blockquote>
<p>下面示例展示了 <code>web.xml</code> 的等价物：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app1-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app1/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果应用程序不需要上下文层次结构，则可以仅仅配置 “root” 上下文，并保持 <code>contextConfigLocation</code> Servlet 参数为空。</p>
</blockquote>
<h4 id="1-1-2-Special-Bean-Types"><a href="#1-1-2-Special-Bean-Types" class="headerlink" title="1.1.2. Special Bean Types"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-special-bean-types">1.1.2. Special Bean Types</a></h4><p><code>DispatcherServlet</code> 委托特殊的 Bean 来处理请求并给予合适的响应。通过“特殊 Bean”，我们意思是实现了框架约定的由 Spring 管理的 <code>Object</code>。这些通常带有内置的约定，但是你可以定制化它们的属性并扩展或更换它们。</p>
<p>下面的表格列出了由 <code>DispatcherServlet</code> 检测的特殊 Bean：</p>
<table>
<thead>
<tr>
<th align="left">Bean Type</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>HandlerMapping</code></td>
<td align="left">将请求映射到 handler，以及前置处理拦截器和后置处理拦截器的列表。该映射基于某些规则，其中的细节随着 <code>HandlerMapping</code> 的实现有所不同。<br><br>两个主要的 <code>HandlerMapping</code> 的实现类：<br>(1) <code>RequestMappingHandlerMapping </code>，它支持 <code>@RequestMapping</code> 注解方法<br>(2) <code>SimpleUrlHandlerMapping</code>，它维护 URI 路径模式到 handler 的显式注册</td>
</tr>
<tr>
<td align="left"><code>HandlerAdapter</code></td>
<td align="left">帮助 <code>DispatcherServlet</code> 调用映射到请求的 handler，不管 handler 实际是如何调用。例如，调用注解式控制器需要解析注解。<code>HandlerAdapter</code> 的主要目的是防止 <code>DispatcherServlet</code> 受此类细节的影响</td>
</tr>
<tr>
<td align="left"><code>HandlerExceptionResolver</code></td>
<td align="left">解析异常的策略，可能会将它们映射到 handler，html 错误视图，或者其他目标</td>
</tr>
<tr>
<td align="left"><code>ViewResolver</code></td>
<td align="left">从 handler 返回的基于字符串的逻辑视图名称解析为要呈现给响应的实际视图</td>
</tr>
<tr>
<td align="left"><code>LocaleResolver</code>,<a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-timezone">LocaleContextResolver</a></td>
<td align="left">解析客户端正在使用的 <code>Locale</code> 以及可能的时区，以便能提供国际化的视图。参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-localeresolver">Locale</a></td>
</tr>
<tr>
<td align="left"><code>ThemeResolver</code></td>
<td align="left">解析你的 Web 应用程序可以使用的主题</td>
</tr>
<tr>
<td align="left"><code>MultipartResolver</code></td>
<td align="left">在某些 multipart 解析库的帮助下，用于解析 multi-part 请求（例如，浏览器表单文件上传）。请参阅 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-multipart">Multipart Resolver</a></td>
</tr>
<tr>
<td align="left"><code>FlashMapManager</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="1-1-3-Web-MVC-Config"><a href="#1-1-3-Web-MVC-Config" class="headerlink" title="1.1.3. Web MVC Config"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-config">1.1.3. Web MVC Config</a></h4><p>应用程序可以声明一些在 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-special-bean-types">Special Bean Types</a> 列出的基础架构的 Bean，需要这些 Bean 来处理请求。<code>DispatcherServlet</code> 会为每个特殊 Bean 检查 <code>WebApplicationContext</code>。如果没有匹配的 Bean 类型，则会回退到使用 <code>DispatcherServlet.properties</code> 列出的默认 bean。</p>
<p>大多数情况下，MVC Config 是最佳出发点。它以 Java 或者 XML 的方式声明了需要的 bean，并且提供了更高级配置回调 API 用于自定义。</p>
<blockquote>
<p><strong>作者的话</strong> MVC Config 是官方术语，代表 Spring MVC 提供的默认配置，可以是注解式启用，也可以是 XML 方式启用，具体来说就是 <code>@EnableWebMvc</code> 和 <code>&lt;mvc:annotation-driven/&gt;</code></p>
</blockquote>
<blockquote>
<p>Spring Boot 依赖于 MVC Java Config 配置 Spring MVC，以及提供了许多额外的便利选项</p>
</blockquote>
<h4 id="1-1-4-Servlet-Config"><a href="#1-1-4-Servlet-Config" class="headerlink" title="1.1.4. Servlet Config"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-container-config">1.1.4. Servlet Config</a></h4><blockquote>
<p><strong>作者的话</strong> 对于 Spring Boot 来说，<code>DispatcherServlet</code> 是自动配置的，而且 Servlet 容器也是在 <code>ApplicationContext</code> 进行 <code>refresh</code> 的过程中内嵌启动的，所以这一节可以简单了解</p>
</blockquote>
<p>在 Servlet 3.0+ 环境下，你可以选择使用编程方式作为一种替代方案进行 Servlet 容器配置，或者你也可以与 <code>web.xml</code> 方式组合使用。如下是注册一个 <code>DispatcherServlet</code> 的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext container)</span> &#123;</span><br><span class="line">        <span class="type">XmlWebApplicationContext</span> <span class="variable">appContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlWebApplicationContext</span>();</span><br><span class="line">        appContext.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> container.addServlet(<span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(appContext));</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WebApplicationInitializer</code> 是由 Spring MVC 提供的接口，可以确保检测到你的实现类并用于初始化任何 Servlet 3 容器。<code>WebApplicationInitializer</code> 的一个实现类（抽象基类）是 <code>AbstractDispatcherServletInitializer</code>，你可以通过覆盖父类方法指定 Servlet 映射以及 <code>DispatcherServlet</code> 配置的路径使得注册 <code>DispatcherServlet</code> 更加容易。</p>
<p>应用程序使用基于 Java 的 Spring 配置如下示例所示，这也是官方建议的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; MyWebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用基于 XML 的 Spring 配置，则应该直接从 <code>AbstractDispatcherServletInitializer</code> 继承下来，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XmlWebApplicationContext</span> <span class="variable">cxt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlWebApplicationContext</span>();</span><br><span class="line">        cxt.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractDispatcherServletInitializer</code> 还提供了一种添加 <code>Filter</code> 实例，并将其自动映射到 <code>DispatcherServlet</code> 的简便方法，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>(), <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加的每个过滤器都会基于其具体类型有一个默认名字，并自动映射到 <code>DispatcherServlet</code>。</p>
<blockquote>
<p><strong>作者的话</strong> 将 <code>Filter</code> 映射到 <code>DispatcherServlet</code> 的方式是通过 Servlet API <code>javax.servlet.FilterRegistration#addMappingForServletNames</code> 实现的</p>
</blockquote>
<p><code>AbstractDispatcherServletInitializer</code> 的 protected 方法 <code>isAsyncSupported</code> 提供了一个地方可以在 <code>DispatcherServlet</code> 上启用异步支持，并且所有过滤器都会映射到它上面。默认地，这个标志位是 <code>true</code></p>
<p>最后，如果你需要进一步自定义 <code>DispatcherServlet</code> 本身，你可以直接覆盖 <code>createDispatcherServlet</code> 方法。</p>
<h4 id="1-1-5-Processing"><a href="#1-1-5-Processing" class="headerlink" title="1.1.5. Processing"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-sequence">1.1.5. Processing</a></h4><p><code>DispatcherServlet</code> 处理过程如下：</p>
<ul>
<li><p>搜索 <code>WebApplicationContext</code> 并将其绑定到 Request 的属性上，处理过程中控制器和其他元素可能会使用到。默认绑定到 <code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> key 上。</p>
</li>
<li><p>将 locale resolver 绑定到 Request 的属性上，以便于当处理请求的过程中让其他元素解析本地化使用。如果你不需要本地化解析，你就不必使用 locale resolver。</p>
</li>
<li><p>将主题解析器绑定到请求，以使视图之类的元素确定用何种主题。如果你不使用主题，可以忽略它。</p>
</li>
<li><p>如果你指定了一个 multipart 文件解析器，将会检查请求的 multiparts。如果找到了 multiparts，请求会被包装成 <code>MultipartHttpServletRequest</code>，用于过程后期其他元素的处理。</p>
</li>
<li><p>搜索合适的 handler。如果找到了一个 handler，与该 handler 有关的执行链（前置处理器、后置处理器、控制器）将会运行，用于准备 model 的渲染。或者，对于注解式控制器，响应可以直接渲染（在 <code>HandlerAdapter</code>）而不是返回一个视图。</p>
</li>
<li><p>如果返回的是 model，视图就会被渲染。如果没有返回 model（可能由于前置处理器或者后置处理器拦截了请求，可能是因为安全问题），就不会渲染视图，因为请求已经完成了。</p>
</li>
</ul>
<p>声明在 <code>WebApplicationContext</code> 的 <code>HandlerExceptionResolver</code> bean 用于解析请求处理过程中抛出的异常。允许自定义异常处理器的逻辑用于处理异常。</p>
<p><code>DispatcherServlet</code> 还支持返回 <code>last-modification-date</code>，正如 Servlet API 指定的。确定特定请求的最后一次修改日期很简单：<code>DispatcherServlet</code> 寻找合适的 handler mapping，并检测被找到的 handler 是否实现了 <code>LastModified</code> 接口。如果是，接口 <code>LastModified</code> 的方法 <code>long getLastModified(request)</code> 的值就会返回给客户端。</p>
<blockquote>
<p><strong>作者的话</strong> 注解式 Controller 想要实现最后一次修改日期需要做一些特殊操作，因为 <code>RequestMappingHandlerAdapter</code> 的 <code>getLastModified</code> 总是返回 -1，但源码方法注解也给了我们指引，需要在 handler 中调用 <code>WebRequest#checkNotModified(long)</code>，如果返回值是 true，则返回 <code>null</code></p>
</blockquote>
<p>你可以通过在 <code>web.xml</code> 文件中添加 Servlet 初始化参数到 Servlet 声明中来自定义一个自己 <code>DispatcherServlet</code>。以下列表列出了支持的参数：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>contextClass</code></td>
<td align="left">实现了 <code>ConfigurableWebApplicationContext</code> 的类，将由此 Servlet 进行实例化与本地配置。默认地，使用 <code>XmlWebApplicationContext</code>。</td>
</tr>
<tr>
<td align="left"><code>contextConfigLocation</code></td>
<td align="left">传递给上下文实例的字符串，标识从哪里寻找上下文。</td>
</tr>
<tr>
<td align="left"><code>namespace</code></td>
<td align="left"><code>WebApplicationContext</code>的命名空间。默认是 <code>[servlet-name]-servlet</code></td>
</tr>
<tr>
<td align="left"><code>throwExceptionIfNoHandlerFound</code></td>
<td align="left">当找不到请求的 handler 时，是否抛出异常</td>
</tr>
</tbody></table>
<h4 id="1-1-6-Interception"><a href="#1-1-6-Interception" class="headerlink" title="1.1.6. Interception"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-handlermapping-interceptor">1.1.6. Interception</a></h4><p>所有的 <code>HandlerMapping</code> 实现类都支持 handler 拦截器，这很有用，比如你希望将某些特定的功能应用于某些请求，举个例子，检查 principal。</p>
<p>拦截器必须实现 <code>org.springframework.web.servlet.HandlerInterceptor</code> 接口，它提供了三个方法，应该可以足够灵活地执行各种前置处理以及后置处理操作。</p>
<ul>
<li><code>preHandle(..)</code>: 在实际的 handler 运行之前</li>
<li><code>postHandle(..)</code>: 在实际的 handler 运行之后</li>
<li><code>afterCompletion(..)</code>: 在完整的请求结束之后</li>
</ul>
<p><code>preHandle(..)</code> 方法返回一个 boolean 值。你可以使用此方法 break 或者 continue 执行链的执行。当方法返回 <code>true</code>，handler 执行链就会继续；当方法返回 <code>false</code>，<code>DispatcherServlet</code> 会认为拦截器本身已经处理了请求（例如，渲染了恰当的视图），并且不会继续执行其他拦截器以及实际的 handler。</p>
<p>请注意，当具有 <code>@ResponseBody</code> 以及 <code>ResponseEntity</code> 的时候，<code>postHandle</code> 没什么用，因为在 <code>postHandle</code> 之前响应就会在 <code>HandlerAdapter</code> 中写入并提交了。这意味着，对响应进行任何更改为时已晚，例如添加额外的 header 都是无用的。对于这种情况，你可以实现 <code>ResponseBodyAdvice</code>，并将它声明为一个 <code>Controller Advice</code> bean，或者，你也可以直接在 <code>RequestMappingHandlerAdapter</code> 上直接配置。</p>
<h4 id="1-1-7-Exceptions"><a href="#1-1-7-Exceptions" class="headerlink" title="1.1.7. Exceptions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers">1.1.7. Exceptions</a></h4><p>如果请求 mapping 期间或者请求 handler（如 @Controller）抛出异常，则 DispatcherServlet 将委托给 HandlerExceptionResolver 链解析异常，并提供可替代的处理，这是典型的错误响应。</p>
<blockquote>
<p><strong>作者的话</strong> 其实就是 try catch 模式，catch 中处理异常</p>
</blockquote>
<p>以下表格列出了可用的 <code>HandlerExceptionResolver</code> 实现类：</p>
<table>
<thead>
<tr>
<th align="left"><code>HandlerExceptionResolver</code></th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>SimpleMappingExceptionResolver</code></td>
<td align="left">异常类名于错误视图名之间的映射。</td>
</tr>
<tr>
<td align="left"><code>DefaultHandlerExceptionResolver</code></td>
<td align="left">解析 Spring MVC 的异常，并将它们映射到 HTTP 状态码</td>
</tr>
<tr>
<td align="left"><code>ResponseStatusExceptionResolver</code></td>
<td align="left">用 <code>@ResponseStatus</code> 注解解析异常，并根据注解中的值将其映射到 HTTP 状态码</td>
</tr>
<tr>
<td align="left"><code>ExceptionHandlerExceptionResolver</code></td>
<td align="left">通过调用 <code>@Controller</code> 或者 <code>@ControllerAdvice</code> 中的 <code>@ExceptionHandler</code> 方法解析异常</td>
</tr>
</tbody></table>
<p><code>HandlerExceptionResolver</code> 的约定规定它可以返回：</p>
<ul>
<li>一个指向错误视图的 <code>ModelAndView</code></li>
<li>如果在解析器处理了异常，则是一个空的 <code>ModelAndView</code></li>
<li>如果异常仍然未解析，则返回 null，后面的解析器继续尝试，如果最后仍然未解析，可以冒泡到 Servlet 容器</li>
</ul>
<p>MVC Config 自动地为默认的 Spring MVC 异常，<code>@ResponseStatus</code> 注解异常，以及 <code>@ExceptionHandler</code> 方法的支持声明了内置的解析器。你可以自定义或者替换它们。</p>
<h5 id="Chain-of-Resolvers"><a href="#Chain-of-Resolvers" class="headerlink" title="Chain of Resolvers"></a>Chain of Resolvers</h5><p>可以通过 HandlerExceptionResolver 在 Spring 配置中声明多个 bean 并根据需要设置他们的 order 属性。order 越高，异常处理器位置越靠后（越晚处理）。</p>
<p>HandlerExceptionResolver 约定可以返回如下：</p>
<ul>
<li>ModelAndView 跳转到错误页面</li>
<li>如果在解析器里处理了异常，则可以返回一个空的 ModelAndView </li>
<li>如果异常仍未处理，则返回 null，供后续解析器继续尝试，如果异常一直存在，允许冒泡到 Servlet 容器。</li>
</ul>
<h5 id="Container-Error-Page"><a href="#Container-Error-Page" class="headerlink" title="Container Error Page"></a>Container Error Page</h5><p>如果没有任何 <code>HandlerExceptionResolver</code> 处理异常，那么就会传播出去，或者如果响应状态为错误状态（即 4xx, 5xx），那么 Servlet 容器会在 HTML 中渲染默认的错误页面。要自定义容器的默认错误页面，可以在 <code>web.xml</code> 声明一个错误页面映射，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>给定之前的例子，当异常向上冒泡或者响应具有一个错误状态，Servlet 容器会将错误派发到配置的 URL（例如，<code>/error</code>）。接着，由 <code>DispatcherServlet</code> 处理，可能将其映射到一个 <code>@Controller</code>，其实现可以返回一个带有 model 的错误视图名，或者返回一个 JSON 响应，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/error&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>));</span><br><span class="line">        map.put(<span class="string">&quot;reason&quot;</span>, request.getAttribute(<span class="string">&quot;javax.servlet.error.message&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-11-Multipart-Resolver"><a href="#1-1-11-Multipart-Resolver" class="headerlink" title="1.1.11. Multipart Resolver"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-multipart">1.1.11. Multipart Resolver</a></h4><p><code>org.springframework.web.multipart.MultipartResolver</code> 是解析包含文件上传的 multipart 请求的策略接口。</p>
<ul>
<li>其中一个实现是基于 Commons FileUpload 框架</li>
<li>另一个是基于 Servlet 3.0 multipart 请求解析</li>
</ul>
<h5 id="Apache-Commons-FileUpload"><a href="#Apache-Commons-FileUpload" class="headerlink" title="Apache Commons FileUpload"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-multipart-resolver-commons">Apache Commons FileUpload</a></h5><p>为了使用 Apache 的 Commons FileUpload：</p>
<ul>
<li>配置一个 <code>CommonsMultipartResolver</code>，名称任意，如：<code>multipartResolver</code></li>
<li>添加 <code>commons-fileupload</code> 依赖</li>
</ul>
<h5 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-multipart-resolver-standard">Servlet 3.0</a></h5><h3 id="1-2-Filters"><a href="#1-2-Filters" class="headerlink" title="1.2. Filters"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#filters">1.2. Filters</a></h3><h4 id="1-2-1-Form-Data"><a href="#1-2-1-Form-Data" class="headerlink" title="1.2.1. Form Data"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#filters-http-put">1.2.1. Form Data</a></h4><p>浏览器只能通过 HTTP GET 或者 HTTP POST 提交表单数据，但是，非浏览器的客户端（比如 Postman）还可以使用 HTTP PUT, PATCH, DELETE 等。Servlet API 规定：<code>ServletRequest.getParameter*()</code> 系列方法仅仅支持访问 HTTP POST 的表单字段。</p>
<p><code>spring-web</code> 模块提供了 <code>FormContentFilter</code>，拦截 Content Type 为 <code>application/x-www-form-urlencoded</code> 的 HTTP PUT, PATCH, DELETE 请求，读取请求体的表单数据，然后将 <code>ServletRequest</code> 进行一层包装，接着就可以通过 <code>ServletRequest.getParameter*()</code> 系列方法直接访问表单数据了。</p>
<h4 id="1-2-2-Forwarded-Headers"><a href="#1-2-2-Forwarded-Headers" class="headerlink" title="1.2.2. Forwarded Headers"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#filters-forwarded-headers">1.2.2. Forwarded Headers</a></h4><p>当请求通过代理（例如，负载均衡器）时，主机，端口号，以及 schema 可能会更改，这使得形成一个指向用户正确的主机，端口和 schema 的连接比较困难。</p>
<p>RFC 7239 定义了 <code>Forwarded</code> HTTP 头部，代理可以用它来提供关于原始请求的信息。还有一些其他的非标准头部，包括 <code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>, <code>X-Forwarded-Proto</code>, <code>X-Forwared-Ssl</code>, 以及 <code>X-Forwarded-Prefix</code>。</p>
<p><code>ForwardedHeaderFilter</code> 是一个 Servlet 过滤器，它可以修改请求：a) 基于<code>Forwarded</code> 头部的主机，端口号，以及 schema；b) 删除这些头部，防止影响后期。该过滤器依赖于包装请求，因此，必须排在其他过滤器（如 <code>RequestContextFilter</code>）之前，它应该与修改后的，而不是原始请求一起使用。</p>
<p>由于应用程序并不知道 header 是否由代理（这是预期的），还是由恶意客户端添加的，因此有必要对于 <code>Forwared</code> 头部做一些安全考虑。这就是为什么在信任边界上（最外层）的代理应该做一层配置，去删除那些从外部传来的不信任的 <code>Forwarded</code> 头部。你还可以给 <code>ForwardedHeaderFilter</code> 配置 <code>removeOnly=true</code>，这种情况下，它会删除不使用这些头部。</p>
<h4 id="1-2-4-CORS"><a href="#1-2-4-CORS" class="headerlink" title="1.2.4. CORS"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#filters-cors">1.2.4. CORS</a></h4><p>Spring MVC 通过控制器的注解，为 CORS 配置提供了细粒度的支持。但是，当你和 Spring Security 一起使用时，建议依赖于内置的 <code>CorsFilter</code>，它必须排在 Spring Security 的过滤器链之前。</p>
<h3 id="1-3-Annotated-Controllers"><a href="#1-3-Annotated-Controllers" class="headerlink" title="1.3. Annotated Controllers"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-controller">1.3. Annotated Controllers</a></h3><p>Spring MVC 提供了一个基于注解的编程模型，其中 <code>@Controller</code> 和 <code>@RestController</code> 组件用注解来表示请求的映射、请求的输入、异常的处理等。</p>
<p>被注解的控制器具有灵活的方法签名（即方法名、参数个性化定制），不必扩展基类也不必实现特定接口。</p>
<p>以下例子展示了一个由注解定义的控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，该方法接受 <code>Model</code> 并将视图名称以 <code>String</code> 形式返回。</p>
<h4 id="1-3-1-Declaration"><a href="#1-3-1-Declaration" class="headerlink" title="1.3.1. Declaration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-controller">1.3.1. Declaration</a></h4><p>你可以在 Servlet 的 <code>WebApplicationContext</code> 中使用标准的 Spring Bean definition 来定义控制器 bean。<code>@Controller</code> 注解允许自动检测，这与 Spring 通用支持检测类路径中的 <code>@Component</code> 类并自动注册 bean definition 是一致的。<code>@Controller</code> 还充当注解类的刻板印象，表示其作为 Web 组件。</p>
<blockquote>
<p>刻板印象是译词，表示该注解具有特定语义。</p>
</blockquote>
<h4 id="1-3-2-Request-Mapping"><a href="#1-3-2-Request-Mapping" class="headerlink" title="1.3.2. Request Mapping"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping">1.3.2. Request Mapping</a></h4><p>你可以使用 <code>@RequestMapping</code> 注解将请求映射到控制器方法。该注解有各种属性去映射，如：URL、HTTP 方法、请求参数、请求头、媒体类型。你可以在类级别使用它来表示共享映射或者在特定方法级别上使用来缩小到特定的端点映射。</p>
<p>还有一些 <code>@RequestMapping</code> 的特定快捷变体：</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>快捷变体是自定义注解，因为，大多数控制器方法应该映射到特定的 HTTP 方法，而不是使用 <code>@RequestMapping</code>。在类级别，仍然需要 <code>@RequestMapping</code> 来表示共享映射。</p>
<blockquote>
<p>默认地，<code>@RequestMapping</code> 与所有 HTTP 方法适配。</p>
</blockquote>
<h5 id="URI-patterns"><a href="#URI-patterns" class="headerlink" title="URI patterns"></a>URI patterns</h5><table>
<thead>
<tr>
<th><div style="width: 120px">Pattern</div></th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>?</code></td>
<td>匹配一个字符</td>
<td><code>&quot;/pages/t?st.html&quot;</code><br>匹配 <code>&quot;/pages/test.html&quot;</code> <br> <code>&quot;/pages/t3st.html&quot;</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配零个或多个字符</td>
<td><code>&quot;/resources/*.png&quot;</code><br>匹配 <code>&quot;/resources/file.png&quot;</code><br><br><code>&quot;/projects/*/versions&quot;</code><br>匹配 <code>&quot;/projects/spring/versions&quot;</code>，<br>但不匹配 <code>&quot;/projects/spring/boot/versions&quot;</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>匹配零个或多个路径段，直到路径结束</td>
<td><code>&quot;/resources/**&quot;</code><br>匹配 <code>&quot;/resources&quot;</code> <br> <code>&quot;/resources/file.png&quot;</code> <br> <code>&quot;/resources/images/file.png&quot;</code></td>
</tr>
<tr>
<td><code>&#123;name&#125;</code></td>
<td>匹配一条路径段，并将其捕获为名为 “name” 的变量</td>
<td><code>&quot;/projects/&#123;project&#125;/versions&quot;</code><br>匹配 <code>&quot;/projects/spring/versions&quot;</code>，并捕获 <code>project=spring</code></td>
</tr>
<tr>
<td><code>&#123;name:[a-z]+&#125;</code></td>
<td>匹配正则表达式 <code>&quot;[a-z]+&quot;</code> 作为名为 “name” 的路径变量</td>
<td><code>&quot;/projects/&#123;project:[a-z]+&#125;/versions&quot;</code><br>匹配 <code>&quot;/projects/spring/versions&quot;</code>，<br>但不匹配 <code>&quot;/projects/spring1/versions&quot;</code></td>
</tr>
</tbody></table>
<h4 id="1-3-3-Handler-Methods"><a href="#1-3-3-Handler-Methods" class="headerlink" title="1.3.3. Handler Methods"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-methods">1.3.3. Handler Methods</a></h4><p><code>@RequestMapping</code> 处理器方法具有灵活的签名，可以从一系列支持的控制器方法参数和返回值中进行选择。</p>
<h5 id="Method-Arguments"><a href="#Method-Arguments" class="headerlink" title="Method Arguments"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments">Method Arguments</a></h5><table>
<thead>
<tr>
<th>Controller method argument</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>WebRequest</code>,<code>NativeWebRequest</code></td>
<td>无需直接使用 Servlet API，对请求参数、请求属性、会话属性的通用访问</td>
</tr>
<tr>
<td><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td>
<td>选择任何特定的请求或相应类型，例如，<code>ServletRequest</code>, <code>HttpServletRequest</code>, 或者 Spring 的 <code>MultipartRequest</code>, <code>MultipartHttpServletRequest</code></td>
</tr>
<tr>
<td><code>javax.servlet.http.HttpSession</code></td>
<td>强制 Session 必须存在。因此，该参数不可能是 null。注意，Session 访问不是线程安全的。如果允许多个请求可以同时访问会话，考虑设置 <code>RequestMappingHandlerAdapter</code> 实例的 <code>synchronizeOnSession</code> 标志位为 tue</td>
</tr>
<tr>
<td><code>javax.servlet.http.PushBuilder</code></td>
<td></td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td></td>
</tr>
<tr>
<td><code>HttpMethod</code></td>
<td>请求的 HTTP 方法</td>
</tr>
<tr>
<td><code>java.util.Locale</code></td>
<td>当前请求的语言环境，由可用的最准确的 <code>LocaleResolver</code> 决定（配置的 <code>LocaleResolver</code> 或者 <code>LocaleContextResolver</code></td>
</tr>
<tr>
<td><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td>
<td></td>
</tr>
<tr>
<td><code>java.io.InputStream</code>,<code>java.io.Reader</code></td>
<td>通过 Servlet API 访问暴露的原始请求体</td>
</tr>
<tr>
<td><code>java.io.OutputStream</code>,<code>java.io.Writer</code></td>
<td>通过 Servlet API 访问暴露的原始响应体</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>用于访问 URI 模板变量</td>
</tr>
<tr>
<td><code>@MatrixVariable</code></td>
<td></td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>用于访问 Servlet 请求参数，包括 multipart 文件</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>用于访问请求头</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>用于访问 cookie</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>用于访问 HTTP 请求体</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>@RequestPart</code></td>
<td>用于访问 <code>multipart/form-data</code> 请求中的 part</td>
</tr>
<tr>
<td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td>
<td></td>
</tr>
<tr>
<td><code>RedirectAttributes</code></td>
<td></td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>用于访问模型中的现有属性（如果不存在则实例化），同时应用数据绑定和验证。请参阅 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args"><code>@ModelAttribute</code></a> 以及 Model 和 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder"><code>DataBinder</code></a></td>
</tr>
<tr>
<td><code>Errors</code>,<code>BindingResult</code></td>
<td></td>
</tr>
<tr>
<td><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td>
<td></td>
</tr>
<tr>
<td><code>UriComponentsBuilder</code></td>
<td></td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td></td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td></td>
</tr>
<tr>
<td>Any other argument</td>
<td></td>
</tr>
</tbody></table>
<h5 id="Return-Values"><a href="#Return-Values" class="headerlink" title="Return Values"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types">Return Values</a></h5><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-ann-return-types">WebFlux</a></p>
<p>下表描述了支持的控制器方法返回值。所有返回值也支持响应式类型。</p>
<table>
<thead>
<tr>
<th align="left">Controller method return value</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@ResponseBody</code></td>
<td align="left">返回值通过 <code>HttpMessageConverter</code> 实现类进行转换，并写入 response 中。见 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-responsebody">@ResponseBody</a></td>
</tr>
<tr>
<td align="left"><code>HttpEntity&lt;B&gt;</code>,<code>ResponseEntity&lt;B&gt;</code></td>
<td align="left">指定完整的响应（包括 HTTP 响应头以及响应体），将通过 <code>HttpMessageConverter</code> 实现类转换，并写入响应</td>
</tr>
<tr>
<td align="left"><code>HttpHeaders</code></td>
<td align="left">用于返回一个只有响应头，没有响应体的 response</td>
</tr>
<tr>
<td align="left"><code>String</code></td>
<td align="left">一个视图名，使用 <code>ViewResolver</code> 实现类进行解析，并与隐式 model 一起使用 —— 通过命令对象和 <code>@ModelAttribute</code> 方法确定。handler 方法也可以通过声明一个 <code>Model</code> 参数编程式地丰富 model（见）<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-registration">Explicit Registrations</a></td>
</tr>
<tr>
<td align="left"><code>View</code></td>
<td align="left">与隐式 model一起用于渲染的 <code>View</code> 实例 —— 通过命令对象和 <code>ModelAttribute</code> 方法确定。handler 方法也可以通过声明一个 <code>Model</code> 参数编程式地丰富 model（见）<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-registration">Explicit Registrations</a></td>
</tr>
<tr>
<td align="left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td>
<td align="left">要添加到隐式 model 中的属性，其中视图名称通过一个 <code>RequestToViewNameTranslator</code> 隐式确定</td>
</tr>
<tr>
<td align="left"><code>@ModelAttribute</code></td>
<td align="left">要添加到 model 中的属性，其视图名通过 <code>RequestToViewNameTranslator</code> 隐式确定。<br>请注意，<code>ModelAttribute</code> 是可选的。在此表的末尾，请参见 “Any other return value”。</td>
</tr>
<tr>
<td align="left"><code>ModelAndView</code> object</td>
<td align="left">要使用的视图和model属性，以及可选的响应状态。</td>
</tr>
<tr>
<td align="left"><code>void</code></td>
<td align="left">一个具有 <code>void</code> 返回类型的方法，如果它还具有一个 <code>ServletResponse</code>，一个 <code>OutputStream</code> 参数，或者一个 <code>@ResponseStatus</code> 注解，那么将认为该方法已经完全处理了该响应。如果控制器做出了正数的 <code>ETag</code> 或者 <code>lastModified</code> 时间戳检查，也是如此。<br>如果以上都不正确，则 <code>void</code> 返回值还可以表示 REST 控制器 “没有响应体”，或者对于 HTML 控制器来说表示选择默认的视图名。</td>
</tr>
<tr>
<td align="left"><code>DeferredResult&lt;V&gt;</code></td>
<td align="left">从任何线程中异步地产生前面返回值的任意 —— 例如，由于某些事件或回调。请参阅 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> 和 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-deferredresult"><code>DeferredResult</code></a></td>
</tr>
<tr>
<td align="left"><code>Callable&lt;V&gt;</code></td>
<td align="left">在 Spring MVC 管理的线程中异步产生上述任何返回值。请参阅 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async">Asynchronous Requests</a> 和 <a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-async-callable"><code>Callable</code></a></td>
</tr>
<tr>
<td align="left"><code>ListenableFuture&lt;V&gt;</code>, <code>java.util.concurrent.CompletionStage&lt;V&gt;</code>, <code>java.util.concurrent.CompletableFuture&lt;V&gt;</code></td>
<td align="left">替代 <code>DeferredResult</code>，以方便起见（例如，当底层服务返回它们其中之一）</td>
</tr>
<tr>
<td align="left"><code>ResponseBodyEmitter</code>, <code>SseEmitter</code></td>
<td align="left">使用 <code>HttpMessageConverter</code> 实现类将对象的流异步地散发出去</td>
</tr>
<tr>
<td align="left"><code>StreamingResponseBody</code></td>
<td align="left">异步的写入 <code>OutputStream</code></td>
</tr>
<tr>
<td align="left">反应性类型 —— Reactor, RxJava, 或者通过 <code>ReactiveAdapterRegistry</code> 的其他</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Any other return value</td>
<td align="left"></td>
</tr>
</tbody></table>
<h5 id="Type-Conversion"><a href="#Type-Conversion" class="headerlink" title="Type Conversion"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-typeconversion">Type Conversion</a></h5><p>如果 Controller 方法参数声明为 String 以外的其他类型，则某些带有 <code>@RequestParam</code>、<code>@RequestHeader</code>、<code>@PathVariable</code> 等注解的参数可能需要类型转换。</p>
<p>对于上述情况，将根据配置的转换器自动进行类型转换。默认地，支持一些简单的类型，如 <code>int</code>, <code>long</code>, <code>Date</code> 等。也可由通过 <code>WebDataBinder</code> 或者通过使用 <code>FormattingConversionService</code> 注册 <code>Formatters</code> 来自定义类型转换。</p>
<h5 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-method-args">@ModelAttribute</a></h5><p>在方法参数上使用 @ModelAttribute 注解来访问 model 中的属性。model 属性还涵盖来自 HTTP Servlet 请求参数的值，其名称与字段名称匹配，这称为数据绑定，让你不必处理解析和转化单个 query 参数以及 form 字段。以下例子展示了如何做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute</span> Pet pet)</span> &#123;</span><br><span class="line">    <span class="comment">// method logic...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>官方提示</strong> <code>@ModelAttribute</code> 是可选的。默认地，任何非简单类型（由 <code>BeanUtils#isSimpleProperty</code> 决定），且未被任何其他参数解析器解析的参数，都会被当作使用了 <code>@ModelAttribute</code> 注解进行解析。<br><br> 这是因为 <code>HandlerMethodArgumentResolverComposite#argumentResolvers</code>（这是一个 List） 包含了两个 <code>ServletModelAttributeMethodProcessor</code>，一个在中间，一个在最后，不同点在于属性 <code>annotationNotRequired</code>，位于中间的 <code>annotationNotRequired=false</code>，即必须有 <code>@ModelAttribute</code> 注解；位于最后的 <code>annotationNotRequired=true</code>，即没有被 <code>@ModelAttribute</code> 注解，所以，在搜索 Processor 进行处理的过程中，如果一直没有参数解析器可以解析，就会使用最后的 <code>ServletModelAttributeMethodProcessor</code> 进行解析。</p>
</blockquote>
<p><strong>注意点：</strong><br>(1) 对简单参数不进行任何注解，可以认为与 <code>@RequestParam(required = false)</code> 等效，而且如果只是添加了 <code>@RequestParam</code> 注解，缺乏该参数反而会报错。</p>
<p>(2) @ModelAttribute 可以注解在方法上，先于 Controller 方法执行。</p>
<h5 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattributes">@SessionAttributes</a></h5><p><code>@SessionAttributes</code> 用于在请求之间的 HTTP Servlet 会话中存储 model 属性。</p>
<p>这是一个类级别注解，该注解声明指定控制器使用的会话属性。</p>
<p>通常列出了应该透明地存储于 session 中的 model 属性的名称或者 mode 属性的类型，以供后续请求访问。、</p>
<p>以下示例使用 <code>@SessionAttributes</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;pet&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditPetForm</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一次请求中，当具有名称 <code>pet</code> 的 model 属性添加到 Model 时，它会自动升级并保存到 HTTP Servlet Session 中。它会一直存储在那里，直到另一个控制器方法使用 <code>SessionStatus</code> 方法参数去清除存储，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;pet&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditPetForm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/pets/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(Pet pet, BindingResult errors, SessionStatus status)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        status.setComplete(); </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattribute">@SessionAttribute</a></h5><p>如果你需要访问全局管理的预先存在的 session 属性（即，控制器之外，例如，通过过滤器产生），可能存在也可能不存在，你可以在方法参数上使用 <code>@SessionAttribute</code> 注解，正如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(<span class="meta">@SessionAttribute</span> User user)</span> &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于需要添加或者删除会话属性的案例，请考虑注入 <code>org.springframework.web.context.request.WebRequest</code> 或者 <code>javax.servlet.http.HttpSession</code> 到控制器方法。</p>
<p>对于要作为控制器工作流程的一部分在会话中临时存储 model 属性，请考虑使用 <code>@SessionAttributes</code>。</p>
<h5 id="RequestAttribute"><a href="#RequestAttribute" class="headerlink" title="@RequestAttribute"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-requestattrib">@RequestAttribute</a></h5><p>类似于 <code>@SessionAttribute</code>，你可以使用 <code>@RequestAttribute</code> 注解去访问事先已经存在的 Request 属性（例如，通过 <code>Filter</code> 或者 <code>HandlerInterceptor</code> 注入的属性）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(<span class="meta">@RequestAttribute</span> Client client)</span> &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Multipart"><a href="#Multipart" class="headerlink" title="Multipart"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart-forms">Multipart</a></h5><p>启用了 <code>MultipartResolver</code> 之后，使用 <code>multipart/form-data</code> 的 POST 请求内容会被解析并且可以作为一般的请求参数访问。</p>
<blockquote>
<p>Spring Boot 会通过 <code>MultipartAutoConfiguration</code> 自动注入 <code>MultipartResolver</code></p>
</blockquote>
<p>下面的示例访问了一个一般的表单字段以及一个上传的文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/form&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleFormUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            <span class="comment">// store the bytes somewhere</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:uploadSuccess&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:uploadFailure&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将参数类型声明为 <code>List&lt;MultipartFile&gt;</code> 允许解析相同参数名的多个文件。</p>
<p>当 <code>@RequestParam</code> 没有指定注解参数名，且被声明为 <code>Map&lt;String, MultipartFile&gt;</code> 或者 <code>MultiValueMap&lt;String, MultipartFile&gt;</code>，，那么对于每个给定参数名的 multipart 文件都会填充到 map 中。</p>
<blockquote>
<p><strong>作者的话</strong> 这种用法请勿设置参数名，否则会发生转化错误；而且这种用法无法收集多个相同参数名的 multipart 文件。</p>
</blockquote>
<blockquote>
<p><strong>官方</strong> 如果使用了 Servlet 3.0 multipart 解析，你还可以声明 <code>javax.servlet.http.Part</code> 作为方法参数或者集合的 Value 类型，以取代 Spring 的 <code>MultipartFile</code></p>
</blockquote>
<p>你还可以将 multipart 内容作为绑定到命令对象的数据的一部分。例如，前面示例中的表单字段和文件可以是表单对象上的字段，如下示例所示：</p>
<blockquote>
<p><strong>作者的话</strong> 命令对象：command object，可以理解为复合对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyForm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MultipartFile file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/form&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleFormUpload</span><span class="params">(MyForm form, BindingResult errors)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!form.getFile().isEmpty()) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = form.getFile().getBytes();</span><br><span class="line">            <span class="comment">// store the bytes somewhere</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:uploadSuccess&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:uploadFailure&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 RESTful 服务方案中，也可以从非浏览器的客户端提交 multipart 请求。如下示例展示了一个带有 JSON 的文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POST /someUrl</span><br><span class="line">Content-Type: multipart/mixed</span><br><span class="line"></span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;meta-data&quot;</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;value&quot;</span><br><span class="line">&#125;</span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;file-data&quot;; filename=&quot;file.properties&quot;</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">... File Data ...</span><br></pre></td></tr></table></figure>

<p>你可以用 <code>@RequestParam</code> 以 <code>String</code>  的方式访问 “meta-data” 部分，但是有可能你想将他从 JSON 反序列化（类似于 <code>@RequestBody</code>）。使用 <code>@RequestPart</code> 注解可以访问被 <code>HttpMessageConverter</code> 转换之后的 multipart：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(<span class="meta">@RequestPart(&quot;meta-data&quot;)</span> MetaData metadata,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestPart(&quot;file-data&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 这种情况下需要特殊设置某个文件的 Content-Type 为 application&#x2F;json</p>
</blockquote>
<h4 id="1-3-4-Model"><a href="#1-3-4-Model" class="headerlink" title="1.3.4. Model"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-methods">1.3.4. Model</a></h4><p>你可以使用 <code>@ModelAttribute</code> 注解：</p>
<ul>
<li><p><code>@RequestMapping</code> 方法上的一个方法参数上，用于创建或者访问一个来自 model 的 <code>Object</code>，并通过 <code>WebDataBinder</code> 将它绑定到请求</p>
</li>
<li><p>作为 <code>@Controller</code> 或者 <code>@ControllerAdvice</code> 类中方法级注解，帮助在任何 <code>@RequestMapping</code> 方法调用之前初始化 model</p>
</li>
<li><p>用于 <code>@RequestMapping</code> 方法，标记其返回值是 model 属性</p>
</li>
</ul>
<p>本节讨论 <code>@ModelAttribute</code> 方法，前面列表中的第 2 项。一个控制器可以有任意数量的 <code>@ModelAttribute</code> 方法。在同一个控制器的 <code>@RequestMapping</code> 方法之前，所有此类的方法都会被调用。<code>@ModelAttribute</code> 方法也可以通过 <code>@ControllerAdvice</code> 在控制器之间共享。详见…</p>
<p><code>@ModelAttribute</code> 具有灵活的方法签名。他们支持许多与 <code>@RequestMapping</code> 方法相同的参数，除了 <code>@ModelAttribute</code> 本身，或者与请求体相关的任何内容。</p>
<p>以下示例展示了 <code>@ModelAttribute</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateModel</span><span class="params">(<span class="meta">@RequestParam</span> String number, Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(accountRepository.findAccount(number));</span><br><span class="line">    <span class="comment">// add more ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例添加了仅仅 1 个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">addAccount</span><span class="params">(<span class="meta">@RequestParam</span> String number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> accountRepository.findAccount(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看也可以在 <code>@RequestMapping</code> 方法上使用 <code>@ModelAttribute</code> 作为方法级注解，在这种情况下，<code>@RequestMapping</code> 方法的返回值会被解释为 model 属性。这通常不需要，因为这是 HTML 控制器的默认行为，除非返回值是 <code>String</code>，会被解释成视图名字。<code>@ModelAttribute</code> 也可以自定义 model 属性名，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ModelAttribute(&quot;myAccount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-DataBinder"><a href="#1-3-5-DataBinder" class="headerlink" title="1.3.5. DataBinder"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder">1.3.5. DataBinder</a></h4><p><code>@Controller</code> 和 <code>@ControllerAdvice</code> 类可以具有 <code>@InitBinder</code> 方法，用来初始化 <code>WebDataBinder</code> 实例，而这些方法又可以：</p>
<ul>
<li>绑定请求参数（即，Form 或者 Query 数据）到 model 对象</li>
<li>将基于字符串的请求值（例如请求参数，路径变量，请求头，cookie等）转换为控制器方法参数的目标类型</li>
<li>当渲染 HTML 形式时，将 model 对象值以 <code>String</code> 值格式化</li>
</ul>
<blockquote>
<p>tips: 也就是说 WebDataBinder 不仅控制 Controller 入参，也控制出参。</p>
</blockquote>
<p><code>@InitBinder</code> 方法可以注册特定于控制器的 <code>java.bean.PropertyEditor</code> 或者 Spring <code>Converter</code> 以及 <code>Formatter</code> 组件。此外，你也可以使用 MVC Config 在全局共享的 <code>FormattingConversionService</code> 注册 <code>Converter</code> 以及 <code>Formatter</code>。</p>
<p><code>@InitBinder</code> 方法支持许多跟 <code>@RequestMapping</code> 一样支持的参数，除了 <code>@ModelAttribute</code> （command object）参数。通常，这些方法以一个 <code>WebDataBinder</code> 参数（用于注册）声明，并返回一个 <code>void</code>。下面展示了一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        dateFormat.setLenient(<span class="literal">false</span>);</span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> <span class="title class_">CustomDateEditor</span>(dateFormat, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，当你通过共享的 <code>FormattingConversionService</code> 使用基于 <code>Formatter</code> 的设置时，你可以再使用相同的方式注册特定于控制器的 <code>Formatter</code> 实现，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">        binder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">DateFormatter</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-6-Exceptions"><a href="#1-3-6-Exceptions" class="headerlink" title="1.3.6. Exceptions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler">1.3.6. Exceptions</a></h4><p><code>@Controller</code> 和 <code>@ControllerAdvice</code> 类可以拥有 <code>@ExceptionHandler</code> 方法来处理来自控制器方法的异常，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handle</span><span class="params">(IOException ex)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中，异常可能与顶级异常（top-level）相匹配（即，直接抛出的 <code>IOException</code>），或者与在顶级包装器异常的直接 cause 相匹配（例如，<code>IOException</code> 被包裹在 <code>IllegalStateException</code>）。</p>
<blockquote>
<p><strong>作者的话</strong> 顶级异常（top-level）可以理解为最外层异常，通常是一个模糊异常，并不具体，另外异常有一个 cause，通常表示具体异常，这里也可以匹配到进行处理。</p>
</blockquote>
<p>对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根异常匹配通常比 cause 异常匹配优先级更高。更具体地，使用 <code>ExceptionDepthComparator</code> 基于异常类型的深度来对异常进行排序。</p>
<p>另外，注解声明可能会缩小匹配的异常类型范围，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handle</span><span class="params">(IOException ex)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你甚至可以使用特定的异常类型数组，以及一个非常通用的参数签名，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handle</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根异常匹配和 cause 异常匹配可能令人觉得很惊讶。<br>在前面展示的 <code>IOException</code> 变量中，该方法通常以实际的 <code>FileSystemException</code> 或者 <code>RemoteException</code> 实例作为参数，因为它们两个都从 <code>IOException</code> 继承。但是，如果在包装器异常中的任何这样的相匹配的异常被传播出来，它们本身也是一个 <code>IOException</code>，则传递的异常实例是包装器异常。<br><strong>作者的话</strong> 也就是需要通过 <code>ex.getCause()</code> 才能拿到具体异常<br>这种行为在 <code>handle(Exception)</code> 变量中更简单。在包装方案下，总是以包装器异常调用异常处理方法，在这种情况下，通过 <code>ex.getCause()</code> 找到实际匹配的异常。仅当作为顶级异常抛出的时候，传递的异常才是实际的 <code>FileSystemException</code> 或者 <code>RemoteException</code>。<br><strong>作者的话</strong> 不过，你调用 <code>ex.getCause()</code> 拿到的也是具体异常，因为 <code>this.cause=this</code></p>
</blockquote>
<p>我们通常建议你在参数签名中尽可能具体，可以降低 root 异常类型和 cause 异常类型之间不匹配的可能性。考虑将多匹配方法分解为单个 <code>@ExceptionHandler</code> 方法，每个方法都通过其签名匹配单个特定异常类型。</p>
<blockquote>
<p><strong>作者的话</strong> 官方就是建议你将每个具体的异常都写一个 <code>@ExceptionHandler</code></p>
</blockquote>
<p>在多个 <code>@ControllerAdvice</code> 安排下，建议你在 <code>@ControllerAdvice</code> 上声明你的主要 root 异常映射，该映射使用相关的 order 优先使用。虽然 root 异常匹配优先于 cause，但是这是在给定的 <code>@Controller</code> 或者 <code>@ControllerAdvice</code> 类方法中定义。这意味着，在较高优先级 <code>@ControllerAdvice</code> bean 上的 cause 匹配优先于任何较低级的 <code>@ControllerAdvice</code> bean。</p>
<h5 id="Method-Arguments-1"><a href="#Method-Arguments-1" class="headerlink" title="Method Arguments"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler-args">Method Arguments</a></h5><p><code>@ExceptionHandler</code> 方法支持以下参数：</p>
<table>
<thead>
<tr>
<th>方法参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="Return-Values-1"><a href="#Return-Values-1" class="headerlink" title="Return Values"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler-return-values">Return Values</a></h5><h4 id="1-3-7-Controller-Advice"><a href="#1-3-7-Controller-Advice" class="headerlink" title="1.3.7. Controller Advice"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice">1.3.7. Controller Advice</a></h4><p>通常，<code>@ExceptionHandler</code>，<code>@InitBinder</code>，以及 <code>@ModelAttribute</code> 方法应用于 <code>@Controller</code> 类（或者类继承层次），将这些注解声明在里面。如果你希望这样的方法在全局范围内更多地应用（跨控制器），则可以在 <code>@ControllerAdvice</code> 或者 <code>@RestControllerAdvice</code> 注解类中声明它们。</p>
<p><code>@ControllerAdvice</code> 使用 <code>@Component</code> 注解，这意味着这样的类可以通过组件扫描（component scanning）注册为 Spring bean。<code>@RestControllerAdvice</code> 是一个由 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code> 注解的组合注解，本质上意味着，<code>@ExceptionHandler</code> 方法是通过消息转换（以及视图解析或者模板解析）渲染到响应体的。</p>
<p>在启动时，用于 <code>@RequestMapping</code> 和 <code>@ExceptionHandler</code> 方法的基础设施类会检测注解有 <code>@ControllerAdvice</code> 的 Spring bean，然后在运行时应用它们的方法。 全局的 <code>@ExceptionHandler</code> 方法（来自 <code>@ControllerAdvice</code>）应用于本地方法之后（来自 <code>@Controller</code>）。相比之下，全局的 <code>@ModelAttribute</code> 和 <code>@InitBinder</code> 方法应用于本地方法之前。</p>
<p>默认地，<code>ControllerAdvice</code> 方法应用于每个请求（即，所有控制器），但是你可以通过注解上的属性，将其缩小到控制器的子集，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Target all Controllers annotated with @RestController</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = RestController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleAdvice1</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers within specific packages</span></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;org.example.controllers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleAdvice2</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers assignable to specific classes</span></span><br><span class="line"><span class="meta">@ControllerAdvice(assignableTypes = &#123;ControllerInterface.class, AbstractController.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleAdvice3</span> &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>全局异常处理 @RestControllerAdvice</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">	<span class="meta">@ExceptionHandler(value = AuthenticationException.class)</span></span><br><span class="line">	<span class="keyword">public</span> ResponseDTO <span class="title function_">AuthenticationExceptionHandler</span><span class="params">(AuthenticationException e)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ResponseDTO.failure(e.getMessage());	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*** ControllerAdvice 处理 Filter 抛出的异常</p>
<p>类比，Sturts 拦截器组，第一个就是 exception 拦截器。本质上是借助过滤器栈，将异常处理的过滤器放在第一个位置。</p>
<p>定义 ExceptionFilter，将捕捉的异常交给异常处理的 Controller。其他的过滤器不用处理异常，直接 throw 即可。<br>请务必调用 setOrder 方法，保持 order 值最大，这样过滤就能排在第一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(Integer.MIN_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionFilter</span> <span class="keyword">extends</span> <span class="title class_">HttpFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            request.setAttribute(<span class="string">&quot;ioException&quot;</span>, e);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/error&quot;</span>).forward(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            request.setAttribute(<span class="string">&quot;servletException&quot;</span>, e);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/error&quot;</span>).forward(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义抛出异常的 Mapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/error&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseVO <span class="title function_">throwException</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">throw</span> (Exception) request.getAttribute(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-4-Functional-Endpoints"><a href="#1-4-Functional-Endpoints" class="headerlink" title="1.4. Functional Endpoints"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn">1.4. Functional Endpoints</a></h3><h4 id="1-4-1-Overview"><a href="#1-4-1-Overview" class="headerlink" title="1.4.1. Overview"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-overview">1.4.1. Overview</a></h4><p>在 WebMvc.fn 中，使用 <code>HandlerFunction</code> 处理 HTTP 请求：这是一个接受 <code>ServerRequest</code> 并返回 <code>ServerResponse</code> 的函数。请求和响应都有固定的约定，提供了 JDK8 友好的 HTTP 请求和响应访问。<code>HandlerFunction</code> 等价于基于注解的编程模型中的 <code>@RequestMapping</code> 方法体。</p>
<p>传入的请求会使用 <code>RouterFunction</code> 路由到一个 handler function：这是一个接收 <code>ServerRequest</code> 并返回 一个 Optional 包裹的 <code>HandlerFunction</code>（<code>Optional&lt;HandlerFunction&gt;</code>） 的函数。当路由器函数匹配到时，就会返回一个 handler function；否则是一个空的 Optional。<code>RouterFunction</code> 等价于 <code>@RequestMapping</code> 注解，但有一个主要的区别，路由函数不仅仅提供数据，还提供行为。</p>
<p><code>RouterFunctions.route()</code> 提供了一个路由器构建器，可以比较容易地创建路由器，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.servlet.function.RequestPredicates.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.servlet.function.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line"><span class="type">PersonRepository</span> <span class="variable">repository</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">PersonHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonHandler</span>(repository);</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .GET(<span class="string">&quot;/person/&#123;id&#125;&quot;</span>, accept(APPLICATION_JSON), handler::getPerson)</span><br><span class="line">    .GET(<span class="string">&quot;/person&quot;</span>, accept(APPLICATION_JSON), handler::listPeople)</span><br><span class="line">    .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">listPeople</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">createPerson</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">getPerson</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 上述代码不符合 Java 语法规范，只是作为一种示例参考，具体注入路由器需要使用 bean 注入</p>
</blockquote>
<p>如果将 <code>RouterFunction</code> 注册为 bean，例如在 <code>@Configuration</code> 类中暴露它，它会被 servlet 自动检测，如 Running a Server 所述。</p>
<h4 id="1-4-2-HandlerFunction"><a href="#1-4-2-HandlerFunction" class="headerlink" title="1.4.2. HandlerFunction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-handler-functions">1.4.2. HandlerFunction</a></h4><p><code>ServerRequest</code> 和 <code>ServerResponse</code> 是不可变接口，可提供 JDK8 友好访问 HTTP 请求和响应，包括 headers，body，method，status code。</p>
<h5 id="ServerRequest"><a href="#ServerRequest" class="headerlink" title="ServerRequest"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-request">ServerRequest</a></h5><p><code>ServerRequest</code> 提供了对 HTTP method，URI，Headers，Query Parameters，而通过 <code>body</code> 方法访问 Body。</p>
<p>以下示例将请求体提取为一个 <code>String</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> request.body(String.class);</span><br></pre></td></tr></table></figure>


<p>以下示例将 Body 提取为一个 <code>List&lt;Person&gt;</code>，其中 <code>Person</code> 对象是从 JSON 或者 XML 此类的序列化形式解吗得到的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; people = request.body(<span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;Person&gt;&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>以下示例展示了如何访问参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MultiValueMap&lt;String, String&gt; params = request.params();</span><br></pre></td></tr></table></figure>

<h5 id="ServerResponse"><a href="#ServerResponse" class="headerlink" title="ServerResponse"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-response">ServerResponse</a></h5><p><code>ServerResponse</code> 提供了对 HTTP response 的访问，并且由于它是不变的，因此你可以使用一个 <code>build</code> 方法来创建它。你可以通过构建器设置响应状态，添加响应头，或者提供响应体。以下示例创建了一个具有 JSON 内容的 200（OK）响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> ...</span><br><span class="line">ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);</span><br></pre></td></tr></table></figure>

<p>以下示例展示了如何使用 <code>Location</code> 头以及无响应体构建一个 201（CREATED）响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URI</span> <span class="variable">location</span> <span class="operator">=</span> ...</span><br><span class="line">ServerResponse.created(location).build();</span><br></pre></td></tr></table></figure>

<h5 id="Handler-Classes"><a href="#Handler-Classes" class="headerlink" title="Handler Classes"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-handler-classes">Handler Classes</a></h5><p>我可以用 lambda 方式书写一个 handler 函数，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandlerFunction&lt;ServerResponse&gt; helloWorld =</span><br><span class="line">  request -&gt; ServerResponse.ok().body(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这很方便，但是在应用程序中我们需要多个函数，并且多个内联的 lambda 可能变得混乱。因此 ，将相关的 handler 函数一起分组到一个 handler 类是很有用的，这与基于注解的应用中，具有跟 <code>@Controller</code> 相似的角色。举个例子，下面的类暴露了响应式 <code>Person</code> 仓库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.ServerResponse.ok;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonHandler</span><span class="params">(PersonRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">listPeople</span><span class="params">(ServerRequest request)</span> &#123; </span><br><span class="line">        List&lt;Person&gt; people = repository.allPeople();</span><br><span class="line">        <span class="keyword">return</span> ok().contentType(APPLICATION_JSON).body(people);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">createPerson</span><span class="params">(ServerRequest request)</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> request.body(Person.class);</span><br><span class="line">        repository.savePerson(person);</span><br><span class="line">        <span class="keyword">return</span> ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">getPerson</span><span class="params">(ServerRequest request)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">personId</span> <span class="operator">=</span> Integer.parseInt(request.pathVariable(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> repository.getPerson(personId);</span><br><span class="line">        <span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ok().contentType(APPLICATION_JSON).body(person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.notFound().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-3-RouterFunction"><a href="#1-4-3-RouterFunction" class="headerlink" title="1.4.3. RouterFunction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-router-functions">1.4.3. RouterFunction</a></h4><p>路由器函数用于将请求路由到相关的 <code>HandlerFunction</code>。通常你不用自己编写路由器函数，而是使用 <code>RouterFunctions</code> 工具类上的一个方法创建它。<code>RouterFunctions.route()</code> （无参）为你提供了一个流利的构建器用于创建路由器函数，而 <code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code> 提供了一个直接创建路由器的方法。</p>
<h4 id="1-4-4-Running-a-Server"><a href="#1-4-4-Running-a-Server" class="headerlink" title="1.4.4. Running a Server"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-running">1.4.4. Running a Server</a></h4><p>通常，你可以通过 MVC Config 在基于 <code>DispatcherHandler</code> 的设置中运行路由函数，这种设置使用 Spring Configuration 声明处理请求所需的组件。MVC Java 配置声明了以下的一些基础设施组件用以支持功能性端点：</p>
<ul>
<li>RouterFunctionMapping</li>
<li>HandlerFunctionAdapter</li>
</ul>
<p>前面的组件使功能性端点兼容到 <code>DispatcherServlet</code> 请求处理生命周期里，并且（可能）与注解控制器并行，如果有任何声明。这也是 Spring Boot Web starter 启用功能性端点的方式。</p>
<p>以下示例展示了 WebFlux Java 配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;?&gt; routerFunctionA() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;?&gt; routerFunctionB() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="comment">// configure message conversion...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// configure CORS...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// configure view resolution for HTML rendering...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-5-Filtering-Handler-Functions"><a href="#1-4-5-Filtering-Handler-Functions" class="headerlink" title="1.4.5. Filtering Handler Functions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-handler-filter-function">1.4.5. Filtering Handler Functions</a></h4><p>你可以在路由函数构建器使用 <code>before</code>，<code>after</code> 或者 <code>filter</code> 方法来过滤 handler 函数。使用注解，你可以通过使用 <code>@ControllerAdvice</code>，<code>ServletFilter</code> 或者两者都用，实现类似的功能。过滤将会应用到构建器构建的路由中。这意味着在嵌套路由中定义的过滤其不适用于顶级路由。例如，考虑如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .path(<span class="string">&quot;/person&quot;</span>, b1 -&gt; b1</span><br><span class="line">        .nest(accept(APPLICATION_JSON), b2 -&gt; b2</span><br><span class="line">            .GET(<span class="string">&quot;/&#123;id&#125;&quot;</span>, handler::getPerson)</span><br><span class="line">            .GET(<span class="string">&quot;&quot;</span>, handler::listPeople)</span><br><span class="line">            .before(request -&gt; ServerRequest.from(request) </span><br><span class="line">                .header(<span class="string">&quot;X-RequestHeader&quot;</span>, <span class="string">&quot;Value&quot;</span>)</span><br><span class="line">                .build()))</span><br><span class="line">        .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson))</span><br><span class="line">    .after((request, response) -&gt; logResponse(response)) </span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h3 id="1-5-URI-Links"><a href="#1-5-URI-Links" class="headerlink" title="1.5. URI Links"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-uri-building">1.5. URI Links</a></h3><h4 id="1-5-1-UriComponents"><a href="#1-5-1-UriComponents" class="headerlink" title="1.5.1. UriComponents"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#web-uricomponents">1.5.1. UriComponents</a></h4><p><code>UriComponentBuilder</code> 有助于从带有变量的 URI 模板中构建 URI。如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UriComponents</span> <span class="variable">uriComponents</span> <span class="operator">=</span> UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;https://example.com/hotels/&#123;hotel&#125;&quot;</span>)  </span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)  </span><br><span class="line">        .encode() </span><br><span class="line">        .build(); </span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> uriComponents.expand(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>).toUri();  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>前面的示例可以合并到一个链中，并使用 <code>buildAndExpand</code> 缩短，如下示例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;https://example.com/hotels/&#123;hotel&#125;&quot;</span>)</span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)</span><br><span class="line">        .encode()</span><br><span class="line">        .buildAndExpand(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .toUri();</span><br></pre></td></tr></table></figure>

<p>你可以直接进入 URI（表示编码）进一步缩短，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;https://example.com/hotels/&#123;hotel&#125;&quot;</span>)</span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)</span><br><span class="line">        .build(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>你可以使用完整的 URI 模板进一步缩短，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;https://example.com/hotels/&#123;hotel&#125;?q=&#123;q&#125;&quot;</span>)</span><br><span class="line">        .build(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-UriBuilder"><a href="#1-5-2-UriBuilder" class="headerlink" title="1.5.2. UriBuilder"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#web-uribuilder">1.5.2. UriBuilder</a></h4><h3 id="1-6-Asynchronous-Requests"><a href="#1-6-Asynchronous-Requests" class="headerlink" title="1.6. Asynchronous Requests"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-async">1.6. Asynchronous Requests</a></h3><p>Spring MVC 集成了 Servlet 3.0 异步请求处理：</p>
<ul>
<li>在控制器方法中，<code>DeferredResult</code> 和 <code>Callable</code> 返回值，并为单个异步返回值提供了基本支持。</li>
<li>控制器可以流传输多个值，包括 SSE 和 原始数据</li>
<li>控制器可以使用 reactive 客户端，并为响应处理返回 reactive types</li>
</ul>
<h4 id="1-6-1-DeferredResult"><a href="#1-6-1-DeferredResult" class="headerlink" title="1.6.1. DeferredResult"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-async-deferredresult">1.6.1. DeferredResult</a></h4><p>一旦在 Servlet 容器中启用了异步处理功能，控制器方法就可以用 <code>DeferredResult</code> 包装任何支持的控制器方法的返回值，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/quotes&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title function_">quotes</span><span class="params">()</span> &#123;</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Save the deferredResult somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// From some other thread...</span></span><br><span class="line">deferredResult.setResult(result);</span><br></pre></td></tr></table></figure>


<h4 id="1-6-3-Processing"><a href="#1-6-3-Processing" class="headerlink" title="1.6.3. Processing"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-async-processing">1.6.3. Processing</a></h4><p>这是 Servlet 异步请求处理非常简洁的概述：</p>
<ul>
<li><p>通过调用 <code>request.startAsync()</code>，<code>ServletRequest</code> 可以放到异步模型中。这样做的主要影响就是，Servlet（以及任何过滤器）可以退出，但是响应会一直打开用于后面处理完成。</p>
</li>
<li><p>调用 <code>request.startAsync()</code> 会返回 <code>AsyncContext</code>，你可以用它来对异步处理做进一步控制。例如，它提供了 <code>dispatch</code> 方法，该方法类似于 Servlet API 的 forward，除了它可以让应用程序在 Servlet 容器线程上恢复请求处理。</p>
</li>
<li><p><code>ServletRequest</code> 提供了对当前 <code>DispatcherType</code> 的访问，你可以用它区别处理初始化请求，异步调度，forward，以及其他调度类型。</p>
</li>
</ul>
<p><code>DeferredResult</code> 处理工作如下：</p>
<ul>
<li><p>控制器返回一个 <code>DeferredResult</code>，并将其保存到一些内存中的可访问的队列或者列表中。</p>
</li>
<li><p>Spring MVC 调用 <code>request.startAsync()</code></p>
</li>
<li><p>同时，<code>DispatcherServlet</code> 以及所有配置的过滤器都退出请求处理线程，但 response 仍然保持打开</p>
</li>
<li><p>应用程序从某个线程设置 <code>DeferredResult</code>，然后 Spring MVC 将请求调度回 Servlet 容器。</p>
</li>
<li><p>再次调用 <code>DispatcherServlet</code>，并以异步产生的返回值进行处理。</p>
</li>
</ul>
<h3 id="1-7-CORS"><a href="#1-7-CORS" class="headerlink" title="1.7. CORS"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors">1.7. CORS</a></h3><p>参考链接：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></p>
<h4 id="1-7-1-Introduction"><a href="#1-7-1-Introduction" class="headerlink" title="1.7.1. Introduction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-intro">1.7.1. Introduction</a></h4><p>出于安全原因，浏览器禁止 AJAX 调用当前源之外的资源。举个例子，你可以将你的银行账户放在一个标签中，而 evil.com 在另一个标签中。来自 evil.com 的脚本不应通过你的凭据向你的银行 API 发出 AJAX 请求，例如从你的账户提取资金。</p>
<p>跨域资源共享是 W3C 的规范，大多数浏览器都实现了这种规范，可以让你指定哪种类型的跨域请求已获得授权，而不是使用基于 IFRAME 或者 JSONP 的不太安全且不太强大的解决方案。</p>
<h4 id="1-7-2-Processing"><a href="#1-7-2-Processing" class="headerlink" title="1.7.2. Processing"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-processing">1.7.2. Processing</a></h4><p>CORS 规范区分预请求、简单请求、实际请求。想要学习更多 CORS，参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">这篇文章</a></p>
<p>Spring MVC <code>HandlerMapping</code> 实现类提供了内置的对 CORS 的支持。在成功将请求映射到一个 handler 之后，<code>HandlerMapping</code> 实现类就会检查给定请求以及 handler 的 CORS 配置，然后采取更进一步的措施。预请求直接处理，但是，简单请求和实际的 CORS 请求会被拦截，校验，并设置需要的 CORS 响应头。</p>
<p>为了启用跨域请求，你需要有一个显式的 CORS 配置。如果找不到合适的 CORS 配置，就会拒绝预请求。如果没有添加 CORS 头部到简单请求、实际 CORS 请求响应中，那么，浏览器就会拒绝它们。</p>
<blockquote>
<p><strong>作者的话</strong> 可能有人会认为跨域是浏览器无法发起请求，其实不是，只是拒绝接收 response。</p>
</blockquote>
<p>每个 <code>HandlerMapping</code> 都可以单独地配置基于模式的 URL <code>CorsConfiguration</code> 映射。在大多数情况下，应用使用 MVC Java 配置或者 XML 命名空间去声明映射，不过这会导致一个传递给所有 <code>HandlerMapping</code> 实例的全局映射。</p>
<p>你可以将位于 <code>HandlerMapping</code> 级别的全局 CORS 配置与更加细粒度的 handler 级别的 CORS 配置相结合。举个例子，注解式 Controller 可以使用类级别或者方法级别的 <code>@CrossOrigin</code> 注解（其他 handler 可以实现 <code>CorsConfigurationSource</code>）</p>
<h4 id="1-7-3-CrossOrigin"><a href="#1-7-3-CrossOrigin" class="headerlink" title="1.7.3. @CrossOrigin"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-controller">1.7.3. @CrossOrigin</a></h4><p><code>@CrossOrigin</code> 注解在注解式控制器的方法上，可以启用跨域请求，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认地，@CrossOrigin 允许：</p>
<ul>
<li>所有 origin</li>
<li>所有 header</li>
<li>所有 HTTP 方法</li>
</ul>
<p>默认情况下，<code>allowedCredentials</code> 不启用，因为那会建立一个信任级别，会暴露敏感的用户特定的信息（例如 cookie 和 CSRF 令牌），应该只能在适当的情况下使用。</p>
<p>@CrossOrigin 可以用于：</p>
<ul>
<li>Controller 的方法，开启 Controller 方法级别的跨域请求</li>
<li>Controller 类，由所有方法继承</li>
</ul>
<p>maxAge 默认 30 分钟</p>
<p><code>@CrossOrigin</code> 也支持类级别，这会被所有方法继承，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;https://domain2.com&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在类级别和方法级别上同时使用 <code>@CrossOrigin</code>，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin(&quot;https://domain2.com&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-7-4-Global-Configuration"><a href="#1-7-4-Global-Configuration" class="headerlink" title="1.7.4. Global Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-global">1.7.4. Global Configuration</a></h4><p>除了细粒度的控制外，也可以通过实现 <code>WebMvcConfigurer.addCorsMappings</code> 定义全局 CORS 配置，参考代码见官网。</p>
<p>具体原理可见 <code>DefaultCorsProcessor</code>。</p>
<h4 id="1-7-5-CORS-Filter"><a href="#1-7-5-CORS-Filter" class="headerlink" title="1.7.5. CORS Filter"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-filter">1.7.5. CORS Filter</a></h4><p>可以通过内置的 CorsFilter 增加 CORS 支持。</p>
<h3 id="1-8-Web-Security"><a href="#1-8-Web-Security" class="headerlink" title="1.8. Web Security"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-web-security">1.8. Web Security</a></h3><p>Spring Security 工程为保护 web 应用免受恶意漏洞提供了支持。清参阅 Spring Security 参考文档，包括：</p>
<ul>
<li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc">Spring MVC Security</a></li>
<li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-mockmvc">Spring MVC Test Support</a></li>
<li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF protection</a></li>
<li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">Security Response Headers</a></li>
</ul>
<h3 id="1-9-HTTP-Caching"><a href="#1-9-HTTP-Caching" class="headerlink" title="1.9. HTTP Caching"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-caching">1.9. HTTP Caching</a></h3><h3 id="1-10-View-Technologies"><a href="#1-10-View-Technologies" class="headerlink" title="1.10. View Technologies"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-view">1.10. View Technologies</a></h3><p>在 Spring MVC 中使用视图技术是可拔插的，无论你决定使用 Thymeleaf，Groovy Markup Templates，JSP，或者其他技术，主要都是配置更改的问题。本章覆盖了与 Spring MVC 集成的视图技术。我们假设你已经熟悉 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-viewresolver">View Resolution</a>。</p>
<h4 id="1-10-1-Thymeleaf"><a href="#1-10-1-Thymeleaf" class="headerlink" title="1.10.1. Thymeleaf"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-view-thymeleaf">1.10.1. Thymeleaf</a></h4><p>Thymeleaf 是一个现代的服务端 Java 模板引擎，强调可以通过双击在浏览器中预览的天然 HTML 模板，这对于独立工作于 UI 模板（例如，通过设计师）非常有帮助，无需运行在服务器。如果你想替换 JSP，则 Thymeleaf 提供了最广泛的功能集之一，以使这种过渡更加容易。Thymeleaf 开发和维护都比较活跃。有关更完整的介绍，请参见 <a href="https://www.thymeleaf.org/">Thymeleaf</a> 项目主页。</p>
<p>Thymeleaf 与 Spring MVC 集成由 Thymeleaf 项目管理。配置涉及了一些 Bean 声明，例如 <code>ServletContextTemplateResolver</code>，<code>SpringTemplateEngine</code>，以及 <code>ThymeleafViewResolver</code>。有关更多项目信息，请参见 <a href="https://www.thymeleaf.org/documentation.html">Thymeleaf+Spring</a>。</p>
<h3 id="1-11-MVC-Config"><a href="#1-11-MVC-Config" class="headerlink" title="1.11. MVC Config"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config">1.11. MVC Config</a></h3><p>MVC Java 配置和 MVC XML 命名空间配置提供了默认的配置，这适合大多数应用程序，如果你觉得不够，也提供了配置 API 供你自定义。</p>
<h4 id="1-11-1-Enable-MVC-Configuration"><a href="#1-11-1-Enable-MVC-Configuration" class="headerlink" title="1.11.1. Enable MVC Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-enable">1.11.1. Enable MVC Configuration</a></h4><p>在 Java 配置中，你可以使用 <code>@EnableMvc</code> 注解来启用 MVC 配置，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> Spring Boot 无需且尽量不要使用 <code>@EnableWebMvc</code>，这会覆盖 Spring Boot 的默认配置。</p>
</blockquote>
<p>在 XML 配置中，你可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素，以启用 MVC 配置，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的示例会注册许多 Spring MVC 的基础 bean，并且适配类路径上的可用依赖（例如，载体转换器，JSON，XML，以及其他什么）</p>
<h4 id="1-11-2-MVC-Config-API"><a href="#1-11-2-MVC-Config-API" class="headerlink" title="1.11.2. MVC Config API"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-customize">1.11.2. MVC Config API</a></h4><p>在 Java 配置中，你可以实现 <code>WebMvcConfigurer</code> 示例，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implement configuration methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 XML 下，你可以检查属性，以及 <code>&lt;mvc:annotation-driven/&gt;</code> 的子元素。你可以浏览 <a href="https://schema.spring.io/mvc/spring-mvc.xsd">Spring MVC XML schema</a> 或者使用 IDE 的代码编译功能，找到那些可用的属性以及子元素。</p>
<h4 id="1-11-3-Type-Conversion"><a href="#1-11-3-Type-Conversion" class="headerlink" title="1.11.3. Type Conversion"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-conversion">1.11.3. Type Conversion</a></h4><p>默认地，Spring MVC 安装了各种数字和日期的格式化器（formatter），并且支持 <code>@NumberFormat</code> 和 <code>@DateTimeFormat</code> 对字段进行自定义。</p>
<p>如果要在 Java 配置中注册自定义的格式化器和转换器，使用以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 其实就是实现 <code>WebMvcConfigurer</code> 的 <code>addFormatters</code> 方法</p>
</blockquote>
<h4 id="1-11-4-Validation"><a href="#1-11-4-Validation" class="headerlink" title="1.11.4. Validation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-validation">1.11.4. Validation</a></h4><p>默认地，如果 Bean Validation 存在于类路径（例如，Hibernate Validator），就会注册一个 <code>LocalValidatorFactoryBean</code> 作为全局的 Validator，供控制器方法参数上的 <code>@Valid</code> 以及 <code>Validated</code> 使用</p>
<blockquote>
<p> <strong>作者的话</strong> 判断是否存在 Bean Validation 框架的方法是注解查找是否存在 <code>javax.validation.Validator</code></p>
</blockquote>
<p>在 Java 配置中，你可以自定义全局 <code>Validator</code> 示例，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Validator <span class="title function_">getValidator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-11-5-Interceptors"><a href="#1-11-5-Interceptors" class="headerlink" title="1.11.5. Interceptors"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-interceptors">1.11.5. Interceptors</a></h4><p>在 Java 配置中，你可以注册拦截器，以应用于收到的请求，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LocaleChangeInterceptor</span>());</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">ThemeChangeInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/admin/**&quot;</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">SecurityInterceptor</span>()).addPathPatterns(<span class="string">&quot;/secure/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-11-6-Content-Types"><a href="#1-11-6-Content-Types" class="headerlink" title="1.11.6. Content Types"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-content-negotiation">1.11.6. Content Types</a></h4><h4 id="1-11-7-Message-Converters"><a href="#1-11-7-Message-Converters" class="headerlink" title="1.11.7. Message Converters"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-message-converters">1.11.7. Message Converters</a></h4><p>你可以通过覆盖 <code>configureMessageConverters()</code>，以 Java 配置的方式自定义 <code>HttpMessageConverter</code>（这会取代 Spring MVC 创建的默认转换器），或者通过覆盖 <code>extendMessageConverters()</code>（这可以自定义默认的转换器或者添加额外的转换器）</p>
<p>以下示例使用自定义的 <code>ObjectMapper</code> 添加了 XML 和 Jackson JSON 转换器，取代默认的转换器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="type">Jackson2ObjectMapperBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2ObjectMapperBuilder</span>()</span><br><span class="line">                .indentOutput(<span class="literal">true</span>)</span><br><span class="line">                .dateFormat(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>))</span><br><span class="line">                .modulesToInstall(<span class="keyword">new</span> <span class="title class_">ParameterNamesModule</span>());</span><br><span class="line">        converters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(builder.build()));</span><br><span class="line">        converters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>(builder.createXmlMapper(<span class="literal">true</span>).build()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-11-10-Static-Resources"><a href="#1-11-10-Static-Resources" class="headerlink" title="1.11.10. Static Resources"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources">1.11.10. Static Resources</a></h4><p>这里提供了一种简便的方法用于提供静态资源服务，是基于 <code>Resource</code> 的位置列表的。</p>
<p>在以下示例中，给定一个以 <code>/resources</code> 开头的请求，相对路径用于查找和提供位于 web 应用的根目录下的 <code>/public</code> 或者类路径 <code>/static</code> 下的静态资源</p>
<p>如果需要以 &#x2F;resources 为前缀，根据其后的相对路径寻找 Web 应用程序根目录下的 &#x2F;public 资源或 类路径 &#x2F;static 下的静态资源，资源设置一年到期，还会评估 Last-Modified 头部，如果存在，返回 304，则可以按如下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>)</span><br><span class="line">            .addResourceLocations(<span class="string">&quot;/public&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>)</span><br><span class="line">            .setCachePeriod(<span class="number">31556926</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>(1) 配置类路径静态资源时，末尾必须有 &#x2F;，不可缺省，否则 404</p>
<h4 id="1-11-11-Default-Servlet"><a href="#1-11-11-Default-Servlet" class="headerlink" title="1.11.11. Default Servlet"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-default-servlet-handler">1.11.11. Default Servlet</a></h4><p>Spring MVC 允许将 DispatcherServlet 映射到 <code>/</code>（因此，这覆盖了容器默认的 Servlet 映射），但是，Spring MVC 仍然允许容器默认的 Servlet 处理静态资源请求。Spring MVC 配置有一个 <code>DefaultServletHttpRequestHandler</code>，使用 <code>/**</code> 的 URL 映射，相对于其他 URL 映射的具有最低优先级（Integer.MAX_VALUE）。</p>
<blockquote>
<p><strong>作者的话</strong> 在 Spring Boot 中，你不启用，是不会将此 <code>HandlerMapping</code> 添加的。并且，启用了也不会发生作用，因为请求会被 <code>SimpleUrlHandlerMapping</code> 中的 <code>/**</code> 匹配到。</p>
</blockquote>
<p>该 handler 将所有请求转发到默认的 Servlet。因此，它必须保持在所有其他 URL <code>HandlerMapping</code> 的最后。如果你使用 <code>mvc:annotation-driven</code>，就是这种情况。另外，如果你设置了自定义的 <code>HandlerMapping</code> 实例，请确保将其 <code>order</code> 属性设置低于 <code>DefaultServletHttpRequestHandler</code>（Integer.MAX_VALUE）</p>
<p>如下示例显示了如何通过使用默认设置启用该功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-11-12-Path-Matching"><a href="#1-11-12-Path-Matching" class="headerlink" title="1.11.12. Path Matching"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-path-matching">1.11.12. Path Matching</a></h4><p>你可以自定义与 URL 的路径匹配和处理有关的可选项。有关各个选项的详细信息，参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> javadoc。</p>
<p>以下示例显示了如何在 Java 配置中自定义路径匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer</span><br><span class="line">            .setUseTrailingSlashMatch(<span class="literal">false</span>)</span><br><span class="line">            .setUseRegisteredSuffixPatternMatch(<span class="literal">true</span>)</span><br><span class="line">            .setPathMatcher(antPathMatcher())</span><br><span class="line">            .setUrlPathHelper(urlPathHelper())</span><br><span class="line">            .addPathPrefix(<span class="string">&quot;/api&quot;</span>, HandlerTypePredicate.forAnnotation(RestController.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UrlPathHelper <span class="title function_">urlPathHelper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PathMatcher <span class="title function_">antPathMatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework Core</title>
    <url>/2022/05/09/Spring-Framework/Spring-Framework-Core/</url>
    <content><![CDATA[<h1 id="Core"><a href="#Core" class="headerlink" title="Core"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#spring-core">Core</a></h1><h2 id="1-The-IoC-Container"><a href="#1-The-IoC-Container" class="headerlink" title="1. The IoC Container"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans">1. The IoC Container</a></h2><p>这一章主要讲述 Spring 的 IoC 容器，也就是 Inversion of Control container。</p>
<h3 id="1-1-Introduction-to-the-Spring-IoC-Container-and-Beans"><a href="#1-1-Introduction-to-the-Spring-IoC-Container-and-Beans" class="headerlink" title="1.1. Introduction to the Spring IoC Container and Beans"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-introduction">1.1. Introduction to the Spring IoC Container and Beans</a></h3><p>本章涵盖了控制反转（IoC）原理的 Spring Framework 实现。IoC 也被称为依赖注入（DI）。依赖注入是这样一个过程，对象定义它们的依赖仅通过构造器参数，工厂方法参数，在对象实例构造完毕或者从工厂方法返回之后设置属性。然后，容器在创建 bean 时注入这些依赖。这个过程通过使用类的直接构造或者例如服务定位器模式的机制，从根本上反转（因此得名控制反转）了 bean 本身控制其依赖的初始化或者定位。</p>
<blockquote>
<p><strong>作者的话</strong> IoC 是 Inversion of Control 的缩写；DI 是 Dependency Injection 的缩写</p>
</blockquote>
<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 是 Spring IoC 容器的基础包。<code>BeanFactory</code> 接口提供了管理任意类型对象的高级配置机制。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，添加了：</p>
<ul>
<li>与 Spring AOP 功能更容易集成</li>
<li>消息资源处理（用于国际化）</li>
<li>事件发布</li>
<li>应用程序层特定上下文，例如用于 Web 应用程序中的 <code>WebApplicationContext</code></li>
</ul>
<p>简而言之，<code>BeanFactory</code> 提供了配置框架和基础功能，并且 <code>ApplicationContext</code> 添加了更多企业特定的功能。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集，仅仅用于本章 Spring IoC 容器的描述。有关使用 <code>BeanFactory</code> 而不是 <code>ApplicationContext</code> 的更多信息，参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beanfactory">The <code>BeanFactory</code></a></p>
<blockquote>
<p>官网中，主要描述的也是 <code>ApplicationContext</code>。</p>
</blockquote>
<p>在 Spring 中，构成应用骨架并由 Spring IoC 容器管理的对象称之为 bean。bean 是由 Spring IoC 容器实例化，组装和管理的对象。一个 bean 只是你应用程序中的众多对象之一。bean 以及其中的依赖项反映在供容器使用的配置元数据中。</p>
<h3 id="1-2-Container-Overview"><a href="#1-2-Container-Overview" class="headerlink" title="1.2. Container Overview"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-basics">1.2. Container Overview</a></h3><p><code>org.springframework.context.ApplicationContext</code> 代表 Spring IoC 容器，负责实例化、配置、组装 bean。通过读取配置元数据，容器获取那些需要实例化、配置、组装的对象的说明。配置元数据表现为 XML，Java 注解，Java 代码。它让你表达出组成你应用的对象，以及这些对象之间丰富的相互依赖性。</p>
<p>Spring 提供了一些 <code>ApplicationContext</code> 接口的实现。在独立应用程序中，通常创建 <code>ClassPathXmlApplicationContext</code> 或者 <code>FileSystemXmlApplicationContext</code> 实例。虽然 XML 一直是一种定义元数据的传统格式，但可以通过提供少量 XML 配置来声明启用其他元数据格式（Java 注解，Java 代码）的支持。它使你可以表达构成你应用程序的对象，以及这些对象之间丰富的相互依赖关系。</p>
<p>Spring 提供了 <code>ApplicationContext	</code> 接口的几种实现。在独立应用程序中，通常创建一个 <code>ClassPathXmlApplicationContext</code> 或者 <code>FileSystemXmlApplicationContext</code>。虽然 XML 是定义配置元数据的传统格式，但是你可以通过提供少量的 XML 配置来声明开启对于这些传统元数据格式的支持，指示容器使用 Java 配置或者代码作为元数据格式。</p>
<p>在大多数应用程序方案中，无需明确的用户代码即可实例化一个或多个 Spring IoC 容器的实例。例如，在 Web 应用程序方案中，应用程序的 <code>web.xml</code> 文件中的样例 web 描述符 XML 简单八行就足够了。如果你使用 Spring Tools for Eclipse，你可以轻松地点几下鼠标或者敲键盘来创建此样板配置。</p>
<p>下图展示了 Spring 工作方式的高级视图。你的应用程序类与配置元数据结合起来，以便于在 <code>ApplicationContext</code> 创建并初始化之后，你可以拥有一个完全配置化的可执行的系统或应用程序。<br><img src="https://img-blog.csdnimg.cn/054c1b5f95d04370b549bd566f4891c7.png" alt="请添加图片描述"></p>
<h4 id="1-2-1-Configuration-Metadata"><a href="#1-2-1-Configuration-Metadata" class="headerlink" title="1.2.1. Configuration Metadata"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-metadata">1.2.1. Configuration Metadata</a></h4><p>如前面图所示，Spring IoC 容器消耗某种形式的配置元数据。配置元数据表现出你如何告诉 Spring 容器去实例化，配置，组装你应用程序中的对象。</p>
<blockquote>
<ul>
<li>组装可以认为是一种依赖注入。</li>
</ul>
</blockquote>
<p>传统上，配置元数据以简单而直观的 XML 格式提供，这是本章用于传达 Spring IoC 容器关键概念和特色的大多数方式。</p>
<blockquote>
<p>基于 XML 的元数据并不是唯一的配置元数据格式。Spring IoC 容器本身与配置元数据实际编写的格式完全分离。如今，许多开发人员选择为他们的 Spring 应用使用基础 Java 的配置</p>
</blockquote>
<p>有关与 Spring 容器一起使用的其他形式的元数据信息，参见：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-annotation-config">Annotation-based configuration</a>: Spring 2.5 引入了基于注解的配置元数据支持</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java">Java-based configuration</a>: 从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多功能称为 Core Spring Framework 的一部分。因此，你可以使用 Java 而不是 XML 文件来定义你应用程序类之外的 bean。要使用这些新功能，见 <code>@Configuration</code>，<code>@Bean</code>，<code>@Import</code>，以及 <code>@DependsOn</code> 注解</li>
</ul>
<p>Spring 配置包含至少一个，且通常不止一个容器必须管理的 bean 定义。基于 XML 的配置元数据将这些 bean 以 <code>&lt;bean/&gt;</code> 元素配置在顶级 <code>&lt;beans/&gt;</code> 元素中。Java 配置通常使用 <code>@Configuration</code> 类中的 <code>@Bean</code> 注解的方法。</p>
<p>以下示例展示了基于 XML 的配置元数据的基本结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>id</code> 属性是标识单个 bean 定义的字符串<br><code>class</code> 属性定义了 bean 的类型，并且使用完全限定类名。</p>
<h4 id="1-2-2-Instantiating-a-Container"><a href="#1-2-2-Instantiating-a-Container" class="headerlink" title="1.2.2. Instantiating a Container"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-instantiation">1.2.2. Instantiating a Container</a></h4><p>提供给 <code>ApplicationContext</code> 构造器的一个或多个位置路径是资源字符串，它使得容器能够从各种外部资源加载配置元数据，例如本地文件系统，Java <code>CLASSPATH</code> 等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Composing-XML-based-Configuration-Metadata"><a href="#Composing-XML-based-Configuration-Metadata" class="headerlink" title="Composing XML-based Configuration Metadata"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-xml-import">Composing XML-based Configuration Metadata</a></h5><p>让 bean 定义涵盖多个 XML 文件可能很有用。通常，每个单独的 XML 配置文件代表你的架构中的一个逻辑层或者模块。</p>
<p>你可以使用 <code>ApplicationContext</code> 构造器从所有这些 XML 片段中加载 bean 定义。该构造器接收多个 <code>Resource</code> 路径，如前一节所示。另外，请使用一个或多个 <code>&lt;import/&gt;</code> 元素从另一个（些）文件中加载 bean 定义。以下示例显示了如何做：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;services.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;resources/messageSource.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;/resources/themeSource.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在前面的例子中，外部 bean 定义是从这三个文件加载的：<code>services.xml</code>，<code>messageSource.xml</code> 以及 <code>themeSource.xml</code>。所有路径均相对于执行 import 的定义文件，因此 <code>services.xml</code> 必须执行 import 的文件在相同的目录或者类路径位置，而 <code>messageSource.xml</code> 和 <code>themesource.xml</code> 必须位于 import 文件位置下的 <code>resources</code> 位置中。如你所见，前导的斜杠被忽略了。但是，鉴于这些路径是相对的，最好不要使用斜杠。依据 Spring Schema，所导入的文件内容，包括顶级 <code>&lt;beans/&gt;</code> 元素，必须是有效的 XML bean 定义。</p>
<blockquote>
<p>使用一个 “..&#x2F;“ 相对路径引用父目录的文件是可以的，但是并不推荐。这样做会产生对当前应用程序之外的文件的依赖。特别地，这种引用对于 <code>classpath:</code> URL（例如，<code>classpath:../services.xml</code>）也不建议，其中运行时解析过程选择 “最近” 的类路径根，然后查看其父目录。类路径配置更改可能导致选择其他的错误的路径。<br>你可以始终使用完全限定资源地址，而不是相对路径：例如，<code>file:C:/config/services.xml</code> 或者 <code>classpath:/config/services.xml</code>。但是，请注意，你将应用程序的配置耦合到特定的绝对路径。通常，最好对这种绝对路径持有一个间接取值 —— 例如，通过在运行时根据 JVM 系统属性解析的占位符 “${…}”</p>
</blockquote>
<p>命名空间本身提供了 import 指令功能。除了普通 bean 定义之外，还可以在 Spring 提供的 XML 命名空间的选择中获得更多配置功能 —— 例如，<code>context</code> 和 <code>util</code> 命名空间。</p>
<h5 id="The-Groovy-Bean-Definition-DSL"><a href="#The-Groovy-Bean-Definition-DSL" class="headerlink" title="The Groovy Bean Definition DSL"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#groovy-bean-definition-dsl">The Groovy Bean Definition DSL</a></h5><p>先省略</p>
<h4 id="1-2-3-Using-the-Container"><a href="#1-2-3-Using-the-Container" class="headerlink" title="1.2.3. Using the Container"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-client">1.2.3. Using the Container</a></h4><p><code>ApplicationContext</code> 是一个高级工厂接口，能够维护各种各样 bean 及其依赖的注册表 。通过使用 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> 方法，你可以检索 你的 bean 实例。</p>
<p><code>ApplicationContext</code> 使你可以读取 bean 定义并访问它们，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>

<p>最灵活的变体形式是 <code>GenericApplicationContext</code> 组合 Reader 委托，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 这种方式避免配置加载与 ApplicationContext 耦合</p>
</blockquote>
<p>然后，你可以使用 <code>getBean</code> 来检索 bean 实例。<code>ApplicationContext</code> 接口还有一些其他的方法用于检索 bean，但是理想情况下，你的应用程序代码绝不应该使用它们。实际上，你的应用程序代码一点都不应该调用 <code>getBean()</code> 方法，因此一点都不依赖于 Spring API。例如，Spring 和 Web 框架的集成，通过元数据声明对 bean 的依赖，进而通过 Web 框架来获取 bean。</p>
<h3 id="1-3-Bean-Overview"><a href="#1-3-Bean-Overview" class="headerlink" title="1.3. Bean Overview"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition">1.3. Bean Overview</a></h3><p>Spring IoC 容器管理一个或多个 bean。这些 bean 是用你提供给容器的配置元数据所创建的（例如，以 XML <code>&lt;bean/&gt;</code> 定义形式）。</p>
<p>在容器之中，这些 Bean Definition 都会以 <code>BeanDefinition</code> 对象形式表现，其中包含（除其他信息）以下元数据：</p>
<ul>
<li>完全限定类名，实际上也就是需要实例化的类</li>
<li>bean 行为配置元素，指示 bean 在容器的行为，例如：scope，生命周期回调 initMethodName、destroyMethodName 等</li>
<li>依赖项（DependsOn）。</li>
<li>设置在新建对象的其他设置（<code>PropertyValues</code>）。比如，池的大小, 连接的数量。</li>
</ul>
<p>该元数据转化为构成每个 Bean Definition 的一组属性。下表描述了这些属性：</p>
<table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">Explained in…​</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Class</td>
<td align="left">Instantiating Beans</td>
</tr>
<tr>
<td align="left">Name</td>
<td align="left">Naming Beans</td>
</tr>
<tr>
<td align="left">Scope</td>
<td align="left">Bean Scopes</td>
</tr>
<tr>
<td align="left">Constructor arguments</td>
<td align="left">Dependency Injection</td>
</tr>
<tr>
<td align="left">Properties</td>
<td align="left">Dependency Injection</td>
</tr>
<tr>
<td align="left">Autowiring mode</td>
<td align="left">Autowiring Collaborators</td>
</tr>
<tr>
<td align="left">Lazy initialization mode</td>
<td align="left">Lazy-initialized Beans</td>
</tr>
<tr>
<td align="left">Initialization method</td>
<td align="left">Initialization Callbacks</td>
</tr>
<tr>
<td align="left">Destruction method</td>
<td align="left">Destruction Callbacks</td>
</tr>
</tbody></table>
<h4 id="1-3-1-Naming-Beans"><a href="#1-3-1-Naming-Beans" class="headerlink" title="1.3.1. Naming Beans"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beanname">1.3.1. Naming Beans</a></h4><p>每个 Bean 可以有一个或多个标识符。这些标识符必须在托管 Bean 的容器中是唯一的。通常，一个 Bean 只有一个标识符。但是，如果需要多个，其余视为别名。</p>
<p>在基于 XML 的配置元数据，你可以使用 <code>id</code> 属性，<code>name</code> 属性，或者两个一起来指定 bean 的标识符。<code>id</code> 属性允许你指定一个标识。按照约定，这些名字是字母或数字组合，例如：myBean, someService 等。</p>
<p>如果你想引入其他别名，你也可以指定 <code>name</code> 属性，使用 <code>,</code> 或者 <code>;</code> 或者空格进行分割。</p>
<blockquote>
<p>在 Spring 3.1 之前 <code>id</code> 属性被定义为 <code>xsd:ID</code> 类型，可能受制于一定的字符。Spring 3.1 之后，它被定义为 <code>xsd:string</code> 类型。注意，尽管不再由 XML 解析器强制执行 bean <code>id</code> 唯一性，但仍然由容器强制执行。</p>
</blockquote>
<p>你不必为 bean 即提供 <code>id</code> 又提供 <code>name</code>。如果你有其中一个没有明确提供，容器会生成一个唯一的名字。但是，如果你想使用名称引用 bean，通过 <code>ref</code> 元素，或者服务定位器风格查找，你必须提供一个 name。</p>
<blockquote>
<center><strong>Bean Naming Conventions</strong></center>
该约定是，当命名 Bean 时，使用用于实例字段名称的标准 Java 约定。即，Bean 的名字以小写字母开头，并从那里开始以驼峰格式。此类名称的示例包括 `accountManager`，`accountService`，`userDao`，`loginController` 等。
</blockquote>
<h5 id="Aliasing-a-Bean-outside-the-Bean-Definition"><a href="#Aliasing-a-Bean-outside-the-Bean-Definition" class="headerlink" title="Aliasing a Bean outside the Bean Definition"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beanname-alias">Aliasing a Bean outside the Bean Definition</a></h5><p>在一个 bean 定义本身中，你可以通过 <code>id</code> 属性指定最多 1 个名称，以及在 <code>name</code> 属性中任意数量的其他名称，为 bean 提供不止一个名称。这些名称可以等效的 bean 别名，并且对于某些场景很有用，例如，让应用程序中的每个组件通过使用特定于该组件本身的 bean name 来引用通用的依赖。</p>
<blockquote>
<p>如果你使用 Java 配置，可以使用 <code>@Bean</code> 注解提供别名。</p>
</blockquote>
<h4 id="1-3-2-Instantiating-Beans"><a href="#1-3-2-Instantiating-Beans" class="headerlink" title="1.3.2. Instantiating Beans"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-class">1.3.2. Instantiating Beans</a></h4><p>Bean Definition 本质上可以认为是创建一个或多个对象的配方。当需要时，容器会查找有名 bean 的配方，并使用该 Bean Definition 封装的配置元数据来创建（或者是获取）一个实际的对象。</p>
<p>如果你使用的是基于 XML 配置元数据，指定 <code>&lt;bean/&gt;</code> 元素的 <code>class</code> 属性作为对象的类型。<code>class</code> 属性（<code>BeanDefinition</code> 实例中的 <code>Class</code> 属性）通常是必需的。</p>
<h5 id="Instantiation-with-a-Constructor"><a href="#Instantiation-with-a-Constructor" class="headerlink" title="Instantiation with a Constructor"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-class-ctor">Instantiation with a Constructor</a></h5><p>当你通过构造器方式创建 bean 时，所有一般的类都可以为 Spring 所用，并与 Spring 兼容。也就是说，开发的类无需实现特定的接口或者以特定方式进行编码。简单地指定 bean 的 class 就足够了。但是，根据你用于该特定 bean 的 IoC 类型，你可能需要一个默认（空）构造器。</p>
<p>Spring IoC 容器几乎可以管理你想要管理的任何类。它不仅仅局限于管理真正的 Java Bean。大多数 Spring 用户更愿意在容器中使用实际的 Java Bean，具有一个默认（无参）构造器，以及适当的属性 Setter 和 Getter。你也可以在容器中有更多特别的非 bean 风格的类。例如，如果你需要使用绝对不符合 Java Bean 规范的旧连接池，Spring 也可以管理它。</p>
<p>使用基于 XML 的配置元数据，你可以按照如下方式指定 bean 的 class：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;anotherExample&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBeanTwo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>有关向构造函数提供参数的机制的详细信息（如果需要），并在对象构造后设置对象实例属性，请参见 Injecting Dependencies。</p>
<h5 id="Instantiation-with-a-Static-Factory-Method"><a href="#Instantiation-with-a-Static-Factory-Method" class="headerlink" title="Instantiation with a Static Factory Method"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-class-static-factory-method">Instantiation with a Static Factory Method</a></h5><p>使用静态工厂方法创建 bean 时，class 属性指定静态工厂方法的类，factory-method 属性指定静态方法名。主要用于遗留代码中的静态工厂方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="Instantiation-by-Using-an-Instance-Factory-Method"><a href="#Instantiation-by-Using-an-Instance-Factory-Method" class="headerlink" title="Instantiation by Using an Instance Factory Method"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-class-instance-factory-method">Instantiation by Using an Instance Factory Method</a></h5><p>实例工厂创建 bean 方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个工厂方法可以包含多个工厂方法。</p>
<h5 id="Determining-a-Bean’s-Runtime-Type"><a href="#Determining-a-Bean’s-Runtime-Type" class="headerlink" title="Determining a Bean’s Runtime Type"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-type-determination">Determining a Bean’s Runtime Type</a></h5><h3 id="1-4-Dependencies"><a href="#1-4-Dependencies" class="headerlink" title="1.4. Dependencies"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-dependencies">1.4. Dependencies</a></h3><p>典型的企业应用程序并不会只包含一个对象（就是 Spring 里的 Bean）。即使是最简单的应用，也会有一些对象共同协作，以一个连贯的应用呈现给终端用户他们所看到的东西。下一节说明你如何从定义许多单独的 Bean Definition 到一个完整实现的应用程序，其中对象相互合作达到目的。</p>
<h4 id="1-4-1-Dependency-Injection"><a href="#1-4-1-Dependency-Injection" class="headerlink" title="1.4.1. Dependency Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators">1.4.1. Dependency Injection</a></h4><p>依赖注入，对象通过构造函数参数、工厂方法的参数，或者在对象构造完毕之后设置到对象实例上的属性，或者工厂方法的返回值。</p>
<p>依赖注入存在两种主要的变体：</p>
<ul>
<li>基于构造函数的依赖注入</li>
<li>基于 Setter 的依赖注入</li>
</ul>
<h5 id="Constructor-based-Dependency-Injection"><a href="#Constructor-based-Dependency-Injection" class="headerlink" title="Constructor-based Dependency Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-constructor-injection">Constructor-based Dependency Injection</a></h5><p>基于构造函数的依赖注入是通过容器调用具有多个参数的构造函数来完成，每个参数代表一个依赖项。</p>
<h6 id="Constructor-Argument-Resolution"><a href="#Constructor-Argument-Resolution" class="headerlink" title="Constructor Argument Resolution"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-constructor-injection">Constructor Argument Resolution</a></h6><p>构造函数参数解析通过参数类型匹配。如果 bean 定义的构造函数参数中不存在潜在的歧义，那么在 bean 定义中定义的构造函数参数的顺序就是当 bean 实例化时提供给构造器的参数的顺序。</p>
<p><strong>Constructor argument type matching</strong><br>如果使用 <code>type</code> 属性显式指定构造函数参数类型，则容器可以使用简单类型的类型匹配。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>&amp;nbsp;<br><strong>Constructor argument index</strong><br>解决构造函数参数歧义：可以通过 index 属性指定构造函数参数的索引（从 0 开始）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>Constructor argument name</strong><br>可以使用 <code>name</code> 属性消除构造器参数歧义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>类似 MyBats 的 <code>@Param</code>，你需要将启用代码的 debug 编译，否则 Spring 无法找到参数名。</p>
</blockquote>
<p>如果不希望使用 debug 编译，则使用 <code>@ConstructorProperties</code> 指定构造器参数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.years = years;</span><br><span class="line">    <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Setter-based-Dependency-Injection"><a href="#Setter-based-Dependency-Injection" class="headerlink" title="Setter-based Dependency Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-setter-injection">Setter-based Dependency Injection</a></h5><p>理论上来说，基于 Setter 的依赖注入是容器在调用无参构造函数或者无参静态工厂方法实例化 bean 之后，再调用 bean 的 setter 方法完成。</p>
<p><code>ApplicationContext</code> 对于它管理的 bean，支持基于构造器的依赖注入，也支持基于 setter 的依赖注入。它还支持，在已经通过构造器注入了一些依赖之后，继续用 setter 注入依赖。</p>
<p>可以用 BeanDefinition 的形式配置依赖项，将其与 PropertyEditior 实例结合使用以将属性从一种格式转换为另一种格式。但是，一般不这样使用编程方式工作，而是用 XML 的 bean 定义，注解，或者 @Configuration + @Bean 方式。然后这些源转换成 BeanDefinition 的实例，用于加载 Spring IoC 容器。</p>
<h5 id="Dependency-Resolution-Process"><a href="#Dependency-Resolution-Process" class="headerlink" title="Dependency Resolution Process"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-dependency-resolution">Dependency Resolution Process</a></h5><p>容器执行 Bean 依赖解析如下：</p>
<ul>
<li>创建 <code>ApplicationContext</code> 并使用描述所有 Bean 的配置元数据初始化。配置元数据可以以 XML，Java 代码，或者注解方式指定。</li>
<li>对于每个 Bean，它的依赖项以属性，构造器参数，或者静态工厂方法（如果你使用它而不是普通构造器）参数的形式表示。实际创建 Bean 时，这些依赖项将提供给 Bean。</li>
<li>每个属性或者构造器参数是要设置的值的实际定义，或者是对容器中另一个 Bean 的引用</li>
<li>每个属性或者构造器参数从指定格式转换为该属性或者构造器参数的实际类型。默认地，Spring 可以将字符串格式转换为所有内置类型，如 <code>int</code>，<code>long</code>，<code>String</code>，<code>boolean</code> 等。</li>
</ul>
<h4 id="1-4-2-Dependencies-and-Configuration-in-Detail"><a href="#1-4-2-Dependencies-and-Configuration-in-Detail" class="headerlink" title="1.4.2. Dependencies and Configuration in Detail"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-properties-detailed">1.4.2. Dependencies and Configuration in Detail</a></h4><p>你可以定义 bean 属性，构造器参数作为引用其他被管理的 bean，或者作为内联值。Spring 的基于 XML 配置元数据支持在 <code>&lt;property/&gt;</code> 以及 <code>&lt;constructor-arg/&gt;</code> 之中的子元素类型。</p>
<h5 id="Straight-Values-Primitives-Strings-and-so-on"><a href="#Straight-Values-Primitives-Strings-and-so-on" class="headerlink" title="Straight Values (Primitives, Strings, and so on)"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-value-element">Straight Values (Primitives, Strings, and so on)</a></h5><p><code>&lt;property/&gt;</code> 元素的属性 <code>value</code> 将一个属性或者构造器参数指定为一个人可读的表现形式。Spring 的 conversion service 用于将这些值从 <code>String</code> 转换为属性或者参数的实际类型。以下示例展示了各种值的设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;misterkaoli&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你还可以配置 <code>java.util.Properties</code> 示例，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mappings&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="The-idref-element"><a href="#The-idref-element" class="headerlink" title="The idref element"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-idref-element">The idref element</a></h5><p><code>ideref</code> 元素是一种错误校验方式，将容器中另一个 bean 的 <code>id</code> 传递给 <code>&lt;constructor-arg/&gt;</code> 或者 <code>&lt;property/&gt;</code> 元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theClientBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的 bean 定义片段等价于下面的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;client&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个形式比第二个更好，因为使用 <code>idref</code> 标记允许容器在部署期间验证所引用的有名 bean 是否实际存在。</p>
<h4 id="1-4-3-Using-depends-on"><a href="#1-4-3-Using-depends-on" class="headerlink" title="1.4.3. Using depends-on"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-dependson">1.4.3. Using <code>depends-on</code></a></h4><p>如果一个 Bean 是另一个 Bean 的依赖项，那通常意味着该 Bean 被设置为另一个 Bean 的属性。通常，你可以在基于 XML 的配置元数据中使用 <code>&lt;ref/&gt;</code> 元素来完成此操作。但是，有时候 Bean 之间的依赖不太直接。一个例子是，需要触发类中的静态初始化器，例如数据库驱动程序注册。<code>depends-on</code> 属性可以显式强制在使用该元素（<code>depends-on</code>）的 Bean 初始化之前，初始化一个或多个 bean。下面的示例使用 <code>depends-on</code> 属性来表达对单个 bean 的依赖性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>要表达对多个 bean 的依赖性，请提供 Bean 名称的列表作为依赖性属性的值（逗号，空格，分号是有效的分隔符）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager,accountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;manager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.jdbc.JdbcAccountDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-4-Lazy-initialized-Beans"><a href="#1-4-4-Lazy-initialized-Beans" class="headerlink" title="1.4.4. Lazy-initialized Beans"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lazy-init">1.4.4. Lazy-initialized Beans</a></h4><p>默认地，<code>ApplicationContext</code> 实现类会迅速创建并配置所有的单例 bean，这作为初始化过程的一部分。通常，这种预启动是可取的，因为可以立即发现配置或者环境中的错误，而不是几个小时，甚至几天之后才发现。当这种行为不可取时，你可以通过将 Bean Definition 标记为懒初始化来防止对单例 bean 的预实例化。懒初始化 bean 告诉 IoC 容器首次请求时要创建一个 bean 实例，而不是在启动时创建一个 bean 实例。</p>
<p>在 XML 中，此行为由 <code>&lt;bean/&gt;</code> 元素上的 <code>lazy-init</code> 属性控制，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.ExpensiveToCreateBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;not.lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当前面的配置被 <code>ApplicationContext</code> 消费时，在 <code>ApplicationContext</code> 启动时，<code>lazy</code> bean 不会迅速地预启动，然而 <code>not.lazy</code> bean 会迅速地预实例化。</p>
<p>但是，当一个懒初始化 bean 是一个非懒初始化的单例 bean 的依赖时，<code>ApplicationContext</code> 在启动时会创建初始化 bean，因为它必须满足单例的依赖性。懒初始化 bean 被注入到别的非懒初始化的单例 bean 中。</p>
<p>你还可以通过使用 <code>&lt;beans/&gt;</code> 元素上的 <code>default-lazy-init</code> 属性来控制容器级别的懒初始化，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-5-Autowiring-Collaborators"><a href="#1-4-5-Autowiring-Collaborators" class="headerlink" title="1.4.5. Autowiring Collaborators"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-autowire">1.4.5. Autowiring Collaborators</a></h4><p>Spring 容器可以自动绑定协作 Bean 之间的关系。你可以让 Spring 自动地通过审查 <code>ApplicationContext</code> 的内容为你的 Bean 解析协作者的话（其他 Bean）。自动绑定有如下优势：</p>
<ul>
<li>自动绑定可以大大减少指定属性或者构造器参数的需求。</li>
<li>自动绑定可以随着对象的进化更新配置。</li>
</ul>
<h5 id="Limitations-and-Disadvantages-of-Autowiring"><a href="#Limitations-and-Disadvantages-of-Autowiring" class="headerlink" title="Limitations and Disadvantages of Autowiring"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-autowired-exceptions">Limitations and Disadvantages of Autowiring</a></h5><p>考虑自动绑定的局限性和劣势：</p>
<ul>
<li>在 <code>property</code> 和 <code>constructor-arg</code> 设置上的显式依赖总是会覆盖自动绑定。你不能自动绑定简单属性，例如原生类型，<code>Strings</code>，以及 <code>Classes</code>。这种限制是设计如此的。</li>
<li>自动绑定不如显式绑定精确。虽然，如前面表格所述，Spring 在可能有产生无法预测结果的歧义情况下，小心地避免猜测。你由 Spring 管理的对象之间的关系不再明确记录。</li>
<li>那些能够从 Spring 容器中生成文档的工具可能无法获得自动绑定信息</li>
<li>可能容器中多个 Bean Definition 都可以匹配待绑定的 Setter 方法或者构造器参数指定的类型。对于数字，集合，或者 <code>Map</code> 实例，这未必是个问题。但是，对于期望单个值得依赖，这种歧义无法解决。如果没有唯一得 Bean Definition，则会抛出异常。<h4 id="1-4-6-Method-Injection"><a href="#1-4-6-Method-Injection" class="headerlink" title="1.4.6. Method Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-method-injection">1.4.6. Method Injection</a></h4>在大多数应用场景中，多数的 bean 都是单例。当一个单例 bean 需要与另一个单例 bean 协作，或者一个非单例 bean 需要与另一个非单例 bean 协作，你通常会定义其中一个 bean 为另一个的属性来处理依赖关系。当 bean 的生命周期不同时，就会出现问题。假设单例 bean A 需要使用非单例（prototype）bean B，也许是在 A 的每个方法调用上。容器只会创建单例 bean A 一次，因此，只有一个机会可以设置属性 。不可能每次需要时容器都为 bean A 提供一个新的 bean B 实例。</li>
</ul>
<blockquote>
<p><strong>作者的话</strong> 官方的意思应该是 bean A 的方法调用都需要一个全新的 bean B，而不是复用同一个，但是在遵循控制反转的规则下，又无法每次需要时从容器中得到一个全新的 bean B。</p>
</blockquote>
<p>解决方案是放弃一些控制反转。你可以让 bean A 实现 <code>ApplicationContextAware</code> 接口来感知容器，并且，每当 bean A 需要的时候，通过调用容器的 <code>getBean(&quot;B&quot;)</code> 请求（通常是新的）一个 bean B 实例。</p>
<h3 id="1-5-Bean-Scopes"><a href="#1-5-Bean-Scopes" class="headerlink" title="1.5. Bean Scopes"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-scopes">1.5. Bean Scopes</a></h3><p>Spring Framework 支持 6 个范围，其中四个仅在使用 web-aware <code>ApplicationContext</code></p>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>（默认值）对于每个 Spring IoC 容器，将单个 Bean Definition 范围示为单个对象实例</td>
</tr>
<tr>
<td>prototype</td>
<td>将单个 Bean Definition 范围示为任意数量的对象实例</td>
</tr>
</tbody></table>
<h3 id="1-6-Customizing-the-Nature-of-a-Bean"><a href="#1-6-Customizing-the-Nature-of-a-Bean" class="headerlink" title="1.6. Customizing the Nature of a Bean"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-nature">1.6. Customizing the Nature of a Bean</a></h3><p>Spring Framework 提供了许多可用的接口来自定义 bean 的性质。本节将它们分组为如下：</p>
<ul>
<li>Lifecycle Callbacks</li>
<li><code>ApplicationContextAware</code> and <code>BeanNameAware</code></li>
<li>Other <code>Aware</code> Interfaces</li>
</ul>
<h4 id="1-6-1-Lifecycle-Callbacks"><a href="#1-6-1-Lifecycle-Callbacks" class="headerlink" title="1.6.1. Lifecycle Callbacks"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle">1.6.1. Lifecycle Callbacks</a></h4><p>要与 Bean 生命周期的容器管理交互，你可以实现 Spring 的 <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口。该容器为前者调用 <code>afterPropertiesSet()</code>，为后者调用调用 <code>destroy()</code>，这使得在 bean 的初始化和销毁时执行某些操作。</p>
<blockquote>
<p><strong>作者的话</strong> <code>InitializingBean</code> 方法的调用是通过创建 bean 的过程中由 <code>AbstractAutowireCapableBeanFactory</code> 调用 <code>invokeInitMethods</code> 方法实现的，该方法除了调用接口实现的方法，还可以触发自定义 init 方法的调用</p>
</blockquote>
<p>在内部，Spring Framework 使用 <code>BeanPostProcessor</code> 实现类来处理任何它能找到的回调接口，并调用适当的方法。如果你需要自定义功能或者其他 Spring 默认没有提供的生命周期行为，则可以自己实现一个 <code>BeanPostProcessor</code>。更多信息，参见 Container Extension Points。</p>
<blockquote>
<p><strong>作者的话</strong> 准确来说，是由 <code>CommonAnnotationBeanPostProcessor</code> 来调用生命周期方法的，而 <code>CommonAnnotationBeanPostProcessor</code> 又是 <code>InitDestroyAnnotationBeanPostProcessor</code> 的子类，后者实现了调用逻辑。</p>
</blockquote>
<p>除了初始化和销毁的回调外，被 Spring 管理的对象还可以实现 <code>Lifecycle</code> 接口，以便于这些对象能够参与由容器自己的生命周期驱动的启动和关闭过程。</p>
<p><code>Lifecycle</code> 回调接口在本节中有描述。</p>
<p>减少与 Spring 的耦合，JSR-250 最佳实践：</p>
<ul>
<li><code>@PostConstruct</code></li>
<li><code>@PreDestroy</code></li>
</ul>
<p>不想使用 JSR-250，可以考虑：</p>
<ul>
<li>init-method</li>
<li>destroy-method</li>
</ul>
<p>Spring 使用 BeanPostProcessor 实现来处理找到的任何回调接口并调用适当的方法。可以自定义功能。</p>
<h5 id="Initialization-Callbacks"><a href="#Initialization-Callbacks" class="headerlink" title="Initialization Callbacks"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean">Initialization Callbacks</a></h5><p><code>org.springframework.beans.factory.InitializingBean</code> 接口让 bean 可以在容器设置所有必要的属性之后执行初始化工作。<code>InitializingBean</code> 接口指定了一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>

<p>我们建议你不要使用 <code>InitializingBean</code> 接口，因为它不必要地将代码耦合到 Spring。另外，我们建议使用 <code>@PostConstruct</code> 注解或者指定一个 POJO 初始化方法。对于基于 XML 的配置元数据，你可以使用 <code>init-method</code> 属性来指定一个返回值为 void，没有参数签名的方法。对于 Java 配置，你可以使用 <code>@Bean</code> 的 <code>initMethod</code> 属性。考虑如下示例：</p>
<blockquote>
<p><strong>作者的话</strong> 如果你没有指定返回值为 void 的无参方法，那么就会启动抛出异常。</p>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> 如果你对调用初始化回调方法顺序并没有严格的需求，那么你完全可以用 <code>@PostConstruct</code> 注解来完成，从而忽视 init 方法或者 <code>InitializingBean</code> 接口。而且，<code>@PostConstruct</code> 注解方法可以配置多个，init 方法或者 <code>InitializingBean</code> 只能指定一个。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例的效果几乎与下面示例效果完全相同：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherExampleBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，前面两个示例中的第一个不会将代码与 Spring 耦合。</p>
<h5 id="Destruction-Callbacks"><a href="#Destruction-Callbacks" class="headerlink" title="Destruction Callbacks"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean">Destruction Callbacks</a></h5><p>实现 DisposableBean 接口可以让 bean 在容器销毁它时执行回调。</p>
<p>给 <code>destroy-method</code> 或者 <code>default-destroy-method</code> 赋予特殊值 <code>(inferred)</code> 会进行方法推断，如：java.io.Closeable，java.lang.AutoCloseable 的实现方法。</p>
<p>&amp;nbsp;</p>
<h5 id="Default-Initialization-and-Destroy-Methods"><a href="#Default-Initialization-and-Destroy-Methods" class="headerlink" title="Default Initialization and Destroy Methods"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-default-init-destroy-methods">Default Initialization and Destroy Methods</a></h5><p>在 <code>&lt;beans&gt;</code> 指定属性：</p>
<ul>
<li>default-init-method</li>
<li>default-destroy-method</li>
</ul>
<p>此属性可以被 <code>&lt;bean&gt;</code> 的属性 init-method 和 destroy-method 覆盖</p>
<h5 id="Combining-Lifecycle-Mechanisms"><a href="#Combining-Lifecycle-Mechanisms" class="headerlink" title="Combining Lifecycle Mechanisms"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-combined-effects">Combining Lifecycle Mechanisms</a></h5><p>为同一个 bean 配置多个生命周期机制，具有不同的初始化方法，调用如下：</p>
<ol>
<li>@PostConstruct 方法</li>
<li>InitializingBean.afterPropertiesSet() 方法</li>
<li>自定义配置的 init() 方法</li>
</ol>
<p>销毁方法类似：</p>
<ol>
<li>@PreDestroy</li>
<li>DisposableBean.destroy()</li>
<li>自定义配置的 destroy()</li>
</ol>
<h5 id="Startup-and-Shutdown-Callbacks"><a href="#Startup-and-Shutdown-Callbacks" class="headerlink" title="Startup and Shutdown Callbacks"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-processor">Startup and Shutdown Callbacks</a></h5><p><code>Lifecycle</code> 接口为那些有自己生命周期需求的对象定义了必要的方法（例如启动或停止某些后台处理过程）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何被 Spring 管理的对象都可以实现 <code>Lifecycle</code> 接口。然后，当 <code>ApplicationContext</code> 本身接收启动和停止信号时，它会汇总定义在该上下文中的所有 <code>Lifecycle</code> 实现类的调用。它通过委托给 <code>LifecycleProcessor</code> 做到这一点，如下列表所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>LifecycleProcessor</code> 本身就是 <code>Lifecycle</code> 接口的扩展。它还添加了两个其他的方法，用于响应上下文的刷新和关闭。</p>
<blockquote>
<p>注意，常规的 <code>org.springframework.context.Lifecycle</code> 接口明确的启动和停止通知的简单合同，并不意味着在上下文刷新事件内自动启动。要对特定 bean 的自动启动（包括启动阶段）进行细粒度的控制，考虑实现 <code>org.springframework.context.SmartLifecycle</code>。</p>
</blockquote>
<p>启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在”依赖”关系，则依赖侧在其依赖之后启动，并且在其依赖之前停止。但是，有时候直接依赖性是未知的。你可能只知道某种类型的对象应该在其他类型对象之前开始。在这种情况下，<code>SmartLifecycle</code> 接口定义了另一个选项，即在父接口上定义的 <code>getPhase()</code> 方法。如下几列展示了 <code>Phased</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Phased</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPhase</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下几行展示了 <code>SmartLifecycle</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span>, Phased &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAutoStartup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">(Runnable callback)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动时，最低阶段的对象首先启动。停止时，遵循反向顺序。因此，实现 <code>SmartLifecycle</code> 及其 <code>getPhase()</code> 方法返回 <code>Integer.MIN_VALUE</code> 将是第一个启动，最后一个停止的对象。</p>
<h5 id="Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications"><a href="#Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications" class="headerlink" title="Shutting Down the Spring IoC Container Gracefully in Non-Web Applications"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-shutdown">Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</a></h5><blockquote>
<p>本节仅适用于非 Web 应用。当关闭相关的 Web 应用时，Spring 基于 Web 的 <code>ApplicationContext</code> 实现已经有了适当的代码，可以优雅地关闭 Spring IoC 容器。</p>
</blockquote>
<h4 id="1-6-2-ApplicationContextAware-and-BeanNameAware"><a href="#1-6-2-ApplicationContextAware-and-BeanNameAware" class="headerlink" title="1.6.2. ApplicationContextAware and BeanNameAware"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-aware">1.6.2. <code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></h4><p>当 <code>ApplicationContextAware</code> 创建一个实现了 <code>org.springframework.context.ApplicationContextAware</code> 接口的对象实例时，会提供一个 <code>ApplicationContext</code> 的引用给该实例。下面几行展示了 <code>ApplicationContextAware</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，bean 可以通过 <code>ApplicationContext</code> 接口或者通过将引用转换到该接口的已知子类（例如 <code>ConfigurableApplicationContext</code>，其暴露了额外的功能），从而程序化地操纵创建它们的 <code>ApplicationContext</code>。一种用法是对其他 bean 的程序化检索。有时候这种功能很有用。但是，总的来说你应该避免它，因为它将代码耦合到 Spring，并且不遵循 IoC 风格，此时将合作者的话作为属性提供给 bean。<code>ApplicationContext</code> 的其他方法提供了对文件资源的访问，发布应用事件，以及访问 <code>MessageSource</code>。这些附加功能在 Additional Capabilities of the <code>ApplicationContext</code> 中进行了描述。</p>
<p>自动绑定时对获得 <code>ApplicationContext</code> 的引用的另一种替代方式。传统的 <code>constructor</code> 以及 <code>byType</code> 自动绑定模式可以分别为构造函数参数或者 setter 方法参数提供 <code>ApplicationContext</code> 类型的依赖。为了获得更多灵活性，包括自动绑定字段以及多参数方法的能力，请使用基于注解的自动绑定特性。如果你这样做了，并且字段，构造器，或者方法携带了@Autowired 注解，那么<code>ApplicationContext</code> 将自动绑定到一个字段，构造器参数，或者期望 <code>ApplicationContext</code> 类型的方法参数。更多信息，参见 Using @Autowired。</p>
<blockquote>
<p>使用 @Autowired 获得 ApplicationContext</p>
</blockquote>
<p>当 <code>ApplicationContext</code> 创建了一个实现 <code>org.springframework.beans.factory.BeanNameAware</code> 接口的类时，它会给该类提供定义在其关联对象定义中的名称引用。下面几行展示了 <code>BeanNameAware</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在普通 bean 属性填充之后，但是在例如 <code>InitializingBean</code>，<code>afterPropertiesSet</code>，或者自定义的 init-method 初始化回调之前调用该回调。</p>
<blockquote>
<p><strong>作者的话</strong> 所以，顺序应该是填充属性（populate），Aware 回调，init 回调。</p>
</blockquote>
<h4 id="1-6-3-Other-Aware-Interfaces"><a href="#1-6-3-Other-Aware-Interfaces" class="headerlink" title="1.6.3. Other Aware Interfaces"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aware-list">1.6.3. Other Aware Interfaces</a></h4><p>除了 <code>ApplicationContextAware</code> 和 <code>BeanNameAware</code>（前面讨论过）之外，Spring 还提供了广泛的 <code>Aware</code> 回调接口，使得 bean 向容器指示它们需要一定的基础架构依赖。正如一般规则，名称表示依赖类型。下表总结了最重要的几个 <code>Aware</code> 接口：</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th>Injected Dependency</th>
<th>Explained in…​</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ApplicationContextAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">ApplicationEventPublisherAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">BeanClassLoaderAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">BeanFactoryAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">BeanNameAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">BootstrapContextAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">LoadTimeWeaverAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">MessageSourceAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">NotificationPublisherAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">ResourceLoaderAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">ServletConfigAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">ServletContextAware</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-7-Bean-Definition-Inheritance"><a href="#1-7-Bean-Definition-Inheritance" class="headerlink" title="1.7. Bean Definition Inheritance"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions">1.7. Bean Definition Inheritance</a></h3><p>Bean Definition 可以包含许多配置信息，包括构造器参数，属性值，特定于容器的信息，例如初始化方法，静态工厂方法名等。子 Bean Definition 从父 Definition 继承配置数据。子 Definition 可以覆盖一些值，或者根据需要添加其他值。使用父子 Bean Definition 可以节约大量键入。有效地，这是一种模板。</p>
<p>如果你以编程的方式使用 <code>ApplicationContext</code> 接口，那么子 Bean Definition 以 <code>ChildBeanDefinition</code> 类标表示。大多数用户在这一层不与它们合作。相反，它们在类中声明式配置 Bean Definition，例如 <code>ClassPathXmlApplicationContext</code>。当你使用基于 XML 的配置元数据时，你可以通过使用 <code>parent</code> 属性来指示子 Bean Definition，将父 bean 指定为该属性的值。下面的示例展示了怎么做：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithDifferentClass&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-8-Container-Extension-Points"><a href="#1-8-Container-Extension-Points" class="headerlink" title="1.8. Container Extension Points"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension">1.8. Container Extension Points</a></h3><p>通常，应用程序开发者不必子类化 <code>ApplicationContext</code> 实现类。取而代之的是，可以通过插入特殊集成接口实现来扩展 Spring IoC 容器。接下来几节描述了这些集成接口。</p>
<h4 id="1-8-1-Customizing-Beans-by-Using-a-BeanPostProcessor"><a href="#1-8-1-Customizing-Beans-by-Using-a-BeanPostProcessor" class="headerlink" title="1.8.1. Customizing Beans by Using a BeanPostProcessor"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp">1.8.1. Customizing Beans by Using a <code>BeanPostProcessor</code></a></h4><p><code>BeanPostProcessor</code> 接口定义了一些回调方法，你可以实现它们来提供自己的实例化逻辑（或者覆盖容器默认的），依赖解析逻辑等。如果你要在 Spring 容器完成实例化，配置，初始化 bean 之后，实现一些自己的逻辑，则可以插入一个或多个自定义的 <code>BeanPostProcessor</code> 实现。</p>
<p>你可以配置多个 <code>BeanPostProcessor</code> 实例，并且通过设置 <code>order</code> 属性控制这些 <code>BeanPostProcessor</code> 实例执行顺序。你只有在 <code>BeanPostProcessor</code> 实现 <code>Ordered</code> 接口时才能设置此属性。如果你编写自己的 <code>BeanPostProcessor</code>，则也应该考虑实现 <code>Ordered</code> 接口。有关更多信息，请参阅 <code>BeanPostProcessor</code> 和 <code>Ordered</code> 接口的 javadoc。另请参见 programmatic registration of BeanPostProcessor instances.</p>
<blockquote>
<p>如果要更改实际的 bean 实例，则需要使用 BeanPostProcessor。虽然，技术上可以通过 BeanFactoryPostProcessor 实现（如：<code>beanFactory.get()</code>），但是这样会导致 bean 过早实例化，违反了标准的容器生命周期。而且，这会产生副作用，如：绕过 bean 的后置处理。</p>
</blockquote>
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code> 接口刚好由 2 个回调方法组成。当这样的类以 post-processor 注册到容器中时，post-processor 在容器初始化方法调用之前，且在任何 bean 初始化回调之后，都会从容器中获得回调。Post Processor 可以对 bean 实例进行任何操作，包括完全忽略回调。一个 Bean Post Processor 通常检查回调接口，或者可能包装带有代理的 bean。一些 Spring AOP 基础架构类以 Bean Post Processor 进行实现，以提供代理包装逻辑</p>
<p><code>ApplicationContext</code> 自动检测实现了 <code>BeanPostProcessor</code> 接口的定义在配置元数据中的任何 bean。<code>ApplicationContext</code> 将这些 bean 注册为后置处理器，以便以后再 bean 创建时可被调用。Bean Post Processor 可以与其他任何 bean 以相同的方式部署到容器中。</p>
<p>请注意，当通过在 Configuration 类上使用 <code>@Bean</code> 工厂方法声明 <code>BeanPostProcessor</code> 时，工厂方法的返回类型应该时实现类本身，或者至少是 <code>org.springframework.beans.factory.config.BeanPostProcessor</code> 接口，清晰表明该 bean 的后置处理性质。否则，<code>ApplicationContext</code> 在完全创建它之前将无法通过类型自动检测到。由于需要尽早实例化 <code>BeanPostProcessor</code> 才能应用于上下文中其他 bean 的初始化，因此这种早期类型检测至关重要。</p>
<blockquote>
<p><strong>作者的话</strong> 如果你的 <code>BeanPostProcessor</code> 不仅实现了 <code>BeanPostProcessor</code> 还实现了其他接口或者继承了其他类，那么 @Bean 返回类型必须使用 <code>BeanPostProcessor</code> 否则 Spring 无法识别到</p>
</blockquote>
<p>具体的底层代码可以阅读 <code>AbstractAutowireCapableBeanFactory#initializeBean()</code>，其中在调用 <code>invokeInitMethods()</code> 方法的前后分别调用了 <code>applyBeanPostProcessorsBeforeInitialization()</code> 和 <code>applyBeanPostProcessorsAfterInitialization()</code>。</p>
<table>
<thead>
<tr>
<th align="left">常见的 BeanPostProcessor</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CommonAnnotationBeanPostProcessor</td>
<td align="left">用于执行 @PostConstruct @PreDestroy 注解的方法</td>
</tr>
<tr>
<td align="left">AutowiredAnnotationBeanPostProcessor</td>
<td align="left">用于自动注入 @Autowired @Value @Inject</td>
</tr>
</tbody></table>
<h5 id="Example-Hello-World-BeanPostProcessor-style"><a href="#Example-Hello-World-BeanPostProcessor-style" class="headerlink" title="Example: Hello World, BeanPostProcessor-style"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-hw">Example: Hello World, BeanPostProcessor-style</a></h5><h5 id="Example-The-AutowiredAnnotationBeanPostProcessor"><a href="#Example-The-AutowiredAnnotationBeanPostProcessor" class="headerlink" title="Example: The AutowiredAnnotationBeanPostProcessor"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-aabpp">Example: The AutowiredAnnotationBeanPostProcessor</a></h5><p>使用回调接口或者注解，配合自定义的 <code>BeanPostProcessor</code> 实现是扩展 Spring IoC 容器的常见手段。一个例子是 Spring <code>AutowiredAnnotationBeanPostProcessor</code> —— 这是 <code>BeanPostProcessor</code> 的一个实现类，其与 Spring 分布和 <code>@Autowired</code> 注解字段，Setter 方法，以及任意配置方法一起</p>
<h4 id="1-8-2-Customizing-Configuration-Metadata-with-a-BeanFactoryPostProcessor"><a href="#1-8-2-Customizing-Configuration-Metadata-with-a-BeanFactoryPostProcessor" class="headerlink" title="1.8.2. Customizing Configuration Metadata with a BeanFactoryPostProcessor"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-factory-postprocessors">1.8.2. Customizing Configuration Metadata with a BeanFactoryPostProcessor</a></h4><p><code>BeanFactoryPostProcessor</code> 是一个扩展点。<code>BeanFactoryPostProcessor</code> 与 <code>BeanPostProcessor</code> 语义类似，但有一个主要区别：<code>BeanFactoryPostProcessor</code> 对 bean 配置元数据进行操作。Spring Ioc 容器允许 <code>BeanFactoryPostProcessor</code> 读取配置元数据，并且可以在实例化除了 <code>BeanFactoryPostProcessor</code> 任何 bean 之前修改这些配置元数据。</p>
<blockquote>
<p><code>BeanDefinitionRegistryPostProcessor</code> 是 <code>BeanFactoryPostProcessor</code> 的子接口。</p>
</blockquote>
<p>可以配置多个 BeanFactoryPostProcessor 实例，并通过 order 属性来控制这些实例的运行顺序。如果编写自己的 BeanFactoryPostProcessor，也应该考虑实现 Ordered 接口。</p>
<p>为了应用这些改变到容器中的配置元数据，当 bean factory 后置处理器声明在 <code>ApplicationContext</code> 中时，它会自动执行。Spring 包含了许多预定义的 bean factory 后置处理器，比如 <code>PropertyOverrideConfigurer</code> 以及 <code>PropertySourcesPlaceholderConfigurer</code>。</p>
<h3 id="1-9-Annotation-based-Container-Configuration"><a href="#1-9-Annotation-based-Container-Configuration" class="headerlink" title="1.9. Annotation-based Container Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-annotation-config">1.9. Annotation-based Container Configuration</a></h3><blockquote>
<center><strong>配置 Spring 注解比 XML 更好吗？</strong></center>
引入基于注解的配置出现了一个问题，即这种方式是否比 XML 更好。简短的答案是：看情况。具体就是，每种方法都有其优点和缺点，通常，开发人员决定哪种测策略更适合他们。由于他们的定义方式，注解在声明的时候提供许多上下文，使得配置更短，更简洁。但是，XML 擅于在不触及源代码以及重新编译的情况下，将组件关联起来。一些开发者更喜欢让关联接近源代码，而另一个开发者人为注解类不再是 POJO，此外，配置变得分散且难以控制。
</blockquote>
<ul>
<li>Spring 2.0 引入 <code>@Required</code> 强化需要的属性</li>
</ul>
<p>基于注解得配置提供了 XML 设置的可替代方案，该方案依赖于字节码元数据来绑定组件而不是声明。无需使用 XML 去描述 Bean 的绑定，开发者只需将配置移动到组件类本身，在相关的类，方法，或者字段声明上面使用注解。如 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-aabpp">Example: The AutowiredAnnotationBeanPostProcessor</a> 所述，结合注解使用 <code>BeanPostProcessor</code> 是扩展 Spring IoC 容器的通用方式。</p>
<h4 id="1-9-1-Required"><a href="#1-9-1-Required" class="headerlink" title="1.9.1. @Required"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-required-annotation">1.9.1. @Required</a></h4><p><code>@Required</code> 注解用于 bean 的 Setter 方法，如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 该注解只能使用在方法上</p>
</blockquote>
<p>该注解表示，受影响的 Bean 属性必须在配置期间填充属性，无论是通过 Bean Definition 中明确的属性值，还是自动绑定。如果受影响的属性并没有填充，则容器会抛出一个异常。这是考虑到尽早且明确的故障，以免以后 <code>NullPointerException</code> 实例或者此类的问题。我们依然建议你将断言放到 bean 类本身（例如，放入 init 方法）。这样做甚至可以当你在容器之外使用类时，也能强制需要的引用和值。</p>
<blockquote>
<p><code>RequiredAnnotationBeanPostProcessor</code> 必须注册为一个 bean，以支持 <code>@Required</code> 注解</p>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> Spring Boot 默认是不注册 <code>RequiredAnnotationBeanPostProcessor</code> 的，因此需要手动导入，譬如使用 <code>@Import</code></p>
</blockquote>
<blockquote>
<p><code>@Required</code> 注解和 <code>RequiredAnnotationBeanPostProcessor</code> 在 Spring 框架 5.1 正式弃用，这是为了支持对必需的配置使用构造器注入（或者一个 <code>InitializingBean.afterPropertiesSet()</code> 自定义的实现，或者随着 Bean 属性 Setter 方法自定义的 <code>@PostConstruct</code> 方法。</p>
</blockquote>
<h4 id="1-9-2-Using-Autowired"><a href="#1-9-2-Using-Autowired" class="headerlink" title="1.9.2. Using @Autowired"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation">1.9.2. Using <code>@Autowired</code></a></h4><blockquote>
<p>在本节包含的示例中，你可以使用 JSR 330 的 <code>@Inject</code> 注解代替 Spring 的 <code>@Autowired</code> 注解。有关更多详情，参见<a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-standard-annotations">此处</a>。</p>
</blockquote>
<p>你可以将 <code>@Autowired</code> 注解应用在构造器上，如下实例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从 Spring Framework 4.3 开始，如果目标 Bean 仅定义了一个构造器，则不再需要在该构造器上使用 <code>@Autowired</code> 注解。但是，如果有几个构造器可用，并且没有 primary 或者默认构造器，至少用 <code>@Autowired</code> 注解一个构造器，以便于指示容器用哪一个。</p>
</blockquote>
<p>你也可以将 <code>@Autowired</code> 注解应用于传统的 Setter 方法，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以将注解应用于具有任意名称和多个参数的方法，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还可以将 <code>@Autowird</code> 应用在字段上，甚至混合构造器一起使用，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过将 <code>@Autowired</code> 注解添加到字段或者期望数组类型的方法上，你可以指示 Spring 从 <code>ApplicationContext</code> 中提供所有特定类型的 Bean，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同的也可以用在集合类型上，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至类型 <code>Map</code> 示例也可以自动绑定，只要期望的 Key 类型是 <code>String</code>。<code>Map</code> 的 value 包含所有期望类型的 Bean，kay 包含相关的 Bean 名称，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况，当对于给定的注入点没有匹配的候选 Bean 可用时，自动绑定就会失败。在声明了数组，集合，或者 Map 情况下，期望至少有一个匹配的元素。</p>
<p>默认的行为是将注解的方法和字段视为必需的依赖。你可以如下示例所示，更改此行为，通过将其标记为非必需的（即，通过设置 <code>@Autowired</code> 属性 <code>required</code> 为 <code>false</code>），让框架跳过不满足的注入点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个非必需的方法依赖（或者在多参数情况下，有一个依赖）不可获得，那么该方法根本不会调用。在这种情况下，非必需的字段将根本不会被填充，保持默认值。</p>
<p>另外，你可以通过 Java 8 的 <code>java.util.Optional</code> 表达特定以来的非必需特性，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(Optional&lt;MovieFinder&gt; movieFinder)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>@Autowired 用法</strong>：<br>(1) 构造函数。若 bean 只有一个构造函数，则可不必。<br>(2) setter 方法<br>(3) 任意的方法<br>(4) 字段<br>(5) 数组、Collection、Map<br>(6) java.util.Optional<br>(7) BeanFactory，ApplicationContext，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 这些接口以及它们的扩展接口</p>
<p><strong>指定类型数组、集合的顺序</strong><br>(1) org.springframework.core.Ordered<br>(2) @Order 或者 @Priority </p>
<p>@Autowired，@Inject、@Value、@Resource 会由 Spring 的 BeanPostProcessor 处理。因此，不能在自己的 BeanPostProcessor 或者 BeanFactoryPostProcessor 中使用这些注解（否则循环了）。</p>
<p>注入见：<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</code></p>
<h4 id="1-9-3-Fine-tuning-Annotation-based-Autowiring-with-Primary"><a href="#1-9-3-Fine-tuning-Annotation-based-Autowiring-with-Primary" class="headerlink" title="1.9.3. Fine-tuning Annotation-based Autowiring with @Primary"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation-primary">1.9.3. Fine-tuning Annotation-based Autowiring with @Primary</a></h4><p>按照<strong>类型</strong>的自动绑定可能产生多个候选者，因此有必要使用更多的控制进行选择。其中一种方式就是使用 <code>@Primary</code> 注解。<code>@Primary</code> 注解表示，当多个 bean 候选者需要自动绑定到一个单值依赖上时，特定的 bean 应该给予优先权。如果多个候选者中存在一个主要的 bean，那么它将会自动绑定到值上。</p>
<blockquote>
<ul>
<li><code>BeanDefinition</code> 接口方法 <code>isPrimary()</code> 正是描述了该 bean 是否具有优先权。</li>
<li>如果你注入了两个类型相同，且都标注了 <code>@Primary</code> 的 bean，而且通过类型获取单个 bean，那么将会抛出异常。具体逻辑见：DefaultListableBeanFactory#determinePrimaryCandidate</li>
</ul>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> 该注解完全可以忽视，一般并不希望自动绑定出现歧义，或者直接使用 <code>@Resource</code> 进行准确绑定。</p>
</blockquote>
<h4 id="1-9-4-Fine-tuning-Annotation-based-Autowiring-with-Qualifiers"><a href="#1-9-4-Fine-tuning-Annotation-based-Autowiring-with-Qualifiers" class="headerlink" title="1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers">1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers</a></h4><p>当你需要在选择过程上有更多控制时，可以使用 <code>@Qualifier</code> 注解。你可以将 qualifier 的值与特定参数绑定，缩小类型匹配的集合，以便于能选出特定的那个 bean。</p>
<p>可以用于：字段、方法参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;main&quot;)</span></span><br><span class="line"><span class="keyword">private</span> MovieCatalog movieCatalog;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="meta">@Qualifier(&quot;main&quot;)</span> MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">    <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>作为备用匹配，bean 的名称被当作默认的限定值。但是，即使你使用这个约定，通过名称引用一个 bean，@Autowired 本质上也是类型驱动注解，只是附带一个可选的语义限定符（在匹配类型的集合中缩小范围），并不能表示唯一一个 bean 的 <code>id</code>。</li>
<li>好的限定符应该表达一个与 bean ID 无关的特定组件的特征。</li>
</ul>
</blockquote>
<p>Qualifier 也可以适用于类型集合，比如 <code>Set&lt;Object&gt;</code>，这意味着限定者并不是唯一的，而是一个筛选条件。</p>
<blockquote>
<ul>
<li>如果你希望通过名称进行注解驱动注入，但不想使用 <code>@Autowired</code>，即使这是可以在类型匹配的候选者中选择对应名称的 bean，你可以使用 JSR-250 注解 <code>@Resource</code>，这是一个语义上定义为通过使用唯一名称标识特定组件的注解，与声明类型无关。</li>
</ul>
</blockquote>
<h4 id="1-9-5-Using-Generics-as-Autowiring-Qualifiers"><a href="#1-9-5-Using-Generics-as-Autowiring-Qualifiers" class="headerlink" title="1.9.5. Using Generics as Autowiring Qualifiers"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-generics-as-qualifiers">1.9.5. Using Generics as Autowiring Qualifiers</a></h4><p>除了显式使用 <code>@Qualifier</code> 注解，你可以使用 Java 泛型作为隐式的限定。</p>
<h4 id="1-9-6-Using-CustomAutowireConfigurerl"><a href="#1-9-6-Using-CustomAutowireConfigurerl" class="headerlink" title="1.9.6. Using CustomAutowireConfigurerl"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-custom-autowire-configurer">1.9.6. Using CustomAutowireConfigurer</a>l</h4><h4 id="1-9-7-Injection-with-Resource"><a href="#1-9-7-Injection-with-Resource" class="headerlink" title="1.9.7. Injection with @Resource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-resource-annotation">1.9.7. Injection with @Resource</a></h4><p>Spring 也支持 JSR-250 注解 <code>@Resource</code>，用于字段或者 bean 属性的 setter 方法。</p>
<p><code>@Resource</code> 具有一个 <code>name</code> 属性。默认地，Spring 将该值当作被注入的 bean 的名字。</p>
<blockquote>
<ul>
<li><code>@Resource</code> 注解不支持 static 字段。</li>
</ul>
</blockquote>
<p>如果没有指定 name，默认的名称将会从字段名或者 setter 方法中解析出来。没有显式地指定名称，类似于 @Autowired，@Resource 将查找主要地类型匹配而不是特定 名称，并且解析熟知的 BeanFactory, ApplicationContext, ResourceLoader, ApplicationEvenetPublisher, MessageSource 接口。</p>
<h4 id="1-9-8-Using-Value"><a href="#1-9-8-Using-Value" class="headerlink" title="1.9.8. Using @Value"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-value-annotations">1.9.8. Using @Value</a></h4><p><code>@Value</code> 典型的用法是注入外部的属性</p>
<p>使用位置：字段、方法参数</p>
<ul>
<li><code>@Value(&quot;$&#123;catalog.name:defaultCatalog&#125;&quot;)</code>，defaultCatalog 为默认值，用冒号隔开</li>
<li><code>@Value(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</code>，嵌套使用</li>
</ul>
<p>Spring 默认是宽松解析，如果要严格解析，配置 <code>PropertySourcesPlaceholderConfigurer</code>，Spring Boot 是默认配置的（见 <code>PropertyPlaceholderAutoConfiguration</code>）。</p>
<h4 id="1-9-9-Using-PostConstruct-and-PreDestroy"><a href="#1-9-9-Using-PostConstruct-and-PreDestroy" class="headerlink" title="1.9.9. Using @PostConstruct and @PreDestroy"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations">1.9.9. Using @PostConstruct and @PreDestroy</a></h4><p><code>CommonAnnotationBeanPostProcessor</code> 不仅能识别 <code>@Resource</code> 注解，还可以识别 JSR-250 生命周期注解：<code>javax.annotation.PostConstruct</code> 和 <code>javax.annotation.PreDestroy</code>。</p>
<blockquote>
<p>在标准 JDK 6 到 JDK 8 中，<code>@Resource</code>, <code>@PostConstruct</code>, <code>@PreDestroy</code> 注解是其中的一部分。但是，整个 <code>javax.annotation</code> 包在 JDK 9 中与核心模块分开，并最终在 JDK 11 移除。如果需要，则应该通过 maven 中心获取 <code>javax.annotation-api</code> 组件，简单地添加到类路径中。</p>
</blockquote>
<h3 id="1-10-Classpath-Scanning-and-Managed-Components"><a href="#1-10-Classpath-Scanning-and-Managed-Components" class="headerlink" title="1.10. Classpath Scanning and Managed Components"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-classpath-scanning">1.10. Classpath Scanning and Managed Components</a></h3><p>通过隐式地类路径扫描找到候选组件。候选组件是那些与过滤器标准相匹配的类，并且会有一个相关的 bean 定义被注册到容器中。这会消除使用 XML 执行 bean 定义的需求。取而代之的，你可以使用注解，AspectJ 类型表达式，或者你自己自定义的过滤器原则来挑选出注册到容器中的 bean 定义。</p>
<h4 id="1-10-1-Component-and-Further-Stereotype-Annotations"><a href="#1-10-1-Component-and-Further-Stereotype-Annotations" class="headerlink" title="1.10.1. @Component and Further Stereotype Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-stereotype-annotations">1.10.1. @Component and Further Stereotype Annotations</a></h4><p><code>@Repository</code> 是那些具有仓库（也可以认为是 Data Access Object）作用的类的标记。</p>
<p>Spring 提供了更多注解：<code>@Component</code>, <code>@Service</code>, <code>@Controller</code>。<code>@Component</code> 对于任何 Spring 管理的组件来说，是一个通用注解。<code>@Repository</code>, <code>@Service</code>, <code>@Controller</code> 是 <code>@Component</code> 的特例。因此，你可以用 <code>@Component</code> 注解你的组件类，但是，通过用 <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code> 注解，你的类可以更好地通过工具处理，或者与切面关联。</p>
<h4 id="1-10-2-Using-Meta-annotations-and-Composed-Annotations"><a href="#1-10-2-Using-Meta-annotations-and-Composed-Annotations" class="headerlink" title="1.10.2. Using Meta-annotations and Composed Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-meta-annotations">1.10.2. Using Meta-annotations and Composed Annotations</a></h4><p>Spring 提供的许多注解可以作为你自己代码的元注解，以供其他注解使用。</p>
<p>你可以组合元注解创建组合型注解。例如，<code>@RestController</code> 注解就是 Spring MVC 框架中，由 <code>@Controller</code> 和 <code>@ResponseBody</code> 组合而成。</p>
<h4 id="1-10-3-Automatically-Detecting-Classes-and-Registering-Bean-Definitions"><a href="#1-10-3-Automatically-Detecting-Classes-and-Registering-Bean-Definitions" class="headerlink" title="1.10.3. Automatically Detecting Classes and Registering Bean Definitions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-scanning-autodetection">1.10.3. Automatically Detecting Classes and Registering Bean Definitions</a></h4><p>Spring 可以自动检测刻板印象类，并注册相关的 <code>BeanDefinition</code> 实例到 <code>ApplicationContext</code>。例如，以下两个类有资格被自动检测到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了自动检测类并注册相关的 bean，需要将 <code>@ComponentScan</code> 添加到 <code>@Configuraion</code> 类上，其中，<code>@ComponentScan</code> 的 <code>basePackages</code> 属性是这些的共有父包。</p>
<blockquote>
<ul>
<li>你可以指定多个父包，以逗号（<code>,</code>）或者分号（<code>;</code>）或者空格分隔。</li>
</ul>
</blockquote>
<p>如果你使用 XML，则可以以如下代码替代：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当你使用 <code>&lt;component-scan/&gt;</code> 元素时 ，<code>AutowiredAnnotationBeanPostProcessor </code> 和 <code>CommonAnnotationBeanPostProcessor </code> 两者会隐式地包含进来。</p>
<blockquote>
<ul>
<li>你可以通过包含 <code>annotation-config</code>，设置其值为 <code>false</code> 来禁用 <code>AutowiredAnnotationBeanPostProcessor </code> 和 <code>CommonAnnotationBeanPostProcessor </code> 的注册。</li>
</ul>
</blockquote>
<h4 id="1-10-4-Using-Filters-to-Customize-Scanning"><a href="#1-10-4-Using-Filters-to-Customize-Scanning" class="headerlink" title="1.10.4. Using Filters to Customize Scanning"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-scanning-filters">1.10.4. Using Filters to Customize Scanning</a></h4><p>默认地，本身是用 @Component 注解的类，会被检测作为候选组件。但是也可以配置过滤器。</p>
<h4 id="1-10-5-Defining-Bean-Metadata-within-Components"><a href="#1-10-5-Defining-Bean-Metadata-within-Components" class="headerlink" title="1.10.5. Defining Bean Metadata within Components"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factorybeans-annotations">1.10.5. Defining Bean Metadata within Components</a></h4><h4 id="1-10-8-Providing-Qualifier-Metadata-with-Annotations"><a href="#1-10-8-Providing-Qualifier-Metadata-with-Annotations" class="headerlink" title="1.10.8. Providing Qualifier Metadata with Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-scanning-qualifiers">1.10.8. Providing Qualifier Metadata with Annotations</a></h4><h3 id="1-11-Using-JSR-330-Standard-Annotations"><a href="#1-11-Using-JSR-330-Standard-Annotations" class="headerlink" title="1.11. Using JSR 330 Standard Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-standard-annotations">1.11. Using JSR 330 Standard Annotations</a></h3><p>从 Spring 3.0 开始，Spring 为 JSR-330 标准注解（依赖注入）提供了支持。这些注解与 Spring 注解一样以相同的方式被扫描。要使用他们，你必须在类路径中持有相关的 jar 包。</p>
<blockquote>
<p>如果你使用 maven，<code>javax.inject</code> 的 artifact 可以在标准 maven 仓库（<a href="https://repo1.maven.org/maven2/javax/inject/javax.inject/1/%EF%BC%89%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%BE%97%E3%80%82%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B7%BB%E5%8A%A0%E5%88%B0">https://repo1.maven.org/maven2/javax/inject/javax.inject/1/）直接获得。你可以将下面的依赖添加到</a> pom.xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="1-11-1-Dependency-Injection-with-Inject-and-Named"><a href="#1-11-1-Dependency-Injection-with-Inject-and-Named" class="headerlink" title="1.11.1. Dependency Injection with @Inject and @Named"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-inject-named">1.11.1. Dependency Injection with @Inject and @Named</a></h4><p>为了代替 <code>@Autowired</code>，你可以使用 <code>@javax.inject.Inject</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listMovies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder.findMovies(...);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>@Autowired</code> 一样，你可以在字段级别，方法级别，构造函数级别内使用 <code>@Inject</code>。此外，你可以将注入点声明为一个 <code>Provider</code>，从而可以按需访问较短的范围或者通过调用 <code>Provider.get()</code> 来懒惰地访问其他 Bean。以下的示例提供了前面示例的变体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Provider&lt;MovieFinder&gt; movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(Provider&lt;MovieFinder&gt; movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listMovies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder.get().findMovies(...);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想使用注入依赖的限定名称，可以使用 <code>@Named</code> 注解，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(<span class="meta">@Named(&quot;main&quot;)</span> MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 <code>@Autowired</code> 一样，<code>@Inject</code> 也可以与 <code>java.util.Optional</code> 或者 <code>@Nullable</code> 一起使用。在这里甚至更合适，因为 <code>@Inject</code> 没有 <code>require</code> 属性。以下一对示例展示了如何使用 <code>@Inject</code> 和 <code>@Nullable</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(Optional&lt;MovieFinder&gt; movieFinder)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-11-2-Named-and-ManagedBean-Standard-Equivalents-to-the-Component-Annotation"><a href="#1-11-2-Named-and-ManagedBean-Standard-Equivalents-to-the-Component-Annotation" class="headerlink" title="1.11.2. @Named and @ManagedBean: Standard Equivalents to the @Component Annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-named">1.11.2. @Named and @ManagedBean: Standard Equivalents to the @Component Annotation</a></h4><p>你可以使用 <code>@javax.inject.Named</code> 或者 <code>@javax.annotation.ManagedBean</code> 代替 <code>@Component</code>，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named(&quot;movieListener&quot;)</span>  <span class="comment">// @ManagedBean(&quot;movieListener&quot;) could be used as well</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@Component</code> 而不为组件指定名称非常常见。<code>@Named</code> 可以以类似的方式使用，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你使用 <code>@Named</code> 或者 <code>@ManagedBean</code> 时，你可以以与使用 Spring 注解时完全相同方式进行组件扫描，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与 <code>@Component</code> 相反，JSR-330 <code>@Named</code> 和 JSR-250 <code>@ManagedBean</code> 注解是不可组合的。你应该使用 Spring 的刻板印象模型来构建自定义的注解。</p>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> 之所以无法构建自定义的组合注解，是因为 Spring 不会去检查你的自定义注解。见 <code>ClassPathScanningCandidateComponentProvider</code> 的 <code>includeFilters</code>。</p>
</blockquote>
<h4 id="1-11-3-Limitations-of-JSR-330-Standard-Annotations"><a href="#1-11-3-Limitations-of-JSR-330-Standard-Annotations" class="headerlink" title="1.11.3. Limitations of JSR-330 Standard Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-standard-annotations-limitations">1.11.3. Limitations of JSR-330 Standard Annotations</a></h4><p>当你使用标准注解时，你应该知道，有一些重要功能是不可用的，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">Spring</th>
<th align="left">java.inject.*</th>
<th align="left">javax.inject restrictions &#x2F; comments</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Autowired</td>
<td align="left">@Inject</td>
<td align="left"><code>@Inject</code> 没有 required 属性。可以用 Java 8 的 <code>Optional</code> 替代</td>
</tr>
<tr>
<td align="left">@Component</td>
<td align="left">@Named &#x2F; @ManagedBean</td>
<td align="left">JSR-330 未提供组合的模型，只是一种识别命名组件的方式</td>
</tr>
<tr>
<td align="left">@Scope(“singleton”)</td>
<td align="left">@Singleton</td>
<td align="left">JSR-330 默认范围就像 Spring 的 <code>prototype</code>。但是，为了使其与 Spring 的一般默认值保持一致，声明在 容器中的 JSR-330 Bean 默认是 <code>singleton</code>。为了使用 <code>singleton</code> 意外的范围，你应该使用 Spring 的 <code>@Scope</code> 注解。<code>javax.inject</code> 也提供了一个 <code>@Scope</code> 注解。然而，这仅仅用于创建你自己的注解。</td>
</tr>
<tr>
<td align="left">@Qualifier</td>
<td align="left">@Qualifier &#x2F; @Named</td>
<td align="left"><code>javax.inject.Qualifier</code> 仅仅是一个用于构建自定义 qualifier 的元注解。可以通过 <code>javax.inject.Named</code> 关联具体的 <code>String</code> 限定词（就像 Spring 带有一个值的 <code>@Qualifier</code>）</td>
</tr>
<tr>
<td align="left">@Value</td>
<td align="left">-</td>
<td align="left">没有对等体</td>
</tr>
<tr>
<td align="left">@Required</td>
<td align="left">-</td>
<td align="left">没有对等体</td>
</tr>
<tr>
<td align="left">@Lazy</td>
<td align="left">-</td>
<td align="left">没有对等体</td>
</tr>
<tr>
<td align="left">ObjectFactory</td>
<td align="left">Provider</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="1-12-Java-based-Container-Configuration"><a href="#1-12-Java-based-Container-Configuration" class="headerlink" title="1.12. Java-based Container Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java">1.12. Java-based Container Configuration</a></h3><h4 id="1-12-1-Basic-Concepts-Bean-and-Configuration"><a href="#1-12-1-Basic-Concepts-Bean-and-Configuration" class="headerlink" title="1.12.1. Basic Concepts: @Bean and @Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts">1.12.1. Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></a></h4><p>在 Spring 新的 Java 注解支持中的中央工件是 <code>@Configuration</code> 注解类以及 <code>@Bean</code> 注解方法。</p>
<p><code>@Bean</code> 注解用于表明方法是实例化，配置和初始化一个由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring <code>&lt;bean/&gt;</code> XML 配置的人，<code>@Bean</code> 注解扮演着与 <code>&lt;bean/&gt;</code> 元素相同的角色。</p>
<h4 id="1-12-2-Instantiating-the-Spring-Container-by-Using-AnnotationConfigApplicationContext"><a href="#1-12-2-Instantiating-the-Spring-Container-by-Using-AnnotationConfigApplicationContext" class="headerlink" title="1.12.2. Instantiating the Spring Container by Using AnnotationConfigApplicationContext"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container">1.12.2. Instantiating the Spring Container by Using <code>AnnotationConfigApplicationContext</code></a></h4><p><code>AnnotationConfigApplicationContext</code> 在<br>以下各节记录了 Spring 的 <code>AnnotationConfigApplicationContext</code>，在 Spring 3.0 引入。这种万能的 <code>ApplicationContext</code> 实现不仅能接收 <code>@Configuration</code> 类作为输入，而且能够接受 <code>@Component</code> 类以及 JSR-330 元数据注解的类。</p>
<p>当提供 <code>@Configuration</code> 类作为输入时，<code>@Configuration</code> 类本身被注册为 Bean Definition，并且在类中声明的所有 <code>@Bean</code> 方法也都会注册为 Bean Definition。</p>
<p>当 <code>@Component</code> 或者 JSR-330 注解的类作为输入时，它们会注册为 Bean Definition，并且在必要时，这些类中的依赖元数据，例如 <code>@Autowired</code> 或者 <code>@Inject</code> 都会被使用。</p>
<h5 id="Simple-Construction"><a href="#Simple-Construction" class="headerlink" title="Simple Construction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-constructor">Simple Construction</a></h5><p>与实例化 <code>ClassPathXmlApplicationContext</code> 时使用 Spring XML 文件作为输入的方式相同，当你实例化一个 <code>AnnotationConfigApplicationContext</code> 时，你可以使用 <code>@Configuration</code> 类作为输入。这是考虑到完全无 XML 的 Spring 容器的使用，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前面说的，<code>AnnotationConfigApplicationContext</code> 不仅限于与 <code>@Configuration</code> 类一起使用。任意 <code>@Component</code> 或者 JSR-330 注解类都可以作为输入提供给构造器，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的示例假定 <code>MyServiceImpl</code>，<code>Dependency1</code>，以及 <code>Dependency2</code> 使用了 Spring 依赖注入注解，例如 <code>@Autowired</code>。</p>
<h5 id="Building-the-Container-Programmatically-by-Using-register-Class-lt-gt-…​"><a href="#Building-the-Container-Programmatically-by-Using-register-Class-lt-gt-…​" class="headerlink" title="Building the Container Programmatically by Using register(Class&lt;?&gt;…​)"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-register">Building the Container Programmatically by Using <code>register(Class&lt;?&gt;…​)</code></a></h5><p>你可以通过使用无参构造器实例化一个 <code>AnnotationConfigApplicationContext</code>，然后使用 <code>register()</code> 对其进行配置。当程序化地构建了一个 <code>AnnotationConfigApplicationContext</code> 这种方式特别有用。以下示例显示了如何做到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">    ctx.register(AdditionalConfig.class);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Enabling-Component-Scanning-with-scan-String…​"><a href="#Enabling-Component-Scanning-with-scan-String…​" class="headerlink" title="Enabling Component Scanning with scan(String…​)"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-scan">Enabling Component Scanning with <code>scan(String…​)</code></a></h5><p>要启用组件扫描，你可以按以下方式注解 <code>@Configuration</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.acme&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，扫描 <code>com.acme</code> 包查找 <code>@Component</code> 注解的类，并且这些类以 Spring Bean Definition 的形式注册在容器中。<code>AnnotationConfigApplicationContext</code> 暴露了 <code>scan(String...)</code> 方法，以允许相同组件扫描功能，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    ctx.scan(<span class="string">&quot;com.acme&quot;</span>);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Support-for-Web-Applications-with-AnnotationConfigWebApplicationContext"><a href="#Support-for-Web-Applications-with-AnnotationConfigWebApplicationContext" class="headerlink" title="Support for Web Applications with AnnotationConfigWebApplicationContext"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-web">Support for Web Applications with <code>AnnotationConfigWebApplicationContext</code></a></h5><p><code>AnnotationConfigApplicationContext</code> 的 <code>WebApplicationContext</code> 变体可用 <code>AnnotationConfigWebApplicationContext</code>。你在在配置 Spring <code>ContextLoaderListener</code> Servlet Listener，Spring MVC <code>DispatcherServlet</code> 等时候，使用此实现。下面的 <code>web.xml</code> 摘要配置了一个典型的 Spring MVC Web 应用（请注意 <code>contextClass</code> context-param 和 init-param 的使用）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext</span></span><br><span class="line"><span class="comment">        instead of the default XmlWebApplicationContext --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited</span></span><br><span class="line"><span class="comment">        fully-qualified @Configuration classes. Fully-qualified packages may also be</span></span><br><span class="line"><span class="comment">        specified for component-scanning --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext</span></span><br><span class="line"><span class="comment">            instead of the default XmlWebApplicationContext --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited</span></span><br><span class="line"><span class="comment">            and fully-qualified @Configuration classes --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h4 id="1-12-3-Using-the-Bean-Annotation"><a href="#1-12-3-Using-the-Bean-Annotation" class="headerlink" title="1.12.3. Using the @Bean Annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-bean-annotation">1.12.3. Using the <code>@Bean</code> Annotation</a></h4><p><code>@Bean</code> 是一种方法级注解，是 <code>&lt;bean/&gt;</code> 元素的等价。注解支持一些 <code>&lt;bean/&gt;</code> 提供的属性，例如：*init-method destroy-method autowiring name.</p>
<p>你可以在 <code>@Configuration</code> 注解类或者 <code>@Component</code> 注解类中使用 <code>@Bean</code> 注解。</p>
<h5 id="Declaring-a-Bean"><a href="#Declaring-a-Bean" class="headerlink" title="Declaring a Bean"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-declaring-a-bean">Declaring a Bean</a></h5><p>要声明一个 Bean，你可以用使用 <code>@Bean</code> 注解一个方法。你可以使用此方法在 <code>ApplicationContext</code> 中注册一个 Bean Definition，其类型由方法返回值指定。默认地，Bean 名称与方法名称相同。以下示例展示了 <code>@Bean</code> 方法声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferServiceImpl <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的配置完全等同于以下 Spring XML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;transferService&quot;</span> class=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>这两种声明都使一个名为 <code>transferService</code> 的 bean 在 <code>ApplicationContext</code> 中可获得，绑定到类型为 <code>TransferServiceImpl</code> 的对象实例上，如下文本图形所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">transferService -&gt; com.acme.TransferServiceImpl</span><br></pre></td></tr></table></figure>

<p>你也可以用接口（或者基类）返回值声明你的 <code>@Bean</code> 方法，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这将预先类型预测的可见性限制为指定的接口类型（<code>TransferService</code>）。然后，只有一次容器知道完全类型，被影响的单例已经被实例化。非懒惰单例 bean 根据其声明 order 初始化。因此，你可能看到不同类型的匹配结果，具体取决于其他组件试图通过非声明类型（例如 @Autowired TransferServiceImple，只有在实例化了 <code>TransferService</code> bean 之后才能解析）匹配。</p>
<h5 id="Bean-Aliasing"><a href="#Bean-Aliasing" class="headerlink" title="Bean Aliasing"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-bean-aliasing">Bean Aliasing</a></h5><p>正如 Naming Beans 讨论的，有时候希望给一个 bean 多个名字，也成为 bean 别名。</p>
<p>如果希望给 bean 赋予多个名称，或者称之为别名，你可以向 <code>@Bean</code> 的 <code>name</code> 属性传递一个字符串数组。为此，<code>@Bean</code> 注解的 <code>name</code> 属性接受一个字符串数组。以下示例显示了如何为一个 bean 设置许多别名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&#123;&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// instantiate, configure and return DataSource bean...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-12-4-Using-the-Configuration-annotation"><a href="#1-12-4-Using-the-Configuration-annotation" class="headerlink" title="1.12.4. Using the @Configuration annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-configuration-annotation">1.12.4. Using the <code>@Configuration</code> annotation</a></h4><p><code>@Configuration</code> 是一个类级别的注解，表明一个对象是 Bean Definition 的来源。<code>@Configuration</code> 类通过 public <code>@Bean</code> 注解方法声明 Bean。<code>@Configuration</code> 类上的 <code>@Bean</code> 方法的调用也可以用于定义 Bean 之间的依赖。</p>
<h5 id="Injecting-Inter-bean-Dependencies"><a href="#Injecting-Inter-bean-Dependencies" class="headerlink" title="Injecting Inter-bean Dependencies"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-injecting-dependencies">Injecting Inter-bean Dependencies</a></h5><p>当 Bean 依赖于另一个 Bean 时，表现为依赖让一个 Bean 方法调用另一个一样简单，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanOne <span class="title function_">beanOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanOne</span>(beanTwo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanTwo <span class="title function_">beanTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanTwo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，<code>beanOne</code> 通过构造器注入接收一个对 <code>beanTwo</code> 的引用。</p>
<blockquote>
<p>仅当 <code>@Bean</code> 方法声明在 <code>@Configuration</code> 类中时，这种声明 Bean 间依赖的方法才生效。你无法通过使用普通 <code>@Component</code> 类声明 Bean 间依赖。</p>
</blockquote>
<h5 id="Lookup-Method-Injection"><a href="#Lookup-Method-Injection" class="headerlink" title="Lookup Method Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-method-injection">Lookup Method Injection</a></h5><p>如前所述，lookup method injection 是你比较少用的高级功能。在单例 Bean 依赖于原型 Bean 时这很有用。使用 Java 进行此类配置提供了一种天然的方式用于实现这种模式。下面的例子展示了如何查找方法注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 Java 配置，你可以创建一个 <code>CommandManager</code> 子类，其中抽象方法 <code>createCommand()</code> 被覆盖以查找一个新的（prototype）Command 对象。下面的示例展示了如何做到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AsyncCommand <span class="title function_">asyncCommand</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AsyncCommand</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncCommand</span>();</span><br><span class="line">    <span class="comment">// inject dependencies here as required</span></span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandManager <span class="title function_">commandManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// return new anonymous implementation of CommandManager with createCommand()</span></span><br><span class="line">    <span class="comment">// overridden to return a new prototype Command object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandManager</span>() &#123;</span><br><span class="line">        <span class="keyword">protected</span> Command <span class="title function_">createCommand</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> asyncCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-12-5-Composing-Java-based-Configurations"><a href="#1-12-5-Composing-Java-based-Configurations" class="headerlink" title="1.12.5. Composing Java-based Configurations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-composing-configuration-classes">1.12.5. Composing Java-based Configurations</a></h4><p>Spring 的基于 Java 的配置特色让你可以组合注解，从而降低配置的复杂度。</p>
<h5 id="Using-the-Import-Annotation"><a href="#Using-the-Import-Annotation" class="headerlink" title="Using the @Import Annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-using-import">Using the @Import Annotation</a></h5><p>就像在 Spring XML 文件中使用 <code>&lt;import/&gt;</code> 元素以帮助模块化配置，<code>@Import</code> 注解也允许你从另一个配置类加载 <code>@Bean</code> 定义，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种功能的引入旨在简化容器实例化，只用准备一个你需要的类，而不是记住所有的 <code>@Configuration</code></p>
<blockquote>
<p>自从 Spring Framework 4.2，<code>@Import</code> 也支持引用普通 Component 类。当你不希望组件扫描时，这是比较有用的，通过少数几个配置类作为入口点，从而定义你需要的组件。</p>
</blockquote>
<p>&amp;nbsp;<br><code>@Import</code> 支持以下几种用法：</p>
<ul>
<li>导入普通 Bean</li>
<li>导入 ImportSelector 实现类</li>
<li>导入 ImportBeanDefinitionRegistrar 实现类</li>
</ul>
<p>更多 <code>@Import</code> 用法参见 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html">API</a></p>
<p><strong>框架案例</strong> MyBatis 的自动扫描 @Mapper 注入，@Import(AutoConfiguredMapperScannerRegistrar.class)</p>
<p>&amp;nbsp;</p>
<h5 id="Conditionally-Include-Configuration-Classes-or-Bean-Methods"><a href="#Conditionally-Include-Configuration-Classes-or-Bean-Methods" class="headerlink" title="Conditionally Include @Configuration Classes or @Bean Methods"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-conditional">Conditionally Include @Configuration Classes or @Bean Methods</a></h5><p>有条件地启用或禁用完整的 @Configuration 类，甚至单个 @Bean 方法。最常用的是使用 <code>@Profile</code>。</p>
<p><code>@Profile</code> 注解实际上是通过更灵活的称之为 <code>@Conditional</code> 的注解实现。<code>@Conditional</code> 注解表示：特定的 <code>org.springframework.context.annotation.Condition</code> 实现应该在 @Bean 注册之前作为参考。</p>
<p><code>Condition</code> 的接口实现提供了一个 <code>matches(...)</code> 方法，它返回 true 或者 false。</p>
<h5 id="Combining-Java-and-XML-Configuration"><a href="#Combining-Java-and-XML-Configuration" class="headerlink" title="Combining Java and XML Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-combining">Combining Java and XML Configuration</a></h5><p>Spring 的 @Configuration 类支持并不是为了完全取代 XML 配置。某些情况下，Spring XML 仍然是一种配置容器的理想方式。在 XML 比较方便或者必须使用的情况下，你可以选择：通过使用例如 <code>ClassPathXmlApplicationContext</code> 以 “XML为中心” 的方式实例化容器；或者以 “Java 为中心” 的方式实例化容器，使用 <code>AnnotationConfigApplicationContext</code> 以及 <code>@ImportResource</code> 注解导入所需的 XML</p>
<h6 id="XML-centric-Use-of-Configuration-Classes"><a href="#XML-centric-Use-of-Configuration-Classes" class="headerlink" title="XML-centric Use of @Configuration Classes"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-combining-xml-centric">XML-centric Use of <code>@Configuration</code> Classes</a></h6><p>也许最好的方式是从 XML 中引导 Spring 容器，并以点对点的方式包含 <code>@Configuration</code> 类。例如，在一个使用 Spring XML 的大型的现有代码库中，很容易在需要的基础上创建 <code>@Configuration</code> 类，并将他们从现存的 XML 文件中包含进去。稍后在本节中，我们会介绍这种 “以 XML 为中心” 情况下使用 <code>@Configuration</code> 类的选项。</p>
<p><strong>Declaring <code>@Configuration</code> classes as plain Spring <code>&lt;bean/&gt;</code> elements</strong></p>
<p>记住，<code>@Configuration</code> 类最终是容器中的 Bean Definition。在本系列示例中，我们创建了一个名为 <code>AppConfig</code> 的 <code>@Configuration</code>，并以一个 <code>&lt;bean/&gt;</code> 定义将其包含进 <code>system-test-config.xml</code> 中。因为 <code>&lt;context:annotaion-config/&gt;</code> 已经开启，容器会识别 <code>@Configuration</code> 注解并正确处理 <code>AppConfig</code> 中声明的 <code>@Bean</code> 方法。</p>
<p>以下示例展示了 Java 中一个普通的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccountRepository <span class="title function_">accountRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferService</span>(accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例展示了案例 <code>system-test-config.xml</code> 文件的部分：<br>&#96;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;!-- enable processing of annotations such as <span class="meta">@Autowired</span> and <span class="meta">@Configuration</span> --&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;context:property-placeholder location=<span class="string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=<span class="string">&quot;com.acme.AppConfig&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>以下示例展示了可能的 <code>jdbc.properties</code> 文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:hsqldb:hsql://localhost/xdb</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:/com/acme/system-test-config.xml&quot;</span>);</span><br><span class="line">    <span class="type">TransferService</span> <span class="variable">transferService</span> <span class="operator">=</span> ctx.getBean(TransferService.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Using &lt;context:component-scan&#x2F;&gt; to pick up <code>@Configuration</code> classes</strong></p>
<h6 id="Configuration-Class-centric-Use-of-XML-with-ImportResource"><a href="#Configuration-Class-centric-Use-of-XML-with-ImportResource" class="headerlink" title="[@Configuration Class-centric Use of XML with @ImportResource]"></a>[<code>@Configuration</code> Class-centric Use of XML with <code>@ImportResource</code>]</h6><p>在一些 <code>@Configuration</code> 类是配置容器的主要机制的应用中，仍然很可能有必要至少使用一些 XML。在这些情况下，你可以使用 <code>@ImportResource</code>，并按你所需定义 XML。这样做可以实现一种 “以 Java 为中心” 的方式配置容器，并将 XML 保持在最低限度。以下示例展示了如何使用 <code>@ImportSource</code> 注解来实现按需使用 XML 的 “以 Java 为中心” 的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">properties-config.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.properties</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:hsqldb:hsql://localhost/xdb</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">    <span class="type">TransferService</span> <span class="variable">transferService</span> <span class="operator">=</span> ctx.getBean(TransferService.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-13-Environment-Abstraction"><a href="#1-13-Environment-Abstraction" class="headerlink" title="1.13. Environment Abstraction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-environment">1.13. Environment Abstraction</a></h3><p><code>Environment</code> 接口是一个集成在容器中的抽象，它模型化了两个关键的应用程序环境方面：profiles 和 properties。</p>
<p>一个 profile 是一个有名的 Bean Definition 逻辑组，仅在给定的 profile 处于激活状态时，Bean Definition 才能注册到容器中。无论是以 XML 方式还是注解方式，bean 都可以分配给一个 profile。<code>Environment</code> 关于 profiles 的作用就是决定哪个 profile 当前是激活的，哪个 profiles 应该默认被激活。</p>
<p>属性在几乎所有应用程序都发挥着重要作用，并且可能来自各种源：属性文件，JVM 系统属性，系统环境变量，JNDI，Servlet 上下文参数，ad-hoc <code>Properties</code> 对象，<code>Map</code> 对象等。<code>Environment</code> 对象对于属性的作用就是提供用户一个方便的服务接口，用于配置属性源以及从中解析属性。</p>
<h4 id="1-13-1-Bean-Definition-Profiles"><a href="#1-13-1-Bean-Definition-Profiles" class="headerlink" title="1.13.1. Bean Definition Profiles"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles">1.13.1. Bean Definition Profiles</a></h4><p>Bean Definition profile 在核心容器中提供了一种机制，可以在不同环境中注册不同的 bean。”environment” 一词对于不同用户来说可能意味着不同的事物，该功能有助于许多用例，例如：</p>
<p>考虑在实际需要 <code>DataSource</code> 的应用的第一个用例。在测试环境中，配置可能类似于下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class="line">        .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">        .addScript(<span class="string">&quot;my-schema.sql&quot;</span>)</span><br><span class="line">        .addScript(<span class="string">&quot;my-test-data.sql&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Using-Profile"><a href="#Using-Profile" class="headerlink" title="Using @Profile"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java">Using <code>@Profile</code></a></h5><p><code>@Profile</code> 注解允许你指示当一个或多个指定 profile 激活时，一个组件才有资格注册。</p>
<p><code>@Profile</code> 也可以在方法级别声明，这样仅包括了配置类的一个特定 bean。</p>
<h5 id="XML-Bean-Definition-Profiles"><a href="#XML-Bean-Definition-Profiles" class="headerlink" title="XML Bean Definition Profiles"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-xml">XML Bean Definition Profiles</a></h5><p>XML 对应的是 <code>&lt;bean/&gt;</code> 元素的 <code>profile</code> 属性。我们前面的示例配置可以以两个 XML 文件的方式重写，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;development&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以避免拆分，并在同一个文件中嵌套 <code>&lt;beans/&gt;</code> 元素，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other bean definitions --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 嵌套 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Activating-a-Profile"><a href="#Activating-a-Profile" class="headerlink" title="Activating a Profile"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-enable">Activating a Profile</a></h5><p>可以以多种方式激活 profile：</p>
<ul>
<li>Environment API 方式</li>
<li>spring.profiles.active</li>
</ul>
<p>最简单的是使用 <code>ApplicationContext</code> 的 <code>Environment</code> API 以编程方式激活：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;development&quot;</span>);</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;profile1&quot;</span>, <span class="string">&quot;profile2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>还可以通过 <code>spring.profiles.active</code> 属性激活配置文件，可以通过系统环境变量，JVM 系统属性，web.xml 中的 servlet 上下文参数，甚至是在 JNDI 中的条目指定。<code>spring.profiles.active</code> 可以接受以逗号（<code>,</code>）分割的 profile 名称列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dspring.profiles.active=<span class="string">&quot;profile1,profile2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="Default-Profile"><a href="#Default-Profile" class="headerlink" title="Default Profile"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-default">Default Profile</a></h5><p>默认的 profile 表示默认启用的 profile。考虑如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultDataConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有激活任何 profile，<code>dataSource</code> 会被创建。你可以将其视为为一个或多个 Bean 提供默认定义的一种方式。如果启用了任意 profile，默认的 profile 不再使用。</p>
<p>你可以通过在 <code>Environment</code> 上使用 <code>setDefaultPrfiles()</code> 或者声明式地使用 <code>spring.profiles.default</code> 来修改默认 profile 的名称。</p>
<h4 id="1-13-2-PropertySource-Abstraction"><a href="#1-13-2-PropertySource-Abstraction" class="headerlink" title="1.13.2. PropertySource Abstraction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-property-source-abstraction">1.13.2. <code>PropertySource</code> Abstraction</a></h4><p>Spring 的 <code>Environment</code> 抽象在属性源的可配置层次结构上提供了搜索操作。考虑下面的代码清单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="type">Environment</span> <span class="variable">env</span> <span class="operator">=</span> ctx.getEnvironment();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">containsMyProperty</span> <span class="operator">=</span> env.containsProperty(<span class="string">&quot;my-property&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Does my environment contain the &#x27;my-property&#x27; property? &quot;</span> + containsMyProperty);</span><br></pre></td></tr></table></figure>

<p>在前面的片段中，我们看到了一种高级方法，其询问 Spring 是否为当前环境定义了 <code>my-property</code> 属性。为了回答这个问题，<code>Environment</code> 对象会对一组 <code>PropertySource</code> 对象执行搜索。<code>PropertySource</code> 是任何键值对源的简单抽象，并且 Spring 的 <code>StandardEnvironment</code> 配置了两个 <code>PropertySource</code> 对象 —— 一个代表 JVM 系统属性集（<code>System.getProperties()</code>），一个代表系统环境变量集（<code>System.getenv()</code>）。</p>
<blockquote>
<p>这些默认的属性源存在于 <code>StandardEnvironment</code>，用于独立应用。<code>StandardServletEnvironment</code> 填充了其他默认的属性源，包括 Servlet Config 以及 Servlet Context 参数。它可以选择性的启用 <code>JndiPropertySource</code>。详细信息参见 javadoc。</p>
</blockquote>
<p>具体而言，当你使用 <code>StandardEnvironment</code> 时，如果在运行时具有 <code>my-property</code> 系统属性或者 <code>my-property</code> 环境变量，调用 <code>env.containsProperty(&quot;my-property&quot;)</code> 就会返回 true。</p>
<blockquote>
<p>执行搜索是分层次的。默认地，系统属性优先于环境变量。因此，如果在调用 <code>env.getProperty(&quot;my-property&quot;)</code> 期间 <code>my-property</code> 属性在两个地方都发生了赋值，系统属性值会”胜利”并返回。请注意，属性值并不会合并，而是完全被前面的条目覆盖。<br>对于通用的 <code>StandardServletEnvironment</code>，完整的层次结构如下，优先级最高的在最顶端：</p>
<ol>
<li>ServletConfig 参数（如果适用，例如，在 <code>DispatcherServlet</code> 上下文的情况下）</li>
<li>ServletContext 参数（web.xml 上下文参数条目）</li>
<li>JNDI 环境变量（<code>java:comp/env/</code> 条目）</li>
<li>JVM 系统属性（<code>-D</code> 命令行参数）</li>
<li>JVM 系统环境（操作系统环境变量）</li>
</ol>
</blockquote>
<p>最重要的是，整个机制都是可配置的。也许你有一个自定义的属性源，要将其继承到此搜索中。为此，实现并实例化你自己的 <code>PropertySource</code> 并将其添加到当前 <code>Environment</code> 的 <code>PropertySources</code> 集合中。下面示例展示了怎么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="type">MutablePropertySources</span> <span class="variable">sources</span> <span class="operator">=</span> ctx.getEnvironment().getPropertySources();</span><br><span class="line">sources.addFirst(<span class="keyword">new</span> <span class="title class_">MyPropertySource</span>());</span><br></pre></td></tr></table></figure>

<p>在前面的代码中，在搜索中以高优先级添加了 <code>MyPropertySource</code>。如果它包含 <code>my-property</code> 属性，属性会被检测并返回，支持其他任何 <code>PropertySource</code> 中的任何 <code>my-property</code> 属性。<code>MutablePropertySources</code> API 暴露了许多方法，这些方法允许精确地操纵属性源集合。</p>
<h4 id="1-13-3-Using-PropertySource"><a href="#1-13-3-Using-PropertySource" class="headerlink" title="1.13.3. Using @PropertySource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-using-propertysource">1.13.3. Using <code>@PropertySource</code></a></h4><p><code>@PropertySource</code> 注解提供了一种便捷的声明式机制，用于将 <code>PropertySource</code> 添加到 Spring 的 <code>Environment</code> 中。</p>
<p>给定一个名为 <code>app.properties</code> 的文件，包含键值对 <code>testbean.name=myTestBean</code>，下面的 <code>@Configuration</code> 类使用 <code>@PropertySource</code>，以这种方式调用 <code>testBean.getName()</code> 返回 <code>myTestBean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">testBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TestBean</span> <span class="variable">testBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>();</span><br><span class="line">        testBean.setName(env.getProperty(<span class="string">&quot;testbean.name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> testBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现在 <code>@PropertySource</code> 中的任何 <code>$&#123;...&#125;</code> 占位符都会用已经注册到 Environment 中的属性源集合进行解析，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">testBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TestBean</span> <span class="variable">testBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>();</span><br><span class="line">        testBean.setName(env.getProperty(<span class="string">&quot;testbean.name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> testBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假定 <code>my.placeholder</code> 存在于已经注册的属性源之一（例如，系统属性或者环境变量）中，占位符会被解析为相关值。如果不存在，那么 <code>default/path</code> 会被作为默认值。如果未指定默认值，且属性无法解析，将会抛出 <code>IllegalArgumentException</code>。</p>
<h4 id="1-13-4-Placeholder-Resolution-in-Statements"><a href="#1-13-4-Placeholder-Resolution-in-Statements" class="headerlink" title="1.13.4. Placeholder Resolution in Statements"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-placeholder-resolution-in-statements">1.13.4. Placeholder Resolution in Statements</a></h4><p>过去，只针对 JVM 系统属性或者环境变量，元素上的占位符可以被解析。现在已不再这样。因为 <code>Environment</code> 抽象是集成在容器中的，因此很容易通过它来路由占位符的解析。这意味着你可以以任何你喜欢的方式配置解析流程。你可以通过系统属性或者环境变量更改搜索优先级，或者完全移除它们。你还可以适当地添加自己的属性资源。</p>
<p>具体而言，无论 <code>customer</code> 属性定义在哪儿，只要在 <code>Environment</code> 中可获得，下面的语句就可以工作：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;com/bank/service/$&#123;customer&#125;-config.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-14-Registering-a-LoadTimeWeaver"><a href="#1-14-Registering-a-LoadTimeWeaver" class="headerlink" title="1.14. Registering a LoadTimeWeaver"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-load-time-weaver">1.14. Registering a <code>LoadTimeWeaver</code></a></h3><p>Spring 使用 <code>LoadTimeWeaver</code> 当类加载到 Java 虚拟机时，动态转换这些类。</p>
<p>要启动加载时编织，你可以将 <code>@EnableLoadTimeWeaving</code> 添加到你的 <code>@Configuration</code> 类，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableLoadTimeWeaving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，对于 XML 配置，你可以使用 <code>context:load-time-weaver</code> 元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一旦配置为 <code>ApplicationContext</code>，任何在该 <code>ApplicationContext</code> 中的 bean 都可以实现 <code>LoadTimeWeaverAware</code>，从而接收到加载时 weaver 示例的引用。</p>
<h3 id="1-15-Additional-Capabilities-of-the-ApplicationContext"><a href="#1-15-Additional-Capabilities-of-the-ApplicationContext" class="headerlink" title="1.15. Additional Capabilities of the ApplicationContext"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-introduction">1.15. Additional Capabilities of the <code>ApplicationContext</code></a></h3><h4 id="1-15-1-Internationalization-using-MessageSource"><a href="#1-15-1-Internationalization-using-MessageSource" class="headerlink" title="1.15.1. Internationalization using MessageSource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-messagesource">1.15.1. Internationalization using <code>MessageSource</code></a></h4><h4 id="1-15-2-Standard-and-Custom-Events"><a href="#1-15-2-Standard-and-Custom-Events" class="headerlink" title="1.15.2. Standard and Custom Events"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events">1.15.2. Standard and Custom Events</a></h4><p><code>ApplicationContext</code> 中的事件处理功能通过 <code>ApplicationEvent</code> 类以及 <code>ApplicationListener</code> 接口提供。如果一个实现了 <code>ApplicationListener</code> 接口的 bean 部署到上下文中，那么每次 <code>ApplicationEvent</code> 发布到 <code>ApplicationContext</code> 时，该 bean 会被通知。本质上，这是一种标准的观察者模式。</p>
<p>Spring 提供的标准事件：</p>
<ul>
<li><code>ContextRefreshedEvent</code></li>
<li><code>ContextStartedEvent</code></li>
<li><code>ContextStoppedEvent</code></li>
<li><code>ContextClosedEvent</code></li>
<li><code>RequestHandledEvent</code></li>
<li><code>ServletRequestHandledEvent</code></li>
</ul>
<h5 id="Annotation-based-Event-Listeners"><a href="#Annotation-based-Event-Listeners" class="headerlink" title="Annotation-based Event Listeners"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events-annotation">Annotation-based Event Listeners</a></h5><p>在一个 bean 的方法上通过使用 <code>@EventListener</code> 注解注册一个事件监听器。</p>
<p>方法签名声明事件监听的类型。事件的类型可以通过泛型参数缩小范围，只要实际事件类型在其实现架构中解析你的泛型参数。</p>
<p>如果方法应该监听多个事件，或者你不想定义参数，那么可以在注解上指定事件类型。</p>
<p>可以通过 <code>condition</code> 属性定义一个 SpEL 表达式来添加更多的运行时过滤效果。</p>
<h5 id="Asynchronous-Listeners"><a href="#Asynchronous-Listeners" class="headerlink" title="Asynchronous Listeners"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events-async">Asynchronous Listeners</a></h5><p>如果你希望异步地处理某个事件，那你可以使用常规的 <code>@Async</code> 注解。</p>
<h5 id="Ordering-Listeners"><a href="#Ordering-Listeners" class="headerlink" title="Ordering Listeners"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events-order">Ordering Listeners</a></h5><p>如果你需要在另一个监听器之前调用某个监听器，则你可以添加 <code>@Order</code> 注解至方法声明，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Order(42)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBlockedListEvent</span><span class="params">(BlockedListEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Generic-Events"><a href="#Generic-Events" class="headerlink" title="Generic Events"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events-generics">Generic Events</a></h5><p>你可以使用泛型来进一步定义事件的架构。例如，使用 <code>EntityCreatedEvent&lt;T&gt;</code>，其中 <code>T</code> 表示创建的实际实体类型。</p>
<h3 id="1-16-The-BeanFactory"><a href="#1-16-The-BeanFactory" class="headerlink" title="1.16. The BeanFactory"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beanfactory">1.16. The BeanFactory</a></h3><p><code>BeanFactory</code> API 为 Spring IoC 功能提供了基础。它的特定约定主要用于与 Spring 的其他部分以及第三方框架集成，并且它的 <code>DefaultListableBeanFactory</code> 实现是更高级别的 <code>GenericApplicationContext</code> 容器的委托。</p>
<p><code>BeanFactory</code> 和相关接口（如 <code>BeanFactoryAware</code>, <code>InitializingBean</code>, <code>DisposableBean</code>）是其他框架的重要集成点。不需要任何注解或者反射，它们可以非常高效地在容器和组件之间通信。应用程序级别的 bean 可以使用相同的回调接口，但是通常会通过注解或者程序配置的方式进行声明式的依赖注入。</p>
<p>请注意，核心 <code>BeanFactory</code> API 级别和它的 <code>DefaultLisableBeanFactory</code> 实现都没有对配置格式或者任何待使用的组件注解做出规定。所有的风格都通过扩展（如：<code>XmlBeanDefinitionReader</code> 和 <code>AutowiredAnnotationBeanPostProcessor</code>）进行，并在共享的作为核心元数据表现形式的 <code>BeanDefinition</code> 对象上操作。这就是使 Spring 容器如此灵活且可扩展的本质。</p>
<h4 id="1-16-1-BeanFactory-or-ApplicationContext"><a href="#1-16-1-BeanFactory-or-ApplicationContext" class="headerlink" title="1.16.1. BeanFactory or ApplicationContext?"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-introduction-ctx-vs-beanfactory">1.16.1. <code>BeanFactory</code> or <code>ApplicationContext</code>?</a></h4><p>在 ApplicationContext 中（如 GenericApplicationContext 实现），可以根据 bean name 或者 bean type（特别是后置处理器） 找到 bean，然而，普通的 DefaultListableBeanFactory 与任何特殊 bean 无关。</p>
<blockquote>
<p>自从 SpringFramework 4.3，如果目标 bean 只定义了一个构造器，那么不再需要指定 @Autowired 注解，见<a href="https://docs.spring.io/spring-framework/docs/4.3.29.RELEASE/spring-framework-reference/htmlsingle/#new-in-4.3">4.3更新日志</a></p>
</blockquote>
<h2 id="2-Resources"><a href="#2-Resources" class="headerlink" title="2. Resources"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources">2. Resources</a></h2><h3 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1. Introduction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-introduction">2.1. Introduction</a></h3><p>不幸地是，Java 标准的 <code>java.net.URL</code> 类和用于各种各样 URL 前缀的标准处理器不足以访问所有的低级资源。例如，没有标准化的 <code>URL</code> 实现可以用于访问需要从类路径或者相对于 <code>ServletContext</code> 的资源。虽然可以为特定的 	<code>URL</code> 前缀注册新的处理器（类似于目前用于注入 <code>http:</code> 前缀的处理器），但这通常非常复杂，并且 <code>URL</code> 接口仍然缺乏一些理想的功能，例如检查被指向的资源存在性。</p>
<h3 id="2-2-The-Resource-Interface"><a href="#2-2-The-Resource-Interface" class="headerlink" title="2.2. The Resource Interface"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-resource">2.2. The Resource Interface</a></h3><p>Spring 的 <code>Resource</code> 接口旨在成为一个用于抽象访问低级资源的更强大的接口。以下列举了 <code>Resource</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resource</span> <span class="keyword">extends</span> <span class="title class_">InputStreamSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    URL <span class="title function_">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    File <span class="title function_">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    Resource <span class="title function_">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getFilename</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如 <code>Resource</code> 接口所示的定义，它扩展了 <code>InputStreamSource</code> 接口。以下列出了 <code>InputStreamSource</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InputStreamSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Resource</code> 接口中一些最重要的方法是：</p>
<ul>
<li><code>getInputStream()</code>: 定位并打开资源，返回一个输入流以从资源中读取。预计每次调用都会返回新的输入流。调用者的职责就是关闭流。</li>
<li><code>exists()</code>: 返回一个 <code>boolean</code> 指示该资源是否真正以物理形式存在。</li>
<li><code>isOpen()</code>: 返回一个 <code>boolean</code> 标识该资源是否标识一个打开流的句柄。如果是 <code>true</code>，则不能多次读取 <code>InputStream</code>，并且必须仅读取一次，然后关闭避免资源泄露。除了 <code>InputStreamResource</code>，所有常规资源实现都会返回 <code>false</code>。</li>
<li><code>getDescription()</code>: 返回此资源的描述，用于使用资源时的错误输出。这通常是完全限定文件名或者资源的实际 URL。</li>
</ul>
<p>其他方法可以让你获得代表资源的实际 <code>URL</code> 或者 <code>File</code> 对象（如果基础实现兼容且支持该功能）。</p>
<h3 id="2-3-Built-in-Resource-Implementations"><a href="#2-3-Built-in-Resource-Implementations" class="headerlink" title="2.3. Built-in Resource Implementations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations">2.3. Built-in Resource Implementations</a></h3><h4 id="2-3-1-UrlResource"><a href="#2-3-1-UrlResource" class="headerlink" title="2.3.1. UrlResource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations-urlresource">2.3.1. UrlResource</a></h4><p><code>UrlResource</code> 包装了 <code>java.net.URL</code>。可以用于访问通常用 <code>URL</code> 访问的任何对象，例如文件、HTTP 目标、FTP 目标等。所有 URL 都有标准化的字符串表现形式，因此使用适当的标准化前缀来指示一种 URL 类型。这包括 <code>file:</code> 用于访问文件系统路径, <code>http:</code> 用于访问通过 HTTP 协议的资源, <code>ftp:</code> 用于访问通过 FTP 的资源等。</p>
<p><code>UrlResource</code> 由 Java 代码通过显式地使用 <code>UrlResource</code> 构造器创建，但是当你调用持有一个 <code>String</code> 参数标识路径的 API 方法时，通常会隐式地创建。对于后一种情况，Java Bean <code>PropertyEditor</code> 最终决定要创建哪种类型的资源。</p>
<h4 id="2-3-2-ClassPathResource"><a href="#2-3-2-ClassPathResource" class="headerlink" title="2.3.2. ClassPathResource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations-classpathresource">2.3.2. ClassPathResource</a></h4><h4 id="2-3-3-FileSystemResource"><a href="#2-3-3-FileSystemResource" class="headerlink" title="2.3.3. FileSystemResource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations-filesystemresource">2.3.3. FileSystemResource</a></h4><p>这是用于 <code>java.io.File</code> 和 <code>java.nio.file.Path</code> 处理的 <code>Resource</code> 实现。它支持以 <code>File</code> 和 <code>URL</code> 方式解析。</p>
<h4 id="2-3-5-InputStreamResource"><a href="#2-3-5-InputStreamResource" class="headerlink" title="2.3.5. InputStreamResource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations-inputstreamresource">2.3.5. InputStreamResource</a></h4><h3 id="2-4-The-ResourceLoader"><a href="#2-4-The-ResourceLoader" class="headerlink" title="2.4. The ResourceLoader"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-resourceloader">2.4. The <code>ResourceLoader</code></a></h3><p><code>ResourceLoader</code> 接口意味着由那些可以返回 <code>Resource</code> 实例的对象实现。下面的清单展示了 <code>ResourceLoader</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    Resource <span class="title function_">getResource</span><span class="params">(String location)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有 Application Context 都实现了 <code>ResourceLoader</code> 接口。因此，所有 Application Context 可以被用于获取 <code>Resource</code> 实例。</p>
<p>当你在特定应用上下文调用 <code>getResource()</code>，并且指定的位置路径没有特定前缀时，你将会获得适合特定 Application Context 的 <code>Resource</code> 类型。例如，假设以下代码段是针对 <code>ClassPathXmlApplicationContext</code> 实例运行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">template</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;some/resource/path/myTemplate.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于 <code>ClassPathXmlApplicationContext</code>，该代码返回 <code>ClassPathResource</code>。如果相同的方法运行在 <code>FileSystemXmlApplicationContext</code> 实例上，将会返回 <code>FileSystemResource</code>。对于 <code>WebApplicationContext</code>，将会返回 <code>ServletContextResource</code>。类似地，将会返回适合于每个上下文的对象。</p>
<p>结果，你可以以适合于特定 Application Context 的方式加载资源。</p>
<p>下表总结了讲 <code>String</code> 对象转换为 <code>Resource</code> 对象的策略。</p>
<table>
<thead>
<tr>
<th align="left">Prefix</th>
<th align="left">Example</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">classpath:</td>
<td align="left"><code>classpath:com/myapp/config.xml</code></td>
<td align="left">从类路径加载</td>
</tr>
<tr>
<td align="left">file:</td>
<td align="left"><code>file:///data/config.xml</code></td>
<td align="left">从文件系统以 <code>URL</code> 加载</td>
</tr>
<tr>
<td align="left">http:</td>
<td align="left"><code>https://myserver/logo.png</code></td>
<td align="left">以 <code>URL</code> 加载</td>
</tr>
<tr>
<td align="left">(none)</td>
<td align="left"><code>/data/config.xml</code></td>
<td align="left">依赖于底层 <code>ApplicationContext</code></td>
</tr>
</tbody></table>
<h4 id="2-5-The-ResourceLoaderAware-interface"><a href="#2-5-The-ResourceLoaderAware-interface" class="headerlink" title="2.5. The ResourceLoaderAware interface"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-resourceloaderaware">2.5. The <code>ResourceLoaderAware</code> interface</a></h4><p><code>ResourceLoaderAware</code> 接口是一个特殊的回调接口，它标识了那些期望提供以 <code>ResourceLoader</code> 接口的组件。下面的清单展示了 <code>ResourceLoaderAware</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoaderAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-7-Application-Contexts-and-Resource-Paths"><a href="#2-7-Application-Contexts-and-Resource-Paths" class="headerlink" title="2.7. Application Contexts and Resource Paths"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-app-ctx">2.7. Application Contexts and Resource Paths</a></h3><p>本节涵盖了如何使用资源创建应用上下文，包括与 XML 工作的快捷方式，如何使用通配符，以及其他细节。</p>
<h4 id="2-7-1-Constructing-Application-Contexts"><a href="#2-7-1-Constructing-Application-Contexts" class="headerlink" title="2.7.1. Constructing Application Contexts"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-app-ctx-construction">2.7.1. Constructing Application Contexts</a></h4><p><code>ApplicationContext</code> 的构造器通常将一个字符串或者字符串数组作为资源路径，例如构成上下文定义的 XML 文件。</p>
<p>当这样的路径没有前缀时，将会从该路径构建特定的 <code>Resource</code> 类型，并用于加载依赖及适配于特定 Application Context 的 Bean Definition。例如，考虑以下示例，该示例创建 <code>ClassPathXmlApplicationContext</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;conf/appContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>bean 定义将会从类路径加载，因为使用了 <code>ClassPathResource</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;conf/appContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果在路径上使用特殊的 classpath 前缀，或者标准的 URL 前缀，将会覆盖默认的 <code>Resource</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;classpath:conf/appContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Constructing-ClassPathXmlApplicationContext-Instances-—-Shortcuts"><a href="#Constructing-ClassPathXmlApplicationContext-Instances-—-Shortcuts" class="headerlink" title="Constructing ClassPathXmlApplicationContext Instances — Shortcuts"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-app-ctx-classpathxml">Constructing ClassPathXmlApplicationContext Instances — Shortcuts</a></h5><p><code>ClassPathXmlApplicationContext</code> 暴露出许多构造器，以便于实例化应用上下文。基本思想是：你可以只提供一个字符串数组，该数组包含 XML 文件名（无前导路径信息），并提供一个 <code>Class</code>。然后，<code>ClassPathXmlApplicationContext</code> 就能从提供的 <code>Class</code> 中推断出路径信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String path, Class&lt;?&gt; clazz)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;path&#125;, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述描述也就是根据当前类进行相对路径查找。</p>
</blockquote>
<h2 id="3-Validation-Data-Binding-and-Type-Conversion"><a href="#3-Validation-Data-Binding-and-Type-Conversion" class="headerlink" title="3. Validation, Data Binding, and Type Conversion"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation">3. Validation, Data Binding, and Type Conversion</a></h2><p>Spring Boot 2.3 不再包含 validation，见 <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.3-Release-Notes#validation-starter-no-longer-included-in-web-starters">github</a></p>
<p>将校验视为业务逻辑有利也有弊，Spring 提供了一种用于校验（以及数据绑定）的设计，这并不会排除其中任何一个。具体而言，验证不应该与 Web 层绑定，并且应该容易本地化，且应该有可能插入任何可用的验证器。考虑到这些问题，Spring 提供了一个 <code>Validator</code> 约定，它在每个应用层都是即基础又高度可用。</p>
<p>数据绑定对于让用户的输入动态绑定到应用程序的域模型（或者是任何拟用于处理用户输入的对象）非常有用。Spring 提供了恰当的名为 <code>DataBinder</code> 来做到这一点。<code>Validator</code> 和 <code>DataBinder</code> 组成了 <code>validation</code> 包，该包主要用于但不局限于 web 层。</p>
<p><code>BeanWrapper</code> 是 Spring 框架中的一个基本概念，在许多地方都有使用。但是，你可能无需直接使用 <code>BeanWrapper</code>。但是，由于这是一个参考文档，所以我们认为需要进行一些解释。我们在本章解释 <code>BeanWrapper</code>，因为如果你要使用它，你很可能在尝试将数据绑定到对象上时这样做。</p>
<p>Spring 的 <code>DataBinder</code> 和低级 <code>BeanWrapper</code> 都使用 <code>PropertyEditorSupport</code> 实现类去解析和格式化属性值。<code>PropertyEditor</code> 和 <code>PropertyEditorSupport</code> 类型是 Java Bean 规范的一部分，也会在本章解释。</p>
<p>*** JavaBean 的校验<br>Java Bean 增加 @Valid 注解，或者 @Validated 注解。 @Validated 支持分组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> HttpBody <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> LoginVO loginVO)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>*** 普通参数校验<br>增加 @Valid 注解以及校验规则，同时 Controller 增加 @Validated 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> HttpBody <span class="title function_">sendVerificationCode</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span> <span class="meta">@PathVariable</span> String to)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-Validation-by-Using-Spring’s-Validator-Interface"><a href="#3-1-Validation-by-Using-Spring’s-Validator-Interface" class="headerlink" title="3.1. Validation by Using Spring’s Validator Interface"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validator">3.1. Validation by Using Spring’s Validator Interface</a></h3><p>Spring 提供了一个 <code>Validator</code> 接口，你可以用它来校验对象。<code>Validator</code> 接口通过使用 <code>Errors</code> 对象工作，以便在验证时，验证器可以将校验的失败报告给 <code>Errors</code> 对象。</p>
<p>考虑如下的一个小型数据对象示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the usual getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的示例通过实现 <code>org.springframework.validation.Validator</code> 接口的两个方法来为 <code>Person</code> 类提供验证行为：</p>
<ul>
<li><code>supports(Class)</code>: 该 <code>Validator</code> 可以验证 <code>Class</code> 的实例吗？</li>
<li><code>validate(Object, org.springframework.validation.Errors)</code>: 验证给定的对象，如果发生验证错误，使用给定的 <code>Errors</code> 对象进行注册。</li>
</ul>
<p>实现 <code>Validator</code> 非常简单，尤其当你了解 Spring Framework 提供的 <code>ValidationUtils</code> 帮助类。以下示例为 <code>Persion</code> 示例实现了 <code>Validator</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This Validator validates only Person instances</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object obj, Errors e)</span> &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmpty(e, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name.empty&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">if</span> (p.getAge() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.rejectValue(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;negativevalue&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="number">110</span>) &#123;</span><br><span class="line">            e.rejectValue(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;too.darn.old&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ValidationUtils</code> 类上的静态方法 <code>rejectIfEmpty(..)</code> 用于当 <code>name</code> 属性为 <code>null</code> 或者空字符串时进行拒绝。</p>
<p>虽然可以实现单个 <code>Validator</code> 类来验证复合对象中的每个嵌套对象，但最好将每个嵌套对象类的验证逻辑封装在其自己的 <code>Validator</code> 实现中。一个复合对象的简单例子是 <code>Customer</code>，其由两个 <code>String</code> 属性（first 和 second name）以及一个复杂对象 <code>Address</code> 组成。<code>Address</code> 对象可以独立于 <code>Customer</code> 对象使用，因此实现了一个独立的 <code>AddressValidator</code>。如果你希望你的 <code>CustomerValidator</code> 重用 <code>AddressValidator</code> 类中包含的逻辑，无需求助于复制粘贴，你可以在 <code>CustomerValidator</code> 中依赖注入或者实例化一个 <code>AddressValidator</code>，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Validator addressValidator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerValidator</span><span class="params">(Validator addressValidator)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (addressValidator == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The supplied [Validator] is &quot;</span> +</span><br><span class="line">                <span class="string">&quot;required and must not be null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!addressValidator.supports(Address.class)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The supplied [Validator] must &quot;</span> +</span><br><span class="line">                <span class="string">&quot;support the validation of [Address] instances.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.addressValidator = addressValidator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This Validator validates Customer instances, and any subclasses of Customer too</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Customer.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object target, Errors errors)</span> &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;surname&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> (Customer) target;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            errors.pushNestedPath(<span class="string">&quot;address&quot;</span>);</span><br><span class="line">            ValidationUtils.invokeValidator(<span class="built_in">this</span>.addressValidator, customer.getAddress(), errors);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            errors.popNestedPath();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-Resolving-Codes-to-Error-Messages"><a href="#3-2-Resolving-Codes-to-Error-Messages" class="headerlink" title="3.2. Resolving Codes to Error Messages"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-conversion">3.2. Resolving Codes to Error Messages</a></h3><p>我们讨论了数据绑定和验证。本节涵盖了于验证错误相关的输出消息。在上一章节的示例中，我们拒绝 <code>name</code> 和 <code>age</code> 字段。如果我们想使用 <code>MessageSource</code> 输出错误消息，则我们可以使用拒绝字段时提供的错误码来完成。当你调用 <code>rejectValue</code> 或者来自 <code>Errors</code> 接口的其他  <code>reject</code> 方法之一时，底层实现不仅仅会注册你传递的错误码，而且会注册许多额外的错误码。<code>MessageCodesResolver</code> 决定了 <code>Errors</code> 接口注册哪些错误码。默认地，使用 <code>DefaultMessageCodesResolver</code>，它不仅仅注册你赋予的错误码的消息，而且还会注册包含你传递给拒绝方法的字段名的消息。因此，如果你通过使用 <code>rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)</code></p>
<h3 id="3-3-Bean-Manipulation-and-the-BeanWrapper"><a href="#3-3-Bean-Manipulation-and-the-BeanWrapper" class="headerlink" title="3.3. Bean Manipulation and the BeanWrapper"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beans">3.3. Bean Manipulation and the BeanWrapper</a></h3><p><code>org.springframework.beans</code> 包遵循 Java Bean 标准。一个 Java Bean 是一个具有默认无参构造器，并且遵循命名约定的类，其中（举个例子）一个属性名为 <code>bingoMadness</code> 有一个 Setter 方法 <code>setBingoMadness(..)</code> 以及一个 Getter 方法 <code>getBingoMadness()</code>。有关 Java Bean 和规范的更多信息，参见 <a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">javabeans</a></p>
<p>在 bean 包中非常重要的类是 <code>BeanWrapper</code> 接口及其相应的实现（<code>BeanWrapperImpl</code>）。正如 Javadoc 引用的那样，<code>BeanWrapper</code> 提供了 set 和 get 属性值（单个或者批量）的功能，获取属性描述符和查询属性，以确定它们是可读还是可写的。此外，<code>BeanWrapper</code> 提供了对嵌套属性的支持，使子属性的属性设置为无限的深度。<code>BeanWrapper</code> 还提供了添加标准 Java Bean <code>PropertyChangeListeners</code> 以及 <code>VetoableChangeListeners</code> 的能力，无需在目标类中的代码支持。最后的但同样重要的是，<code>BeanWrapper</code> 提供了设置索引属性的支持。<code>BeanWrapper</code> 通常不直接使用应用程序代码，而是由 <code>DataBinder</code> 以及 <code>BeanFactory</code> 使用。</p>
<p><code>BeanWrapper</code> 的工作方式见名知意：它包装 Bean 在该 Bean 上执行操作，例如设置和检索属性。</p>
<h4 id="3-3-1-Setting-and-Getting-Basic-and-Nested-Properties"><a href="#3-3-1-Setting-and-Getting-Basic-and-Nested-Properties" class="headerlink" title="3.3.1. Setting and Getting Basic and Nested Properties"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beans-conventions">3.3.1. Setting and Getting Basic and Nested Properties</a></h4><p>Set 和 Get 属性是通过 <code>BeanWrapper</code> 的重载方法变体 <code>setPropertyValue</code> 和 <code>getPropertyValue</code> 完成的。详细信息参见它们的 Javadoc。下表展示了这些约定的一些例子：</p>
<table>
<thead>
<tr>
<th align="left">Expression</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left">表示关联着 <code>getName()</code> 或者 <code>isName()</code> 以及 <code>setName(..)</code> 方法的属性 <code>name</code></td>
</tr>
<tr>
<td align="left"><code>account.name</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>account[2]</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>account[COMPANYNAME]</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>以下两个示例类使用 <code>BeanWrapper</code> 去 Get 和 Set 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Employee managingDirector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">getManagingDirector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.managingDirector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setManagingDirector</span><span class="params">(Employee managingDirector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.managingDirector = managingDirector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">float</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码片段展示了一些，关于如何检索和操纵实例化的 <code>Companies</code> 和 <code>Employees</code> 某些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanWrapper</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(<span class="keyword">new</span> <span class="title class_">Company</span>());</span><br><span class="line"><span class="comment">// setting the company name..</span></span><br><span class="line">company.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Some Company Inc.&quot;</span>);</span><br><span class="line"><span class="comment">// ... can also be done like this:</span></span><br><span class="line"><span class="type">PropertyValue</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Some Company Inc.&quot;</span>);</span><br><span class="line">company.setPropertyValue(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok, let&#x27;s create the director and tie it to the company:</span></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">jim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(<span class="keyword">new</span> <span class="title class_">Employee</span>());</span><br><span class="line">jim.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jim Stravinsky&quot;</span>);</span><br><span class="line">company.setPropertyValue(<span class="string">&quot;managingDirector&quot;</span>, jim.getWrappedInstance());</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieving the salary of the managingDirector through the company</span></span><br><span class="line"><span class="type">Float</span> <span class="variable">salary</span> <span class="operator">=</span> (Float) company.getPropertyValue(<span class="string">&quot;managingDirector.salary&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-Spring-Type-Conversion"><a href="#3-4-Spring-Type-Conversion" class="headerlink" title="3.4. Spring Type Conversion"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#core-convert">3.4. Spring Type Conversion</a></h3><h3 id="3-7-Java-Bean-Validation"><a href="#3-7-Java-Bean-Validation" class="headerlink" title="3.7. Java Bean Validation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation">3.7. Java Bean Validation</a></h3><p>Spring Framework 为 Java Bean Validation API 提供了支持。</p>
<h4 id="3-7-1-Overview-of-Bean-Validation"><a href="#3-7-1-Overview-of-Bean-Validation" class="headerlink" title="3.7.1. Overview of Bean Validation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-overview">3.7.1. Overview of Bean Validation</a></h4><p>Bean Validation 通过约束声明和 Java 应用的元数据提供了一种通用的验证方式。要使用它，你可以用声明式验证约束注解域模型，之后这些约束在运行时会被强制执行。有内置的约束，你也可以定义你自己的自定义约束。</p>
<p>考虑以下示例，该实例展示了一个具有两个属性的简单 <code>PersonForm</code> 模型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonForm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean Validation 让你可以声明约束，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonForm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(max=64)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，Bean Validation validator 基于声明的约束验证该类实例。</p>
<h4 id="3-7-2-Configuring-a-Bean-Validation-Provider"><a href="#3-7-2-Configuring-a-Bean-Validation-Provider" class="headerlink" title="3.7.2. Configuring a Bean Validation Provider"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring">3.7.2. Configuring a Bean Validation Provider</a></h4><p>Spring 为 Bean Validation API 提供了完全的支持，包括 Bean Validation provider 作为一个 Spring bean 的引导。这让你可以在你的应用任何需要验证的地方注入 <code>javax.validation.ValidatorFactory</code> 或者 <code>javax.validation.Validator</code>。</p>
<p>你可以使用 <code>LocalValidatorFactoryBean</code> 配置一个默认 Validator 作为 Spring Bean，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LocalValidatorFactoryBean <span class="title function_">validator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalValidatorFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Injecting-a-Validator"><a href="#Injecting-a-Validator" class="headerlink" title="Injecting a Validator"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring-inject">Injecting a Validator</a></h5><p><code>LocalValidatorFactoryBean</code> 实现了 <code>javax.validation.ValidatorFactory</code> 和 <code>javax.validation.Validator</code> 以及 Spring 的 <code>org.springframework.validation.Validator</code>。你可以注入这些接口中的任何一个到你需要调用校验逻辑的 Bean 中。</p>
<p>如果你更喜欢直接使用 Bean Validation API，你可以注入 <code>javax.validation.Validator</code> 的引用，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.Validator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Configuring-Custom-Constraints"><a href="#Configuring-Custom-Constraints" class="headerlink" title="Configuring Custom Constraints"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring-constraints">Configuring Custom Constraints</a></h5><p>每个 Bean 验证约束由两部分组成：</p>
<ul>
<li><code>@Constraint</code> 注解，声明了约束及其可配置的属性</li>
<li><code>javax.validation.ConstraintValidator</code> 接口的实现类，实现了约束的行为</li>
</ul>
<h5 id="Spring-driven-Method-Validation"><a href="#Spring-driven-Method-Validation" class="headerlink" title="Spring-driven Method Validation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring-method">Spring-driven Method Validation</a></h5><h5 id="Additional-Configuration-Options"><a href="#Additional-Configuration-Options" class="headerlink" title="Additional Configuration Options"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring-other">Additional Configuration Options</a></h5><h4 id="3-7-3-Configuring-a-DataBinder"><a href="#3-7-3-Configuring-a-DataBinder" class="headerlink" title="3.7.3. Configuring a DataBinder"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-binder">3.7.3. Configuring a <code>DataBinder</code></a></h4><h2 id="4-Spring-Expression-Language-SpEL"><a href="#4-Spring-Expression-Language-SpEL" class="headerlink" title="4. Spring Expression Language (SpEL)"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#expressions">4. Spring Expression Language (SpEL)</a></h2><p>Spring 表达式语言（简称 SpEL）是一种功能强大的表达式语言，支持在运行时查询和操作对象图。该语言的语法类似于 Unified EL，但提供了额外的特性、最显著的方法调用和基本字符串模板功能。</p>
<p>虽然还有其他几种可用的 Java 表达式语言—— OGNL，MVEL，以及 JBoss EL，但仅举几个例子，创建 Spring 表达式语言是为了向 Spring 社区提供一种受良好支持的表达式语言，该语言可以在 Spring 产品组合中的所有产品中使用。它的语言特性是由 Spring 投资组合中的项目需求驱动的，包括在 Spring Tools For Eclipse 中队代码完成支持的工具需求。也就是说，SpEL 基于一种与技术无关的 API，它允许在需要时集成其他表达式语言实现。</p>
<h2 id="5-Aspect-Oriented-Programming-with-Spring"><a href="#5-Aspect-Oriented-Programming-with-Spring" class="headerlink" title="5. Aspect Oriented Programming with Spring"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop">5. Aspect Oriented Programming with Spring</a></h2><p>面向切面编程（AOP）提供了另一种关于编程结构的思考方式，以对面向对象编程（OOP）进行补充。OOP 中关键的模块化单元是类，而 AOP 中，模块化单元是切面。切面使横跨多个类和对象切入的关注点（例如事务管理）模块化成为可能。（此类关注点通常在 AOP 的文献中称为“横切”关注点。）</p>
<p>Spring 的关键组件之一就是 AOP 框架。尽管 Spring IoC 容器不依赖于 AOP（意味着，如果你不想用，你就不必使用 AOP），但是 AOP 补充了 Spring IoC，提供了一个功能强大的中间件解决方案。</p>
<blockquote>
<p align="center">Spring AOP 和 AspectJ pointcuts</p>
Spring 要不通过使用基于 schema 的方式，要不通过 `@AspectJ` 注解风格提供了简易且强大的写入自定义切点的方式。这两种方式都提供了完全的类型 Advice 并且 AspectJ 切点语言的使用同时也是用 Spring AOP 进行编织。
本章讨论了基于 schema 以及基于 @AspectJ 的 AOP 支持。下一章将讨论低级的 AOP 支持。
</blockquote>
<p>AOP 在 Spring Framework 中能做什么：</p>
<ul>
<li>提供声明式企业服务。最重要的此类服务是<a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/data-access.html#transaction-declarative">声明式事务管理</a></li>
<li>让用户实现自定义切面，用 AOP 补充他们的 OOP</li>
</ul>
<h3 id="5-1-AOP-Concepts"><a href="#5-1-AOP-Concepts" class="headerlink" title="5.1. AOP Concepts"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-introduction-defn">5.1. AOP Concepts</a></h3><p>让我们通过定义一些核心 AOP 概念和术语开始。这些术语不是 Spring 特有的。不幸地是，AOP 术语不是特别直观。但是，如果 Spring 使用自己的术语，那将更加令人困惑。</p>
<ul>
<li>Aspect：切面，一个横跨多个类的模块化。事务管理是企业 Java 应用程序中横切问题很好的例子。在 Spring AOP 中，切面是通过使用常规类或者基于 @Aspect 注解的常规类。</li>
<li>Join point：连接点，执行程序期间的一个点，可以是一个方法的执行或者一个异常的处理。在 Spring AOP 中，连接点就是代表一个方法的执行。</li>
<li>Advice：通知，一个切面在特定连接点采取的行动。不同类似的通知包括 around，before，after。许多 AOP 框架，包括 Spring，将 advice 模型为一个拦截器，并在连接点周围维护一系列拦截器。</li>
<li>Pointcut：切入点，匹配连接点的谓词。advice 与 pointcut 表达式关联，并且在切点匹配的任何 join point 执行。由 pointcut 表达式匹配的 join point 的概念是 AOP 的重点。默认，Spring 使用 AspectJ pointcut 表达式语言。</li>
<li>Introduction（引入）：代表一个类声明额外的方法或字段。Spring AOP 让你可以将新的接口（以及相关实现）引入任何通知对象。例如，你可以使用一个 introduction 使 Bean 实现一个 <code>IsModified</code> 接口，以简化缓存。（一个 introduction 在 AspectJ 社区中称为类内声明）</li>
<li>Target object：由一个或多个切面通知的对象。</li>
<li>AOP proxy：由 AOP 框架创建的对象，以实现切面约定（通知方法执行等）。在 Spring 框架中，AOP 代理可以是 JDK 动态代理或者是 CGLIB 代理。</li>
<li>Weaving：将切面与其他应用类或对象链接，以创建一个通知对象。这可以在编译时（例如。使用 AspectJ 编译器），加载时，或者运行时完成。像其他纯 Java AOP 框架一样，Spring AOP 在运行时进行编织。</li>
</ul>
<p>Spring AOP 包括下面通知类型：</p>
<ul>
<li>Before advice</li>
<li>After returning advice</li>
<li>After throwing advice</li>
<li>After (finally) advice</li>
<li>Around advice</li>
</ul>
<h3 id="5-3-AOP-Proxies"><a href="#5-3-AOP-Proxies" class="headerlink" title="5.3. AOP Proxies"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-introduction-proxies">5.3. AOP Proxies</a></h3><p>Spring AOP 默认使用标准 JDK 动态代理作为 AOP 代理。这使得可以代理任何接口（或者一组接口）。</p>
<p>Spring AOP 也可以使用 CGLIB 代理，这对于代理一些类而非接口是很有必要的。默认地，如果业务对象没有实现接口，则使用 CGLIB。由于最好的实践是面向接口编程而非面向类编程，业务类通常实现一个或多个业务接口。当你需要通知一个未声明在任何接口的方法时，或者需要将代理对象作为固定类型传递给一个方法时，可以<a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-proxying">强制使用 CGLIB</a>。</p>
<h3 id="5-4-AspectJ-support"><a href="#5-4-AspectJ-support" class="headerlink" title="5.4. @AspectJ support"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-ataspectj">5.4. @AspectJ support</a></h3><h4 id="5-4-1-Enabling-AspectJ-Support"><a href="#5-4-1-Enabling-AspectJ-Support" class="headerlink" title="5.4.1. Enabling @AspectJ Support"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-aspectj-support">5.4.1. Enabling @AspectJ Support</a></h4><h4 id="5-4-2-Declaring-an-Aspect"><a href="#5-4-2-Declaring-an-Aspect" class="headerlink" title="5.4.2. Declaring an Aspect"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-at-aspectj">5.4.2. Declaring an Aspect</a></h4><p>启用 <code>@AspectJ</code> 支持之后，应用上下文定义的任何 bean 与 @Aspect 注解的类是由 Spring 自动检测，并用于配置 Spring AOP。</p>
<p>与其他任何类相同，切面（使用 @Aspect 注解的类）可以拥有方法和字段。他们也可以包含切入点，通知，和介绍声明。</p>
<h4 id="5-4-3-Declaring-a-Pointcut"><a href="#5-4-3-Declaring-a-Pointcut" class="headerlink" title="5.4.3. Declaring a Pointcut"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-pointcuts">5.4.3. Declaring a Pointcut</a></h4><p>切入点可以确定感兴趣的连接点，从而让我们控制通知的运行时机。Spring AOP 仅仅支持方法 Spring bean 的方法执行连接点，因此你可以考虑 Spring bean 上的方法执行匹配的切入点。</p>
<p>切入点的声明有两个部分：</p>
<ul>
<li>签名，包括名称和任何参数</li>
<li>切点表达式，精确指定哪些方法的执行是我们所感兴趣的</li>
</ul>
<p>在 <code>@AspectJ</code> 注解风格的 AOP 中，切入点的签名由常规的方法定义提供，切入表达式由 <code>@Pointcut</code> 注解表示。</p>
<p>构成 <code>@Pointcut</code> 注解值的切入点表达式时常规的 AspectJ 5 切入点表达式。</p>
<p>&amp;nbsp;</p>
<h5 id="Supported-Pointcut-Designators"><a href="#Supported-Pointcut-Designators" class="headerlink" title="Supported Pointcut Designators"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators">Supported Pointcut Designators</a></h5><p>Spring AOP 支持以下 AspectJ 切入点指示符用于切入点表达式：</p>
<ul>
<li><code>execution</code>：用于匹配方法执行连接点。</li>
<li><code>within</code>：</li>
<li><code>this</code></li>
<li><code>target</code></li>
<li><code>args</code></li>
<li><code>@target</code></li>
<li><code>@args</code></li>
<li><code>@within</code></li>
<li><code>@annotation</code></li>
</ul>
<p>Spring AOP 还支持一个名为 bean 的 PCD。该 PCD 允许你将连接点的匹配限定为特定名称的 Spring bean 或者一组名称的 Spring bean（使用通配符）。</p>
<p>&amp;nbsp;</p>
<h5 id="Combining-Pointcut-Expressions"><a href="#Combining-Pointcut-Expressions" class="headerlink" title="Combining Pointcut Expressions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-pointcuts-combining">Combining Pointcut Expressions</a></h5><p>你可以通过 <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> 来组合切入点表达式。你也可以按名称引用切入点表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">anyPublicOperation</span><span class="params">()</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.xyz.myapp.trading..*)&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inTrading</span><span class="params">()</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tradingOperation</span><span class="params">()</span> &#123;&#125; </span><br></pre></td></tr></table></figure>


<p>&amp;nbsp;</p>
<h4 id="5-4-4-Declaring-Advice"><a href="#5-4-4-Declaring-Advice" class="headerlink" title="5.4.4. Declaring Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice">5.4.4. Declaring Advice</a></h4><p>通知和切入点表达式有关，然后在切入点匹配的方法 before，after 或者 around 执行。</p>
<h5 id="Before-Advice"><a href="#Before-Advice" class="headerlink" title="Before Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice-before">Before Advice</a></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeforeExample</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&amp;nbsp;</p>
<h5 id="After-Returning-Advice"><a href="#After-Returning-Advice" class="headerlink" title="After Returning Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice-after-returning">After Returning Advice</a></h5><p>当匹配的方法执行正常返回时，After returning advice 将会执行。</p>
<p>有时候，你需要在通知体里面访问实际的返回值。你可以使用 <code>@AfterReturning</code> 绑定返回值，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterReturningExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        pointcut=&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;,</span></span><br><span class="line"><span class="meta">        returning=&quot;retVal&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">(Object retVal)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性 <code>returning</code> 中的名称必须与通知方法的参数名称相匹配。当方法执行返回时，返回值会传递给通知方法中相关的参数。<code>returning</code> 还限制只能匹配那些特定类型的返回值（本例中，<code>Object</code> 匹配任何返回值）</p>
<p>&amp;nbsp;</p>
<h5 id="After-Throwing-Advice"><a href="#After-Throwing-Advice" class="headerlink" title="After Throwing Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice-after-throwing">After Throwing Advice</a></h5><p>当匹配的方法以抛出异常的方式结束时，after throwing advice 会运行。</p>
<p>通常，你希望仅当给定类型的异常抛出时，运行某个通知，而且你也需要在通知体中访问该异常。你可以使用 <code>throwing</code> 属性进行限制匹配，并且绑定抛出的异常到通知参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterThrowingExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        pointcut=&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;,</span></span><br><span class="line"><span class="meta">        throwing=&quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRecoveryActions</span><span class="params">(DataAccessException ex)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性 throwing 中的名称必须与通知方法的参数名称相匹配。当方法是因为抛出异常而结束时，异常会传递给通知方法中相关的参数。throwing 也可以限制仅仅匹配方法执行过程中特定的异常（比如这里的 DataAccessException）。</p>
<p>&amp;nbsp;</p>
<h5 id="After-Finally-Advice"><a href="#After-Finally-Advice" class="headerlink" title="After (Finally) Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice-after-finally">After (Finally) Advice</a></h5><p>当匹配的方法执行退出时，After(finally) advice 会运行。通过 @After 注解声明。必须准备号 After 通知以处理正常和异常的返回条件。通常，它用于释放资源等。</p>
<blockquote>
<p><strong>注意</strong> @AfterThrowing 并不表示通用的异常处理。@AfterThrowing 通知方法仅仅应该从连接点接收异常，而不是从伴随的 <code>@After</code> &#x2F; <code>@AfterReturning</code> 方法。</p>
</blockquote>
<p>&amp;nbsp;</p>
<h5 id="Around-Advice"><a href="#Around-Advice" class="headerlink" title="Around Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-ataspectj-around-advice">Around Advice</a></h5><p>环绕通知围绕着被匹配方法的执行。在方法执行前后，它均有机会工作，并确定何时，如何，甚至是否方法实际上是否要运行。如果你需要以线程安全的方式（例如，启动和停止计时器）在方法执行前后共享状态，通常需要时候 Around 通知。</p>
<p><strong>官方建议</strong> 总是使用功能最小的通知形式来满足需求，即，如果需要前置通知，那么就不用使用环绕通知。</p>
<p>环绕通知使用 <code>@Around</code> 注解声明。通知方法的第一个参数必须是 <code>ProceedingJoinPoint</code>。在通知体里，调用 <code>ProceedingJoinPoint.proceed()</code> 方法会引起底层方法的运行。<code>proceed</code> 方法还可以传递一个 <code>Object[]</code>。数组中的值将作为执行方法时的参数。</p>
<blockquote>
<p>用 <code>Object[]</code> 调用 <code>proceed()</code> 的行为与被 AspectJ 编译器编译的环绕通知的 <code>proceed()</code> 行为有点不同。对于使用传统 AspectJ 语言编写的环绕通知，传递给 <code>proceed</code> 的参数数量必须与传递给环绕通知的参数数量匹配，并且，在给定参数位置传递给 <code>proceed</code> 的值会取代在连接点处绑定到实体上的原始值。Spring 采取的方法更简单，更好地匹配基于代理的，仅仅执行语义。如果你编译为 Spring 所写的 @AspectJ 切面，并且与 AspectJ 编译器和 Weaver 一起使用 <code>preceed</code> 携带的参数，你只需要意识到这种差异。</p>
</blockquote>
<p>环绕通知的返回值就是方法调用者可见的返回值，其他调用者并不会感知。例如，实现一个简单的缓存切面，如果存在缓存那么就从缓存中得到并返回值，如果不存在就调用 proceed()。</p>
<p><strong>注意</strong> 可以在 Around 通知体中调用一次，多次，或者不调用 <code>proceed()</code> 方法。这些都是合法的。</p>
<h5 id="Access-to-the-Current-JoinPoint"><a href="#Access-to-the-Current-JoinPoint" class="headerlink" title="Access to the Current JoinPoint"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-ataspectj-advice-params-the-joinpoint">Access to the Current JoinPoint</a></h5><p>任何的通知方法都可以声明 org.aspectj.lang.JoinPoint 类型参数，作为它的第一个参数。</p>
<p><strong>注意</strong> Around 通知需要声明第一个参数为 <code>ProceedingJoinPoint</code>，它时 <code>JoinPoint</code> 的子类。</p>
<p>JoinPoint 接口提供了许多有用的方法：</p>
<ul>
<li><code>getArgs():Object[]</code>：返回方法参数</li>
<li><code>getThis():Object</code>：返回代理对象</li>
<li><code>getTarget():Object</code>：返回目标对象</li>
<li><code>getSignature():Signature</code>：返回被通知方法的描述</li>
<li><code>toString():String</code>：打印被通知方法的有用描述</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
</search>
