<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Eureka 配置实践</title>
    <url>/2022/07/12/Eureka-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h1><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>确保引入 maven 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>Eureka 的 Server 配置没有特别好的文档，官网的指引也只是让你看源代码注释。</p>
<h3 id="Eureka-Instance-Config"><a href="#Eureka-Instance-Config" class="headerlink" title="Eureka Instance Config"></a>Eureka Instance Config</h3><ul>
<li>Instance Id<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getInstanceId</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获得该实例注册到 eureka 的唯一 ID（在 appName 范围内）</p>
<ul>
<li>App Name<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getAppname</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获得注册到 eureka 的应用名称</p>
<ul>
<li>lease renewal interval in seconds</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getLeaseRenewalIntervalInSeconds()</span><br></pre></td></tr></table></figure>

<p>字面意思：租约续期间隔。</p>
<p>表示 eureka 客户端多久发送心跳给 eureka server，告诉它自己还活着。如果心跳在 <code>getLeaseExpirationDurationInSeconds()</code> 指定的期间还未收到，eureka server 就会从它的视图中移除该实例，从而禁用了该实例的流量。</p>
<blockquote>
<p>该参数只是用于 Eureka Client 发送心跳间隔。需要确保与 Eureka Server 的 <code>getLeaseExpirationDurationInSeconds()</code> 参数值一致，否则 Eureka Server 无法正常工作。</p>
</blockquote>
<ul>
<li>lease expiration duration in seconds</li>
</ul>
<p>表示 Eureka Server 自收到某个实例最后一次心跳，在可以从它的视图中移除该实例从而禁用该实例流量之前，等待的时间，单位：秒。</p>
<p>设置该值太长可能意味着，即使该实例并不存活，也可以将流量路由到该实例。设置该值太小可能意味着，由于临时的网络故障，该实例可能会从流量中剔除。该值设置至少高于 <code>getLeaseRenewalIntervalInSeconds()</code> 指定的值。</p>
<blockquote>
<p>如果该值比 <code>getLeaseRenewalIntervalInSeconds()</code> 小，那么实例将无法存活于注册表，即使注册成功，很快就被剔除。</p>
</blockquote>
<h3 id="Eureka-Server-Config"><a href="#Eureka-Server-Config" class="headerlink" title="Eureka Server Config"></a>Eureka Server Config</h3><ul>
<li>AWS Access Id</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getAWSAccessId</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>AWS 云 Access ID</p>
<ul>
<li>AWS Secret Key</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getAWSSecretKey</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>AWS 云 Secret Key</p>
<ul>
<li><p>EIPBindRebindRetries</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getEIPBindRebindRetries</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EIPBindingRetryIntervalMsWhenUnbound</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getEIPBindingRetryIntervalMsWhenUnbound</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EIPBindingRetryIntervalMs</p>
</li>
<li><p>enable-self-preservation</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">shouldEnableSelfPreservation</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>是否开启自我保护机制。</p>
<p>启用后，Eureka Server 将跟踪其应该从服务接收到的续约次数。任何时候，续约数量低于 <code>getRenewalPercentThreshold()</code> 定义的阈值百分比，Eureka Server 会关闭过期以避免危险。这有助于在 Eureka Client 与 Eureka Server 之间发生网络问题时维持注册表信息。</p>
<blockquote>
<p>注意，自我保护是防止一些网络问题误杀。</p>
</blockquote>
<ul>
<li>eviction-interval-timer-in-ms</li>
</ul>
<p>清理无效节点的时间间隔。默认值 60000</p>
<blockquote>
<p>可以将这个时间设置的短一些，进行快速下线。防止使用不可用的服务。</p>
</blockquote>
<ul>
<li>expected-client-renewalI-interval-seconds</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getExpectedClientRenewalIntervalSeconds</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>期望客户端以这个间隔发送它们的心跳。</p>
<p>默认值：30</p>
<p>如果客户端以不同的频率发送心跳，例如每 15 秒发送一次，那么应该相应地调整此参数，否则，自我保护将无法按预期工作。</p>
<blockquote>
<p>该参数用于计算内部的阈值。</p>
</blockquote>
<ul>
<li>Response Cache Update Interval Ms</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">getResponseCacheUpdateIntervalMs</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>获取更新 Eureka Client 负载缓存的时间间隔。</p>
<ul>
<li>Use Read Only Response Cache</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">shouldUseReadOnlyResponseCache</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>字面意思：是否使用只读响应缓存</p>
<p><code>com.netflix.eureka.registry.ResponseCache</code> 当前使用两级缓存策略来响应。带有过期策略的独写缓存，以及不会过期的只读缓存。</p>
<ul>
<li>Renewal Percent Threshold</li>
</ul>
<p>在由 <code>getRenewalThresholdUpdateIntervalMs()</code> 指定的期间，期望从服务端续期次数的最小百分比。</p>
<p>如果续约降低到阈值以下，并且启用了 <code>shouldEnableSelfPreservation()</code> 则会禁用过期。</p>
<ul>
<li>getRenewalThresholdUpdateIntervalMs</li>
</ul>
<p>由 <code>getRenewalPercentThreshold()</code> 指定的阈值，应该更新的间隔。阈值更新间隔</p>
<ul>
<li>shouldEnableSelfPreservation</li>
</ul>
<p>检查 eureka server 是否启用了自我保护。</p>
<p>当启用，服务会跟踪它应该从微服务接受到的续约次数。在任何时候，续订次数的数量低于 <code>getRenewalPercentThreshold()</code> 定义的阈值百分比，服务器就会关闭过期以避免危险。这有助于在客户端和服务端之间产生网络问题时服务器维持注册信息。</p>
]]></content>
  </entry>
  <entry>
    <title>Hystrix 配置实践</title>
    <url>/2022/07/15/Hystrix-%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>涉及到断路器的参数（HystrixCommandProperties）：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">circuitBreaker.enabled</td>
<td align="left">是否开启断路器</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">circuitBreaker.requestVolumeThreshold</td>
<td align="left">请求总数阈值。这意味着，如果 hystrix 命令在休眠窗口期间调用次数不足 20 次，即使请求都失败，断路器也不会打开</td>
<td align="left">20</td>
</tr>
<tr>
<td align="left">circuitBreaker.sleepWindowInMilliseconds</td>
<td align="left">休眠窗口</td>
<td align="left">5000</td>
</tr>
<tr>
<td align="left">circuitBreaker.errorThresholdPercentage</td>
<td align="left">错误阈值。当请求总数在休眠窗口内超过了阈值，断路器就会打开。</td>
<td align="left">50</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Nginx 官方学习笔记</title>
    <url>/2022/07/12/Nginx-%E5%AE%98%E6%96%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Nginx-官方学习笔记"><a href="#Nginx-官方学习笔记" class="headerlink" title="Nginx 官方学习笔记"></a>Nginx 官方学习笔记</h1><h2 id="Module-参考"><a href="#Module-参考" class="headerlink" title="Module 参考"></a>Module 参考</h2><h3 id="ngx-http-core-module"><a href="#ngx-http-core-module" class="headerlink" title="ngx_http_core_module"></a><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html">ngx_http_core_module</a></h3><blockquote>
<p>语法：server_name name …;<br>默认：server_name “”;<br>上下文：server</p>
</blockquote>
<p>设置虚拟主机名，例如：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个名字成为主服务名。</p>
<p>服务名可以包含一个星号（”*”）替换名字的第一个部分或者最后一个部分：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> example.com <span class="regexp">*.example.com</span> <span class="regexp">www.example.*</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的名称称为通配符名。</p>
<p>上面提到的前两个名称可以合并为一个：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> .example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以在服务名称中使用正则表达式，并在名字前面使用波浪号（”~”）：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com ~^www\d+\.example\.com$;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正则表达式中有名捕获会创建变量（0.8.25），之后可以在其他指令中使用：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> ~^(www\.)?(?&lt;domain&gt;.+)$;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /sites/<span class="variable">$domain</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /sites/default;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>允许该服务在没有 “Host” 头部字段的情况下为给定的 address:port 对处理请求。</p>
<blockquote>
<p>在 0.8.48 之前，默认使用机器的主机名。</p>
</blockquote>
<h3 id="ngx-http-log-module"><a href="#ngx-http-log-module" class="headerlink" title="ngx_http_log_module"></a><a href="https://nginx.org/en/docs/http/ngx_http_log_module.html">ngx_http_log_module</a></h3><p><code>ngx_http_log_module</code> 模块以指定格式写入请求日志</p>
<h4 id="Example-Configuration"><a href="#Example-Configuration" class="headerlink" title="Example Configuration"></a>Example Configuration</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">log_format compression &#x27;$remote_addr - $remote_user <span class="selector-attr">[$time_local]</span> &#x27;</span><br><span class="line">                       &#x27;&quot;$request&quot; $status $bytes_sent &#x27;</span><br><span class="line">                       &#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">access_log /spool/logs/nginx-access<span class="selector-class">.log</span> compression buffer=<span class="number">32</span>k;</span><br></pre></td></tr></table></figure>

<h4 id="Directives"><a href="#Directives" class="headerlink" title="Directives"></a>Directives</h4><h5 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h5><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">access_log <span class="selector-attr">[path [buffer=size]</span> <span class="selector-attr">[gzip[=level]</span>] <span class="selector-attr">[flush=time]</span> <span class="selector-attr">[if=condition]</span>];</span><br><span class="line">access_log off;</span><br></pre></td></tr></table></figure>
<p>默认值:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">access_log logs/access<span class="selector-class">.log</span> combined;</span><br></pre></td></tr></table></figure>
<p>上下文：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">http, server, location, if in location, limit_except</span><br></pre></td></tr></table></figure>

<p>为缓冲日志写入设置 path，format，以及配置。可以在同一配置级别上指定几个日志。可以在第一个参数中指定 “<code>syslog:</code>“ 前缀来配置日志记录到 syslog。特殊值 <code>off</code> 取消当前级别上所有的 access_log 指令。如果没有指定 format，那么就会使用预定义的 “combined”。</p>
<p>如果使用 <code>buffer</code> 或者 <code>gzip</code> 参数，那么写入日志将会缓冲。</p>
<p>当开启缓冲时，以下几种时机将会把数据写入文件：</p>
<ul>
<li>如果下一行日志放不下缓冲区；</li>
<li>如果缓冲数据比 <code>flush</code> 参数指定的还要旧；</li>
<li>当工作进程重新打开日志文件，或者工作进程关闭</li>
</ul>
<p>如果使用 <code>gzip</code> 参数，则在写入文件之前压缩缓冲区的数据。压缩的级别可以设置在 1（最快，压缩率低）到 9 （最慢，压缩率高）之间。默认情况下，缓冲区大小为 64K 字节，压缩级别为 1。由于数据在原子块中压缩，日志文件可以通过 “<code>zcat</code>“ 解压缩或读取。</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">access_log /path/to/log.gz combined gzip flush=5m;</span><br></pre></td></tr></table></figure>

<p>文件路径可以包含变量（0.7.6+），但是此类日志有一些约束：</p>
<ul>
<li>由 worker process 使用的用户凭据应该有权限使用此类日志在文件夹创建文件</li>
<li>不可以使用缓冲写</li>
<li>为每个日志写入打开并关闭文件。但是，由于可以将频繁使用的文件描述符存储到缓存中，在由 open_log_file_cache 指令的 valid 参数指定的时间内，旧文件的写入可以继续。</li>
<li>在每个日志写入过程中，请检查请求的 root 目录是否存在，如果不存在，日志不会创建。因此，指定 root 和 access_log 以相同的配置级别是一个好主意：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    root       /spool/vhost/data/$host;</span><br><span class="line">    access_log /spool/vhost/logs/$host;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code> 参数可以开启有条件的日志记录。如果 <code>condition</code> 等于 0 或者一个空字符串，则不会记录请求。在下面的示例中，请求码为 2xx 以及 3xx 不会被记录：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">map $status $loggable &#123;</span><br><span class="line">    ~^<span class="selector-attr">[23]</span>  <span class="number">0</span>;</span><br><span class="line">    default <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">access_log /path/<span class="selector-tag">to</span>/access<span class="selector-class">.log</span> combined if=$loggable;</span><br></pre></td></tr></table></figure>

<h5 id="log-format"><a href="#log-format" class="headerlink" title="log_format"></a>log_format</h5><p>日志格式可以包含一些通用的变量，以及一些仅仅存在于日志写入时的变量：</p>
<p>$bytes_sent 客户端发送的字节数</p>
<p>$connection 连接序列号</p>
<p>$connection_requests 通过一个连接发起的请求的当前序号</p>
<p>$msec 日志写入的时间，以秒为单位，精确到毫秒</p>
<p>$pipe 如果请求是管道，则是 “p”，否则为 “.”</p>
<p>$request_length 请求长度（包含请求行，头部，以及请求体）</p>
<p>$request_time 请求处理时间，以秒为单位，精确到毫秒，从客户端读取第一个字节，并在最后一个字节发送给客户端之后写入日志所用时间</p>
<p>$status 响应状态码</p>
<p>$time_iso8601 以 ISO 8601 标准格式的本地时间。类似 <code>2022-07-12T15:05:16+08:00</code></p>
<p>$time_local 以通用日志格式的本地时间。类似 <code>12/Jul/2022:15:05:16 +0800</code></p>
<p>配置始终包含预定义的 “<code>combined</code>“ 格式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">log_format combined &#x27;$remote_addr - $remote_user <span class="selector-attr">[$time_local]</span> &#x27;</span><br><span class="line">                    &#x27;&quot;$request&quot; $status $body_bytes_sent &#x27;</span><br><span class="line">                    &#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&#x27;;</span><br></pre></td></tr></table></figure>


<h5 id="open-log-file-cache"><a href="#open-log-file-cache" class="headerlink" title="open_log_file_cache"></a>open_log_file_cache</h5><p>定义一个缓冲，该缓冲存储了名称包含变量的频繁使用的日志文件描述符。该指令具有如下参数：</p>
<p>max</p>
<p>inactive</p>
<p>min_uses</p>
<p>valid</p>
<p>设置应该检查仍然存在相同名称的文件的时间，默认情况下，为 60 秒</p>
<p>off<br>禁用缓存</p>
]]></content>
  </entry>
  <entry>
    <title>Python 爬虫学习笔记</title>
    <url>/2022/06/29/Python-%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Python-爬虫"><a href="#Python-爬虫" class="headerlink" title="Python 爬虫"></a>Python 爬虫</h1><h2 id="1-urllib"><a href="#1-urllib" class="headerlink" title="1. urllib"></a>1. urllib</h2><h3 id="1-1-参考文档"><a href="#1-1-参考文档" class="headerlink" title="1.1. 参考文档"></a>1.1. 参考文档</h3><p><a href="https://docs.python.org/3/howto/urllib2.html">https://docs.python.org/3/howto/urllib2.html</a></p>
<h3 id="1-2-抓取-url"><a href="#1-2-抓取-url" class="headerlink" title="1.2. 抓取 url"></a>1.2. 抓取 url</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>) <span class="keyword">as</span> response:</span><br><span class="line">    html = response.read()</span><br></pre></td></tr></table></figure>

<p>如果你想抓取 url 并存储到临时文件夹下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(<span class="string">&#x27;http://python.org/&#x27;</span>) <span class="keyword">as</span> response:</span><br><span class="line">    <span class="keyword">with</span> tempfile.NamedTemporaryFile(delete=<span class="literal">False</span>) <span class="keyword">as</span> tmp_file:</span><br><span class="line">        shutil.copyfileobj(response, tmp_file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(tmp_file.name) <span class="keyword">as</span> html:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>定制化 Request</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">req = urllib.request.Request(<span class="string">&#x27;http://www.voidspace.org.uk&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">   the_page = response.read()</span><br></pre></td></tr></table></figure>

<h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://www.someserver.com/cgi-bin/register.cgi&#x27;</span></span><br><span class="line">values = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;Michael Foord&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;location&#x27;</span> : <span class="string">&#x27;Northampton&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;language&#x27;</span> : <span class="string">&#x27;Python&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">data = urllib.parse.urlencode(values)</span><br><span class="line">data = data.encode(<span class="string">&#x27;ascii&#x27;</span>) <span class="comment"># data should be bytes</span></span><br><span class="line">req = urllib.request.Request(url, data)</span><br><span class="line"><span class="keyword">with</span> urllib.request.urlopen(req) <span class="keyword">as</span> response:</span><br><span class="line">   the_page = response.read()</span><br></pre></td></tr></table></figure>
<h2 id="2-requests"><a href="#2-requests" class="headerlink" title="2. requests"></a>2. requests</h2><p><a href="https://requests.readthedocs.io/en/latest/">https://requests.readthedocs.io/en/latest/</a></p>
<h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">&#x27;https://api.github.com/events&#x27;</span>)</span><br><span class="line">r = requests.post(<span class="string">&#x27;https://httpbin.org/post&#x27;</span>, data=&#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line">r = requests.put(<span class="string">&#x27;https://httpbin.org/put&#x27;</span>, data=&#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line">r = requests.delete(<span class="string">&#x27;https://httpbin.org/delete&#x27;</span>)</span><br><span class="line">r = requests.head(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line">r = requests.options(<span class="string">&#x27;https://httpbin.org/get&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置编码格式</span></span><br><span class="line">r.encoding = <span class="string">&#x27;UTF-8&#x27;</span></span><br><span class="line"><span class="comment"># 返回响应字符串</span></span><br><span class="line">r.text</span><br><span class="line"><span class="comment"># 返回 url 地址</span></span><br><span class="line">r.url</span><br><span class="line"><span class="comment"># 返回响应字节</span></span><br><span class="line">r.content</span><br><span class="line"><span class="comment"># 响应状态码</span></span><br><span class="line">r.status_code</span><br><span class="line"><span class="comment"># 响应头</span></span><br><span class="line">r.headers</span><br></pre></td></tr></table></figure>

<h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, params=params, headers=headers)</span><br></pre></td></tr></table></figure>

<h1 id="BS4"><a href="#BS4" class="headerlink" title="BS4"></a>BS4</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回数组</span></span><br><span class="line">soup.select(<span class="string">&#x27;#haha&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h1><h2 id="headless"><a href="#headless" class="headerlink" title="headless"></a>headless</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">share_browser</span>():</span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    path = <span class="string">&#x27;C:\Program Files\Google\Chrome\Application\chrome.exe&#x27;</span></span><br><span class="line">    chrome_options.binary_location = path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> webdriver.Chrome(chrome_options=chrome_options)</span><br></pre></td></tr></table></figure>


<h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<h3 id="Get-请求"><a href="#Get-请求" class="headerlink" title="Get 请求"></a>Get 请求</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url=url, params=params, headers=headers)</span><br><span class="line">content = response.text</span><br></pre></td></tr></table></figure>


<h2 id="scrapy"><a href="#scrapy" class="headerlink" title="scrapy"></a>scrapy</h2><p>以下这段话来自 <a href="https://scrapy.org/">https://scrapy.org/</a></p>
<blockquote>
<p>An open source and collaborative framework for extracting the data you need from websites.<br>In a fast, simple, yet extensible way.</p>
</blockquote>
<p>scrapy 是一个开源和协作框架，用于从网站上提取所需的数据。<br>以快速，简单但可扩展的方式。</p>
<h3 id="安装错误总结"><a href="#安装错误总结" class="headerlink" title="安装错误总结"></a>安装错误总结</h3><blockquote>
<p>来自于尚硅谷 Python 视频</p>
</blockquote>
<ol>
<li>缺少 twisted.test.raiser 扩展</li>
</ol>
<p><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted">http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a></p>
<ol start="2">
<li>升级 pip</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>



<h3 id="快速开始-1"><a href="#快速开始-1" class="headerlink" title="快速开始"></a>快速开始</h3><ol>
<li>创建爬虫项目</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy startproject myproject</span><br></pre></td></tr></table></figure>
<blockquote>
<p>myproject 为自定义项目名称。项目名称必须以字母开头，并且只包含字母、数字、下划线。</p>
</blockquote>
<p>命令执行完毕会得到如下目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├─myproject</span><br><span class="line">│  │  scrapy.cfg</span><br><span class="line">│  │</span><br><span class="line">│  └─myproject</span><br><span class="line">│      │  items.py</span><br><span class="line">│      │  middlewares.py</span><br><span class="line">│      │  pipelines.py</span><br><span class="line">│      │  settings.py</span><br><span class="line">│      │  __init__.py</span><br><span class="line">│      │</span><br><span class="line">│      └─spiders</span><br><span class="line">│              __init__.py</span><br></pre></td></tr></table></figure>


<ol>
<li>创建爬虫文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy genspider 爬虫名 爬取网页</span><br></pre></td></tr></table></figure>


<ol>
<li>运行爬虫代码</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy crawl 爬虫名</span><br></pre></td></tr></table></figure>


<h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><p>获取响应字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response.text</span><br></pre></td></tr></table></figure>


<p>获取响应二进制数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response.body</span><br></pre></td></tr></table></figure>


<p>获取</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/04/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>undo 分配</title>
    <url>/2022/05/09/undo-%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>分配临时回滚段和持久回滚段的函数名不同只在于末尾的单词不同：</p>
<p>trx_assign_rseg_temp</p>
<p>trx_assign_rseg_durable</p>
<p>当一个事务被判定为读写模式时，会为其分配 trx_id 以及持久回滚段。</p>
<p>分配临时回滚段是当调用 <code>trx_undo_report_row_operation</code> 时，判断是否是临时表而动态分配的。</p>
]]></content>
  </entry>
  <entry>
    <title>undo 清理</title>
    <url>/2022/05/02/undo-%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<h1 id="purge-queue"><a href="#purge-queue" class="headerlink" title="purge_queue"></a>purge_queue</h1><p>purge_queue中记录了所有等待Purge的Rollback Segment和其History中trx_no最小的事务</p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>storage&#x2F;innobase&#x2F;trx&#x2F;trx0undo.cc</p>
<p>事务结束的时候，对于需要Purge的Update类型的Undo Log，会按照事务提交的顺序trx_no，挂载到Rollback Segment Header的History List上。</p>
<p>在 trx_undo_update_cleanup 函数中调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trx_undo_update_cleanup</span><span class="params">(<span class="type">trx_t</span> *trx, <span class="type">trx_undo_ptr_t</span> *undo_ptr, <span class="type">page_t</span> *undo_page, <span class="type">bool</span> update_rseg_history_len, ulint n_added_logs, <span class="type">mtr_t</span> *mtr)</span> &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 update undo 添加到 history</span></span><br><span class="line">  trx_purge_add_update_undo_to_history(</span><br><span class="line">      trx, undo_ptr, undo_page, update_rseg_history_len, n_added_logs, mtr);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/purge.svg">



<p><code>srv_do_purge()</code> 为入口函数</p>
<p><code>trx_purge()</code> 获取最老的视图复制给 <code>purge_sys-&gt;view</code>，方便之后真正 purge undo log 时判断其是否不会再被访问到了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trx_sys-&gt;mvcc-&gt;clone_oldest_view(&amp;purge_sys-&gt;view);</span><br></pre></td></tr></table></figure>


<p>通过 <code>trx_purge_attach_undo_recs()</code> 获取需要被 purge 的undo log：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n_pages_handled = trx_purge_attach_undo_recs(n_purge_threads, batch_size);</span><br></pre></td></tr></table></figure>

<p>trx_purge_attach_undo_recs</p>
<p>通过 <code>trx_purge_fetch_next_rec()</code> 循环获取可以被purge 的 undo log，默认最多获取 300 个 undo 页</p>
<blockquote>
<p>可以通过 innodb_purge_batch_size 来调整</p>
</blockquote>
<h2 id="trx-purge-fetch-next-rec-流程"><a href="#trx-purge-fetch-next-rec-流程" class="headerlink" title="trx_purge_fetch_next_rec 流程"></a>trx_purge_fetch_next_rec 流程</h2><ol>
<li>trx_purge_choose_next_log</li>
</ol>
<p>该函数作用：选择下一个需要清理的 undo log，并且更新 purge_sys 的信息</p>
<p>通过 <code>trx_purge_choose_next_log()</code> 从<code>purge_sys::purge_queue</code> 取出第一个回滚段</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/trx_purge_choose_next_log.svg">

<ol start="2">
<li>trx_purge_get_next_rec</li>
</ol>
<p>从其 history list 上读取最老还未被 purge 的事务的undo log header。<br>从此 undo log header 依次读取undo log record，每次读取会设置purge_sys的变量</p>
<p>读取完毕后，重新统计此回滚段最老还未被purge的事务的位点，然后重新放入purge_sys::purge_queue；最后回到第一步。</p>
<h2 id="trx-purge-choose-next-log"><a href="#trx-purge-choose-next-log" class="headerlink" title="trx_purge_choose_next_log"></a>trx_purge_choose_next_log</h2><p>依次从 purge_queue 中 pop 出拥有全局最小 trx_no 的 Undo Log。</p>
<h2 id="TrxUndoRsegsIterator-set-next-流程"><a href="#TrxUndoRsegsIterator-set-next-流程" class="headerlink" title="TrxUndoRsegsIterator::set_next() 流程"></a>TrxUndoRsegsIterator::set_next() 流程</h2><p>如果满足 <code>m_iter != m_trx_undo_rsegs.end()</code>，表示当前即将处理的 rollback segment 还未到最后一个，即还有更多的 rollback segment 需要处理。</p>
<p>如果当前即将处理的 rollback segment 已经到最后一个了，那么将会进入一个 <code>while(!m_purge_sys-&gt;purge_queue-&gt;empty())</code> 循环：</p>
<ul>
<li><p>如果满足 <code>m_trx_undo_rsegs.get_trx_no() == UINT64_UNDEFINED</code>，表示当前需要处理的 rollback segment 对应的事务并不存在（一条伪记录），那么将会将 purge_queue 顶部的元素赋值给 <code>m_trx_undo_rsegs</code>。弹出顶部 rollback segment</p>
</li>
<li><p>其次，如果满足 <code>purge_sys-&gt;purge_queue-&gt;top().get_trx_no() == m_trx_undo_rsegs.get_trx_no()</code>，表示 purge_queue 顶部的 rollback segment 对应的事务就是当前待处理的事务，那么将purge_queue 顶部的 rollback segment 添加到 <code>m_trx_undo_rsegs</code>。弹出顶部 rollback segment</p>
</li>
<li><p>否则，表示当前待处理的 rollback segment 集合对应的事务并不等于 purge_queue 顶部事务，跳出循环</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>各类场景请求参数</title>
    <url>/2022/05/24/%E5%90%84%E7%B1%BB%E5%9C%BA%E6%99%AF%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li>身份证号码</li>
</ul>
<p>存在 X 这种非数字的符号，需要注意用户可能会小写</p>
]]></content>
  </entry>
  <entry>
    <title>简历</title>
    <url>/2022/07/18/%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<p>知识：</p>
<p><strong>PHP</strong> <strong>Java</strong> JavaScript HTML CSS <strong>MySQL</strong> <strong>Redis</strong> <strong>Nginx</strong> XML Json Node.js Vue 企业微信自建 企业微信代开发</p>
<p>云尚作业统计模块</p>
<p>空中课堂一期大屏统计模块</p>
<p>实验竞赛统计模块</p>
<p>腾讯云云点播、对象存储、拓课云、推流直播等服务对接</p>
<p>2020 年</p>
<p>负责积分系统；</p>
<p>负责江苏名师空中课堂教师成长备课模块的数据库设计，发起备课，备课查询，备课详情、备课内容讨论；</p>
<p>负责江苏名师空中课堂题库模块的题库上传，批量上传，基础教学数据查询；</p>
<p>负责江苏名师空中课堂资源中心的数据库设计，资源统计，旧数据表迁移等；</p>
<p>2021年 </p>
<p>负责江苏名师一期空中课堂大屏接口，统计缓存各维度数据；</p>
<p>负责企微自建应用云上家长课堂接口；</p>
<p>负责校园安全系统学生、教师考勤，功能室管理、护导管理功能，后期独立负责维护后续问题，自行搭建维护了一个基于 vue element admin 后台框架的前端项目，便于管理多个学校设备，用于状态查看，设备信息导入等；</p>
<p>负责企微应用数据打卡设计、接口编写；</p>
<p>负责企微应用鼓 e 小视频设计、编码;</p>
<p>负责梁溪名师在线的团队在线校验；</p>
<p>负责企微应用行走日记的设计、编码；</p>
<p>负责企微应用学生点名设计、编码；</p>
<p>负责鼓楼云尚作业的分组功能、作业数据统计功能、自动化批改脚本、学生作业报告、学生错题统计；</p>
<p>负责企微应用校长信箱设计、编码；</p>
<p>负责南京师范大学附属中学树人学校、力人初中的招生系统编码；</p>
<p>负责南京实验幼儿园招生系统；</p>
<p>负责五塘、宝善、金达、滨江、鼓楼第二实验幼儿园联合招生系统；</p>
<p>负责鼓楼一中心学校招生系统；</p>
<p>负责江苏名师空中课堂苏 e 优课的证书方法与缓存，以及后续证书问题的更进；</p>
<p>负责省机关幼儿园家校助理团的设计、编码 8.1</p>
]]></content>
  </entry>
  <entry>
    <title>Android 笔记</title>
    <url>/2022/07/18/Android/Android-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="清单文件"><a href="#清单文件" class="headerlink" title="清单文件"></a>清单文件</h1><h1 id="Activities"><a href="#Activities" class="headerlink" title="Activities"></a>Activities</h1><h2 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h2><h3 id="创建一个-fragment"><a href="#创建一个-fragment" class="headerlink" title="创建一个 fragment"></a>创建一个 fragment</h3><p>一个 fragment 表示某个 activity 中用户接口的一个模块化部分。一个 fragment 有它自己的生命周期，接受它自己的输入事件，并且你可以在activity 运行时添加或移除 fragment。</p>
<h4 id="设置环境"><a href="#设置环境" class="headerlink" title="设置环境"></a>设置环境</h4><p>fragments 需要 AndroidX fragment 库的依赖。为此，你需要添加 Google Maven 仓库到你的项目 build.grade 文件。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ...</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了将 AndroidX Fragment 库包含到你的项目，需要在你的 App 的 build.gradle 文件添加如下依赖：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def fragment_version = &quot;<span class="number">1.3</span>.<span class="number">5</span>&quot;</span><br><span class="line"></span><br><span class="line">    // Java language implementation</span><br><span class="line">    implementation &quot;androidx<span class="selector-class">.fragment</span>:fragment:$fragment_version<span class="string">&quot;</span></span><br><span class="line"><span class="string">    // Kotlin</span></span><br><span class="line"><span class="string">    implementation &quot;</span>androidx.fragment:fragment-ktx:$fragment_version<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建一个-fragment-类"><a href="#创建一个-fragment-类" class="headerlink" title="创建一个 fragment 类"></a>创建一个 fragment 类</h4><p>为了创建一个 fragment，需要继承 AndroidX 的 <code>Fragment</code> 类，并覆盖它的方法，类似你创建一个 <code>Activity</code> 类。为了创建一个定义了自己的布局的最小 fragment，需要为基本构造器提供 fragment 的布局资源。如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleFragment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_fragment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fragment 库还提供了更多专业的 fragment 基类：</p>
<ul>
<li><p>DialogFragment<br>显示悬浮对话框，使用此类创建一个对话框是一个对于使用 Activity  dialog helper 方法的好的替代方案，因为 fragment 会自动处理对话框的创建和清理。详细信息参考 DialogFragment。</p>
</li>
<li><p>PreferenceFragmentCompat<br>显示作为列表的 Preference 对象的层次结构。你可以使用<br>PreferenceFragmentCompat 来为你的 App 创建一个设置屏幕。</p>
</li>
</ul>
<h4 id="添加一个-fragment-到-activity"><a href="#添加一个-fragment-到-activity" class="headerlink" title="添加一个 fragment 到 activity"></a>添加一个 fragment 到 activity</h4><p>通常，你的 fragment 必须嵌入在 AndroidX <code>FragmentActivity</code> 中，用以贡献一部分 UI 到 activity 布局。<code>FragmentActivity</code> 是 <code>AppCompatActivity</code> 基类，因此如果你已经在你的 App 中为 AppCompatActivity 提供了向后兼容性，那么你不必改变你的 activity 基类。</p>
<p>你可以通过两种方式添加 fragment：</p>
<ul>
<li>在 activity 的布局文件中定义片段</li>
<li>在 activity 布局文件定义 fragment 容器，后面通过程序添加到 activity。</li>
</ul>
<p>在任何一种情况下，你都需要添加一个 <code>FragmentContainerView</code>，定义了 fragment 应该放在 activity 试图层次结构中的位置。</p>
<p>强烈建议：使用 Fragment 作为 fragment 的容器，因为 <code>FragmentContainerView</code> 包含了其他 View Group（如 FrameLayout）没有提供的修复程序。</p>
<h5 id="通过-XML-添加-fragment"><a href="#通过-XML-添加-fragment" class="headerlink" title="通过 XML 添加 fragment"></a>通过 XML 添加 fragment</h5><p>为了声明将 fragment 添加到你的 activity 布局 XML，你需要添加一个 <code>FragmentContainerView</code> 元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/example_activity.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_container_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.example.ExampleFragment&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>Android:name 指定要实例化的 fragment 类名。当 activity 布局填充时，指定的 fragment 会实例化，当新实例化 fragment 时，onInflate() 会被调用，并且会创建一个 <code>FragmentTransaction</code> 去将 fragment 添加到 <code>FragmentManager</code>。</p>
<h5 id="程序化添加-fragment"><a href="#程序化添加-fragment" class="headerlink" title="程序化添加 fragment"></a>程序化添加 fragment</h5><p>为了程序化添加 fragment 到 activity，布局应该引入 <code>FragmentContainerView</code> 作为 fragment 容器，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- res/layout/example_activity.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fragment_container_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>与 XML 方式不同，android:name 属性并未使用，因此不会自动实例化特定 fragment。相反，使用 FragmentTransaction 来实例化 fragment 并将其添加到 activity 的布局中。</p>
<p>当你的 activity 在运行时，你可以制造 fragment transaction 例如添加、删除或者替换 fragment。在 <code>FragmentActivity</code> 中，你可以获得 <code>FragmentManager</code> 的实例，你可以通过它创建 <code>FragmentTransaction</code>。 在 activity 的 onCreate() 方法中，你可以使用 FragmentTransaction.add() 实例化你的 fragment，传递参数 ViewGroup ID 和 fragment Class，然后提交事务，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleActivity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">            getSupportFragmentManager().beginTransaction()</span><br><span class="line">                .setReorderingAllowed(<span class="literal">true</span>)</span><br><span class="line">                .add(R.id.fragment_container_view, ExampleFragment.class, <span class="literal">null</span>)</span><br><span class="line">                .commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当执行一个 FragmentTransaction 时，你应该总是使用 setReorderingAllowed(true)。更多信息参考官网。</p>
</blockquote>
<p>在前面的例子中，请注意，只有在 savedInstanceState 为 null 时，才会创建 fragment 事务。这是为了确保仅仅当 activity 第一次创建的时候，fragment 才会添加一次。发生配置更改或者 activity recreate，savedInstanceState 不再为 null，并且不需要再添加一次 fragment，因为 fragment 可以自动从 savedInstanceState 恢复。</p>
<p>如果你的 fragment 需要一些初始化数据，你可以通过在调用 FragmentTransaction.add() 时提供一个 Bundle，如下图所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleActivity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">            bundle.putInt(<span class="string">&quot;some_int&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            getSupportFragmentManager().beginTransaction()</span><br><span class="line">                .setReorderingAllowed(<span class="literal">true</span>)</span><br><span class="line">                .add(R.id.fragment_container_view, ExampleFragment.class, bundle)</span><br><span class="line">                .commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 fragment 中，你可以通过调用 <code>requireArguments()</code> 来获取参数 Bundle，并且可以使用适合的 getter 方法来获取每个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleFragment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(R.layout.example_fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">someInt</span> <span class="operator">=</span> requireArguments().getInt(<span class="string">&quot;some_int&quot;</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">implementation &#x27;com<span class="selector-class">.squareup</span><span class="selector-class">.okhttp3</span>:okhttp:<span class="number">4.9</span>.<span class="number">0</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android 笔记</category>
      </categories>
      <tags>
        <tag>Android 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>向 Activity 添加 Fragment</title>
    <url>/2022/07/18/Android/%E5%90%91-Activity-%E6%B7%BB%E5%8A%A0-Fragment/</url>
    <content><![CDATA[<h1 id="向-Activity-添加-Fragment"><a href="#向-Activity-添加-Fragment" class="headerlink" title="向 Activity 添加 Fragment"></a>向 Activity 添加 Fragment</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>在 Activity 的布局文件内声明片段</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.news.ArticleListFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/list&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.news.ArticleReaderFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/viewer&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><code>&lt;fragment&gt;</code> 的 android:name 属性指定要在布局中进行实例化的 Fragment 类。</p>
<p>创建 activity 布局时，系统会将每个 fragment 实例化，并调用 OnCreateView() 方法，以检索每个片段的布局。系统会返回插入 fragment 后的 View。</p>
<blockquote>
<p>注意：每个片段都需要唯一标识符，重启 Activity 时，系统可使用该标识符来恢复片段（您也可以使用该标识符来捕获片段，从而执行某些事务，如将其移除）。可以通过两种方式为片段提供 ID：</p>
</blockquote>
<p>为 android:id 属性提供唯一 ID。<br>为 android:tag 属性提供唯一字符串。</p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>在 activity 运行期间，可以随时将片段添加到 activity 布局中，只需指定 fragment 放入哪个 ViewGroup。</p>
<p>在 activity 中执行片段事务（如添加、移除或替换片段），必须使用 FragmentTransaction API。</p>
<p>可以从 FragmentActivity 获取一个FragmentTransaction实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FragmentManager</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> getSupportFragmentManager();</span><br><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">fragmentTransaction</span> <span class="operator">=</span> fragmentManager.beginTransaction();</span><br></pre></td></tr></table></figure>

<p>然后，使用 add() 方法添加片段，指定要添加的片段以及插入哪个视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExampleFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleFragment</span>();</span><br><span class="line">fragmentTransaction.add(R.id.fragment_container, fragment);</span><br><span class="line">fragmentTransaction.commit();</span><br></pre></td></tr></table></figure>

<p>一旦通过 FragmentTransaction 做出了更改，就必须调用 commit() 以使更改生效。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 构造 Mapper Proxy 原理</title>
    <url>/2022/07/16/MyBatis/MyBatis-%E6%9E%84%E9%80%A0-Mapper-Proxy-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>在 MyBatis 应用中，我们定义的 <code>Mapper</code> 接口，最终都会转换为 JDK 动态代理对象 <code>Proxy</code>。</p>
<p>假设有 UserMapper.xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br></pre></td></tr></table></figure>
<p>在 MyBatis 的框架中，提供了 <code>SqlSession</code> 的默认实现类 <code>DefaultSqlSession</code>，关注其实现方法 <code>getMapper()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultSqlSession.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> configuration.getMapper(type, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 getMapper 内部调用了属性 <code>Configuration</code> 的 getMapper 方法，将代码细节委托给 <code>Configuration</code> 实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configuration.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Configuration</code> 内部的实现是将 getMapper 的细节委托给 <code>MapperRegistry</code> 实现，顾名思义，Mapper 注册表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MapperRegistry.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保该类型被识别</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is not known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Error getting mapper instance. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由 <code>MapperRegistry</code> 的实现可以知道，其内部维护了一个 <code>knownMappers</code> 结构，用于进行 <code>Mapper</code> 接口到 <code>MapperProxyFactory</code> 的映射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><code>MapperProxyFactory</code>，由类名可以知道这是一个批量生产 MapperProxy 的工厂类，关注其如何生产 MapperProxy</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MapperProxyFactory.java</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 InvocationHandler</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> <span class="title class_">MapperProxy</span>&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 JDK 动态代理的方法创建代理类</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; mapperInterface &#125;, mapperProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，创建了一个 <code>MapperProxy</code>，这是一个由 MyBatis 提供的 <code>InvocationHandler</code> 的实现类，然后将其传递给 <code>Proxy.newProxyInstance</code> 方法创建 Proxy 并返回。</p>
<blockquote>
<p>从名字上看，MapperProxyFactory 似乎是生产 MapperProxy 的工厂，但在过程中，MapperProxy 只是扮演了代理类的 Handler 角色，MapperProxyFactory 真正生产的应该是代理类。</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>AES 加密算法</title>
    <url>/2022/07/18/Security/AES-%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="AES-加密算法"><a href="#AES-加密算法" class="headerlink" title="AES 加密算法"></a>AES 加密算法</h1><h2 id="密钥扩展算法"><a href="#密钥扩展算法" class="headerlink" title="密钥扩展算法"></a>密钥扩展算法</h2><img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/crypto/AES%E5%AF%86%E9%92%A5%E6%89%A9%E5%B1%95%E7%AE%97%E6%B3%95.drawio.svg">

<p>步骤说明：</p>
<ol>
<li><p>将密钥 key 按左图的格式，从上到下，从左到右排列，每一列 4 个字节，其中 $k_n$ 表示 1 个字节。</p>
<blockquote>
<p>AES 支持密钥长度为 16、24、32 字节，因此可能的列数是 4、6、8</p>
</blockquote>
</li>
<li><p>将每一列的 4 字节从上到下拼接成 32 bit，记为 $W_t$</p>
</li>
</ol>
<blockquote>
<p>根据密钥长度不同，列数是 4、6、8，因此 $W$ 每一行的长度是 4、6、8</p>
</blockquote>
<ol start="3">
<li>依次求解 $W_t$，$t$ 的范围是 $[4,43]$（因为已经得到 $[0,3]$ 的值），规则如下：<br>若 $t%4&#x3D;0$，则：<br>$$w[t]&#x3D;w[t-4]⊕g(w[t-1])$$<br>否则：<br>$$w[t]&#x3D;w[t-4]⊕w[t-1]；$$</li>
</ol>
<p>g 函数的流程如下：</p>
<ol>
<li>将 $W_t$ 循环左移 8 bit（即 1 字节）</li>
<li>对每个字节做 S 盒置换</li>
<li>将每个字节与 32 bit 常量$(RC[t&#x2F;4],0,0,0)$进行异或。</li>
</ol>
<blockquote>
<p>$RC$ 是一个一维数组，其所需长度随着 AES 算法密钥的长度变化，</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/luop/p/4334160.html">https://www.cnblogs.com/luop/p/4334160.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>加密解密笔记</title>
    <url>/2022/07/10/Security/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="加密解密笔记"><a href="#加密解密笔记" class="headerlink" title="加密解密笔记"></a>加密解密笔记</h1><h2 id="密码技术"><a href="#密码技术" class="headerlink" title="密码技术"></a>密码技术</h2><ul>
<li>原文：或者叫明文，就是被隐藏的文字。</li>
<li>加密法：指隐藏原文的法则。</li>
<li>密文：或者叫伪文，指对原文按照加密法处理过后生成的可公开传递的文字。</li>
<li>密钥：在加密法中起决定性的因素，可能是数字、词汇，也可能是一些字母，或者这些东西的组合。</li>
</ul>
<h2 id="1-对称加密算法"><a href="#1-对称加密算法" class="headerlink" title="1. 对称加密算法"></a>1. 对称加密算法</h2><p>对称加密是指加密和解密使用同一个密钥。对称加密只有一个密钥，作为私钥。<br>具体的算法有：DES、3DES、TDEA、Blowfish、RC5、IDEA。常用的有：DES、AES</p>
<p>优点：计算量小、加密速度快<br>缺点：不太安全，需要保存好密钥，而且，一般会为每个用户准备不同私钥，存储量大。</p>
<h3 id="1-1-ECB-和-CBC"><a href="#1-1-ECB-和-CBC" class="headerlink" title="1.1. ECB 和 CBC"></a>1.1. ECB 和 CBC</h3><ul>
<li>ECB 模式</li>
</ul>
<p>Electronic Codebook 电码本。将数据按照8个字节一段进行DES加密或解密得到一段段的8个字节的密文或者明文，最后一段不足8个字节（一般补0或者F），按照需求补足8个字节进行计算（并行计算），之后按照顺序将计算所得的数据连在一起即可，各段数据之间互不影响。</p>
<ul>
<li>CBC 模式</li>
</ul>
<p>Cipher Block Chaining 密文分组链接模式。</p>
<p>(1) 将数据按照 8 字节分组，得到D1, D2, … , Dn（若数据不是8的整数倍，用指定的PADDING数据补位）<br>(2) 第一组数据 D1 与初始化向量 I 异或后的结果进行 DES 加密得到第一组密文 C1<br>(3) 第二组数据 D2 与第一组的加密结果 C1 异或以后的结果进行 DES 加密，得到第二组密文 C2<br>(4) 之后的数据以此类推，得到Cn<br>(5) 按顺序连为C1C2C3…Cn即为加密结果。</p>
<h3 id="1-2-DES"><a href="#1-2-DES" class="headerlink" title="1.2. DES"></a>1.2. DES</h3><p>分组密码，以 64 位为分组对数据加密，密钥长度是 56 位。穷举法进行搜索，运算次数为 $2^{56}$ </p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>PHP</li>
</ul>
<p>php 7.1 之前加密与解密参考<a href="https://github.com/JiangChunbo/crypto/blob/master/des/php7.1-/DES.php">这里</a></p>
<p>php 7.1 之后加密解密 —— openssl</p>
<h4 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h4><ul>
<li>pkcs7Padding 函数</li>
</ul>
<p>可能在填充字节的过程中遇到。如果是 pkcs5Padding，固定传入 $size &#x3D; 8 即可</p>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/des/php7.1-/DES.php#L30">代码参考</a></p>
<p>&amp;nbsp;</p>
<ul>
<li>php 7.1 之前加密与解密</li>
</ul>
<p>如果与 Java 系统对接，建议传入 $key 固定为 8 位，保持与 Java 加解密库兼容。</p>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/des/php7.1-/DES.php">代码参考</a></p>
<p>&amp;nbsp;</p>
<ul>
<li>php 7.1 之后加密解密 —— openssl</li>
</ul>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/des/php7.1+/DES.php">代码参考</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openssl_encrypt</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">string</span> <span class="variable">$data</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">string</span> <span class="variable">$cipher_algo</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">string</span> <span class="variable">$passphrase</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> <span class="variable">$options</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">string</span> <span class="variable">$iv</span> = <span class="string">&quot;&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">	&amp;<span class="variable">$tag</span>, <span class="keyword">string</span> <span class="variable">$aad</span> = <span class="string">&quot;&quot;</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">int</span> <span class="variable">$tag_length</span> = <span class="number">16</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">string</span>|<span class="title">false</span></span></span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$data</td>
<td align="left">数据</td>
</tr>
<tr>
<td align="left">$options</td>
<td align="left">OPENSSL_NO_PADDING：需要手动填充，否则不对齐返回 false<br>OPENSSL_RAW_DATA：自动以 pkcs5 填充</td>
</tr>
</tbody></table>
<p>&amp;nbsp;</p>
<ul>
<li>Java 加密解密</li>
</ul>
<p>Java DESKeySpec 需要密码至少 8 字节，如果超过 8 字节，只取前 8 字节。</p>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/des/jdk8+/DES.java">代码参考</a></p>
<p>&amp;nbsp;</p>
<h3 id="1-2-AES"><a href="#1-2-AES" class="headerlink" title="1.2. AES"></a>1.2. AES</h3><p>AES 是一个高级加密标准（Advanced Encryption Standard）。</p>
<p>AES 按加密方式分为：AES-128、AES-192、AES-256</p>
<p>按加密模式分为：ECB、CBC、CTR、CFB、OCF</p>
<p>对称分组密码体制，分组长度 128 位。这种加密算法是美国联邦政府采用的区块加密标准，AES 标准用来代替原先的 DES。</p>
<p>javax.crypto 包下。</p>
<p>加解密功能由 Cipher 组件提供，</p>
<p>在设置 Cipher 类的时候注意点：<br>(1) Cipher 在使用时需以参数方式指定 transformation<br>(2) transformation 格式为 algorithm&#x2F;mode&#x2F;padding，其中 algorithm 为必输项，<br>(3) 缺省的 mode 为 ECB，缺省的 padding 为 PKCS5Padding<br>(4) 在 block 算法与流加密模式组合时，需在 mode 后面指定每次处理的 bit 数，如 DES&#x2F;CFB8&#x2F;NoPadding，如未指定则使用缺省值，SunJCE 缺省值为 64 bits<br>(5) Cipher 有 4 中操作模式：ENCRYPT_MODE(加密)、DECRYPT_MODE(解密)、WRAP_MODE(导出Key)、UNWRAP_MODE(导入Key)，初始化（init）时需要指定某种操作模式</p>
<p>&amp;nbsp;</p>
<h3 id="1-3-Discuz"><a href="#1-3-Discuz" class="headerlink" title="1.3. Discuz"></a>1.3. Discuz</h3><p>php 论坛框架 discuz 的加密算法，也兼容过期时间校验。</p>
<p><a href="https://gitee.com/jiang_chun_bo/encrypt/blob/master/discuz/php/DiscuzUtil.php">代码参考</a></p>
<p>&amp;nbsp;</p>
<h2 id="2-非对称加密算法"><a href="#2-非对称加密算法" class="headerlink" title="2. 非对称加密算法"></a>2. 非对称加密算法</h2><p>加密和解密用的不是同一个密钥。每个用户拥有 2 把钥匙，公钥和私钥。顾名思义，公钥，是可以对外发布的，私钥是自己保存，只有自己知道的。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><strong>信息加密和解密</strong> 用 A 用户的公钥加密后只能用 A 用户的私钥解密。B 需要告诉 A：请来 X 区域找我。B 使用 A 的公钥进行加密，将密文发送给 A，其他人拿到密文没有 A 私钥是无法知道内容的，只有 A 拿到密文之后使用私钥解密才行。</p>
<p><strong>加签和解签</strong> 公钥是用来解密信息的，确保别人知道这条消息是由我发布的，且是完整的。</p>
<p>A 用户通过私钥加密：我是 A，我收到了你的信息。此时，B 通过 A 的公钥解密，确认 A 已经收到了自己的消息。</p>
<h3 id="生成-RSA-密钥对"><a href="#生成-RSA-密钥对" class="headerlink" title="生成 RSA 密钥对"></a>生成 RSA 密钥对</h3><ul>
<li><p>openssl 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1024 密钥长度</span></span><br><span class="line">openssl genrsa -out key.pem 1024</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-out</td>
<td align="left">指定生成文件，包含公钥和私钥</td>
</tr>
</tbody></table>
</li>
<li><p>Java 代码生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">keySize</span> <span class="operator">=</span> <span class="number">1028</span>;</span><br><span class="line"><span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">keyPairGenerator.initialize(keySize);</span><br><span class="line"><span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line"></span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());</span><br></pre></td></tr></table></figure>
</li>
<li><p>PHP 代码生成</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$opensslConfigPath</span> = <span class="string">&#x27;D:\wampserver\bin\apache\apache2.4.46\conf\openssl.cnf&#x27;</span>;</span><br><span class="line"><span class="variable">$config</span> = <span class="keyword">array</span>(</span><br><span class="line">    <span class="string">&#x27;digest_alg&#x27;</span> =&gt; <span class="string">&#x27;sha512&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;private_key_bits&#x27;</span> =&gt; <span class="number">1024</span>,</span><br><span class="line">    <span class="string">&#x27;private_key_type&#x27;</span> =&gt; OPENSSL_KEYTYPE_RSA,</span><br><span class="line">    <span class="string">&#x27;config&#x27;</span>=&gt; <span class="variable">$opensslConfigPath</span></span><br><span class="line">);</span><br><span class="line"><span class="variable">$res</span> = <span class="title function_ invoke__">openssl_pkey_new</span>(<span class="variable">$config</span>); <span class="comment">//创建密钥对</span></span><br><span class="line"><span class="title function_ invoke__">openssl_pkey_export</span>(<span class="variable">$res</span>, <span class="variable">$privkey</span>, <span class="literal">null</span>, <span class="variable">$config</span>); <span class="comment">//生成私钥</span></span><br><span class="line"><span class="variable">$pubKey</span> = <span class="title function_ invoke__">openssl_pkey_get_details</span>(<span class="variable">$res</span>)[<span class="string">&#x27;key&#x27;</span>]; <span class="comment">//生成公钥</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$privkey</span>);</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$pubKey</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="RSA-加密与解密"><a href="#RSA-加密与解密" class="headerlink" title="RSA 加密与解密"></a>RSA 加密与解密</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul>
<li><p>Java 公钥加密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">modulus</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">pubExp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;&quot;</span>, <span class="number">16</span>);</span><br><span class="line"><span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="type">RSAPublicKeySpec</span> <span class="variable">pubKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RSAPublicKeySpec</span>(modulus, pubExp);</span><br><span class="line"><span class="type">RSAPublicKey</span> <span class="variable">key</span> <span class="operator">=</span> (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);</span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>);</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line"><span class="type">byte</span>[] cipherData = cipher.doFinal(<span class="string">&quot;密文&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>
</li>
<li><p>Java 私钥解密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] encrypted = <span class="string">&quot;&quot;</span>; <span class="comment">// 密文，需要 base64 解码</span></span><br><span class="line"><span class="type">PKCS8EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(Base64.getDecoder().decode(<span class="string">&quot;非 PEM 格式私钥&quot;</span>));</span><br><span class="line"><span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line"><span class="type">RSAPrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> (RSAPrivateKey) keyFactory.generatePrivate(keySpec);</span><br><span class="line"><span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>);</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line"><span class="type">byte</span>[] decrptyed = cipher.doFinal(encrypted);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(decrptyed));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><ul>
<li>公钥加密</li>
</ul>
<p>使用 <strong>JSEncrypt</strong> 库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">JSEncrypt</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;jsencrypt/lib/JSEncrypt&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> publicKey = <span class="string">&#x27;&#x27;</span> <span class="comment">// PEM 格式公钥</span></span><br><span class="line"><span class="keyword">const</span> origin = <span class="string">&#x27;&#x27;</span> <span class="comment">// 需要加密的数据</span></span><br><span class="line"><span class="keyword">const</span> jsEncrypt = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>()</span><br><span class="line">jsEncrypt.<span class="title function_">setPublicKey</span>(publicKey)</span><br><span class="line"><span class="keyword">const</span> encrypted = jsEncrypt.<span class="title function_">encrypt</span>(origin) <span class="comment">// 返回的是 base64 编码的结果</span></span><br></pre></td></tr></table></figure>

<ul>
<li>私钥解密<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> privateKey = <span class="string">&#x27;&#x27;</span> <span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> encrypted = <span class="string">&#x27;&#x27;</span> <span class="comment">// 传递 base64 编码的加密值</span></span><br><span class="line"><span class="keyword">const</span> jsEncrypt = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>()</span><br><span class="line">jsEncrypt.<span class="title function_">setPrivateKey</span>(privateKey)</span><br><span class="line"><span class="keyword">const</span> decrypted = jsEncrypt.<span class="title function_">decrypt</span>(msg)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul>
<li>解密<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$encrypted</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 密文，如果有必要需要进行 base64 解码</span></span><br><span class="line"><span class="variable">$decrypted</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 解密之后存放的变量</span></span><br><span class="line"><span class="variable">$private_key</span> = <span class="string">&#x27;&#x27;</span>; <span class="comment">// PEM 格式私钥</span></span><br><span class="line"><span class="title function_ invoke__">openssl_private_decrypt</span>(<span class="variable">$password</span>, <span class="variable">$decrypted</span>, <span class="variable">$private_key</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h2><p>通过对所有数据提取指纹信息以实现数据签名、数据完整性校验等功能。数据摘要算法也被称为哈希算法或散列算法。</p>
<p>具体摘要算法：</p>
<p>CRC8 CRC16 CRC 32</p>
<p>MD2 MD4 MD5 </p>
<p>SHA1 SHA256  SHA384  SHA512，SHA（Secure Hash Algorithm）是由美国专门制定密码算法的标准机构——美国国家标准技术研究院制定。</p>
<p>RIPEMD、PANAMA、TIGER、ADLER32 </p>
]]></content>
      <tags>
        <tag>crpto</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro BasicHttpAuthenticationFilter 认证流程</title>
    <url>/2022/07/08/Shiro/Shiro-BasicHttpAuthenticationFilter-%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Shiro-BasicHttpAuthenticationFilter-认证流程分析"><a href="#Shiro-BasicHttpAuthenticationFilter-认证流程分析" class="headerlink" title="Shiro BasicHttpAuthenticationFilter 认证流程分析"></a>Shiro BasicHttpAuthenticationFilter 认证流程分析</h1><p>以 Shiro 1.8.0 为例子，其中新增了一些新的组件，譬如 <code>HttpAuthenticationFilter</code><br>之前使用的 1.4.1 并不存在 <code>HttpAuthenticationFilter</code> 组件</p>
<h2 id="1-BasicHttpAuthenticationFilter-层次结构"><a href="#1-BasicHttpAuthenticationFilter-层次结构" class="headerlink" title="1. BasicHttpAuthenticationFilter 层次结构"></a>1. BasicHttpAuthenticationFilter 层次结构</h2><p>要分析 <code>BasicHttpAuthenticationFilter</code> 的认证流程，其实也是分析该过滤器（<code>doFilter</code>）的执行流程，而该过滤器的继承层次有一定复杂度，因此先了解一下其继承结构：</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/BasicHttpAuthenticationFilter.png" width="500">


<h2 id="2-OncePerRequestFilter-doFilter"><a href="#2-OncePerRequestFilter-doFilter" class="headerlink" title="2. OncePerRequestFilter.doFilter"></a>2. OncePerRequestFilter.doFilter</h2><p>从继承关系可以看到 <code>BasicHttpAuthenticationFilter</code> 继承自抽象类 <code>OncePerRequestFilter</code>。</p>
<blockquote>
<p><code>OncePerRequestFilter</code> 的字面意思是：Once Per Request，即每个请求只执行一次，它巧妙的设计使得无论添加多少个过滤器，都只执行一次。</p>
</blockquote>
<p>如下是 <code>OncePerRequestFilter</code> 的 <code>doFilter</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain filterChain)</span></span><br><span class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(request <span class="keyword">instanceof</span> HttpServletRequest) || !(response <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;OncePerRequestFilter just supports HTTP requests&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpServletRequest) request;</span><br><span class="line">    <span class="type">HttpServletResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> (HttpServletResponse) response;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">alreadyFilteredAttributeName</span> <span class="operator">=</span> getAlreadyFilteredAttributeName();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasAlreadyFilteredAttribute</span> <span class="operator">=</span> request.getAttribute(alreadyFilteredAttributeName) != <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasAlreadyFilteredAttribute || skipDispatch(httpRequest) || shouldNotFilter(httpRequest)) &#123;</span><br><span class="line">        <span class="comment">// 继续执行，不调用此过滤器</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用该过滤器</span></span><br><span class="line">        request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doFilterInternal(httpRequest, httpResponse, filterChain);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 为本次请求删除 &quot;已经过滤&quot; 的请求属性，能够释放一些空间</span></span><br><span class="line">            request.removeAttribute(alreadyFilteredAttributeName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-AdviceFilter-doFilterInternal"><a href="#3-AdviceFilter-doFilterInternal" class="headerlink" title="3. AdviceFilter.doFilterInternal"></a>3. AdviceFilter.doFilterInternal</h2><p>可以知道 <code>OncePerRequestFilter</code> 已经实现了 <code>doFilter</code>，而且知道，真正的处理逻辑在 <code>doFilterInternal()</code> 方法中。然而，<code>doFilterInternal()</code> 方法是在子类 <code>AdviceFilter</code> 实现的，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前置处理</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">continueChain</span> <span class="operator">=</span> preHandle(request, response);</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Invoked preHandle method.  Continuing chain?: [&quot;</span> + continueChain + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否继续</span></span><br><span class="line">        <span class="keyword">if</span> (continueChain) &#123;</span><br><span class="line">            executeChain(request, response, chain);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后置处理</span></span><br><span class="line">        postHandle(request, response);</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Successfully invoked postHandle method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        exception = e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        cleanup(request, response, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-PathMatchingFilter-preHandle"><a href="#4-PathMatchingFilter-preHandle" class="headerlink" title="4. PathMatchingFilter.preHandle"></a>4. PathMatchingFilter.preHandle</h2><p>下面先看 preHandle，<code>PathMatchingFilter</code> 已经实现了 preHandle()。PathMatchingFilter，顾名思义，路径匹配过滤器，它的作用就是来根据路径匹配结果，调用相应过滤器（没匹配上的直接 return true，即继续执行过滤器链）。</p>
<blockquote>
<p>path 匹配是通过 <code>FilterChainDefinitionMap</code> 注册的，比如设置了 “&#x2F;login”, “anon”，那么如果本次请求的地址也是 &#x2F;login，则会匹配上。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.appliedPaths == <span class="literal">null</span> || <span class="built_in">this</span>.appliedPaths.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;appliedPaths property is null or empty.  This Filter will passthrough immediately.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String path : <span class="built_in">this</span>.appliedPaths.keySet()) &#123;</span><br><span class="line">        <span class="comment">// If the path does match, then pass on to the subclass implementation for</span></span><br><span class="line">        <span class="comment">// specific checks</span></span><br><span class="line">        <span class="comment">// (first match &#x27;wins&#x27;):</span></span><br><span class="line">        <span class="keyword">if</span> (pathsMatch(path, request)) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Current requestURI matches pattern &#x27;&#123;&#125;&#x27;.  Determining filter chain execution...&quot;</span>, path);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">config</span> <span class="operator">=</span> <span class="built_in">this</span>.appliedPaths.get(path);</span><br><span class="line">            <span class="keyword">return</span> isFilterChainContinued(request, response, path, config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no path matched, allow the request to go through:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码中的 config 对象具有非常高的灵活性，在 <code>BasicHttpAuthenticationFilter</code> 的流程中，你可以进行一些 HTTP Method、permissive 的特殊配置，这些设计都是内嵌在过滤器中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 表示对于 /** 的 GET POST 请求都需要经过 Basic 验证</span></span><br><span class="line">chainDefinition.addPathDefinition(<span class="string">&quot;/**&quot;</span>, <span class="string">&quot;authcBasic[get,post]&quot;</span>);</span><br><span class="line"><span class="comment">// 表示对于 /permissive 开头的请求都会放行</span></span><br><span class="line">chainDefinition.addPathDefinition(<span class="string">&quot;/permissive/**&quot;</span>, <span class="string">&quot;authcBasic[permissive]&quot;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果 path 匹配成功，则会先执行 isFilterChainContinued()，isFilterChainContinued() 方法也是在 PathMatchingFilter 实现的。它的作用就是判断过滤器是否可用，如果可用就继续执行；否则，跳过，return true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isFilterChainContinued</span><span class="params">(ServletRequest request, ServletResponse response,</span></span><br><span class="line"><span class="params">    String path, Object pathConfig)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEnabled(request, response, path, pathConfig)) &#123; <span class="comment">// isEnabled check added in 1.2</span></span><br><span class="line">        <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">            log.trace(<span class="string">&quot;Filter &#x27;&#123;&#125;&#x27; is enabled for the current request under path &#x27;&#123;&#125;&#x27; with config [&#123;&#125;].  &quot;</span> +</span><br><span class="line">                <span class="string">&quot;Delegating to subclass implementation for &#x27;onPreHandle&#x27; check.&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; getName(), path, pathConfig &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//The filter is enabled for this specific request, so delegate to subclass implementations</span></span><br><span class="line"><span class="comment">//so they can decide if the request should continue through the chain or not:</span></span><br><span class="line">        <span class="keyword">return</span> onPreHandle(request, response, pathConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Filter &#x27;&#123;&#125;&#x27; is disabled for the current request under path &#x27;&#123;&#125;&#x27; with config [&#123;&#125;].  &quot;</span> +</span><br><span class="line">            <span class="string">&quot;The next element in the FilterChain will be called immediately.&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; getName(), path, pathConfig &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//This filter is disabled for this specific request,</span></span><br><span class="line"><span class="comment">//return &#x27;true&#x27; immediately to indicate that the filter will not process the request</span></span><br><span class="line"><span class="comment">//and let the request/response to continue through the filter chain:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>isEnabled 方法本质上是判断 enabled 是否为 true。其实几乎所有的过滤器都可以执行，因此 enabled 默认为 true，除非人为的去设置它的值：</p>
<h2 id="5-AccessControlFilter-onPreHandle"><a href="#5-AccessControlFilter-onPreHandle" class="headerlink" title="5. AccessControlFilter.onPreHandle"></a>5. AccessControlFilter.onPreHandle</h2><p>从 <code>preHandle()</code> 走下来的，这里之所以起名为 <code>onPreHandle()</code>，是因为这才是真正的执行逻辑，之前的种种都是可以看作判断。</p>
<p><code>onPreHandle()</code> 在 <code>PathMatchingFilter</code> 的子类 <code>AccessControlFilter</code> 有了新的实现，它的返回值依赖两个方法 isAccessAllowed()、onAccessDenied()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> isAccessAllowed(request, response, mappedValue) || onAccessDenied(request, response, mappedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述逻辑可以转换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onPreHandle</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (isAccessAllowed(request, response, mappedValue)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onAccessDenied(request, response, mappedValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-HttpAuthenticationFilter-isAccessAllowed"><a href="#6-HttpAuthenticationFilter-isAccessAllowed" class="headerlink" title="6. HttpAuthenticationFilter.isAccessAllowed"></a>6. HttpAuthenticationFilter.isAccessAllowed</h2><p>当执行 AccessControlFilter.onPreHandle 会首先判断 <code>isAccessAllowed</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> WebUtils.toHttp(request);</span><br><span class="line">    <span class="type">String</span> <span class="variable">httpMethod</span> <span class="operator">=</span> httpRequest.getMethod();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether the current request&#x27;s method requires authentication.</span></span><br><span class="line">    <span class="comment">// If no methods have been configured, then all of them require auth,</span></span><br><span class="line">    <span class="comment">// otherwise only the declared ones need authentication.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的 mappedValue 其实就是上述的 config 对象，本质上是一个 String[]</span></span><br><span class="line">    <span class="comment">// 这里可以校验一些 HTTP Method 是否需要认证</span></span><br><span class="line">    <span class="comment">// 这也就是为什么你可以设计为 authBasic[get,post]</span></span><br><span class="line">    Set&lt;String&gt; methods = httpMethodsFromOptions((String[]) mappedValue);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">authcRequired</span> <span class="operator">=</span> methods.size() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String m : methods) &#123;</span><br><span class="line">        <span class="keyword">if</span> (httpMethod.toUpperCase(Locale.ENGLISH).equals(m)) &#123;</span><br><span class="line">            <span class="comment">// 需要认证</span></span><br><span class="line">            authcRequired = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (authcRequired) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.isAccessAllowed(request, response, mappedValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述校验 HTTP Method 的方法对 RESTful 风格非常有效：<br>实际上，该方法先做了一个 HTTP Method 的比对，自定义 FilterChainDefinitionMap 的时候，可以设置一批 HTTP method 是需要认证的，比如：<br>如果当前使用 RESTful 风格请求。现有 [PUT] &#x2F;project 用于更新，[GET] &#x2F;project 用于获取全部数据，这两个请求 URL 都是一样的，但如何让 GET 请求通过，PUT 请求需要授权呢？答案就是使用 HTTP Method 方法过滤。<br>配置 &#x2F;project &#x3D; authcBasic[PUT]<br>那么，访问 &#x2F;project 的时候，GET 方法是不用认证的。<br>所以现在知道，即使没有写 GET，依然也会走 BasicHttpAuthenticationFilter，只是认证直接跳过（return true）。<br>因此，如果 HTTP Method 属于这一类 Method，那么就调用了 super.isAccessAllowed 进行判断。</p>
<h2 id="7-AuthenticationFilter-isAccessAllowed"><a href="#7-AuthenticationFilter-isAccessAllowed" class="headerlink" title="7. AuthenticationFilter.isAccessAllowed"></a>7. AuthenticationFilter.isAccessAllowed</h2><p>下面继续观察 super.isAccessAllowed() 方法到底做了什么？</p>
<p>首先，在继承链上，离 <code>HttpAuthenticationFilter</code> 最近的 <code>AuthenticatingFilter</code> 也实现了 isAccessAllowed() 方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.isAccessAllowed(request, response, mappedValue) ||</span><br><span class="line">            (!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注意到，该方法也使用了 super 去调用父类方法，找到最近的有实现方法的父类 AuthenticationFilter，方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> getSubject(request, response);</span><br><span class="line">    <span class="keyword">return</span> subject.isAuthenticated();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 Subject，然后调用 isAuthenticated() 判断是否已经认证过了。</p>
<blockquote>
<p>作用：判断是否认证过了，通俗来说，就是登陆了没。</p>
</blockquote>
<p>如果 isAccessAllowed 返回 false，表示不允许访问，那么需要继续判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">!isLoginRequest(request, response) &amp;&amp; isPermissive(mappedValue)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>isLoginRequest()</code> 的判断，在本 BasicHttpAuthenticationFilter 的案例中，根据请求头判断<br><code>isPermissive()</code> 的判断是根据你是否在 chainDefinition 配置 [permissive]</p>
</blockquote>
<h2 id="8-BasicHttpAuthenticationFilter-isLoginRequest"><a href="#8-BasicHttpAuthenticationFilter-isLoginRequest" class="headerlink" title="8. BasicHttpAuthenticationFilter.isLoginRequest"></a>8. BasicHttpAuthenticationFilter.isLoginRequest</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isLoginRequest</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.isLoginAttempt(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLoginAttempt</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">authzHeader</span> <span class="operator">=</span> getAuthzHeader(request);</span><br><span class="line">    <span class="comment">// 判断头部 Authorization 是否以 BASIC 开头</span></span><br><span class="line">    <span class="keyword">return</span> authzHeader != <span class="literal">null</span> &amp;&amp; isLoginAttempt(authzHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-BasicHttpAuthenticationFilter-onAccessDenied"><a href="#9-BasicHttpAuthenticationFilter-onAccessDenied" class="headerlink" title="9. BasicHttpAuthenticationFilter.onAccessDenied"></a>9. BasicHttpAuthenticationFilter.onAccessDenied</h2><p>回到 AccessControlFilter.onPreHandle 第二个处理逻辑 —— <code>onAccessDenied</code></p>
<p>该方法就是 isAccessAllowed 返回 false 之后执行的，即访问拒绝的逻辑。</p>
<p><code>BasicHttpAuthenticationFilter</code> 实现了自己的 onAccessDenied：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onAccessDenied</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loggedIn</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// false by default or we wouldn&#x27;t be in this method</span></span><br><span class="line">    <span class="comment">// 判断是否是 Basic 特定请求头</span></span><br><span class="line">    <span class="keyword">if</span> (isLoginAttempt(request, response)) &#123;</span><br><span class="line">        loggedIn = executeLogin(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!loggedIn) &#123;</span><br><span class="line">        <span class="comment">// 发送质询</span></span><br><span class="line">        sendChallenge(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loggedIn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="10-AuthenticatingFilter-executeLogin"><a href="#10-AuthenticatingFilter-executeLogin" class="headerlink" title="10. AuthenticatingFilter.executeLogin"></a>10. AuthenticatingFilter.executeLogin</h2><p>BasicHttpAuthenticationFilter 是没有实现 executeLogin() 的，因此将调用父类 AuthenticatingFilter 的 executeLogin() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">executeLogin</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span> createToken(request, response);</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;createToken method implementation returned null. A valid non-null AuthenticationToken &quot;</span> +</span><br><span class="line">            <span class="string">&quot;must be created in order to execute a login attempt.&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> getSubject(request, response);</span><br><span class="line">        subject.login(token);</span><br><span class="line">        <span class="keyword">return</span> onLoginSuccess(token, subject, request, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> onLoginFailure(token, e, request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createToken()，该方法又是 BasicHttpAuthenticationFilter 来实现的，其实也就是从 Authorization 的 Request Header 提取base64 编码的用户名和密码，然后解析，最终会实例化 UsernamePasswordToken。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AuthenticationToken <span class="title function_">createToken</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">authorizationHeader</span> <span class="operator">=</span> getAuthzHeader(request);</span><br><span class="line">    <span class="keyword">if</span> (authorizationHeader == <span class="literal">null</span> || authorizationHeader.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Create an empty authentication token since there is no</span></span><br><span class="line">        <span class="comment">// Authorization header.</span></span><br><span class="line">        <span class="keyword">return</span> createToken(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;Attempting to execute login with auth header&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String[] prinCred = getPrincipalsAndCredentials(authorizationHeader, request);</span><br><span class="line">    <span class="keyword">if</span> (prinCred == <span class="literal">null</span> || prinCred.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// Create an authentication token with an empty password,</span></span><br><span class="line">        <span class="comment">// since one hasn&#x27;t been provided in the request.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> prinCred == <span class="literal">null</span> || prinCred.length == <span class="number">0</span> ? <span class="string">&quot;&quot;</span> : prinCred[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> createToken(username, <span class="string">&quot;&quot;</span>, request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> prinCred[<span class="number">0</span>];</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> prinCred[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createToken(username, password, request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在 createToken 之后，会 getSubject，执行 login()。后面会委托给 SecurityManager.login 方法，在 securityManager 中会对 token 进行验证，本质上就是调用 Realm 方法验证，如果验证过程中没有异常抛出，则顺利执行，</p>
<p>​如果认证过程没有异常抛出，最终会走到 onLoginSuccess()，如果有异常抛出则执行 onLoginFailure()。</p>
<blockquote>
<p>一般也就是在 Realm 的执行逻辑中抛出异常。</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro DefaultFilter 使用笔记</title>
    <url>/2022/07/14/Shiro/Shiro-DefaultFilter-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Shiro-DefaultFilter-使用笔记"><a href="#Shiro-DefaultFilter-使用笔记" class="headerlink" title="Shiro DefaultFilter 使用笔记"></a>Shiro DefaultFilter 使用笔记</h1><h2 id="anon"><a href="#anon" class="headerlink" title="anon"></a>anon</h2><p>AnonymousFilter</p>
<p>匿名过滤器，请求 <code>onPreHandle()</code> 直接通过。</p>
<h2 id="authc"><a href="#authc" class="headerlink" title="authc"></a>authc</h2><p>FormAuthenticationFilter</p>
<p>onAccessDenied 方法分 loginUrl 处理和非 loginUrl 处理：<br>(1) 当请求是 loginUrl 时，其中又根据是否为 POST 请求判断是否是 login 页面请求还是，login 提交。<br>(2) 当请求是非 loginUrl 时，向 session 存储了一个属性 shiroSavedRequest， 然后跳转到登录页面。</p>
<h2 id="authcBasic"><a href="#authcBasic" class="headerlink" title="authcBasic"></a>authcBasic</h2><p>BasicHttpAuthenticationFilter</p>
<p>onAccessDenied 逻辑：</p>
<ol>
<li>通过请求头 Authorization 判断是否为 login 请求，如果是，执行 executeLogin 逻辑，获取 username, password 构造 AuthenticationToken 进行 Realm 认证。</li>
<li>如果不是 login 请求，或者登录失败，发送质询</li>
</ol>
<h2 id="invalidRequest"><a href="#invalidRequest" class="headerlink" title="invalidRequest"></a>invalidRequest</h2><p>InvalidRequestFilter</p>
<p>默认全局过滤器，过滤一些非法请求</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro FilterChainDefinitionMap 注册原理</title>
    <url>/2022/07/14/Shiro/Shiro-FilterChainDefinitionMap-%E6%B3%A8%E5%86%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Shiro-FilterChainDefinitionMap-注册原理"><a href="#Shiro-FilterChainDefinitionMap-注册原理" class="headerlink" title="Shiro FilterChainDefinitionMap 注册原理"></a>Shiro FilterChainDefinitionMap 注册原理</h1><p>在进行 <code>FilterChainDefinitionMap</code> 配置的时候，需要准备两个字符串，分别称之为 <code>antPath</code> 和 <code>definition</code>。以如下的配置为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultShiroFilterChainDefinition</span> <span class="variable">chainDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShiroFilterChainDefinition</span>();</span><br><span class="line">chainDefinition.addPathDefinition(<span class="string">&quot;/url&quot;</span>, <span class="string">&quot;authc, roles[admin,user], perms[file:edit]&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个字符串可以认为是路径（可以包含通配符），第二个字符串是过滤器链定义</p>
</blockquote>
<p>对于 <code>FilterChainDefinitionMap</code> 中每个 filter Chain Definition 的处理都是在 <code>DefaultFilterChainManager</code> 进行的，主要关注如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处的 chainName 就是 antPath </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createChain</span><span class="params">(String chainName, String chainDefinition)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(chainName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;chainName cannot be null or empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(chainDefinition)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;chainDefinition cannot be null or empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;Creating chain [&quot;</span> + chainName + <span class="string">&quot;] with global filters &quot;</span> + globalFilterNames + <span class="string">&quot; and from String definition [&quot;</span> + chainDefinition + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先以此添加全局 filter，比如 InvalidRequestFilter</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(globalFilterNames)) &#123;</span><br><span class="line">        globalFilterNames.stream().forEach(filterName -&gt; addToChain(chainName, filterName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对值进行标记解析，以获得最后特定于过滤器的配置项</span></span><br><span class="line">    <span class="comment">// 这里以半角逗号(,) 作为分隔符，忽略两边空白符</span></span><br><span class="line">    <span class="comment">// 例如对于值：</span></span><br><span class="line">    <span class="comment">//     &quot;authc, roles[admin,user], perms[file:edit]&quot;</span></span><br><span class="line">    <span class="comment">// 最终的标记数组为：</span></span><br><span class="line">    <span class="comment">//     &#123; &quot;authc&quot;, &quot;roles[admin,user]&quot;, &quot;perms[file:edit]&quot; &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    String[] filterTokens = splitChainDefinition(chainDefinition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个标记都是特定于每个过滤器的</span></span><br><span class="line">    <span class="comment">// 即，这些配置可能是过滤器约定好的，你需要熟悉这些用法</span></span><br><span class="line">    <span class="comment">// 譬如 roles[admin,user] 括号 [] 之间代表着角色</span></span><br><span class="line">    <span class="comment">//      perms[file:edit] 括号 [] 之间代表权限，权限又用 : 隔开，前者表示操作对象，后者表示操作类型</span></span><br><span class="line">    <span class="comment">// 剥离 name，提取括号 [] 之间的特定于过滤器的配置</span></span><br><span class="line">    <span class="keyword">for</span> (String token : filterTokens) &#123;</span><br><span class="line">        <span class="comment">// 一定是一个包含 2 个元素的数组，第一个是 filter name，第二个 config 可能是 null</span></span><br><span class="line">        <span class="comment">// [ &quot;authc&quot;, null ]</span></span><br><span class="line">        <span class="comment">// [ &quot;roles&quot;, &quot;admin,user&quot; ]</span></span><br><span class="line">        <span class="comment">// [ &quot;perms&quot;, &quot;file:edit&quot; ]</span></span><br><span class="line">        String[] nameConfigPair = toNameConfigPair(token);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在，我们拥有过滤器名称，路径，以及特定于路径的配置（可能是 null，也就是没有配置）</span></span><br><span class="line">        addToChain(chainName, nameConfigPair[<span class="number">0</span>], nameConfigPair[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addToChain</span><span class="params">(String chainName, String filterName, String chainSpecificFilterConfig)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(chainName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;chainName cannot be null or empty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> getFilter(filterName);</span><br><span class="line">    <span class="keyword">if</span> (filter == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;There is no filter with name &#x27;&quot;</span> + filterName +</span><br><span class="line">                <span class="string">&quot;&#x27; to apply to chain [&quot;</span> + chainName + <span class="string">&quot;] in the pool of available Filters.  Ensure a &quot;</span> +</span><br><span class="line">                <span class="string">&quot;filter with that name/path has first been registered with the addFilter method(s).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里主要就是把配置字符串，如：admin,user 按照半角逗号（,）分割</span></span><br><span class="line">    <span class="comment">// 将得到的 chainName 和 [admin, user] 放入过滤器中  Map&lt;String, Object&gt; appliedPaths 结构中</span></span><br><span class="line">    <span class="comment">// 之所以这样做，是因为对于不同的路径，可能会配置同一个过滤器的不同过滤规则</span></span><br><span class="line">    <span class="comment">// 比如： 学校列表学校管理员与区级管理员可访问，区列表仅区级管理员访问</span></span><br><span class="line">    <span class="comment">//      /school/list  roles[school_admin, area_admin]</span></span><br><span class="line">    <span class="comment">//      /area/list    roles[area_admin]</span></span><br><span class="line">    applyChainConfig(chainName, filter, chainSpecificFilterConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensureChain 顾名思义，表示确保 chain 存在，如果不存在就新建一个</span></span><br><span class="line">    <span class="type">NamedFilterList</span> <span class="variable">chain</span> <span class="operator">=</span> ensureChain(chainName);</span><br><span class="line">    chain.add(filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro Subject login 流程分析</title>
    <url>/2022/07/14/Shiro/Shiro-Subject-login-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Subject-login-流程分析"><a href="#Subject-login-流程分析" class="headerlink" title="Subject login 流程分析"></a>Subject login 流程分析</h1><p>通常，在执行登录之前，我们必须拥有一个 <code>Subject</code> 对象，可能是从 <code>SecurityUtils</code> 类中获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br></pre></td></tr></table></figure>

<p>Shiro 框架中 <code>Subject</code> 实现类 <code>DelegatingSubject</code>，顾名思义，委托中的 <code>Subject</code>，该类本身不做 login 操作，而是将 login 操作委托给 <code>SecurityManager</code></p>
<p>Subject.login() 的方法声明如下，需要传入一个 <code>AuthenticationToken</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">login</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException;</span><br></pre></td></tr></table></figure>

<p>具体实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    clearRunAsIdentitiesInternal();</span><br><span class="line">    <span class="comment">// 委托给 SecurityManager 执行</span></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> securityManager.login(<span class="built_in">this</span>, token);</span><br><span class="line"></span><br><span class="line">    PrincipalCollection principals;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subject <span class="keyword">instanceof</span> DelegatingSubject) &#123;</span><br><span class="line">        <span class="type">DelegatingSubject</span> <span class="variable">delegating</span> <span class="operator">=</span> (DelegatingSubject) subject;</span><br><span class="line">        <span class="comment">//we have to do this in case there are assumed identities - we don&#x27;t want to lose the &#x27;real&#x27; principals:</span></span><br><span class="line">        principals = delegating.principals;</span><br><span class="line">        host = delegating.host;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        principals = subject.getPrincipals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (principals == <span class="literal">null</span> || principals.isEmpty()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Principals returned from securityManager.login( token ) returned a null or &quot;</span> +</span><br><span class="line">                <span class="string">&quot;empty value.  This value must be non null and populated with one or more elements.&quot;</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.principals = principals;</span><br><span class="line">    <span class="built_in">this</span>.authenticated = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (token <span class="keyword">instanceof</span> HostAuthenticationToken) &#123;</span><br><span class="line">        host = ((HostAuthenticationToken) token).getHost();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (host != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> subject.getSession(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = decorate(session);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.session = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DefaultSecurityManager</code> 的 login 方法如下，其中 authenticate 是执行认证的关键方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Subject <span class="title function_">login</span><span class="params">(Subject subject, AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    AuthenticationInfo info;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        info = authenticate(token);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onFailedLogin(token, ae, subject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;onFailedLogin method threw an &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;exception.  Logging and propagating original AuthenticationException.&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> ae; <span class="comment">//propagate</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Subject</span> <span class="variable">loggedIn</span> <span class="operator">=</span> createSubject(token, info, subject);</span><br><span class="line"></span><br><span class="line">    onSuccessfulLogin(token, info, loggedIn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loggedIn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SecurityManager</code> 将认证的方法委托给了内部认证器 <code>Authenticator</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> AuthenticationInfo <span class="title function_">authenticate</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.authenticator.authenticate(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractAuthenticator</code> 认证方法 <code>authenticate()</code> 代码如下，其中 <code>doAuthenticate()</code> 是认证的关键方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> AuthenticationInfo <span class="title function_">authenticate</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Method argument (authentication token) cannot be null.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.trace(<span class="string">&quot;Authentication attempt received for token [&#123;&#125;]&quot;</span>, token);</span><br><span class="line"></span><br><span class="line">    AuthenticationInfo info;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        info = doAuthenticate(token);</span><br><span class="line">        <span class="keyword">if</span> (info == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;No account information found for authentication token [&quot;</span> + token + <span class="string">&quot;] by this &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;Authenticator instance.  Please check that it is configured correctly.&quot;</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="type">AuthenticationException</span> <span class="variable">ae</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> AuthenticationException) &#123;</span><br><span class="line">            ae = (AuthenticationException) t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ae == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Exception thrown was not an expected AuthenticationException.  Therefore it is probably a little more</span></span><br><span class="line">            <span class="comment">//severe or unexpected.  So, wrap in an AuthenticationException, log to warn, and propagate:</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Authentication failed for token submission [&quot;</span> + token + <span class="string">&quot;].  Possible unexpected &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;error? (Typical or expected login exceptions should extend from AuthenticationException).&quot;</span>;</span><br><span class="line">            ae = <span class="keyword">new</span> <span class="title class_">AuthenticationException</span>(msg, t);</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled())</span><br><span class="line">                log.warn(msg, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notifyFailure(token, ae);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Unable to send notification for failed authentication attempt - listener error?.  &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;Please check your AuthenticationListener implementation(s).  Logging sending exception &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;and propagating original AuthenticationException instead...&quot;</span>;</span><br><span class="line">                log.warn(msg, t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> ae;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;Authentication successful for token [&#123;&#125;].  Returned account [&#123;&#125;]&quot;</span>, token, info);</span><br><span class="line"></span><br><span class="line">    notifySuccess(token, info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，我们可以认为 Shiro 框架中的认证器就是 <code>ModularRealmAuthenticator</code>，因为没有其他实现类了，其 <code>doAuthenticate()</code> 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doAuthenticate</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    assertRealmsConfigured();</span><br><span class="line">    Collection&lt;Realm&gt; realms = getRealms();</span><br><span class="line">    <span class="keyword">if</span> (realms.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有 1 个 Realm</span></span><br><span class="line">        <span class="keyword">return</span> doSingleRealmAuthentication(realms.iterator().next(), authenticationToken);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 具有多个 Realm</span></span><br><span class="line">        <span class="keyword">return</span> doMultiRealmAuthentication(realms, authenticationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果配置了多个 <code>Realm</code>，会使用到认证策略 <code>AuthenticationStrategy</code>，认证策略也有很多种，其中的 <code>AllSuccessfulStrategy</code> 要求所有的 <code>Realm</code> 都必须认证成功，并且会合并所有的 <code>AuthenticationInfo</code> 中的 <code>PrincipalCollection</code> 形成 <code>MutablePrincipalCollection</code>，凭证 <code>credential</code> 也会合并为集合。</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot 整合 MyBatis 启动原理</title>
    <url>/2022/07/15/Spring-Boot/Spring-Boot-%E6%95%B4%E5%90%88-MyBatis-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Spring-Boot-整合-MyBatis-启动原理"><a href="#Spring-Boot-整合-MyBatis-启动原理" class="headerlink" title="Spring Boot 整合 MyBatis 启动原理"></a>Spring Boot 整合 MyBatis 启动原理</h1><p>MyBatis 整合 Spring Boot 需要解决的是如何将自己创建的代理对象（<code>java.lang.reflect.Proxy</code>）交给 Spring 容器管理，这与将一个类（Class）交给 Spring 管理有所不同。</p>
<blockquote>
<p>将对象交给 Spring 容器管理，我们可以选择注入 Bean Definition，然后让 Spring 完成对象构造、配置、初始化等操作，然后放到 <code>singletonObjects</code> 单例池中，也可以选择直接放到单例池中，也就是不构造 Bean Definition，也不会存在于 <code>beanDefinitionMap</code>，这就是下面提及的 <code>SingletonBeanRegistry.registerSingleton</code> 方式</p>
</blockquote>
<p>将自定义的对象交给 Spring 容器管理，一般考虑的方式是：</p>
<ul>
<li>@Bean</li>
<li>factory method</li>
<li>SingletonBeanRegistry.registerSingleton</li>
<li>FactoryBean</li>
</ul>
<p>对于 <code>@Bean</code> 方式，我们可以使用这种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserMapper <span class="title function_">videoMapper</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加到 MapperRegistry.knownMappers，否则 SqlSession.getMapper 会抛出异常</span></span><br><span class="line">    sqlSession.getConfiguration().addMapper(UserMapper.class);</span><br><span class="line">    <span class="keyword">return</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方式的确可行，但是我们每定义一个 Mapper 就需要写一个 <code>@Bean</code> 方法，还是比较麻烦的。</p>
<p>factory method 注入的方式与 <code>@Bean</code> 大同小异。</p>
<p>MyBatis 整合进 Spring 选择的是 <code>FactoryBean</code> 方式，通过向容器注入 <code>FactoryBean</code> 这种特殊的 Bean Definitnion，进而注入 <code>Mapper</code></p>
<p>比较朴素的想法是，对于每个 <code>Mapper</code> 我们都为它定义一个 <code>FactoryBean</code>，但是这样工作量太大，MyBatis 通过动态 Class 实现了只需要一个 <code>MapperFactoryBean</code> 就可以构造出不同的 <code>Mapper</code> 实例</p>
<blockquote>
<p>底层对应 <code>MapperFactoryBean</code> 的属性 <code>mapperInterface</code>，表示不同的 <code>Mapper</code> 接口的 <code>Class</code> 对象</p>
</blockquote>
<p>在使用 Spring 整合 MyBatis 的时候，通常会使用如下配置，这也是官网 <a href="http://mybatis.org/spring/getting-started.html">Getting Started</a> 提供的案例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.spring.sample.mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis Spring Boot Starter 为了解决上述这种按需配置 <code>MapperFactoryBean</code> 的繁琐步骤，引入了 Spring 类路径扫描机制。</p>
<h2 id="Spring-Boot-加载-Mapper"><a href="#Spring-Boot-加载-Mapper" class="headerlink" title="Spring Boot 加载 Mapper"></a>Spring Boot 加载 Mapper</h2><ol>
<li>Spring Boot 启动过程中，会调用 <code>AbstractApplicationContext</code> 的 <code>refresh</code> 方法，其中一个过程是 <code>invokeBeanFactoryPostProcessors</code>，它会调用 <code>ConfigurationClassPostProcessor</code> 后置处理器加载具有 <code>@Configuration</code> 注解的 Bean。</li>
<li><code>ConfigurationClassPostProcessor</code> 关注的是 <code>@Configuration</code> 类型的 Bean，它会判断该 Bean 是否包含 <code>@Import</code> 注解。假设我们将 <code>@MapperScan</code> 添加在主启动类上（一般是具有 <code>@SpringBootApplication</code> 注解），那么将会读取主启动类注解，发现具有 <code>@MapperScan</code>，而 <code>@MapperScan</code> 嵌套了 <code>@Import</code> 注解，value 为 <code>MapperScannerRegistrar.class</code>，因此，将会构造<code>MapperScannerRegistrar</code> Bean Definition 进入 Spring 容器</li>
</ol>
<p>当 <code>@Configuration</code> 类解析完毕加载到容器后，就会执行 <code>load</code> 方法，用于加载这些 <code>@Configuration</code> 类相关的 Bean、Resource 等（如 <code>@Import</code>, <code>@ImportResource</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.reader.loadBeanDefinitions(configClasses)</span><br></pre></td></tr></table></figure>

<p>当 <code>load</code> 完毕，此时 <code>MapperScannerRegistrar</code> 已经加载到 Spring 容器，而且 <code>load</code> 会主动触发 <code>MapperScannerRegistrar</code> 的回调方法 <code>registerBeanDefinitions</code>。</p>
<p><code>MapperScannerRegistrar</code> 是 <code>ImportBeanDefinitionRegistrars</code> 的子类，其关键方法 <code>registerBeanDefinitions</code> 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得 @MapperScan 的全部属性</span></span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">mapperScanAttrs</span> <span class="operator">=</span> AnnotationAttributes</span><br><span class="line">        .fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));</span><br><span class="line">    <span class="keyword">if</span> (mapperScanAttrs != <span class="literal">null</span>) &#123;</span><br><span class="line">        registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry,</span><br><span class="line">            generateBaseBeanName(importingClassMetadata, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在底层构造了一个 <code>MapperScannerConfigurer</code> Bean Definitnion，并注册到容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造 MapperScannerConfigurer Bean Definition</span></span><br><span class="line">    <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);</span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;processPropertyPlaceHolders&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; annotationClass = annoAttrs.getClass(<span class="string">&quot;annotationClass&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Annotation.class.equals(annotationClass)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;annotationClass&quot;</span>, annotationClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; markerInterface = annoAttrs.getClass(<span class="string">&quot;markerInterface&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Class.class.equals(markerInterface)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;markerInterface&quot;</span>, markerInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">BeanNameGenerator</span>&gt; generatorClass = annoAttrs.getClass(<span class="string">&quot;nameGenerator&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BeanNameGenerator.class.equals(generatorClass)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;nameGenerator&quot;</span>, BeanUtils.instantiateClass(generatorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">MapperFactoryBean</span>&gt; mapperFactoryBeanClass = annoAttrs.getClass(<span class="string">&quot;factoryBean&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;mapperFactoryBeanClass&quot;</span>, mapperFactoryBeanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlSessionTemplateRef</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;sqlSessionTemplateRef&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(sqlSessionTemplateRef)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;sqlSessionTemplateBeanName&quot;</span>, annoAttrs.getString(<span class="string">&quot;sqlSessionTemplateRef&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlSessionFactoryRef</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;sqlSessionFactoryRef&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(sqlSessionFactoryRef)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;sqlSessionFactoryBeanName&quot;</span>, annoAttrs.getString(<span class="string">&quot;sqlSessionFactoryRef&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集 basePackage</span></span><br><span class="line">    List&lt;String&gt; basePackages = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    basePackages.addAll(</span><br><span class="line">        Arrays.stream(annoAttrs.getStringArray(<span class="string">&quot;value&quot;</span>)).filter(StringUtils::hasText).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getStringArray(<span class="string">&quot;basePackages&quot;</span>)).filter(StringUtils::hasText)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    basePackages.addAll(Arrays.stream(annoAttrs.getClassArray(<span class="string">&quot;basePackageClasses&quot;</span>)).map(ClassUtils::getPackageName)</span><br><span class="line">        .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (basePackages.isEmpty()) &#123;</span><br><span class="line">        basePackages.add(getDefaultBasePackage(annoMeta));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">lazyInitialization</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;lazyInitialization&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;lazyInitialization&quot;</span>, lazyInitialization);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">defaultScope</span> <span class="operator">=</span> annoAttrs.getString(<span class="string">&quot;defaultScope&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!AbstractBeanDefinition.SCOPE_DEFAULT.equals(defaultScope)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">&quot;defaultScope&quot;</span>, defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 basePackage 属性，用逗号(,)分隔</span></span><br><span class="line">    builder.addPropertyValue(<span class="string">&quot;basePackage&quot;</span>, StringUtils.collectionToCommaDelimitedString(basePackages));</span><br><span class="line"></span><br><span class="line">    registry.registerBeanDefinition(beanName, builder.getBeanDefinition());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MapperScannerConfigurer</code> 是 <code>BeanDefinitionRegistryPostProcessor</code> 的实现类，也就说其调用时机在 refresh 方法的 <code>invokeBeanFactoryPostProcessors</code> 中，它执行了类路径扫描，并注册了相关的 Mapper，关键方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.processPropertyPlaceHolders) &#123;</span><br><span class="line">        processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建扫描器</span></span><br><span class="line">    <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">    scanner.setAddToConfig(<span class="built_in">this</span>.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(<span class="built_in">this</span>.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(<span class="built_in">this</span>.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(<span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">    scanner.setSqlSessionTemplate(<span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(<span class="built_in">this</span>.sqlSessionFactoryBeanName);</span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(<span class="built_in">this</span>.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(<span class="built_in">this</span>.nameGenerator);</span><br><span class="line">    scanner.setMapperFactoryBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(lazyInitialization)) &#123;</span><br><span class="line">        scanner.setLazyInitialization(Boolean.valueOf(lazyInitialization));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(defaultScope)) &#123;</span><br><span class="line">        scanner.setDefaultScope(defaultScope);</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里将之前用逗号(,)分隔的 basePackage 字符串分解成 String[]</span></span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassPathBeanDefinitionScanner</code> 的 scan 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">beanCountAtScanStart</span> <span class="operator">=</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line">    doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassPathBeanDefinitionScanner</code> 的 doScan 方法如下，它返回扫描到的所有 <code>BeanDefinitionHolder</code> 的集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">                definitionHolder =</span><br><span class="line">                        AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis 覆盖了原来的 <code>doScan</code> 方法，因为我们不能把扫描到的 <code>Mapper</code> 接口交给 Spring 容器，否则后续的实例化将无法进行。因此，MyBatis 在调用 <code>super.doScan()</code> 方法得到扫描到的 <code>Set&lt;BeanDefinitionHolder&gt;</code> 之后又进行后置处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 Spring 内置提供的 doScan 方法</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">        LOGGER.warn(() -&gt; <span class="string">&quot;No MyBatis mapper was found in &#x27;&quot;</span> + Arrays.toString(basePackages)</span><br><span class="line">            + <span class="string">&quot;&#x27; package. Please check your configuration.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 后置处理</span></span><br><span class="line">        processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyBatis 的 <code>ClassPathMapperScanner</code> 后置处理方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> &#123; AbstractBeanDefinition definition;</span><br><span class="line">    <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry();</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">        definition = (AbstractBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">scopedProxy</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ScopedProxyFactoryBean.class.getName().equals(definition.getBeanClassName())) &#123;</span><br><span class="line">            definition = (AbstractBeanDefinition) Optional</span><br><span class="line">                .ofNullable(((RootBeanDefinition) definition).getDecoratedDefinition())</span><br><span class="line">                .map(BeanDefinitionHolder::getBeanDefinition).orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;The target bean definition of scoped proxy bean not found. Root bean definition[&quot;</span> + holder + <span class="string">&quot;]&quot;</span>));</span><br><span class="line">            scopedProxy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扫描到的 Mapper 接口，因此这里获取到的应该是形如 UserMapper 之类的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> definition.getBeanClassName();</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Creating MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + beanClassName</span><br><span class="line">            + <span class="string">&quot;&#x27; mapperInterface&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mapper 接口是 Bean 原始的类型，但是实际类型是 MapperFactoryBean</span></span><br><span class="line">        <span class="comment">// 将原始类型（Mapper）作为构造器参数传入</span></span><br><span class="line">        definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName); <span class="comment">// issue #59</span></span><br><span class="line">        <span class="comment">// 将 BeanClass 强制修改为 MapperFactoryBean 类型</span></span><br><span class="line">        definition.setBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line"></span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;addToConfig&quot;</span>, <span class="built_in">this</span>.addToConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attribute for MockitoPostProcessor</span></span><br><span class="line">        <span class="comment">// https://github.com/mybatis/spring-boot-starter/issues/475</span></span><br><span class="line">        definition.setAttribute(FACTORY_BEAN_OBJECT_TYPE, beanClassName);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">explicitFactoryUsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionFactoryBeanName)) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionFactory&quot;</span>, <span class="built_in">this</span>.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(<span class="built_in">this</span>.sqlSessionTemplateBeanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">            LOGGER.warn(</span><br><span class="line">                () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RuntimeBeanReference</span>(<span class="built_in">this</span>.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (explicitFactoryUsed) &#123;</span><br><span class="line">            LOGGER.warn(</span><br><span class="line">                () -&gt; <span class="string">&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(<span class="string">&quot;sqlSessionTemplate&quot;</span>, <span class="built_in">this</span>.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!explicitFactoryUsed) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Enabling autowire by type for MapperFactoryBean with name &#x27;&quot;</span> + holder.getBeanName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        definition.setLazyInit(lazyInitialization);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (scopedProxy) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ConfigurableBeanFactory.SCOPE_SINGLETON.equals(definition.getScope()) &amp;&amp; defaultScope != <span class="literal">null</span>) &#123;</span><br><span class="line">        definition.setScope(defaultScope);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!definition.isSingleton()) &#123;</span><br><span class="line">        <span class="type">BeanDefinitionHolder</span> <span class="variable">proxyHolder</span> <span class="operator">=</span> ScopedProxyUtils.createScopedProxy(holder, registry, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (registry.containsBeanDefinition(proxyHolder.getBeanName())) &#123;</span><br><span class="line">            registry.removeBeanDefinition(proxyHolder.getBeanName());</span><br><span class="line">        &#125;</span><br><span class="line">        registry.registerBeanDefinition(proxyHolder.getBeanName(), proxyHolder.getBeanDefinition());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Gateway</title>
    <url>/2022/07/15/Spring-Cloud/Spring-Cloud-Gateway/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/">Spring Cloud Gateway</a></h1><h2 id="1-How-to-Include-Spring-Cloud-Gateway"><a href="#1-How-to-Include-Spring-Cloud-Gateway" class="headerlink" title="1. How to Include Spring Cloud Gateway"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gateway-starter">1. How to Include Spring Cloud Gateway</a></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你包含了 starter，但是你不想启用网关，则可以设置 <code>spring.cloud.gateway.enabled=false</code></p>
<h2 id="2-Glossary"><a href="#2-Glossary" class="headerlink" title="2. Glossary"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#glossary">2. Glossary</a></h2><ul>
<li><strong>Route</strong>: 网关的基本构建。它由 ID，目标 URI，谓词集合，以及过滤器集合定义。如果聚合谓词为 true，则匹配路由。</li>
<li><strong>Predicate</strong>: 这是 Java 8 Function Predicate。输入类型是 <code>Spring Framework ServerWebExchange</code>。这使你可以匹配来自 HTTP 请求中的任何东西，例如 Header 或者参数。</li>
<li><strong>Filter</strong>: 这些是一些 <code>GatewayFilter</code> 实例，它们由特定的工厂构建出来。在这里，你可以在发送下游请求之前或之后修改请求和响应。</li>
</ul>
<h2 id="4-Configuring-Route-Predicate-Factories-and-Gateway-Filter-Factories"><a href="#4-Configuring-Route-Predicate-Factories-and-Gateway-Filter-Factories" class="headerlink" title="4. Configuring Route Predicate Factories and Gateway Filter Factories"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#configuring-route-predicate-factories-and-gateway-filter-factories">4. Configuring Route Predicate Factories and Gateway Filter Factories</a></h2><p>配置谓词和过滤器有两种方式：快捷方式和完全扩展参数。下面大多数示例都是用快捷方式。</p>
<h3 id="4-1-Shortcut-Configuration"><a href="#4-1-Shortcut-Configuration" class="headerlink" title="4.1. Shortcut Configuration"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#shortcut-configuration">4.1. Shortcut Configuration</a></h3><p>快捷方式配置由过滤器名称识别，跟着一个等号（<code>=</code>），后面跟着由逗号（<code>,</code>）分割的参数值。</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">https://example.org</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">Cookie=mycookie,mycookievalue</span></span><br></pre></td></tr></table></figure>
<p>上面的样例定义了具有两个参数的 <code>Cookie</code> 路由谓词工厂，参数分别是，cookie name <code>mycookie</code>，以及要匹配 <code>mycookievalue</code> 的值。</p>
<h1 id="5-Route-Predicate-Factories"><a href="#5-Route-Predicate-Factories" class="headerlink" title="5. Route Predicate Factories"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gateway-request-predicates-factories">5. Route Predicate Factories</a></h1><p>Spring Cloud Gateway 包含许多内置的路由谓词工厂，所有这些谓词匹配不同的 HTTP 请求属性</p>
<h2 id="5-1-The-After-Route-Predicate-Factory"><a href="#5-1-The-After-Route-Predicate-Factory" class="headerlink" title="5.1. The After Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-after-route-predicate-factory">5.1. The After Route Predicate Factory</a></h2><p><code>After</code> 路由谓词工厂携带一个参数，即一个 <code>datetime</code>（其实是 Java 的 <code>ZonedDateTime</code>）。该谓词匹配发生在指定时间之后的请求。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">after_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">After=2021-06-03T10:00:00.000+08:00</span></span><br></pre></td></tr></table></figure>


<h2 id="5-2-The-Before-Route-Predicate-Factory"><a href="#5-2-The-Before-Route-Predicate-Factory" class="headerlink" title="5.2. The Before Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-before-route-predicate-factory">5.2. The Before Route Predicate Factory</a></h2><p><code>Before</code> 路由谓词工厂携带一个参数，即一个 <code>datetime</code>（其实是 Java 的 <code>ZonedDateTime</code>）。该谓词匹配发生在指定时间之前的请求。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">before_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Before=2021-06-03T10:00:00.000+08:00</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-The-Between-Route-Predicate-Factory"><a href="#5-3-The-Between-Route-Predicate-Factory" class="headerlink" title="5.3. The Between Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-between-route-predicate-factory">5.3. The Between Route Predicate Factory</a></h2><p><code>Between</code> 路由谓词工厂携带两个参数，<code>datetime1</code> 和 <code>datetime2</code>，他们都是 Java 的 <code>ZonedDateTime</code> 对象。该谓词匹配发生在 <code>datetime1</code> 之后，以及 <code>datetime2</code> 之前的请求。<code>datetime2</code> 参数必须在 <code>datetime1</code> 之后。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Between=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017-01-21T17:42:47.789-07:00</span>[<span class="string">America/Denver</span>]</span><br></pre></td></tr></table></figure>

<h2 id="5-4-The-Cookie-Route-Predicate-Factory"><a href="#5-4-The-Cookie-Route-Predicate-Factory" class="headerlink" title="5.4. The Cookie Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-cookie-route-predicate-factory">5.4. The Cookie Route Predicate Factory</a></h2><p><code>Cookie</code> 路由谓词工厂携带两个参数，<code>name</code> 和 <code>regexp</code>（本质是 Java 的正则表达式）。该谓词匹配具有给定名称，并且值匹配正则表达式的 cookie。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Cookie=x-token,</span> <span class="string">\w+</span></span><br></pre></td></tr></table></figure>

<h2 id="5-5-The-Header-Route-Predicate-Factory"><a href="#5-5-The-Header-Route-Predicate-Factory" class="headerlink" title="5.5. The Header Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-header-route-predicate-factory">5.5. The Header Route Predicate Factory</a></h2><p><code>Header</code> 路由谓词工厂携带两个参数，<code>name</code> 和 <code>regexp</code>（本质是 Java 的正则表达式）。该谓词匹配具有给定名称，并且值匹配正则表达式的 header。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>


<h2 id="5-6-The-Host-Route-Predicate-Factory"><a href="#5-6-The-Host-Route-Predicate-Factory" class="headerlink" title="5.6. The Host Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-host-route-predicate-factory">5.6. The Host Route Predicate Factory</a></h2><p><code>Header</code> 路由谓词工厂携带一个参数：主机名 <code>patterns</code> 列表。模式是一种 Ant 风格的带有 <code>.</code> 作为分隔符的模式。该谓词匹配模式中的的 <code>Host</code> 头部。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>消息头部的字段名是大小写不敏感的，也就是头部 X-Request-Id，也可以传递 x-request-id<br>RFC 2616 <a href="https://www.rfc-editor.org/rfc/inline-errata/rfc2616.html%EF%BC%8C%E6%9F%A5%E8%AF%A2">https://www.rfc-editor.org/rfc/inline-errata/rfc2616.html，查询</a> (“:”) 关键字附近文字可以找到：Field names are case-insensitive.</p>
</blockquote>
<h2 id="5-7-The-Method-Route-Predicate-Factory"><a href="#5-7-The-Method-Route-Predicate-Factory" class="headerlink" title="5.7. The Method Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-method-route-predicate-factory">5.7. The Method Route Predicate Factory</a></h2><p><code>Method</code> 路由谓词工厂携带一个参数 <code>methods</code>，该参数是一个或者多个参数：待匹配的 HTTP 方法。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">Method=GET,POST</span></span><br></pre></td></tr></table></figure>

<h2 id="5-8-The-Path-Route-Predicate-Factory"><a href="#5-8-The-Path-Route-Predicate-Factory" class="headerlink" title="5.8. The Path Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-path-route-predicate-factory">5.8. The Path Route Predicate Factory</a></h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8080</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/echo/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="5-9-The-Query-Route-Predicate-Factory"><a href="#5-9-The-Query-Route-Predicate-Factory" class="headerlink" title="5.9. The Query Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-query-route-predicate-factory">5.9. The Query Route Predicate Factory</a></h2><p><code>Query</code> 路由谓词工厂携带两个参数，一个必需的 <code>param</code> 和一个可选的 <code>regexp</code>（本质是 Java 的正则表达式）。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">method_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://www.baidu.com</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Query=id</span></span><br></pre></td></tr></table></figure>

<h2 id="5-10-The-RemoteAddr-Route-Predicate-Factory"><a href="#5-10-The-RemoteAddr-Route-Predicate-Factory" class="headerlink" title="5.10. The RemoteAddr Route Predicate Factory"></a><a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#the-remoteaddr-route-predicate-factory">5.10. The RemoteAddr Route Predicate Factory</a></h2><p><code>RemoteAddr</code> 路由谓词工厂携带一个 <code>sources</code> 列表，这是 CIDR 符号字符串，例如 <code>192.168.0.1/16</code>，此处 <code>192.168.0.1</code> 是 IP 地址，16 是子网掩码。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">remoteaddr_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">RemoteAddr=192.168.0.187/24</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud OpenFeign</title>
    <url>/2022/07/13/Spring-Cloud/Spring-Cloud-OpenFeign/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-OpenFeign"><a href="#Spring-Cloud-OpenFeign" class="headerlink" title="Spring Cloud OpenFeign"></a>Spring Cloud OpenFeign</h1><h2 id="1-Declarative-REST-Client-Feign"><a href="#1-Declarative-REST-Client-Feign" class="headerlink" title="1. Declarative REST Client: Feign"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign">1. Declarative REST Client: Feign</a></h2><p>Feign 是一个声明式 Web 服务客户端。它使得编写 Web 服务客户端更容易。使用 Feign 创建一个接口并注解它。它具有可插入的注解支持，包括 Feign 注解和 JAX-RS 注解。Feign 还支持可插拔的编码器和解码器。Spring Cloud 增加了对 Spring MVC 注解的支持，以及支持使用 Spring Web 中默认项相同的 <code>HttpMessageConverters</code>。Spring Cloud 集成了 Ribbon 以及 Eureka，Spring Cloud CiruitBreaker，以及 Spring Cloud LoadBalancer，以便在使用 Feign 时提供负载均衡的 HTTP 客户端。</p>
<h3 id="1-1-How-to-Include-Feign"><a href="#1-1-How-to-Include-Feign" class="headerlink" title="1.1. How to Include Feign"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#netflix-feign-starter">1.1. How to Include Feign</a></h3><p>要在项目中包含 Feign，请使用 group 为 <code>org.springframework.cloud</code>，artifact id 为 <code>spring-cloud-starter-openfeign</code> 的 starter。有关使用当前 Spring Cloud Release Train 设置你的构建系统的详情，参见 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</a></p>
<p>示例 Spring Boot 应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>StoreClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;stores&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StoreClient</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)</span></span><br><span class="line">    List&lt;Store&gt; <span class="title function_">getStores</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value = &quot;/stores&quot;)</span></span><br><span class="line">    Page&lt;Store&gt; <span class="title function_">getStores</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.POST, value = &quot;/stores/&#123;storeId&#125;&quot;, consumes = &quot;application/json&quot;)</span></span><br><span class="line">    Store <span class="title function_">update</span><span class="params">(<span class="meta">@PathVariable(&quot;storeId&quot;)</span> Long storeId, Store store)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>@FeignClient</code> 注解中，字符串 value（即上面的 “stores”）是一个任意的 client name，用于创建一个 Ribbon 负载均衡或者 Spring Cloud LoadBalancer。你还可以使用 <code>url</code> 属性（绝对值或者一个主机名）指定一个 URL。应用上下文中 Bean 的名称是接口的完全限定名。为了指定你自己的别名，你可以使用 <code>@FeignClient</code> 注解的 <code>qualifiers</code> 值。</p>
<p>上面的负载均衡客户端将会希望发现 “stores” 服务的物理地址。如果你的应用是 Eureka 客户端，则它将在 Eureka 服务注册表中解析该服务。如果你不想使用 Eureka，则可以使用 <code>SimpleDiscoveryClient</code> 在外部配置中简单地配置服务器列表。</p>
<h3 id="1-2-Overriding-Feign-Defaults"><a href="#1-2-Overriding-Feign-Defaults" class="headerlink" title="1.2. Overriding Feign Defaults"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-overriding-defaults">1.2. Overriding Feign Defaults</a></h3><p>Spring Cloud 的 Feign 支持中的一个核心概念就是有名客户端。每个 Feign 客户端都是一群组件的部分，它们共同协作按需与远程服务进行连接，并且这个整体有一个你作为开发者使用 <code>@FeignClient</code> 注解赋予的名字。Spring Cloud 使用 <code>FeignClientsConfiguration</code> 为每个有名客户端按需地，以 <code>ApplicationContext</code> 的形式创建一个全新的整体。这包含一个 <code>feign.Decoder</code>，一个 <code>feign.Encoder</code>，以及一个 <code>feign.Contract</code>。可以使用 <code>@FeignClient</code> 注解的 <code>contextId</code> 属性覆盖该整体的名称。</p>
<p>Spring Cloud 使你可以使用 <code>@FeignClient</code> 声明额外的配置（覆盖 <code>FeignClientsConfiguration</code>）完全控制 feign 客户端。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;stores&quot;, configuration = FooConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StoreClient</span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，客户端是由已经存在于 <code>FeignClientsConfiguration</code> 中的组件，以及 <code>FooConfiguration</code> （后者覆盖前者）中的种种组成。</p>
<blockquote>
<p><code>FooConfiguration</code> 不需要 <code>@Configuration</code> 注解。但是，如果这样做，请将其从任何 <code>@ComponentScan</code> 中排除，否则将包含此配置，因为它将将成为 <code>feign.Decoder</code>，<code>feign.Encoder</code>，<code>feign.Contract</code> 等默认源。</p>
</blockquote>
<p><code>name</code> 和 <code>url</code> 属性也支持占位符。</p>
<h4 id="1-2-1-SpringEncoder-configuration"><a href="#1-2-1-SpringEncoder-configuration" class="headerlink" title="1.2.1. SpringEncoder configuration"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#springencoder-configuration">1.2.1. SpringEncoder configuration</a></h4><p>在我们提供的 <code>SpringEncoder</code> 中，我们为二进制内容类型设置了 <code>null</code> 字符集，并未所有其他的设置了 <code>UTF-8</code>。</p>
<p>你可以通过设置 <code>feign.encoder.charset-from-content-type</code> 的值为 <code>true</code>来修改此行为，以从 <code>Content-Type</code> 头部 charset 获得字符集。</p>
<h3 id="1-3-Timeout-Handling"><a href="#1-3-Timeout-Handling" class="headerlink" title="1.3. Timeout Handling"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#timeout-handling">1.3. Timeout Handling</a></h3><p>我们可以在默认和有名客户端上配置超时。OpenFeign 可与两个超时参数一起使用：</p>
<ul>
<li><code>connectTime</code></li>
<li><code>readTimeout</code></li>
</ul>
<h3 id="1-5-Feign-Hystrix-Support"><a href="#1-5-Feign-Hystrix-Support" class="headerlink" title="1.5. Feign Hystrix Support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-hystrix">1.5. Feign Hystrix Support</a></h3><p>如果 Hystrix 在类路径，并且 <code>feign.hystrix.enabled=true</code>，Feign 将用熔断器包装所有方法。还提供返回一个 <code>com.netflix.hystrix.HystrixCommand</code>。这使你可以使用响应式模式。</p>
<h3 id="1-6-Feign-Hystrix-Fallbacks"><a href="#1-6-Feign-Hystrix-Fallbacks" class="headerlink" title="1.6. Feign Hystrix Fallbacks"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-hystrix-fallback">1.6. Feign Hystrix Fallbacks</a></h3><h3 id="1-10-Feign-Inheritance-Support"><a href="#1-10-Feign-Inheritance-Support" class="headerlink" title="1.10. Feign Inheritance Support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-inheritance">1.10. Feign Inheritance Support</a></h3><p>Feign 通过单继承接口支持样板 API。这允许你将通用操作分组为方便的基础接口。</p>
<p><strong>UserService.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.GET, value =&quot;/users/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">long</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserResource.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserResource</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>UserClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> project.user;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> <span class="keyword">extends</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-Timeout-Handling-1"><a href="#1-3-Timeout-Handling-1" class="headerlink" title="1.3. Timeout Handling"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#timeout-handling">1.3. Timeout Handling</a></h3><p>我们可以在默认和有名客户端上配置 timeout 属性。OpenFeign 用这两个 timeout 参数进行工作：</p>
<ul>
<li><code>connectTimeout</code> 防止由于较长的服务端处理时间导致的阻塞。</li>
<li><code>readTimeout</code> 在连接建立的时候使用，并且当返回响应花费太久的时候会触发</li>
</ul>
<blockquote>
<p>如果服务没有运行或者不可用，数据包可能以连接被拒绝结束。通信以错误信息或者后背方式结束。如果 <code>connectTimeout</code> 设置非常低，这就有可能在 <code>connectTimeout</code> 之前就结束通信。执行查找以及接收这样的数据包的时间可能会产生较大一部分延迟。可以基于涉及到 DNS 查找的远程主机修改该值。</p>
</blockquote>
<p>当启用 Hystrix 后，超时配置默认是 1000 毫秒。因此，它可能发生在我们前面配置的客户端超时之前。增加该超时，防止发生这种情况。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">command:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">execution:</span></span><br><span class="line">        <span class="attr">timeout:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">isolation:</span></span><br><span class="line">          <span class="attr">thread:</span></span><br><span class="line">            <span class="attr">timeoutInMilliseconds:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当启用 Hystrix 的 timeout 且它的 timeout 设置得比 feign client 更长时，<code>HystrixTimeoutException</code> 会包装一个 feign 异常。否则，唯一的区别就是异常的原因。<code>HystrixTimeoutException</code> 的目的是包装先发生的任何运行时异常，并抛出自身实例。</p>
</blockquote>
<h3 id="1-5-Feign-Hystrix-Support-1"><a href="#1-5-Feign-Hystrix-Support-1" class="headerlink" title="1.5. Feign Hystrix Support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#spring-cloud-feign-hystrix">1.5. Feign Hystrix Support</a></h3><p>如果 Hystrix 在类路径中，且 <code>feign.hystrix.enabled=true</code>，Feign 将使用熔断器包装所有的方法。还可以返回一个 <code>HystrixCommand</code>。</p>
<h3 id="1-12-Feign-logging"><a href="#1-12-Feign-logging" class="headerlink" title="1.12. Feign logging"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#feign-logging">1.12. Feign logging</a></h3><p>为每个 Feign 客户端创建了一个 logger。默认情况下，logger 的名字是用于创建 Feign 客户端的接口的完全限定类名。Feign 日志仅仅响应 <code>DEBUG</code> 级别。</p>
<p><strong>application.yml</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.level.project.user.UserClient</span>: <span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p>你可以为每个客户端配置的 <code>Logger.Level</code> 对象，告诉 Feign 多少要记录。选项如下：</p>
<ul>
<li><code>NONE</code>，不记录日志（DEFAULT）</li>
<li><code>BASIC</code>，仅仅记录请求方法，URL，响应状态码，以及执行时间</li>
<li><code>HEADERS</code>，记录基本信息，以及请求头和响应头</li>
<li><code>FULL</code>，记录来自请求或响应的头部</li>
</ul>
<h3 id="1-13-Feign-QueryMap-support"><a href="#1-13-Feign-QueryMap-support" class="headerlink" title="1.13. Feign @QueryMap support"></a><a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.10.RELEASE/reference/html/#feign-querymap-support">1.13. Feign @QueryMap support</a></h3>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Bean @Autowired 与 JSR-250 @Resource</title>
    <url>/2022/07/19/Spring-Core/Spring-Core-@Resource-%E4%B8%8E-@Autowired/</url>
    <content><![CDATA[<h1 id="Spring-Bean-Autowired-与-JSR-250-Resource"><a href="#Spring-Bean-Autowired-与-JSR-250-Resource" class="headerlink" title="Spring Bean @Autowired 与 JSR-250 @Resource"></a>Spring Bean @Autowired 与 JSR-250 @Resource</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>由 Spring 提供的注解，依赖注入的过程由 <code>AutowiredAnnotationBeanPostProcessor</code> 执行。</p>
<p>通常这一步骤发生在 <code>populateBean</code> 流程之中，使用特定的 <code>InstantiationAwareBeanPostProcessor</code> 进行属性注入</p>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p>由 JSR-250 中提供的注解，依赖注入的过程由 <code>CommonAnnotationBeanPostProcessor</code> 执行。</p>
<p>通常这一步骤发生在 <code>populateBean</code> 流程之中，使用特定的 <code>InstantiationAwareBeanPostProcessor</code> 进行属性注入</p>
<ol>
<li>如果 <code>@Resource</code> 指定了 <code>name</code>，则按照 <code>name</code> 查找 Bean，找到则注入；找不到抛出异常</li>
<li>如果 <code>@Resource</code> 没有指定 <code>name</code>，通过 Java 反射得到 <code>Field</code> 属性 <code>name</code>，找不到则按照类型匹配</li>
</ol>
<blockquote>
<p>由于显式指定了 <code>@Resource</code> 的 <code>name</code>，因此在找不到的情况下必须抛出异常，这可能是人为的疏漏；如果没有指定 <code>name</code>，那么容器会智能地按照属性名、类型地顺序依次寻找。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">autowireResource</span><span class="params">(BeanFactory factory, LookupElement element, <span class="meta">@Nullable</span> String requestingBeanName)</span></span><br><span class="line">        <span class="keyword">throws</span> NoSuchBeanDefinitionException &#123;</span><br><span class="line"></span><br><span class="line">    Object resource;</span><br><span class="line">    Set&lt;String&gt; autowiredBeanNames;</span><br><span class="line">    <span class="comment">// 此处的 element.name 以及在构造器中赋值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> element.name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> AutowireCapableBeanFactory) &#123;</span><br><span class="line">        <span class="type">AutowireCapableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (AutowireCapableBeanFactory) factory;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> element.getDependencyDescriptor();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.fallbackToDefaultTypeMatch &amp;&amp; element.isDefaultName &amp;&amp; !factory.containsBean(name)) &#123;</span><br><span class="line">            autowiredBeanNames = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">            resource = beanFactory.resolveDependency(descriptor, requestingBeanName, autowiredBeanNames, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (resource == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchBeanDefinitionException</span>(element.getLookupType(), <span class="string">&quot;No resolvable resource object&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            resource = beanFactory.resolveBeanByName(name, descriptor);</span><br><span class="line">            autowiredBeanNames = Collections.singleton(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        resource = factory.getBean(name, element.lookupType);</span><br><span class="line">        autowiredBeanNames = Collections.singleton(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">        <span class="type">ConfigurableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (ConfigurableBeanFactory) factory;</span><br><span class="line">        <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestingBeanName != <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(autowiredBeanName)) &#123;</span><br><span class="line">                beanFactory.registerDependentBean(autowiredBeanName, requestingBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Spring Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 循环依赖</title>
    <url>/2022/07/10/Spring-Core/Spring-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="Spring-循环依赖"><a href="#Spring-循环依赖" class="headerlink" title="Spring 循环依赖"></a>Spring 循环依赖</h1><h2 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h2><p>singletonObjects<br>earlySingletonObjects<br>singletonFactories</p>
<p>对于 earlySingletonObjects 的使用场景存在于多循环依赖，比如 beanA 依赖于 beanB 和 beanC，beanB 和 beanC 分别依赖 beanA。在 beanB 进行属性注入 beanA 的时候，beanA 已经从 singletonFactories 构造出一个 earlySingletonObject 了，因此在 beanC 注入 beanA 的时候不必重复构造 beanA，只需从 earlySingletonObjects 中取得即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A-&gt;B-&gt;A</span><br><span class="line">A-&gt;C-&gt;A</span><br></pre></td></tr></table></figure>

<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>假设 beanA 依赖 beanB，beanB 依赖 beanA，以这种最朴素的场景为例</p>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>假设程序以 beanA 开始解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractApplicationContext.refresh()</span><br><span class="line">-&gt; AbstractApplicationContext.finishBeanFactoryInitialization(beanFactory)</span><br><span class="line">-&gt; DefaultLisableBeanFactory.preInstantiateSingletons()</span><br><span class="line">-&gt; AbstractBeanFactory.getBean(beanA)</span><br><span class="line">-&gt; AbstractBeanFactory.doGetBean(beanA)</span><br></pre></td></tr></table></figure>


<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ol>
<li>检查 singletonObjects 是否存在 beanA。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意第二个参数为 true</span></span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">// 此时 beanA 还没有开始创建，这里一定返回 null</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 由于 beanA 还没有开始创建，因此也不会存在于 singletonsCurrentlyInCreation</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开始创建 beanA</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二个参数是一个类似于 java.util.function.Supplier 的函数式接口</span></span><br><span class="line"><span class="comment">// 用于创建 beanA</span></span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        destroySingleton(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationNotAllowedException</span>(beanName,</span><br><span class="line">                        <span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该方法会将 beanA 添加到 singletonsCurrentlyInCreation</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">newSingleton</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">recordSuppressedExceptions</span> <span class="operator">=</span> (<span class="built_in">this</span>.suppressedExceptions == <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="built_in">this</span>.suppressedExceptions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 此处调用函数式接口进行 beanA 的创建</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">                <span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">                singletonObject = <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="built_in">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.suppressedExceptions = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>创建 beanA</li>
</ol>
<p>通过 getSingleton 传递的函数式接口调用链如下 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory.createBean()</span><br><span class="line">-&gt; AbstractAutowireCapableBeanFactory.doCreateBean(beanName, mbdToUse, args)</span><br></pre></td></tr></table></figure>


<ol start="4">
<li>添加到 singletonFactories</li>
</ol>
<p><code>doCreateBean</code> 方法首先会进行 beanA 的实例化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br></pre></td></tr></table></figure>

<p>然后紧跟着将实例化的 beanA 以函数式接口 Supplier 的形式（实际上是 ObjectFactory）添加到 singletonFactories：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的参数 bean 是刚刚实例化完毕的 beanA</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure>


<ol start="5">
<li>开始填充 beanA 的属性</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br></pre></td></tr></table></figure>


<p>在填充过程中会调用一些 <code>InstantiationAwareBeanPostProcessor</code> 进行 <code>postProcessProperties</code> 操作，</p>
<p>如果你使用的是 <code>@Autowired</code> 进行属性绑定，那么 <code>AutowiredAnnotationBeanPostProcessor</code> 会处理关于 beanB 的属性绑定问题。</p>
<ol start="6">
<li>解析依赖 beanB</li>
</ol>
<p><code>AutowiredAnnotationBeanPostProcessor</code> 的注入调用链如下，最终又会回到 beanFactory 的 getBean 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultListableBeanFactory.doResolveDependency()</span><br><span class="line">-&gt; DependencyDescriptor.resolveCandidate(<span class="string">&quot;beanB&quot;</span>, BeanB.class, beanFactory)</span><br><span class="line">-&gt; beanFactory.getBean(<span class="string">&quot;beanB&quot;</span>)</span><br></pre></td></tr></table></figure>


<ol start="7">
<li>与步骤 1 相同</li>
</ol>
<p>beanB 此时还没有创建，因此不会存在于 <code>singletonObjects</code> ，而且也不会存在于 <code>singletonsCurrentlyInCreation</code></p>
<ol start="8">
<li><p>将 beanB 添加到 <code>singletonsCurrentlyInCreation</code></p>
</li>
<li><p>实例化 beanB，将对象工程添加到 <code>singletonFactories</code></p>
</li>
<li><p>填充 beanB 属性，相关的 <code>InstantiationAwareBeanPostProcessor</code> 发挥作用。此时，发现 beanB 依赖 beanA，继续调用 beanFactory.getBean(“beanA”)</p>
</li>
<li><p>与步骤 1 类似</p>
</li>
</ol>
<p>由于 beanA 在创建前已经将自己放到 <code>singletonsCurrentlyInCreation</code> 中，而且将自己的对象工厂放到 <code>singletonFactories</code> 中了，因此会调用 <code>singletonFactories</code> 中的对象工厂方法获得一个 beanA，并且 beanA 的对象工厂会从 <code>singletonFactories</code> 移除，同时添加到 <code>earlySingletonObjects</code></p>
<blockquote>
<p>此时这个 beanA 属性还没有填充</p>
</blockquote>
<p>这时候 getBean(“beanA”) 返回得到一个还未填充属性的 beanA</p>
<ol start="12">
<li><p>回到 beanB 填充属性，将得到的 beanA 填充进自己的属性。接着，beanB 完成了自己的属性填充就可以将对象添加到 <code>singletonObjects</code> 中，并且移除 <code>singletonFactories</code> 和 <code>earlySingletonObjects</code> 相关的对象</p>
</li>
<li><p>回到 beanA 填充属性，将得到的 beanB 填充进自己的属性。接着，beanA 完成了自己的属性填充就可以将对象添加到 <code>singletonObjects</code> 中，并且移除 <code>singletonFactories</code> 和 <code>earlySingletonObjects</code> 相关的对象</p>
</li>
</ol>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>数据文档生成器 screw</title>
    <url>/2022/07/18/Tool/%E6%95%B0%E6%8D%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8-screw/</url>
    <content><![CDATA[<h1 id="数据文档生成器-screw"><a href="#数据文档生成器-screw" class="headerlink" title="数据文档生成器 screw"></a>数据文档生成器 screw</h1><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://github.com/yihr/screw">https://github.com/yihr/screw</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247490367&idx=4&sn=33457d828191fc8717bf90e29d02aa5b&chksm=fbb292c1ccc51bd776a938e2a0aca306363c8ea526362c83a1ed0e7d2522d136a5482f529481&mpshare=1&scene=1&srcid=08075ho06D4MoWdvYI6HZGn2&sharer_sharetime=1596771975108&sharer_shareid=00de337ccf971170dff621a18a7fdda8&key=bbcde1cc2908d6bbca75f9126db113cba3e65212579f0c49d238ed98e48a07667ecea3754647040875027233e7254e03354cbcb58a82ff9c1b4f865e3e510b1759f8f013ff094835f46a0f3809a473f4&ascene=1&uin=MjE2Mjg4NzYz&devicetype=Windows+10+x64&version=62090529&lang=zh_CN&exportkey=A98TRXcX38ZaCSWR2WlBPus=&pass_ticket=/q1C0cKlfjbdKpTIM9MtXaZTfIIIRMMDAPgn/J8FuXo=">参考文章</a></p>
<h2 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.smallbun.screw<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>screw-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="JUnit-生成"><a href="#JUnit-生成" class="headerlink" title="JUnit 生成"></a>JUnit 生成</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBDocument</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 生成文件配置</span></span><br><span class="line">        <span class="type">EngineConfig</span> <span class="variable">engineConfig</span> <span class="operator">=</span> EngineConfig.builder()</span><br><span class="line">            <span class="comment">/* 生成文件路径，本地路径 */</span></span><br><span class="line">            .fileOutputDir(<span class="string">&quot;D:/&quot;</span>)</span><br><span class="line">            <span class="comment">/* 是否打开输出的目录 */</span></span><br><span class="line">            .openOutputDir(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">/* 文件类型 */</span></span><br><span class="line">            .fileType(EngineFileType.HTML)</span><br><span class="line">            <span class="comment">/* 生成模板实现 */</span></span><br><span class="line">            .produceType(EngineTemplateType.freemarker)</span><br><span class="line">            .build();</span><br><span class="line">        <span class="comment">// 生成文档配置（包含以下自定义版本号、描述等配置连接）</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">config</span> <span class="operator">=</span> Configuration.builder()</span><br><span class="line">            .version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">            .description(<span class="string">&quot;数据库文档&quot;</span>)</span><br><span class="line">            .dataSource(dataSource)</span><br><span class="line">            .engineConfig(engineConfig)</span><br><span class="line">            .produceConfig(getProcessConfig())</span><br><span class="line">            .build();</span><br><span class="line">        <span class="comment">// 执行生成</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DocumentationExecute</span>(config).execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置想要生成的表 + 配置想要忽略的表</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProcessConfig <span class="title function_">getProcessConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ProcessConfig.builder()</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>screw</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 打包部署脚本</title>
    <url>/2022/07/18/Vue/Vue-%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="Vue-打包部署脚本"><a href="#Vue-打包部署脚本" class="headerlink" title="Vue 打包部署脚本"></a>Vue 打包部署脚本</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save-dev scp2 cross-env ora@4.1.1 chalk</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> scpClient = <span class="built_in">require</span>(<span class="string">&#x27;scp2&#x27;</span>);      <span class="comment">// 基于ssh2的纯javascript安全复制程序</span></span><br><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">&#x27;ora&#x27;</span>);             <span class="comment">// 一个优雅的 Node.js 终端加载动画效果</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>);         <span class="comment">// 字体颜色插件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spinner = <span class="title function_">ora</span>(<span class="string">&#x27;正在发布到 &#x27;</span> + process.<span class="property">env</span>.<span class="property">NODE_ENV</span> + <span class="string">&#x27; 服务器...\n&#x27;</span>);</span><br><span class="line">spinner.<span class="title function_">start</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">SERVER_LIST</span> = &#123;</span><br><span class="line">    <span class="string">&#x27;development&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>,            <span class="comment">// ip</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">22</span>,                       <span class="comment">// 端口</span></span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>,               <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span>,                <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/opt/www&#x27;</span>                <span class="comment">// 发布至静态服务器的项目路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;production&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">hostname</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>,      <span class="comment">// ip</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">22</span>,                       <span class="comment">// 端口</span></span><br><span class="line">        <span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>,               <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">password</span>: <span class="string">&#x27;xxx&#x27;</span>,                <span class="comment">// 登录服务器的账号</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/opt/www&#x27;</span>                <span class="comment">// 发布至静态服务器的项目路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是公钥认证在这里创建私钥文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;C:\\Users\\Administrator\\.ssh\\id_rsa&#x27;</span></span><br><span class="line"><span class="keyword">const</span> privateKey = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>).<span class="title function_">readFileSync</span>(path).<span class="title function_">toString</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = <span class="variable constant_">SERVER_LIST</span>[process.<span class="property">env</span>.<span class="property">NODE_ENV</span>];</span><br><span class="line">scpClient.<span class="title function_">scp</span>(</span><br><span class="line">    <span class="string">&#x27;dist/&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">host</span>: server.<span class="property">hostname</span>,</span><br><span class="line">        <span class="attr">port</span>: server.<span class="property">port</span>,</span><br><span class="line">        <span class="attr">username</span>: server.<span class="property">username</span>,</span><br><span class="line">        <span class="attr">password</span>: server.<span class="property">password</span>,</span><br><span class="line">        privateKey,</span><br><span class="line">        <span class="attr">path</span>: server.<span class="property">path</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">        spinner.<span class="title function_">stop</span>();</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">red</span>(<span class="string">&#x27;发布失败.\n&#x27;</span>));</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(chalk.<span class="title function_">green</span>(<span class="string">&#x27;Success! 成功发布到&#x27;</span> + process.<span class="property">env</span>.<span class="property">NODE_ENV</span> + <span class="string">&#x27;服务器! \n&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>package.json</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>,</span><br><span class="line">  <span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;npm run build &amp;&amp; cross-env NODE_ENV=development node ./deploy&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2022/07/16/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="Proxy-模式"><a href="#Proxy-模式" class="headerlink" title="Proxy 模式"></a>Proxy 模式</h2><h3 id="Proxy-模式中的角色"><a href="#Proxy-模式中的角色" class="headerlink" title="Proxy 模式中的角色"></a>Proxy 模式中的角色</h3><p>在 Proxy 模式中一般有以下角色：</p>
<ul>
<li>Subject（主体）</li>
</ul>
<p>Subject 定义了使 Proxy 和 RealSubject 之间具有一致性的接口。</p>
<ul>
<li>Proxy（代理人）</li>
</ul>
<p>Proxy 会尽量处理来自外界的请求。当自己不能处理时，才会将工作交给 RealSubject。Proxy 也要实现 Subject 定义的接口。</p>
<ul>
<li>RealSubject（实际主体）</li>
</ul>
<p>RealSubject 会在 Proxy 无法胜任工作时出场。它也会实现 Subject 接口。</p>
<p>下面这段示例程序实现了一个 “带有名字的打印机”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setPrinterName</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getPrinterName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String string)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Printer</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        heavyJob(<span class="string">&quot;正在生成 Printer 示例 (&quot;</span> + name + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrinterName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrinterName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===&quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;===&quot;</span>);</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heavyJob</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrinterProxy</span> <span class="keyword">implements</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Printer real;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrinterProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrinterProxy</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrinterName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.real != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.real.setPrinterName(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrinterName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String string)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensure();</span><br><span class="line">        real.print(string);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensure</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.real == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.real == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.real = <span class="keyword">new</span> <span class="title class_">Printer</span>(<span class="built_in">this</span>.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Proxy-模式变体"><a href="#Proxy-模式变体" class="headerlink" title="Proxy 模式变体"></a>Proxy 模式变体</h3><ul>
<li><p>Virtual Proxy（虚拟代理）<br>Virtual Proxy 就是上面呈现的 Proxy 模式。当真正需要 RealSubject 时，才生成和初始化实例。</p>
</li>
<li><p>Remote Proxy（远程代理）<br>Remote Proxy 可以让我们不必在意 RealSubject 是否在远程网络上，透明地使用它的功能。Java 的 RMI（Remote Method Invocation：远程方法调用）就相当于 Remote Proxy。</p>
</li>
<li><p>Access Proxy<br>Access Proxy 用于限制 RealSubject 的功能访问。例如，这种代理只允许访问特定的方法，当访问其他方法时则报错。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB 日志</title>
    <url>/2022/07/11/InnoDB%20%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="http://blog.itpub.net/7728585/viewspace-2284045/">解析 roll_pointer</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/427911093">庖丁解牛 </a></p>
<p><a href="https://zhuanlan.zhihu.com/p/453169285">InnoDB之UNDO LOG介绍</a></p>
<h1 id="Undo-Logs"><a href="#Undo-Logs" class="headerlink" title="Undo Logs"></a>Undo Logs</h1><p>Undo Log 是一条或者多条 Undo Log Record 的集合，每一条 Undo Log Record 都与一个读写事务相关。每条 Undo Log 记录包含了有关如何撤销事务最新更改的信息<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-logs.html">[?]</a>。</p>
<h2 id="1-Undo-Tablespaces"><a href="#1-Undo-Tablespaces" class="headerlink" title="1. Undo Tablespaces"></a>1. Undo Tablespaces</h2><p>Undo Tablesapces 包含许多 Undo Log。</p>
<blockquote>
<p>MySQL 最多支持 127 个 Undo Tablespace。默认为 2 个。</p>
</blockquote>
<p>InnoDB 是一个多版本的存储引擎。它可以保留有关更改行的旧版本的信息，以支持事务功能，例如并发和回滚。此信息以一个称为回滚段的数据结构，存储于 undo 表空间。回滚段驻留在 undo 表空间和全局临时表空间中<a href="s">[1]</a>。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo-tablespace.png">


<h2 id="2-Rollback-Segment"><a href="#2-Rollback-Segment" class="headerlink" title="2. Rollback Segment"></a>2. Rollback Segment</h2><p>InnoDB 在 Undo Tablespace 中使用 Rollback Segment 来组织 Undo Log，最多支持 128 个 Rollback Segment。</p>
<p>其中第 0 号、33-127号针对普通表设计，1-32 号针对临时表设计。</p>
<blockquote>
<p>一个事务可能即操作了临时表，也操作了物理表，因此，一个事务是可以使用多个 Rollback Segment。</p>
</blockquote>
<h2 id="3-Rollback-Segment-Array-Header"><a href="#3-Rollback-Segment-Array-Header" class="headerlink" title="3. Rollback Segment Array Header"></a>3. Rollback Segment Array Header</h2><p>Undo Tablespace 文件中的第 3 个 Page 固定作为这 128 个 Rollback Segment 的目录，即 Rollback Segment Array Header</p>
<h2 id="4-Rollback-Segment-Header"><a href="#4-Rollback-Segment-Header" class="headerlink" title="4. Rollback Segment Header"></a>4. Rollback Segment Header</h2><p>通过 Rollback Segment Header 来管理 Rollback Segment，Rollback Segment Header 通常在 Rollback Segment 第 1 页。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/rollback_segment_header.png" width="300">

<table>
<thead>
<tr>
<th><div style="width:200px">字段</div></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Max Size</td>
<td>参数名 TRX_RSEG_MAX_SIZE， 回滚段可用的最大 Page 数</td>
</tr>
<tr>
<td>History Size</td>
<td>参数名 TRX_RSEG_HISTORY_SIZE，History List 包含的 Page 数</td>
</tr>
<tr>
<td>History List Base Node</td>
<td>参数名 TRX_RSEG_HISTORY</td>
</tr>
</tbody></table>
<p>History List 把所有已经提交，但还没有被 purge 的事务的 Undo Log 连接起来，purge 线程可以通过此 List 对已经没有事务使用的 Undo Log 进行 purge。</p>
<p>每个事务在需要记录 Undo Log 时都会申请 1 个或者 2 个 Slot（INSERT 和 UPDATE 分开），同时把事务的第一个 Undo Page 放入对应 Slot 中</p>
<h3 id="5-Undo-Page"><a href="#5-Undo-Page" class="headerlink" title="5. Undo Page"></a>5. Undo Page</h3><p>Undo Page 一般可以分为两种：Header Page 和 Normal Page。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo-page.png">


<p>Undo Header Page 是事务需要写 Undo Log 时申请的第一个 Undo Page</p>
<p>Undo Header Page 是当活跃事务产生的 Undo Record 超过 Undo Header Page 容量后，单独分配的 Undo Page</p>
<h3 id="6-Undo-Page-Header"><a href="#6-Undo-Page-Header" class="headerlink" title="6. Undo Page Header"></a>6. Undo Page Header</h3><img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo-page-header.png" width="400">

<table>
<thead>
<tr>
<th><div style="width:200px">字段</div></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Undo Page Type</td>
<td>TRX_UNDO_PAGE_TYPE，使用该页事务的类型<br>可选值: TRX_UNDO_INSERT、TRX_UNDO_UPDATE</td>
</tr>
<tr>
<td>Latest Log Record Offset</td>
<td>最新事务开始记录 Undo Log 的位置</td>
</tr>
<tr>
<td>Free Space Offset</td>
<td>页内空闲空间起始地址，在此之后可记录 Undo Log</td>
</tr>
<tr>
<td>Undo Page List Node</td>
<td>undo page list节点，可以把同一个事务所用到的所有undo page双向串联起来</td>
</tr>
</tbody></table>
<h3 id="6-Undo-Segment"><a href="#6-Undo-Segment" class="headerlink" title="6. Undo Segment"></a>6. Undo Segment</h3><p>InnoDB 中的 Undo Tablespace 中准备了大量的 Undo Segment 槽位，默认按照 1024 一组划分为 Rollback Segment。</p>
<blockquote>
<p>每个 Undo Tablespace 最多会包含128 个 Rollback Segment。1 个 Undo Slot 对应 1 个 Undo Segment</p>
</blockquote>
<p>每个写事务开始写操作之前都需要持有一个 Undo Segment。在任何时刻，每个 Undo Segment 都是被一个事务独占的。</p>
<p>对于较大的 Undo Log 随着不断地写入，按需分配足够多的 Undo Page 分散承载。</p>
<p>每个 Undo Segment  至少持有 1 个 Undo Page，每个 Undo Page 会在开头 38 - 56 字节记录 Undo Page Header。</p>
<blockquote>
<p>Rollback Segment 中 Undo Slot 具体的数值是 $\frac {Page Size}{16}$，见<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-undo-logs.html">15.6.6 Undo Logs</a>。因为默认 Page Size &#x3D; 16 KB，因此默认以 1024 一组划分为一个 Rollback Segment。</p>
</blockquote>
<h3 id="7-Undo-Segment-Header"><a href="#7-Undo-Segment-Header" class="headerlink" title="7. Undo Segment Header"></a>7. Undo Segment Header</h3><p>Undo Segment 中的第 1 个 Undo Page 还会在 56~86 字节记录 Undo Segment Header。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo-segment-header.png" style="width: 400px">

<table>
<thead>
<tr>
<th><div style="width:200px">字段</div></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>State</td>
<td>TRX_UNDO_STATE，Undo Segment 的状态</td>
</tr>
<tr>
<td>Last Log Offset</td>
<td>TRX_UNDO_LAST_LOG，当前页最后一个 Undo Log Header 的位置</td>
</tr>
<tr>
<td>Undo Segment FSEG Entry</td>
<td>TRX_UNDO_FSEG_HEADER，segment对应的inode的（space_id，page_no，offset等）</td>
</tr>
<tr>
<td>Undo Segment Page List Base Node</td>
<td>TRX_UNDO_PAGE_LIST,undo page list的Base Node，对于同一个事务下的undo header page和undo normal page构成双向链表</td>
</tr>
</tbody></table>
<p>TRX_UNDO_PAGE_LIST：对于一般事务来说，不会出现一页写不下的情况，所以，对于大多数事务该链表长度是 1。</p>
<p>在事务结束 (commit &#x2F; rollback) 的时候，会依次检查一些条件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// trx_undo_set_state_at_finish()</span></span><br><span class="line"><span class="keyword">if</span> (undo-&gt;size == <span class="number">1</span> &amp;&amp; mach_read_from_2(page_hdr + TRX_UNDO_PAGE_FREE) &lt; </span><br><span class="line">TRX_UNDO_PAGE_REUSE_LIMIT) &#123;</span><br><span class="line">    <span class="comment">// 如果占用 Page == 1，而且本页使用空间偏移量小于 3 / 4</span></span><br><span class="line">    <span class="comment">// 那么，标记为 TRX_UNDO_CACHED</span></span><br><span class="line">    state = TRX_UNDO_CACHED;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (undo-&gt;type == TRX_UNDO_INSERT) &#123;</span><br><span class="line">    <span class="comment">// 如果类型为 INSERT</span></span><br><span class="line">    <span class="comment">// 那么，标记为 TRX_UNDO_TO_FREE</span></span><br><span class="line">    state = TRX_UNDO_TO_FREE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 最后就是类型为 UPDATE 而且占用空间较多</span></span><br><span class="line">    state = TRX_UNDO_TO_PURGE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于标记为 <code>TRX_UNDO_CACHED</code> 的 Undo Segment 会在 <code>trx_undo_insert_cleanup</code> &#x2F; <code>trx_undo_update_cleanup</code> 中添加到 insert cached list &#x2F; update cached list 头部。</p>
<p>对于 INSERT 类型的清理在 <code>trx_commit_in_memory()</code> 会直接释放掉标记为 <code>TRX_UNDO_TO_FREE</code> 的 Undo Segment。</p>
<p>UPDATE 类型的 Undo Segment 会等待 Purge 完毕回收。</p>
<h3 id="8-Undo-Log-Header"><a href="#8-Undo-Log-Header" class="headerlink" title="8. Undo Log Header"></a>8. Undo Log Header</h3><p>每个写事务会修改一些数据记录，对应产生一些 Undo Log Record。这些 Undo Log Record 连接在一起形成该事务的 Undo Log。这些 Undo Log Record 开头存在一个 Undo Log Header 记录一些信息。</p>
<img src="https://cannedbread-1302516612.cos.ap-shanghai.myqcloud.com/undo_log_header.png" width="300">


<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">占用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Transaction ID</td>
<td align="left">8</td>
<td align="left">事务 ID</td>
</tr>
<tr>
<td align="left">Delete Mark</td>
<td align="left">2</td>
<td align="left">表示该 Undo Log 是否存在 TRX_UNDO_DEL_MARK_REC 类型的 Undo Log Record，避免 Purge 时不必要的扫描</td>
</tr>
<tr>
<td align="left">Log Start Offset</td>
<td align="left">2</td>
<td align="left">记录 Undo Log Header 的结束位置，便于之后 Header 增加内容时的兼容</td>
</tr>
<tr>
<td align="left">Next Undo Log</td>
<td align="left">2</td>
<td align="left">后一个 Undo Log</td>
</tr>
<tr>
<td align="left">Prev Undo</td>
<td align="left">2</td>
<td align="left">前一个 Undo Log</td>
</tr>
</tbody></table>
<h3 id="8-Undo-Log-Record-结构"><a href="#8-Undo-Log-Record-结构" class="headerlink" title="8. Undo Log Record 结构"></a>8. Undo Log Record 结构</h3><p>主要分为两大类：</p>
<ul>
<li>insert undo log record</li>
<li>update undo log record<br>其中，update undo log record 还有其他更多的类别</li>
</ul>
<h4 id="8-1-Insert-Undo-Log-Record"><a href="#8-1-Insert-Undo-Log-Record" class="headerlink" title="8.1. Insert Undo Log Record"></a>8.1. Insert Undo Log Record</h4><p>TRX_UNDO_INSERT_REC</p>
<table>
<thead>
<tr>
<th align="left">TRX_UNDO_INSERT_REC</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">next (2)</td>
<td align="left">下一个 undo log 的位置</td>
</tr>
<tr>
<td align="left">type_cmpl (1)</td>
<td align="left">Undo 类型，TRX_UNDO_INSERT_REC: 11</td>
</tr>
<tr>
<td align="left">Undo Number</td>
<td align="left">在一个事务中从 0 开始递增</td>
</tr>
<tr>
<td align="left">Table ID</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Key Field 1 Length</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Key Field 1 Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">…</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Key Field n Length</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Key Field n Content</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">start</td>
<td align="left">undo 开始的位置</td>
</tr>
</tbody></table>
<blockquote>
<p>INSERT 操作的 undo log record 在事务提交后就可以删除</p>
</blockquote>
<h4 id="8-2-Update-Undo-Log-Record"><a href="#8-2-Update-Undo-Log-Record" class="headerlink" title="8.2. Update Undo Log Record"></a>8.2. Update Undo Log Record</h4><p>该类别的 Undo Log Record 可以再分为三种：</p>
<ul>
<li>TRX_UNDO_DEL_MARK_REC</li>
<li>TRX_UNDO_UPD_DEL_REC</li>
<li>TRX_UNDO_UPD_EXIST_REC</li>
</ul>
<p>TRX_UNDO_UPD_EXIST_REC</p>
<table>
<thead>
<tr>
<th align="left"><div style="width: 200px">字段</div></th>
<th align="left">占用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">end of record</td>
<td align="left">2</td>
<td align="left">本页中，该记录的末尾偏移量。只有当记录完全写完才能写入，事先不知道大小。</td>
</tr>
<tr>
<td align="left">type_cmpl</td>
<td align="left">1</td>
<td align="left">TRX_UNDO_UPD_EXIST_REC</td>
</tr>
<tr>
<td align="left">undo_no</td>
<td align="left"></td>
<td align="left">在一个事务中从 0 开始递增</td>
</tr>
<tr>
<td align="left">table id</td>
<td align="left"></td>
<td align="left">表 ID</td>
</tr>
<tr>
<td align="left">info bits</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">trx_id</td>
<td align="left">压缩</td>
<td align="left">旧记录的 trx_id</td>
</tr>
<tr>
<td align="left">roll_pointer</td>
<td align="left">压缩</td>
<td align="left">旧记录的 roll_pointer</td>
</tr>
<tr>
<td align="left">clustered index 1 length</td>
<td align="left"></td>
<td align="left">聚簇索引 1 长度</td>
</tr>
<tr>
<td align="left">clustered index 1 value</td>
<td align="left"></td>
<td align="left">聚簇索引 1 值</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">clustered index n length</td>
<td align="left"></td>
<td align="left">聚簇索引 n 长度</td>
</tr>
<tr>
<td align="left">clustered index n value</td>
<td align="left"></td>
<td align="left">聚簇索引 n 值</td>
</tr>
<tr>
<td align="left">n_updated</td>
<td align="left"></td>
<td align="left">共有多少个列被更新了</td>
</tr>
<tr>
<td align="left">len of index_col_info</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">索引列各列信息</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">start of record</td>
<td align="left">2</td>
<td align="left">本页中，该记录的起始偏移量</td>
</tr>
</tbody></table>
<p>TRX_UNDO_DEL_MARK_REC</p>
<table>
<thead>
<tr>
<th align="left"><div style="width: 200px">字段</div></th>
<th align="left">占用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">end of record (2)</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Type and Flags (1)</td>
<td align="left"></td>
<td align="left">TRX_UNDO_DEL_MARK_REC</td>
</tr>
<tr>
<td align="left">Undo Number</td>
<td align="left"></td>
<td align="left">在一个事务中从 0 开始递增</td>
</tr>
<tr>
<td align="left">Table ID</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Info Bits</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">trx_id</td>
<td align="left"></td>
<td align="left">旧记录的 trx_id</td>
</tr>
<tr>
<td align="left">roll_pointer</td>
<td align="left"></td>
<td align="left">旧记录的 roll_pointer</td>
</tr>
<tr>
<td align="left">clustered index 1 length</td>
<td align="left"></td>
<td align="left">聚簇索引 1 长度</td>
</tr>
<tr>
<td align="left">clustered index 1 value</td>
<td align="left"></td>
<td align="left">聚簇索引 1 值</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">clustered index n length</td>
<td align="left"></td>
<td align="left">聚簇索引 n 长度</td>
</tr>
<tr>
<td align="left">clustered index n value</td>
<td align="left"></td>
<td align="left">聚簇索引 n 值</td>
</tr>
<tr>
<td align="left">start of record</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">事务中 DELETE 仅将记录的 deleted_flag 标识设置为 1</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">当对每一条数据记录进行 delete mark 操作前，需要把该数据记录的 trx_id 和 roll_pointer 的旧值记录到 undo log record，再将 trx_id 和 roll_pointer 更新。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>撤销日志是为了实现事务原子性而出现的产物。事务处理过程中，如果出现了错误或者用户执行了 rollback 语句，MySQL 可以利用 undo log 中的信息将数据恢复到事务开始之前的状态<br>撤销日志在 MySQL InnoDB 存储引擎中还用来实现多版本并发控制。</p>
</blockquote>
<p>在全局临时表空间中的 Undo Log 用于事务修改用户定义的临时表中的数据。这些 Undo Log 不会记录 Redo Log，因为崩溃恢复不需要它们。它们仅在服务器运行时用于回滚。这种类型的 Undo Log 通过避免 Redo 日志 I&#x2F;O 对性能有帮助。<br>每个 undo 表空间和全局临时表空间最多支持 128 个回滚段。<code>innodb_rollback_segments</code> 变量定义了回滚段的数量。<br>事务最多分配 4 个 undo 日志，每个对应下面的操作类型：</p>
<ol>
<li><code>INSERT</code> 用户定义的表</li>
<li><code>UPDATE</code> 和 <code>DELETE</code> 用户定义的表</li>
<li><code>INSERT</code> 用户定义的临时表</li>
<li><code>UPDATE</code> 和 <code>DELETE</code> 用户定义的临时表<br>根据需要分配 undo 日志。例如，执行常规表和临时表上的 <code>INSERT</code>，<code>UPDATE</code>，以及 <code>DELETE</code> 操作的事务需要完全分配 4 个 undo 日志；仅在常规表上执行 <code>INSERT</code> 操作的事务只需要 1 个 undo 日志。</li>
</ol>
<ul>
<li>如果每个事务执行 <code>INSERT</code> 或者 <code>UPDATE</code> 或者 <code>DELETE</code> 操作之一，那么 InnoDB 可以支持的并发独写事务数是：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(innodb_page_size / 16) * innodb_rollback_segments * number of undo tablespaces</span><br></pre></td></tr></table></figure></li>
<li>如果每个事务执行 <code>INSERT</code> 加上 <code>UPDATE</code> 或者 <code>DELETE</code> 操作之一，那么 InnoDB 可以支持的并发独写事务数是：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(innodb_page_size / 16 / 2) * innodb_rollback_segments * number of undo tablespaces</span><br></pre></td></tr></table></figure></li>
<li>如果每个事务都在临时表上执行 <code>INSERT</code> 操作，那么 InnoDB 可以支持的并发独写事务数是：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(innodb_page_size / 16) * innodb_rollback_segments</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Undo-Log-分配"><a href="#Undo-Log-分配" class="headerlink" title="Undo Log 分配"></a>Undo Log 分配</h3><p>当开启一个事务的时候，会调用 <code>trx_assign_rseg_durable</code> 分配一个 Rollback Segment。<br>只读事务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trx_assign_rseg_temp();</span><br><span class="line">-&gt; get_next_temp_rseg();</span><br><span class="line">-&gt; trx_sys-&gt;tmp_rsegs</span><br></pre></td></tr></table></figure>
<p>读写事务</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trx_assign_rseg_durable() </span><br><span class="line">-&gt; get_next_redo_rseg()</span><br><span class="line">    -&gt;get_next_redo_rseg_from_trx_sys() -&gt; (trx_sys-&gt;rsegs)</span><br><span class="line">      get_next_redo_rseg_from_undo_spaces() -&gt; (undo_space-&gt;rsegs())</span><br></pre></td></tr></table></figure>
<p>当 InnoDB 没有配置独立 Undo Tablespace 时， trx_sys-&gt;regs 为读写事务分配回滚段；否则从 undo_spaces-&gt;regs() 分配回滚段<br>当第一次真正产生修改需要写 Undo Log Record 的时候，调用 <code>trx_undo_assign_undo</code> 来获得一个 Undo Segment</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">trx_undo_assign_undo(*trx. *undo_ptr, type) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     尝试获取缓存中可用的 Undo Log</span></span><br><span class="line"><span class="comment">     1. 对于 type == TRX_UNDO_INSERT</span></span><br><span class="line"><span class="comment">          从 rseg-&gt;insert_undo_cached 链表上获取 Undo Log 对象，并从链表移除</span></span><br><span class="line"><span class="comment">          之后调用 trx_undo_insert_header_reuse 重新初始化 Undo Page Header</span></span><br><span class="line"><span class="comment">     2. 对于 type == TRX_UNDO_UPDATE</span></span><br><span class="line"><span class="comment">          从 rseg-&gt;update_undo_cached 链表上获取 Undo Log 对象，并从链表移除</span></span><br><span class="line"><span class="comment">          之后调用 trx_undo_header_create 创建新的 Undo Log Header</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">          </span><br><span class="line">    undo = trx_undo_reuse_cached();</span><br><span class="line">    <span class="keyword">if</span> (undo == nullptr) &#123;</span><br><span class="line"><span class="comment">// 如果没有缓存的 Undo Log 对象，调用 trx_undo_create 从回滚段上分配一个空闲的 Undo Slot</span></span><br><span class="line">        trx_undo_create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Undo-Log-写入"><a href="#Undo-Log-写入" class="headerlink" title="Undo Log 写入"></a>Undo Log 写入</h3><h4 id="1-分配回滚段"><a href="#1-分配回滚段" class="headerlink" title="1. 分配回滚段"></a>1. 分配回滚段</h4><p>事务从调用 <code>trx_start_low</code> 函数开始。</p>
<p>当该事务被判定为读写模式时，会分配 TRX_ID 以及回滚段。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来自 trx_start_low 片段</span></span><br><span class="line"><span class="keyword">if</span> (!trx-&gt;read_only &amp;&amp;</span><br><span class="line">      (trx-&gt;mysql_thd == nullptr || read_write || trx-&gt;ddl_operation)) &#123;</span><br><span class="line">    <span class="comment">// 分配 Rollback Segment</span></span><br><span class="line">    trx_assign_rseg_durable(trx);</span><br><span class="line">    <span class="comment">// 分配 TRX_ID</span></span><br><span class="line">    trx-&gt;id = trx_sys_allocate_trx_id();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当写事务开始时，会先调用 <code>trx_assign_rseg_durable</code>  分配一个 Rollback Segment。</p>
<p>分配策略：依次尝试下一个活跃的 Rollback Segment。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ Assign a durable rollback segment to a transaction in a round-robin</span><br><span class="line">fashion.</span><br><span class="line">@param[in,out]	trx	transaction that involves a durable write. */</span><br><span class="line"><span class="type">void</span> <span class="title function_">trx_assign_rseg_durable</span><span class="params">(<span class="type">trx_t</span> *trx)</span> &#123;</span><br><span class="line">  ut_ad(trx-&gt;rsegs.m_redo.rseg == nullptr);</span><br><span class="line"></span><br><span class="line">  trx-&gt;rsegs.m_redo.rseg = srv_read_only_mode ? nullptr : get_next_redo_rseg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用回滚段"><a href="#2-使用回滚段" class="headerlink" title="2. 使用回滚段"></a>2. 使用回滚段</h4><p>当第一次真正产生修改需要写 Undo Record 的时候，会从 <code>trx_undo_report_row_operation</code> 进入，接着调用 <code>trx_undo_assign_undo</code> 获得一个 Undo Segment。优先复用 <code>trx_rseg_t</code> 上 Cached List 中的 trx_undo_t，也就是已经分配出来但没有被正在使用的 Undo Segment。</p>
<p>如果没有缓存的 Undo Segment，才调用 <code>trx_undo_create</code> 创建新的 Undo Segment，<code>trx_undo_create</code> 会轮询选择当前 Rollback Segment 中可用的 Slot，申请新的 Undo Page，初始化 Undo Page Header，Undo Segment Header</p>
<h4 id="3-写入"><a href="#3-写入" class="headerlink" title="3. 写入"></a>3. 写入</h4><p>对于 INSERT UNDO LOG 写入的入口函数 <code>trx_undo_page_report_insert</code></p>
<p>对于 UPDATE UNDO LOG 写入的入口函数 <code>trx_undo_page_report_modify</code></p>
<p>在写入过程中，可能出现 Undo Page 空间不足的情况，当出现这种情况，会调用 <code>trx_undo_erase_page_end</code> 来清除刚刚写入的区域，然后调用 <code>trx_undo_add_page</code> 申请一个新的 Undo Page 加入到 Undo Page List，同时 undo-&gt;last_page_no 指向新的 Undo Page，重新尝试写入。</p>
<h1 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h1><h2 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h2><p>The System Tablespace</p>
<p>系统表空间是更改缓冲区的存储区域。如果在系统表空间中创建表，而不是每张表一个文件或者常规表空间，它也可能包含表和索引数据。在过于的版本中，系统表空间包含 InnoDB 的数据字典。在 MySQL 8.0 中，InnoDB 将元数据存储在数据字典中。<br>系统表空间可以有一个或者多个数据文件。默认地，会在数据文件夹下创建一个系统表空间数据文件，名为 <code>ibdata</code>。系统表空间的大小和数量由 innodb_data_file_path 启动项定义。</p>
<h2 id="File-Per-Table-Tablespaces"><a href="#File-Per-Table-Tablespaces" class="headerlink" title="File-Per-Table Tablespaces"></a>File-Per-Table Tablespaces</h2><p>对于单个 InnoDB 表，file-per-table 表空间包含了该表的数据以及索引，并存储于文件系统的单个文件中</p>
<h1 id="Redo-Log-重做日志用来实现事务的持久性"><a href="#Redo-Log-重做日志用来实现事务的持久性" class="headerlink" title="Redo Log 重做日志用来实现事务的持久性"></a>Redo Log 重做日志用来实现事务的持久性</h1><p>Redo Log 是在崩溃期间使用的基于磁盘的数据结构，以纠正不完整事务写入的数据。<br>在正常操作期间，Redo Log 将那些来自于 SQL 语句或者低级 API 调用的表数据修改操作请求进行编码。<br>在初始化并接受连接之前，那些由于无法预期的关闭导致未能将数据文件更新的修改操作会被重新执行。</p>
<blockquote>
<p>重做日志用来实现事务的持久性<br>默认地，Redo Log 在物理上表现为磁盘上两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 的文件。MySQL 以循环的方式写入 Redo Log 文件。根据受影响的记录，Redo Log 将它们编码；这些数据统称为 redo。</p>
</blockquote>
<h2 id="Changing-the-Number-or-Size-of-Redo-Log-Files"><a href="#Changing-the-Number-or-Size-of-Redo-Log-Files" class="headerlink" title="Changing the Number or Size of Redo Log Files"></a>Changing the Number or Size of Redo Log Files</h2><p>如果要修改 Redo Log 的大小数量，需要执行以下步骤：</p>
<ol>
<li>停止 MySQL Server 并确保它没有错误关闭</li>
<li>编辑 my.cnf 更改日志文件配置。要更改日志文件大小，配置 <code>innodb_log_file_size</code>。为了增加日志文件的数量，需配置 <code>innodb_log_files_in_group</code></li>
<li>再次启动 MySQL 服务<h2 id="Group-Commit-for-Redo-Log-Flushing"><a href="#Group-Commit-for-Redo-Log-Flushing" class="headerlink" title="Group Commit for Redo Log Flushing"></a>Group Commit for Redo Log Flushing</h2>与其他符合 ACID 数据库引擎一样，InnoDB 在提交事务之前会刷写（flush） Redo Log。InnoDB 使用组提交功能，将多个 flush 请求组合在一起，以避免为每个提交进行一次 flush 操作。使用组提交，InnoDB 向日志文件发出单个的写入，用于为同一时间的多个用户事务执行提交动作，这可以显著提高吞吐量。<h2 id="Redo-Log-Archiving"><a href="#Redo-Log-Archiving" class="headerlink" title="Redo Log Archiving"></a>Redo Log Archiving</h2>复制 Redo Log 记录的备份工具有时候可能会在进行备份操作时无法跟上 Redo Log 的生成速度，导致由于这些记录被覆盖而导致 Redo Log 记录丢失。在备份操作期间，存在着显著的 MySQL 服务活动，并且 Redo Log 文件存储介质比备份存储介质更快的速度运行时，最常常发生此问题。在 MySQL 8.0.17 中引入的重做记录归档功能，通过在 Redo Log 文件之外将 Redo Log 记录顺序写入归档文件来解决此事。<h2 id="Performance-Considerations"><a href="#Performance-Considerations" class="headerlink" title="Performance Considerations"></a>Performance Considerations</h2><img src="https://img-blog.csdnimg.cn/55d9b5977dcd478b9035dc0faee7a8fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA572Q6KOF6Z2i5YyF,size_20,color_FFFFFF,t_70,g_se,x_16" alt="请添加图片描述"></li>
</ol>
<h1 id="Undo-Tablespaces"><a href="#Undo-Tablespaces" class="headerlink" title="Undo Tablespaces"></a>Undo Tablespaces</h1><p>撤销表空间包含 undo 日志，这些记录是包含有关如何撤销事务的最新的更改的信息。<br>InnoDB 是一个多版本的存储引擎。它可以保留有关更改行的旧版本的信息，以支持事务功能，例如并发和回滚。此信息以一个称为回滚段的数据结构，存储于 undo 表空间。回滚段驻留在 undo 表空间和全局临时表空间中。</p>
<h2 id="Default-Undo-Tablespaces"><a href="#Default-Undo-Tablespaces" class="headerlink" title="Default Undo Tablespaces"></a>Default Undo Tablespaces</h2><p>初始化 MySQL 实例的时候，会创建两个默认的 undo 表空间。<br>默认 undo 表空间的创建位置由 innodb_undo_directory 变量定义。如果 innodb_undo_directory 变量未定义，则再数据目录中创建默认的 undo 表空间。默认 undo 表空间数据文件名为 <code>undo_001</code> 和 <code>undo_002</code>。数据字典中定义的相应的 undo 表空间名称是 innodb_undo_001 和 innodb_undo_002</p>
<h2 id="Undo-Tablespace-Size"><a href="#Undo-Tablespace-Size" class="headerlink" title="Undo Tablespace Size"></a>Undo Tablespace Size</h2><p>在 MySQL 8.0.23 之前，undo 表空间的大小取决于 innodb_page_size。对于默认的 16K 页大小，初始 undo 表空间是 10MB。</p>
<h2 id="Dropping-Undo-Tablespaces"><a href="#Dropping-Undo-Tablespaces" class="headerlink" title="Dropping Undo Tablespaces"></a>Dropping Undo Tablespaces</h2><p>MySQL 8.0.14 可以使用 <code>DROP UNDO TABLESPACES</code> 语法在运行时删除使用 <code>CREATE UNDO TABLESPACES</code> 语法创建的表空间。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>ReadView，每个事务在读取数据的时候都会被分配一个视图，通过视图就可以判断其他事务对数据的可见性。</p>
<p>分配：通过 <code>trx_assign_read_view()</code> 分配视图</p>
<p>回收：事务结束时，会通过 <code>view_close()</code> 对其视图进行回收。</p>
<p><code>m_low_limit_id</code>：读取行为不应该看到 <code>trx_id</code> &gt;&#x3D; <code>m_low_limit_id</code> 的事务，即高水位。分配时取 <code>trx_sys::max_trx_id</code>，即当前还没有被分配的事务最大 ID</p>
<p><code>m_up_limit_id</code>：读取行为应该可以看到所有 trx_id &lt; <code>m_up_limit_id</code> 的事务，即低水位。低水位，如果m_ids不为空，取其最小值，否则取trx_sys::max_trx_id，即与高水位相等。</p>
<blockquote>
<p>关于 <code>m_low_limit_id</code> 和 <code>m_up_limit_id</code> 的解释以及高水位和低水位的比喻均来自于源码注释。</p>
</blockquote>
<p><code>m_ids</code>：在此视图初始化时，通过 <code>copy_trx_ids()</code> 从 <code>trx_sys::rw_trx_ids</code> 拷贝一份活跃事务ID(不包含当前事务ID)。</p>
]]></content>
  </entry>
  <entry>
    <title>Spring Cloud Config</title>
    <url>/2022/07/17/Spring-Cloud/Spring-Cloud-Config/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/">Spring Cloud Config</a></h1><h2 id="1-Quick-Start"><a href="#1-Quick-Start" class="headerlink" title="1. Quick Start"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_quick_start">1. Quick Start</a></h2><blockquote>
<p>该章是官网的一个体验案例</p>
</blockquote>
<p>首先，启动服务，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> spring-cloud-config-server</span><br><span class="line">$ ../mvnw spring-boot:run</span><br></pre></td></tr></table></figure>
<p>服务是一个 Spring Boot 程序，你也可以从 IDE 运行。</p>
<p>接下来，试验一下客户端，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl localhost:8888/foo/development</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;master&quot;</span>,<span class="string">&quot;propertySources&quot;</span>:[</span><br><span class="line">  &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;https://github.com/scratches/config-repo/foo-development.properties&quot;</span>,<span class="string">&quot;source&quot;</span>:&#123;<span class="string">&quot;bar&quot;</span>:<span class="string">&quot;spam&quot;</span>&#125;&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;https://github.com/scratches/config-repo/foo.properties&quot;</span>,<span class="string">&quot;source&quot;</span>:&#123;<span class="string">&quot;foo&quot;</span>:<span class="string">&quot;bar&quot;</span>&#125;&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure>

<p>定位属性资源的默认策略是去克隆一个 git 存储库（位于 <code>spring.cloud.config.server.git.uri</code>），并使用它去实例化一个迷你的 <code>SpringApplication</code>。</p>
<p>HTTP 服务以下格式的资源：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">/&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>

<h3 id="1-1-Client-Side-Usage"><a href="#1-1-Client-Side-Usage" class="headerlink" title="1.1. Client Side Usage"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_client_side_usage">1.1. Client Side Usage</a></h3><p>为了在应用程序中使用这些功能，你可以将其构建为依赖于 <code>spring-cloud-config-client</code> 的Spring Boot 项目。最简便的方法是使用 Spring Boot 启动器 <code>org.springframework.cloud:spring-cloud-starter-config</code>。对于 maven 用户以及 Gradle 和 Spring CLI 用户的 Spring IO 版本管理属性文件，也有一个父 POM 和 BOM（spring-cloud-starter-parent）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>现在，你可以创建一个标准的 Spring Boot 应用，就像下面的 HTTP 服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当这个 HTTP 服务启动的时候，它会从默认的监听于本地端口 8888 配置服务（如果启动了）获取外部配置。如果想修改默认行为，你可以修改 bootstrap.properties 中的配置服务的位置，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">spring.cloud.config.uri: http://myconfigserver.com</span><br></pre></td></tr></table></figure>

<p>默认地，如果应用名称没有设置，则会使用 <code>application</code>。如果要修改默认行为，可以使用 <code>spring.application.name</code> 进行修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name:</span> <span class="string">myapp</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>设置属性 <code>$&#123;spring.application.name&#125;</code> 不要使用保留字 <code>application-</code> 作为应用名前缀，防止无法解析出正确的资源。</li>
</ul>
</blockquote>
<h2 id="2-Spring-Cloud-Config-Server"><a href="#2-Spring-Cloud-Config-Server" class="headerlink" title="2. Spring Cloud Config Server"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_spring_cloud_config_server">2. Spring Cloud Config Server</a></h2><p>Spring Cloud Config Server 提供了一个用于外部配置的 HTTP 资源 API。通过使用 <code>@EnableConfigServer</code> 注解，服务就能嵌入到 Spring Boot 应用中。因此，下面的应用就是一个配置服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigServer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(ConfigServer.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和所有的 Spring Boot 应用一样，它默认运行在 8080 端口，但你可以将其切换到约定好的 8888 端口。最简单的方式是，通过配置 <code>spring.config.name=configserver</code> 来启动应用，这同时也设置了默认的存储库类型。</p>
<blockquote>
<p>注意，这种配置方式的依据是 Config Server jar 包下的 configserver.yml 文件。实际并没有作用，引用的是 github 上面的样本地址。</p>
</blockquote>
<p>另一种方式是使用你自己的 <code>application.properties</code>，如下所示：</p>
<p><strong>application.properties</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring.cloud.config.server.git.uri:</span> <span class="string">file://$&#123;user.home&#125;/config-repo</span></span><br></pre></td></tr></table></figure>

<p>在这里，<code>$&#123;user.home&#125;/config-repo</code> 是一个包含 YAML 以及属性文件的 git 存储库。</p>
<blockquote>
<p>在 Windows 上，如果 git 存储库是一个绝对驱动的前缀，你需要再加一个 “&#x2F;“，例如：<code>file:///$&#123;user.home&#125;/config-repo)</code></p>
</blockquote>
<h3 id="2-1-Environment-Repository"><a href="#2-1-Environment-Repository" class="headerlink" title="2.1. Environment Repository"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_environment_repository">2.1. Environment Repository</a></h3><p>在什么地方存储配置服务的配置数据？管理此行为的策略是 <code>EnvironmentRepository</code>，服务 <code>Environment</code> 对象。这个 <code>Environment</code> 是 Spring Environment 的浅拷贝（包括 <code>propertySources</code> 作为主要功能）。<code>Environment</code> 资源是三个变量的参数化：</p>
<ul>
<li><code>&#123;application&#125;</code>，映射到 <code>spring.application.name</code></li>
<li><code>&#123;profile&#125;</code>，在客户端映射到 <code>spring.profiles.active</code></li>
<li><code>&#123;label&#125;</code></li>
</ul>
<p>存储库的实现通常表现得像一个 Spring Boot 程序，它从 <code>spring.config.name</code> 等于 <code>&#123;application&#125;</code> 以及 <code>spring.profiles.active</code> 等于 <code>&#123;profiles&#125;</code> 中加载配置文件。配置文件的优先规则也与常规的 Spring Boot 程序相同：激活的配置文件优先于默认值，如果又多个配置文件，则选择最后一个（类似向 Map 添加条目）。</p>
<p>如果存储库是基于文件的，那么服务器将从 application.yml 和 foo.yml 中创建一个 <code>Environment</code>。如果 YAML 文件在它们内部有指向 Spring 配置文件的文档，那么会使用更高的优先级。如果有特定的配置 YAML 文件，那么这些文件也以比默认值更高的优先级而使用。高优先级转换为在 <code>Environment</code> 中提前列出的 <code>PropertySource</code>。</p>
<h4 id="2-1-1-Git-Backend"><a href="#2-1-1-Git-Backend" class="headerlink" title="2.1.1. Git Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_git_backend">2.1.1. Git Backend</a></h4><p>默认的 <code>EnvironmentRepository</code> 的实现使用 Git 后端，这对于管理升级和物理环境，以及对于跟踪变化非常方便。要更改存储库的位置，你可以在 Config Server（例如在 <code>application.yml</code> 中）中设置 <code>spring.cloud.config.server.git.uri</code> 配置属性。如果你用一个 <code>file:</code> 前缀进行设置，则应从本地存储库工作，以便于你可以在没有服务器的情况下快速启动。但是，在这种情况下，服务直接在本地存储库上操作而无需克隆（无论是否是裸仓库都无关紧要，因为 Config Server 永远不会更改 “remote” 存储库）。为了扩展 Config Server 并使其高度可用，你需要将所有服务实例指向相同的存储库，因此只有共享文件系统才能起作用。甚至在这种情况下，最好将 <code>ssh:</code> 协议用于共享文件系统存储库，以便于服务可以克隆它，并将本地工作副本作为缓存。</p>
<h5 id="Skipping-SSL-Certificate-Validation"><a href="#Skipping-SSL-Certificate-Validation" class="headerlink" title="Skipping SSL Certificate Validation"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_skipping_ssl_certificate_validation">Skipping SSL Certificate Validation</a></h5><p>通过将 <code>git.skipSslValidation</code> 属性设置为 <code>true</code>（默认为 <code>false</code>），可以禁用配置服务器对 Git 服务器的 SSSL 证书校验：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://example.com/my/repo</span></span><br><span class="line">          <span class="attr">skipSslValidation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="Setting-HTTP-Connection-Timeout"><a href="#Setting-HTTP-Connection-Timeout" class="headerlink" title="Setting HTTP Connection Timeout"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_setting_http_connection_timeout">Setting HTTP Connection Timeout</a></h5><h4 id="2-1-3-File-System-Backend"><a href="#2-1-3-File-System-Backend" class="headerlink" title="2.1.3. File System Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_file_system_backend">2.1.3. File System Backend</a></h4><p>Config Server 中拥有一个 <code>native</code> profile，该配置不使用 Git，而是从本地类路径或者文件系加载配置文件。为了使用本地配置，以 <code>spring.profiles.active=native</code> 启动 Config Server。</p>
<p>搜索路径可以包含占位符 <code>&#123;application&#125;</code>, <code>&#123;profile&#125;</code>, <code>&#123;label&#125;</code>。通过这种方式，你可以在路径中分离目录并选择一个对你有意义的策略。</p>
<p>如果你没有在搜索路径中使用占位符，存储库还会将 <code>&#123;label&#125;</code> 参数追加到存储路径末尾，因此属性文件会从每个搜索路径，以及有一个 label 后缀的子目录去加载。因此，没有占位符的默认行为与在搜索路径末尾添加 <code>/&#123;label&#125;/</code> 相同。举个例子，<code>file:/tmp/config</code> 与 <code>file:/tmp/config,file:/tmp/config/&#123;label&#125;</code> 相同。这个行为可以通过设置 <code>spring.cloud.config.server.native.addLabelLocations=false</code> 从而禁用。</p>
<blockquote>
<ul>
<li>默认添加 label 后缀的行为很单纯，例如，你设置了 <code>spring.cloud.config.server.native.search-locations=file:///f:/profiles/application</code>，同时 label 参数为 dev，那么还会搜索的路径就是 <code>file:///f:/profiles/applicationdev</code>，并不会帮你自动添加路径分隔符 <code>/</code>，至少在 2.2.8.RELEASE 测试是如此。</li>
</ul>
</blockquote>
<h4 id="2-1-6-Sharing-Configuration-With-All-Applications"><a href="#2-1-6-Sharing-Configuration-With-All-Applications" class="headerlink" title="2.1.6. Sharing Configuration With All Applications"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_sharing_configuration_with_all_applications">2.1.6. Sharing Configuration With All Applications</a></h4><h5 id="2-1-6-1-File-Based-Repositories"><a href="#2-1-6-1-File-Based-Repositories" class="headerlink" title="2.1.6.1. File Based Repositories"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#spring-cloud-config-server-file-based-repositories">2.1.6.1. File Based Repositories</a></h5><p>使用基于文件的存储库，在所有客户端应用之间共享文件名为 <code>application*</code> 的资源（<code>application.properties</code>, <code>application.yml</code>, <code>application-*.properties</code> 等）。你可以使用具有这些文件名的资源来进行全局默认配置，并且根据需要让它们被应用特定的文件覆盖。</p>
<p>属性覆盖功能也可以用于设置全局默认，应用程序允许在本地覆盖它们。</p>
<blockquote>
<p>使用 native 配置文件（本地文件系统后端），你应该使用不属于服务自己的配置的指定搜索路径。否则，位于默认搜索路径中的 <code>application*</code> 资源会被移除，因为它们是服务的一部分。</p>
</blockquote>
<h4 id="2-1-7-JDBC-Backend"><a href="#2-1-7-JDBC-Backend" class="headerlink" title="2.1.7. JDBC Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_jdbc_backend">2.1.7. JDBC Backend</a></h4><p>Spring Cloud Config 服务支持 JDBC 作为配置属性的后端。你可以通过添加 <code>spring-jdbc</code> 到类路径，并使用 <code>jdbc</code> 配置，或者添加 <code>JdbcEnvironmentRepository</code> 该 bean 来启用此功能。</p>
<p>你可以通过设置 <code>spring.cloud.config.server.jdbc.enabled=false</code> 来禁用 <code>JdbcEnvironmentRepository</code> 的自动配置。</p>
<blockquote>
<p>至少 Spring Cloud Config 2.2.8.RELEASE 开始支持 enabled 属性</p>
</blockquote>
<p>数据库需要有一个名为 <code>PROPERTIES</code> 的表，列为 <code>APPLICATION</code>, <code>PROFILE</code>, <code>LABEL</code>, <code>KEY</code>, <code>VALUE</code>。所有的字段都是 Java 的 String 类型，因此你可以定义为 <code>VARCHAR</code>。属性值表现与它们来自 Spring Boot 属性文件 <code>&#123;application&#125;-&#123;profile&#125;.properties</code> 相同，包括所有的编码与解码，这些稍后会进行处理（即不会直接再存储库实现中）。</p>
<blockquote>
<p>默认的 SQL 为 <code>SELECT KEY, VALUE from PROPERTIES where APPLICATION=? and PROFILE=? and LABEL=?</code>，但这对于 MySQL 并不管用，因为 KEY 为关键字，应当被反引号包裹，否则在执行过程中报错。</p>
</blockquote>
<h4 id="2-1-8-Redis-Backend"><a href="#2-1-8-Redis-Backend" class="headerlink" title="2.1.8. Redis Backend"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_redis_backend">2.1.8. Redis Backend</a></h4><h4 id="2-1-11-Composite-Environment-Repositories"><a href="#2-1-11-Composite-Environment-Repositories" class="headerlink" title="2.1.11 Composite Environment Repositories"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#composite-environment-repositories">2.1.11 Composite Environment Repositories</a></h4><p>从多个环境存储库提取配置数据。</p>
<h3 id="2-2-Health-Indicator"><a href="#2-2-Health-Indicator" class="headerlink" title="2.2.  Health Indicator"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_health_indicator">2.2.  Health Indicator</a></h3><p>配置服务器附带一个健康指示器，用于检查配置的 <code>EnvironmentRepository</code> 是否正常工作。默认地，它会请求 <code>EnvironmentRepository</code> 一个名为 <code>app</code> 的应用，<code>default</code> 的配置，由 <code>EnvironmentRepository</code> 实现提供的默认标签。</p>
<p>通过 <code>health.config.enabled=false</code>，你可以禁用健康指示器。</p>
<h3 id="2-3-Security"><a href="#2-3-Security" class="headerlink" title="2.3. Security"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_security">2.3. Security</a></h3><p>你可以以任何对你有意义的方法保护 Config Server（从物理网络安全到 OAuth2 持票人令牌），Spring Security 和 Spring Boot 提供了许多安全性的功能。</p>
<p>为了使用默认的 Spring Boot 配置 HTTP Basic 安全，需要包含 Spring Security 到类路径。默认具有一个名为 <code>user</code> 的用户名和随机生成的密码。实践中，随机密码并没有太大用处，推荐配置密码并加密。</p>
<blockquote>
<ul>
<li>需要包含 <code>spring-boot-starter-security</code> 依赖，以使用 Spring 的自动配置化的 HTTP Basic 安全</li>
<li>通过设置 <code>spring.security.user.password</code> 配置密码</li>
<li>客户端注意设置用户名和密码</li>
</ul>
</blockquote>
<h3 id="2-4-Encryption-and-Decryption"><a href="#2-4-Encryption-and-Decryption" class="headerlink" title="2.4. Encryption and Decryption"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_encryption_and_decryption">2.4. Encryption and Decryption</a></h3><blockquote>
<p>为了使用加密和解密功能，旧版本 JDK 需要下载完全的 <a href="https://www.oracle.com/java/technologies/javase-jce-all-downloads.html">JCD</a></p>
</blockquote>
<p>如果远程属性资源包含加密内容（以 <code>&#123;cipher&#125;</code> 开头），则先解密再通过 HTTP 发送。该设置的优点是：当属性值 “静止” 时，不需要以纯文本方式展示。如果值无法被解密，将会从属性源中删除它，并添加一个额外的有相同键的属性，但是具有 <code>invalid</code> 前缀，值意味着不适用。这主要是为了加密文本用作密码，有可能意外泄漏。</p>
<h3 id="2-5-Key-Management"><a href="#2-5-Key-Management" class="headerlink" title="2.5. Key Management"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_key_management">2.5. Key Management</a></h3><p>Config Server 可以使用对称加密或者非对称加密（RSA 密钥对）。选择不对称加密在安全性方面更优越，但使用对称密钥通常更方便，因为它是在 <code>bootstrap.properties</code> 中配置的单个属性值。</p>
<p>要配置对称密钥，你需要设置 <code>encryt.key</code> 为密钥字符串（或者使用 <code>ENCRYPT_KEY</code> 环境变量，可以脱离纯文本配置文件）。</p>
<h3 id="2-6-Creating-a-Key-Store-for-Testing"><a href="#2-6-Creating-a-Key-Store-for-Testing" class="headerlink" title="2.6. Creating a Key Store for Testing"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_creating_a_key_store_for_testing">2.6. Creating a Key Store for Testing</a></h3><p>使用 JDK 自带的 <code>keytool</code> 工具创建密钥库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ keytool -genkeypair -<span class="built_in">alias</span> mytestkey -keyalg RSA \</span><br><span class="line">  -dname <span class="string">&quot;CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US&quot;</span> \</span><br><span class="line">  -keypass changeme -keystore server.jks -storepass letmein</span><br></pre></td></tr></table></figure>

<p>将生成的 <code>server.jks</code> 文件放到类路径下，然后在 <code>bootstrap.yml</code> 进行配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">keyStore:</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:/server.jks</span> <span class="comment"># keystore 文件存储路径</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">letmein</span> <span class="comment"># storepass 密钥仓库</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">mytestkey</span> <span class="comment"># 密钥对别名</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">changeme</span> <span class="comment"># keypass 用来保护所生成密钥对中的私钥</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-Using-Multiple-Keys-and-Key-Rotation"><a href="#2-7-Using-Multiple-Keys-and-Key-Rotation" class="headerlink" title="2.7. Using Multiple Keys and Key Rotation"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_using_multiple_keys_and_key_rotation">2.7. Using Multiple Keys and Key Rotation</a></h3><h3 id="2-8-Serving-Encrypted-Properties"><a href="#2-8-Serving-Encrypted-Properties" class="headerlink" title="2.8. Serving Encrypted Properties"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_serving_encrypted_properties">2.8. Serving Encrypted Properties</a></h3><p>有时候，你往客户端自行解密配置，而不是在配置中心解密完毕再传送过来。在这种情况下，如果你提供了 <code>encrypt.*</code> 相关配置来定位 key，你还是可以具有 <code>/encrypt</code> 和 <code>/decrypt</code> 端点，但是你需要在 <code>boostrap.[yml|properties]</code> 设置 <code>spring.cloud.config.server.encrypt.enabled=false</code> 来显式关闭传出属性的解密功能。如果你不关心端点，那么如果你没有配置 key 或者 enabled 标志，就能起作用了。</p>
<h2 id="3-Serving-Alternative-Formats"><a href="#3-Serving-Alternative-Formats" class="headerlink" title="3. Serving Alternative Formats"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_serving_alternative_formats">3. Serving Alternative Formats</a></h2><p>来自环境端点的默认 JSON 格式是完美被 Spring 应用消费的，因为它直接映射到 <code>Environment</code> 抽象上。如果你愿意，你也可以通过增加一个后缀（”.yml”, “.yaml” 或者 “.properties”）以 YAML 或者 Java 属性消费相同的数据。这对于那些不关心 JSON 端点的结构，或者额外元数据的应用来消费是非常有用的（例如，未使用 Spring 的应用可能会受益于此方法的简单性）。</p>
<h2 id="4-Serving-Plain-Text"><a href="#4-Serving-Plain-Text" class="headerlink" title="4. Serving Plain Text"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_serving_plain_text">4. Serving Plain Text</a></h2><p>不使用 <code>Environment</code> 抽象，你的应用可能需要对其环境量身定制的通用普通文本配置文件。Config Server 通过一个位于 <code>/&#123;application&#125;/&#123;profile&#125;/&#123;label&#125;/&#123;path&#125;</code> 的额外端点提供这些，其中，<code>application</code>，<code>profile</code>，<code>label</code> 与常规的环境端点有相同含义，但是 <code>path</code> 是一个文件名的路径（例如 log.xml）。此端点的源文件以与环境端点相同的方式定位。相同的搜索路径被用于 properties 和 YAML 文件。但是，仅返回第一个被匹配的资源，而不是聚合所有资源。</p>
<p>在资源被定位之后，以常规格式的占位符（<code>$&#123;...&#125;</code>）会被使用提供的 application name，profile，label 解析。以这种方式，资源端点与环境端点紧密集成。</p>
<h2 id="5-Embedding-the-Config-Server"><a href="#5-Embedding-the-Config-Server" class="headerlink" title="5. Embedding the Config Server"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_embedding_the_config_server">5. Embedding the Config Server</a></h2><p>配置服务最好以独立应用运行。但是，如果你需要，你也可以将其嵌入到另一个应用中。使用 <code>@EnableConfigServer</code> 注解，一个可选的属性 <code>spring.cloud.config.server.bootstrap</code> 在这种情况下是有用的。这是一个标记，指示该服务是否应该从它自己的远程存储库配置自己。默认地，该标记是关闭的，因为它可以延迟启动。但是，当嵌入另一个应用中时，将与任何其他应用程序以一样的方式启动是有意义的。将 <code>spring.cloud.config.server.bootstrap</code> 设置为 <code>true</code> 时，还必须使用符合环境存储库配置。</p>
<h2 id="6-Push-Notifications-and-Spring-Cloud-Bus"><a href="#6-Push-Notifications-and-Spring-Cloud-Bus" class="headerlink" title="6. Push Notifications and Spring Cloud Bus"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_push_notifications_and_spring_cloud_bus">6. Push Notifications and Spring Cloud Bus</a></h2><p>许多源代码存储库提供者（如 Github，Gitlab，Gitea, Gitee, Gogs, 或者 Bitbucket）通过 webhook 通知你存储库中的更改。你可以通过提供者的用户接口以一个 URL 和一组你感兴趣的事件配置 webhook。如果你添加了 <code>spring-cloud-config-monitor</code> 依赖，并且在你的配置中心激活了 Spring Cloud Bus，那么 <code>/monitor</code> 端点会被启用。</p>
<p>当 webhook 被激活时，配置服务会针对它认为可能已经更改的应用程序发送 <code>RefreshRemoteApplicationEvent</code> 。变更检测是策略化的。但是，默认地，它会寻找与应用程序名称匹配的文件中地变更。</p>
<h2 id="7-Spring-Cloud-Config-Client"><a href="#7-Spring-Cloud-Config-Client" class="headerlink" title="7. Spring Cloud Config Client"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_spring_cloud_config_client">7. Spring Cloud Config Client</a></h2><p>Spring Boot 应用可以立即使用 Spring Config 服务。</p>
<h3 id="7-1-Config-First-Bootstrap"><a href="#7-1-Config-First-Bootstrap" class="headerlink" title="7.1. Config First Bootstrap"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#config-first-bootstrap">7.1. Config First Bootstrap</a></h3><p>类路径上拥有 Spring Cloud Config Client 的应用程序，默认的行为是：当配置客户端启动时，它会绑定到 Config Server（通过 <code>spring.cloud.config.uri</code> 引导配置属性），并使用远程属性源初始化 Spring 的 <code>Environment</code>。</p>
<p>此行为的最终结果是，所有希望消费 Config Server 的客户端需要一个 <code>bootstrap.yml</code>，其中需要在 <code>spring.cloud.config.uri</code> 中配置好服务地址（默认是 <code>http://localhost:8888</code>）。</p>
<h3 id="7-2-Discovery-First-Bootstrap"><a href="#7-2-Discovery-First-Bootstrap" class="headerlink" title="7.2. Discovery First Bootstrap"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#discovery-first-bootstrap">7.2. Discovery First Bootstrap</a></h3><h3 id="7-3-Config-Client-Fail-Fast"><a href="#7-3-Config-Client-Fail-Fast" class="headerlink" title="7.3. Config Client Fail Fast"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#config-client-fail-fast">7.3. Config Client Fail Fast</a></h3><h3 id="7-4-Config-Client-Retry"><a href="#7-4-Config-Client-Retry" class="headerlink" title="7.4. Config Client Retry"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#config-client-retry">7.4. Config Client Retry</a></h3><h3 id="7-5-Locating-Remote-Configuration-Resources"><a href="#7-5-Locating-Remote-Configuration-Resources" class="headerlink" title="7.5. Locating Remote Configuration Resources"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_locating_remote_configuration_resources">7.5. Locating Remote Configuration Resources</a></h3><p>Config Service 从 <code>/&#123;application&#125;/&#123;profile&#125;/&#123;label&#125;</code> 供应属性源，在客户端应用中<strong>默认</strong>的绑定如下：</p>
<ul>
<li>“application”&#x3D;<code>$&#123;spring.application.name&#125;</code></li>
<li>“profile”&#x3D;<code>$&#123;spring.profiles.active&#125;</code></li>
<li>“label”&#x3D;”master”</li>
</ul>
<p>你可以通过设置 <code>spring.cloud.config.*</code> 来覆盖它们（此处 <code>*</code> 表示 <code>name</code>, <code>profile</code>, <code>label</code>）。</p>
<p><code>label</code> 对于回滚到之前的配置版本比较有用，使用默认的 Config Server 实现，它可以是 git label，分支名，commit ID。</p>
<p><code>label</code> 也可以用逗号分隔的列表表示，在这种情况下，列表中的项目会逐个尝试，直至成功（即只有一个有效）。当工作在功能分支上时，此行为可能比较有用，例如，你可能希望将 <code>label</code> 与你的分支对齐，但使其可选，在这种情况下，你可以使用 <code>spring.cloud.config.label=myfeature,develop</code>。</p>
<h3 id="7-6-Specifying-Multiple-Urls-for-the-Config-Server"><a href="#7-6-Specifying-Multiple-Urls-for-the-Config-Server" class="headerlink" title="7.6. Specifying Multiple Urls for the Config Server"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_specifying_multiple_urls_for_the_config_server">7.6. Specifying Multiple Urls for the Config Server</a></h3><h3 id="7-7-Configuring-Timeouts"><a href="#7-7-Configuring-Timeouts" class="headerlink" title="7.7. Configuring Timeouts"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_configuring_timeouts">7.7. Configuring Timeouts</a></h3><p>配置超时阈值：</p>
<ul>
<li>读取超时：<code>spring.cloud.config.request-read-timeout</code></li>
<li>连接超时：<code>spring.cloud.config.request-connect-timeout</code></li>
</ul>
<h3 id="7-8-Security"><a href="#7-8-Security" class="headerlink" title="7.8. Security"></a><a href="https://docs.spring.io/spring-cloud-config/docs/2.2.8.RELEASE/reference/html/#_security_2">7.8. Security</a></h3><p>如果你使用 HTTP Basic 安全验证，客户端需要知晓密码（如果不是默认的，还需要用户名）。你可以通过配置服务的 URI 指定用户名和密码，或者通过 <code>username</code> 和 <code>password</code> 属性：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">     <span class="attr">uri:</span> <span class="string">https://user:secret@myconfig.mycompany.com</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">     <span class="attr">uri:</span> <span class="string">https://myconfig.mycompany.com</span></span><br><span class="line">     <span class="attr">username:</span> <span class="string">user</span></span><br><span class="line">     <span class="attr">password:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>spring.cloud.config.username</code> 和 <code>spring.cloud.config.password</code> 会覆盖 URI 里的值</p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud Netflix</title>
    <url>/2022/07/12/Spring-Cloud/Spring-Cloud-Netflix/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/">Spring Cloud Netflix</a></h1><h2 id="1-Service-Discovery-Eureka-Clients"><a href="#1-Service-Discovery-Eureka-Clients" class="headerlink" title="1. Service Discovery: Eureka Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#service-discovery-eureka-clients">1. Service Discovery: Eureka Clients</a></h2><p>服务发现是微服务架构的关键原则之一。手工配置每个客户端或基于某种约定是非常脆弱的。Eureka 是 Netflix 服务发现服务端和客户端。服务可以被配置和部署，变得高可用，每个服务都会复制其他已经注册服务的状态。</p>
<h3 id="1-1-How-to-Include-Eureka-Client"><a href="#1-1-How-to-Include-Eureka-Client" class="headerlink" title="1.1. How to Include Eureka Client"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-eureka-client-starter">1.1. How to Include Eureka Client</a></h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-Registering-with-Eureka"><a href="#1-2-Registering-with-Eureka" class="headerlink" title="1.2. Registering with Eureka"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#registering-with-eureka">1.2. Registering with Eureka</a></h3><p>当 Eureka Client 注册 Eureka Server 时，它会提供自己的元数据，比如：主机，端口，健康指示器 URL，主页等详细信息。Eureka Server 接收属于某个服务的每个实例的心跳消息。如果心跳在可配置的时间表上失败，则通常从注册表中删除实例。</p>
<p>以下实例展示了最小的 Eureka Client 应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">home</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(Application.class).web(<span class="literal">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>请注意，前面的示例展示了一个普通的 Spring Boot 应用。通过包含 <code>spring-cloud-starter-netflix-eureka-client</code> 于类路径，你的应用会自动注册到 Eureka Server。需要配置的就是定位 Eureka Server，如下示例所示：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>在前面的示例中，<code>defaultZone</code> 是一个魔术字符串备用值，它为任何没有表示首选项的客户端提供服务 URL（换句话说，这是一个有用的默认值）。</p>
<blockquote>
<p><code>defaultZone</code> 属性是大小写敏感，并且需要驼峰格式，因为 <code>serviceUrl</code> 属性是一个 <code>Map&lt;String, String&gt;</code>。因此，<code>defaultZone</code> 属性不遵循通常的 Spring Boot 蛇形约定 <code>default-zone</code>。</p>
</blockquote>
<p>默认的应用名（即，服务 ID），虚拟机主机名，以及非安全端口（从 <code>Environment</code> 中获取）分别是 <code>$&#123;spring.application.name&#125;</code>，<code>$&#123;spring.application.name&#125;</code>，以及 <code>$&#123;server.port&#125;</code>。</p>
<h3 id="1-3-Authenticating-with-the-Eureka-Server"><a href="#1-3-Authenticating-with-the-Eureka-Server" class="headerlink" title="1.3. Authenticating with the Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#authenticating-with-the-eureka-server">1.3. Authenticating with the Eureka Server</a></h3><p>如果 eureka.client.serviceUrl.defaultZone 之一有凭证嵌入其中，则会自动把 HTTP basic 认证添加到 eureka 客户端。</p>
<p><strong>注意</strong> 这里并不是给 URL 添加凭证，只是激活 HTTP basic 用于请求的认证。</p>
<h3 id="1-4-Status-Page-and-Health-Indicator"><a href="#1-4-Status-Page-and-Health-Indicator" class="headerlink" title="1.4. Status Page and Health Indicator"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#status-page-and-health-indicator">1.4. Status Page and Health Indicator</a></h3><h3 id="1-5-Registering-a-Secure-Application"><a href="#1-5-Registering-a-Secure-Application" class="headerlink" title="1.5. Registering a Secure Application"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#registering-a-secure-application">1.5. Registering a Secure Application</a></h3><p>如果你的应用希望通过 HTTPS 连接，你可以在 <code>EurekaInstanceConfig</code> 设置两个标记：</p>
<ul>
<li><code>eureka.instance.[nonSecurePortEnabled]=[false]</code></li>
<li><code>eureka.instance.[securePortEnabled]=[true]</code></li>
</ul>
<h3 id="1-6-Eureka’s-Health-Checks"><a href="#1-6-Eureka’s-Health-Checks" class="headerlink" title="1.6. Eureka’s Health Checks"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#eurekas-health-checks">1.6. Eureka’s Health Checks</a></h3><h3 id="1-7-Eureka-Metadata-for-Instances-and-Clients"><a href="#1-7-Eureka-Metadata-for-Instances-and-Clients" class="headerlink" title="1.7. Eureka Metadata for Instances and Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#eureka-metadata-for-instances-and-clients">1.7. Eureka Metadata for Instances and Clients</a></h3><h4 id="1-7-1-Using-Eureka-on-Cloud-Foundry"><a href="#1-7-1-Using-Eureka-on-Cloud-Foundry" class="headerlink" title="1.7.1. Using Eureka on Cloud Foundry"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-eureka-on-cloud-foundry">1.7.1. Using Eureka on Cloud Foundry</a></h4><h4 id="1-7-2-Using-Eureka-on-AWS"><a href="#1-7-2-Using-Eureka-on-AWS" class="headerlink" title="1.7.2. Using Eureka on AWS"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-eureka-on-aws">1.7.2. Using Eureka on AWS</a></h4><p>如果你计划将应用程序部署到 AWS 云上，则必须将 Eureka 实例配置为 AWS-aware。你可以通过自定义 <code>EurekaInstanceConfigBean</code> 来做到这一点，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&quot;!default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> EurekaInstanceConfigBean <span class="title function_">eurekaInstanceConfig</span><span class="params">(InetUtils inetUtils)</span> &#123;</span><br><span class="line">  <span class="type">EurekaInstanceConfigBean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EurekaInstanceConfigBean</span>(inetUtils);</span><br><span class="line">  <span class="type">AmazonInfo</span> <span class="variable">info</span> <span class="operator">=</span> AmazonInfo.Builder.newBuilder().autoBuild(<span class="string">&quot;eureka&quot;</span>);</span><br><span class="line">  b.setDataCenterInfo(info);</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-3-Changing-the-Eureka-Instance-ID"><a href="#1-7-3-Changing-the-Eureka-Instance-ID" class="headerlink" title="1.7.3. Changing the Eureka Instance ID"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#changing-the-eureka-instance-id">1.7.3. Changing the Eureka Instance ID</a></h3><p>一般地，NetFlix Eureka 实例以 host name 注册为其主机名。Spring Cloud Eureka 提供了一个明确的默认值：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$&#123;spring.cloud.client.hostname&#125;:$&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>例如：<code>myhost:myappname:8080</code></p>
<p>在 Spring Cloud 中，你可以通过提供唯一标识符 <code>eureka.instance.instanceId</code> 来覆盖该值：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instanceId:</span> <span class="string">$&#123;spring.application.name&#125;:$&#123;vcap.application.instance_id:$&#123;spring.application.instance_id:$&#123;random.value&#125;&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-Using-the-EurekaClient"><a href="#1-8-Using-the-EurekaClient" class="headerlink" title="1.8. Using the EurekaClient"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-the-eurekaclient">1.8. Using the EurekaClient</a></h3><p>一旦你拥有一个发现客户端的应用程序，你可以使用它从 Eureka Server 发现服务实例。这样做的一种方法是使用本地 <code>com.netflix.discovery.EurekaClient</code></p>
<h2 id="1-9-Alternatives-to-the-Native-Netflix-EurekaClient"><a href="#1-9-Alternatives-to-the-Native-Netflix-EurekaClient" class="headerlink" title="1.9. Alternatives to the Native Netflix EurekaClient"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#alternatives-to-the-native-netflix-eurekaclient">1.9. Alternatives to the Native Netflix EurekaClient</a></h2><p>你无需使用原生的 NetFlix 的 <code>EurekaClient</code>。而且，在某种形式的包装之后通常会更容易使用它。通过逻辑 eureka 服务标识符（VIPs）而不是物理 URL，Spring Cloud 支持 Feign（一个 REST 客户端构建器）以及 Spring RestTemplate。</p>
<h2 id="1-10-Why-Is-It-so-Slow-to-Register-a-Service"><a href="#1-10-Why-Is-It-so-Slow-to-Register-a-Service" class="headerlink" title="1.10. Why Is It so Slow to Register a Service?"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#why-is-it-so-slow-to-register-a-service">1.10. Why Is It so Slow to Register a Service?</a></h2><p>作为一个实例，还涉及到向注册中心（通过 client 的 serviceUrl）的定期心跳，默认时间为 30 秒。一个服务，直到该实例，注册中心，客户端缓存中都有相同的元数据（因此需要 3 个心跳），客户端才能发现其不可用。你可以通过设置 <code>eureka.instance.leaseRenewalIntervalInSeconds</code> 来更改周期。将其设置为小于 30 的值，可以加快客户端连接到其他服务的进程。在生产中，由于注册中心的内部计算对租赁续期做了假设，因此最好坚持使用默认值。</p>
<h1 id="2-Service-Discovery-Eureka-Server"><a href="#2-Service-Discovery-Eureka-Server" class="headerlink" title="2. Service Discovery: Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server">2. Service Discovery: Eureka Server</a></h1><p><a href="https://gitee.com/jiang_chun_bo/cannedbread-parent/tree/master/cannedbread-eureka-server">参考配置</a></p>
<h2 id="2-1-How-to-Include-Eureka-Server"><a href="#2-1-How-to-Include-Eureka-Server" class="headerlink" title="2.1. How to Include Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-eureka-server-starter">2.1. How to Include Eureka Server</a></h2><p>要在你的项目中包含 Eureka Server，请使用 group ID 为 <code>org.springframework.cloud</code> 以及 artifact ID 为 <code>spring-cloud-starter-netflix-eureka-server</code> 的 starter。参见 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</a></p>
<h2 id="2-2-How-to-Run-a-Eureka-Server"><a href="#2-2-How-to-Run-a-Eureka-Server" class="headerlink" title="2.2. How to Run a Eureka Server"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-running-eureka-server">2.2. How to Run a Eureka Server</a></h2><p>服务端有一个主页和 HTTP API （在 &#x2F;eureka&#x2F;* 下）。</p>
<p>&amp;nbsp;</p>
<h2 id="2-3-High-Availability-Zones-and-Regions"><a href="#2-3-High-Availability-Zones-and-Regions" class="headerlink" title="2.3. High Availability, Zones and Regions"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-zones-and-regions">2.3. High Availability, Zones and Regions</a></h2><p>Eureka 服务端并没有后端存储，但是注册表中的服务实例都必须发送心跳，来保持它们的注册最新（这可以在内存中完成）。客户端还有一个内存中的 Eureka 注册缓存，因此对于每个服务的请求，不必跳转到注册表。</p>
<p>默认情况下，每个 Eureka 服务端也是 Eureka 客户端，至少需要一个服务 URL 来定位对等体。如果没有提供服务 URL，服务跑起来并开始工作，就会填充大量的噪音到日志中（无法与对等体注册的异常）。</p>
<p>&amp;nbsp;</p>
<h2 id="2-4-Standalone-Mode"><a href="#2-4-Standalone-Mode" class="headerlink" title="2.4. Standalone Mode"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-standalone-mode">2.4. Standalone Mode</a></h2><p>双缓存和心跳机制，两者组合可以让独立 Eureka Server 对于失败具有相当的弹性，只要有某种监视器或者弹性的运行时间保持存活。在独立模式下，你可能更希望关闭客户端行为，避免不断尝试并无法达到对等体的错误。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> serviceUrl 需要指向本地实例相同的主机。</p>
<h2 id="2-5-Peer-Awareness"><a href="#2-5-Peer-Awareness" class="headerlink" title="2.5. Peer Awareness"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-peer-awareness">2.5. Peer Awareness</a></h2><p>通过运行多个实例，并让他们互相注册，eureka 可以变得更具有弹性和可用性。实际上，这是默认的行为，所以你只需要向对等体添加有效的 serviceUrl 即可。</p>
<p>为了在单个主机上体验对等感知，可以操作 <code>/etc/hosts</code> 文件来解析主机名。实际上，如果运行在一台已知主机名的机器上时，没有必要配置 <code>eureka.instance.hostname</code>。默认地，会使用 <code>java.net.InetAddress</code> 寻找。</p>
<p>你可以向一个系统添加多个对等体，只要它们通过至少边缘彼此连接，它们之间就会同步注册信息。如果对等体物理分离，那么系统原则上存在脑裂的问题。</p>
<h2 id="2-6-When-to-Prefer-IP-Address"><a href="#2-6-When-to-Prefer-IP-Address" class="headerlink" title="2.6. When to Prefer IP Address"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-eureka-server-prefer-ip-address">2.6. When to Prefer IP Address</a></h2><p>在某些情况下，eureka 更偏向于建议使用服务的 IP 而不是主机名。设置 <code>eureka.instance.preferIpAddress</code> 为 true，那么当应用注册到 eureka 时，将会使用 IP 地址而不是主机名。</p>
<blockquote>
<p>如果 Java 无法确定 hostname，那么就会发送 IP 地址给 eureka。</p>
</blockquote>
<h2 id="2-8-Disabling-Ribbon-with-Eureka-Server-and-Client-starters"><a href="#2-8-Disabling-Ribbon-with-Eureka-Server-and-Client-starters" class="headerlink" title="2.8. Disabling Ribbon with Eureka Server and Client starters"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#disabling-ribbon-with-eureka-server-and-client-starters">2.8. Disabling Ribbon with Eureka Server and Client starters</a></h2><p><code>spring-cloud-starter-netflix-eureka-server</code> 和 <code>spring-cloud-starter-netflix-eureka-client</code> y与 <code>spring-cloud-starter-netflix-ribbon</code> 一起出现。由于 Ribbon 负载均衡处于维护模式，因此我们建议切换使用 Spring Cloud LoadBalancer，也包含在 Eureka starter 中。</p>
<p>为此，你可以将 <code>spring.cloud.loadbalancer.ribbon.enabled</code> 属性设置为 <code>false</code>。</p>
<p>然后，你还可以从构建文件中地 Eureka starter 中排除 ribbon 相关的依赖，像这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.ribbon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ribbon-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-Circuit-Breaker-Spring-Cloud-Circuit-Breaker-With-Hystrix"><a href="#3-Circuit-Breaker-Spring-Cloud-Circuit-Breaker-With-Hystrix" class="headerlink" title="3. Circuit Breaker: Spring Cloud Circuit Breaker With Hystrix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#circuit-breaker-spring-cloud-circuit-breaker-with-hystrix">3. Circuit Breaker: Spring Cloud Circuit Breaker With Hystrix</a></h2><h3 id="3-1-Disabling-Spring-Cloud-Circuit-Breaker-Hystrix"><a href="#3-1-Disabling-Spring-Cloud-Circuit-Breaker-Hystrix" class="headerlink" title="3.1. Disabling Spring Cloud Circuit Breaker Hystrix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#disabling-spring-cloud-circuit-breaker-hystrix">3.1. Disabling Spring Cloud Circuit Breaker Hystrix</a></h3><p>你可以通过设置 <code>spring.cloud.circuitbreaker.hystrix.enabled</code> 为 <code>false</code> 来禁用自动配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.cloud.circuitbreaker.hystrix.enabled=<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-Configuring-Hystrix-Circuit-Breakers"><a href="#3-2-Configuring-Hystrix-Circuit-Breakers" class="headerlink" title="3.2. Configuring Hystrix Circuit Breakers"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#configuring-hystrix-circuit-breakers">3.2. Configuring Hystrix Circuit Breakers</a></h3><h4 id="3-2-1-Default-Configuration"><a href="#3-2-1-Default-Configuration" class="headerlink" title="3.2.1. Default Configuration"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#default-configuration">3.2.1. Default Configuration</a></h4><p>为了给您所有的断路器提供默认配置，请创建传递一个 <code>HystrixCircuitBreakerFactory</code> 或者 <code>ReactiveHystrixCircuitBreakerFactory</code> 的 <code>Customize</code> Bean。<code>configureDefault</code> 方法可用于提供默认配置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;HystrixCircuitBreakerFactory&gt; <span class="title function_">defaultConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configureDefault(id -&gt; HystrixCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))</span><br><span class="line">            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">            .withExecutionTimeoutInMilliseconds(<span class="number">4000</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Reactive-Example"><a href="#Reactive-Example" class="headerlink" title="Reactive Example"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#reactive-example">Reactive Example</a></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;ReactiveHystrixCircuitBreakerFactory&gt; <span class="title function_">defaultConfig</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configureDefault(id -&gt; HystrixObservableCommand.Setter</span><br><span class="line">            .withGroupKey(HystrixCommandGroupKey.Factory.asKey(id))</span><br><span class="line">            .andCommandPropertiesDefaults(HystrixCommandProperties.Setter()</span><br><span class="line">                    .withExecutionTimeoutInMilliseconds(<span class="number">4000</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-Specific-Circuit-Breaker-Configuration"><a href="#3-2-2-Specific-Circuit-Breaker-Configuration" class="headerlink" title="3.2.2. Specific Circuit Breaker Configuration"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#specific-circuit-breaker-configuration">3.2.2. Specific Circuit Breaker Configuration</a></h4><p>类似于提供默认配置，您可以传递一个 <code>HystrixCircuitBreakerFactory</code> 创建一个 <code>Customize</code> Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;HystrixCircuitBreakerFactory&gt; <span class="title function_">customizer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configure(builder -&gt; builder.commandProperties(</span><br><span class="line">                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(<span class="number">2000</span>)), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Reactive-Example-1"><a href="#Reactive-Example-1" class="headerlink" title="Reactive Example"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#reactive-example-2">Reactive Example</a></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Customizer&lt;ReactiveHystrixCircuitBreakerFactory&gt; <span class="title function_">customizer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> factory -&gt; factory.configure(builder -&gt; builder.commandProperties(</span><br><span class="line">                    HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(<span class="number">2000</span>)), <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Circuit-Breaker-Hystrix-Clients"><a href="#4-Circuit-Breaker-Hystrix-Clients" class="headerlink" title="4. Circuit Breaker: Hystrix Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#circuit-breaker-hystrix-clients">4. Circuit Breaker: Hystrix Clients</a></h2><p>Netflix 已经创建了一个名为 Hystrix 的库，该库实现了 <a href="https://martinfowler.com/bliki/CircuitBreaker.html">circuit breaker pattern</a>（熔断器模式）。在微服务体系结构中，通常具有多层服务调用，如下示例所示：</p>
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/main/docs/src/main/asciidoc/images/Hystrix.png">

<p><strong>Figure 1. Microservice Graph</strong></p>
<p>较低级别的服务失败可能导致级联失败，直至用户。当对特定服务调用超过 <code>circuitBreaker.requestVolumeThreshold</code>（默认是 20 次请求），并且，在一个由 <code>metrics.rollingStats.timeInMilliseconds</code> 定义滑动窗口（默认为 10 秒）内，失败百分比大于 <code>circuitBreaker.errorThresholdPercentage</code>（默认 &gt;50%）， 熔断器会打开，并且不进行调用。在出错并且熔断器打开的情况下，开发者可以提供一个 fallback。</p>
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-netflix/main/docs/src/main/asciidoc/images/HystrixFallback.png">

<p><strong>Figure 2. Hystrix fallback prevents cascading failures</strong></p>
<h2 id="4-1-How-to-Include-Hystrix"><a href="#4-1-How-to-Include-Hystrix" class="headerlink" title="4.1. How to Include Hystrix"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#how-to-include-hystrix">4.1. How to Include Hystrix</a></h2><p>若要在你的项目中包含 Hystrix，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-netflix-hystrix</code> 的 starter。</p>
<p>下面示例展示了一个极简的带有 Hystrix 熔断器的 Eureka 服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>(Application.class).web(<span class="literal">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoreIntegration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;defaultStores&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getStores</span><span class="params">(Map&lt;String, Object&gt; parameters)</span> &#123;</span><br><span class="line">        <span class="comment">//do stuff that might fail</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">defaultStores</span><span class="params">(Map&lt;String, Object&gt; parameters)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">/* something useful */</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>@HystrixCommand</code> 由名为 <a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica">“javanica”</a> 的 Netflix contrib 库提供。Spring Cloud 以代理的方式包装具有该注解的 Spring Bean，用于连接到 Hystrix 熔断器。熔断器计算何时打开和关闭回路，以及在失败的情况下做什么。</p>
<p>要配置 <code>@HystrixCommand</code>，你可以以 <code>@HystrixProperty</code> 注解列表的形式使用 <code>commandProperties</code> 属性。有关更多详情，请参见<a href="https://github.com/Netflix/Hystrix/tree/master/hystrix-contrib/hystrix-javanica#configuration">此处</a>。有关可用属性的详细信息，参见 <a href="https://github.com/Netflix/Hystrix/wiki/Configuration">Hystrix wiki</a></p>
<h2 id="4-2-Propagating-the-Security-Context-or-Using-Spring-Scopes"><a href="#4-2-Propagating-the-Security-Context-or-Using-Spring-Scopes" class="headerlink" title="4.2. Propagating the Security Context or Using Spring Scopes"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-hystrix-starter">4.2. Propagating the Security Context or Using Spring Scopes</a></h2><p>如果你希望一些线程的本地上下文传播到 <code>@HystrixCommand</code>，默认声明并不起作用，因为它在线程池中执行命令（在超时情况下）。你可以通过配置或者直接在注解上，请求 Hystrix 使用不同的 “Isolation Strategy”，切换 Hystrix 使用相同的线程作为调用者。以下示例演示了在注解中设置线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;stubMyService&quot;,</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;</span></span><br><span class="line"><span class="meta">      @HystrixProperty(name=&quot;execution.isolation.strategy&quot;, value=&quot;SEMAPHORE&quot;)</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Health-Indicator"><a href="#4-3-Health-Indicator" class="headerlink" title="4.3. Health Indicator"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#health-indicator">4.3. Health Indicator</a></h3><p>连接熔断器的状态也可以暴露在调用应用的 <code>/health</code> 端点上，如下示例所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hystrix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;openCircuitBreakers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;StoreIntegration::getStoresByLocationLink&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CIRCUIT_OPEN&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-Hystrix-Metrics-Stream"><a href="#4-4-Hystrix-Metrics-Stream" class="headerlink" title="4.4. Hystrix Metrics Stream"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#hystrix-metrics-stream">4.4. Hystrix Metrics Stream</a></h3><p>若要启动 Hystrix metrics stream，请包含关于 <code>spring-boot-starter-actuator</code> 的依赖，并设置 <code>management.endpoints.web.exposure.include=hystrix.stream</code>。这样做会暴露 <code>/actuator/hystrix.stream</code> 作为管理端点，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-Circuit-Breaker-Hystrix-Dashboard"><a href="#5-Circuit-Breaker-Hystrix-Dashboard" class="headerlink" title="5. Circuit Breaker: Hystrix Dashboard"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#circuit-breaker-hystrix-dashboard">5. Circuit Breaker: Hystrix Dashboard</a></h2><p>只需要引入以下依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置类添加以下注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure>


<h2 id="6-Hystrix-Timeouts-And-Ribbon-Clients"><a href="#6-Hystrix-Timeouts-And-Ribbon-Clients" class="headerlink" title="6. Hystrix Timeouts And Ribbon Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#hystrix-timeouts-and-ribbon-clients">6. Hystrix Timeouts And Ribbon Clients</a></h2><p>当使用 Hystrix command 包装你希望的 Ribbon 客户端时，确保你的 Hystrix 配置的 timeout 比 Ribbon 配置的 timeout 更长，包括任何可能的重试。例如，如果你的 Ribbon 连接 timeout 是 1 秒，并且 Ribbon 客户端可能重试请求 3 次，那么你的 Hystrix 超时时间应该略高于 3 秒。</p>
<blockquote>
<p><strong>作者的话</strong> 如果上述示例配置低于 3 秒，那么 Ribbon 可能还未完成 3 次重试就已经结束，并不满足配置预期。</p>
</blockquote>
<h3 id="6-1-How-to-Include-the-Hystrix-Dashboard"><a href="#6-1-How-to-Include-the-Hystrix-Dashboard" class="headerlink" title="6.1. How to Include the Hystrix Dashboard"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.10.RELEASE/reference/html/#netflix-hystrix-dashboard-starter">6.1. How to Include the Hystrix Dashboard</a></h3><p>若要在你的项目包含 Hystrix Dashboard，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-netflix-hystrix-dashboard</code> 的 starter。</p>
<p>若要运行 Hystrix Dashboard，请使用 <code>@EnableHystrixDashboard</code> 注解你的 Spring Boot 主类。然后访问 <code>/hystrix</code>，并将 dashboard 指向一个实例在 Hystrix 客户端应用中的 <code>/hystrix.stream</code> 端点。</p>
<h2 id="7-Client-Side-Load-Balancer-Ribbon"><a href="#7-Client-Side-Load-Balancer-Ribbon" class="headerlink" title="7. Client Side Load Balancer: Ribbon"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-ribbon">7. Client Side Load Balancer: Ribbon</a></h2><p>Ribbon 是一个客户端的负载均衡，可以对 HTTP 和 TCP 客户端行为进行大量控制。Feign 已经使用了 Ribbon，因此，如果你使用 <code>@FeignClient</code>，这部分也会使用。</p>
<blockquote>
<p>Ribbon 是一个进程内 LB</p>
</blockquote>
<p>Ribbon 的核心概念是有名客户端。每个负载均衡器都是组件集合的一部分，组件们在一起工作，按需要连接到远程服务器，并且整体有一个名字，这是你作为开发者赋予的名字。根据需要，Spring Cloud 通过使用 <code>RibbonClientConfiguration</code> 以 <code>ApplicationContext</code> 为每个有名客户端创建一个新的整体。这包含一个 <code>ILoadBalancer</code>，一个 <code>RestClient</code>，以及一个 <code>ServerListFiter</code>。</p>
<h3 id="7-1-How-to-Include-Ribbon"><a href="#7-1-How-to-Include-Ribbon" class="headerlink" title="7.1. How to Include Ribbon"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#netflix-ribbon-starter">7.1. How to Include Ribbon</a></h3><p>要在你的项目使用 ribbon，请使用 group ID 为 <code>org.springframework.cloud</code>，artifact ID 为 <code>spring-cloud-starter-netflix-ribbon</code> 的 starter。有关使用当前 Spring Cloud Release Train 设置你的构建系统详情见 <a href="https://projects.spring.io/spring-cloud/">Spring Cloud Project page</a></p>
<blockquote>
<p>如果你依赖了 eureka，则 ribbon 也会同时引入，无需显式引入</p>
</blockquote>
<h3 id="7-2-Customizing-the-Ribbon-Client"><a href="#7-2-Customizing-the-Ribbon-Client" class="headerlink" title="7.2. Customizing the Ribbon Client"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#customizing-the-ribbon-client">7.2. Customizing the Ribbon Client</a></h3><p>你可以通过使用 <code>&lt;client&gt;.ribbon.*</code> 之中的外部属性配置 Ribbon 客户端的一些部分，这类似于使用原生的 Netflix API，但你可以使用 Spring Boot 配置文件。原生选项可以在 <a href="https://github.com/Netflix/ribbon/blob/master/ribbon-core/src/main/java/com/netflix/client/config/CommonClientConfigKey.java"><code>CommonClientConfigKey</code></a>  （ribbon-core 的一部分）以静态字段查看。</p>
<p>Spring Cloud 还让你通过使用 <code>@RibbonClient</code> 声明额外配置（除了 <code>RibbonClientConfiguration</code>）来完全控制客户端，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;custom&quot;, configuration = CustomConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个案例中，客户端由已经存在于 <code>RibbonClientConfiguration</code> 的组件，以及在 <code>CustomConfiguration</code> （后者通常覆盖前者）中的一些组成。</p>
<blockquote>
<p><code>CustomConfiguration</code> 类必须是 <code>@Configuration</code> 类，但是注意，不要放在主应用上下文的 <code>@ComponentScan</code> 中。否则，它将被所有的 <code>@RibbonClients</code> 共享。如果你使用 <code>@ComponentScan</code>（或者 <code>@SpringBootApplication</code>），你需要采取一些方法以避免将其包括在内（例如，你可以将其放入分开的，不重叠的包中，或者在 <code>@ComponentScan</code> 中指定要明确扫描的包）。</p>
</blockquote>
<h3 id="7-3-Customizing-the-Default-for-All-Ribbon-Clients"><a href="#7-3-Customizing-the-Default-for-All-Ribbon-Clients" class="headerlink" title="7.3. Customizing the Default for All Ribbon Clients"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#customizing-the-default-for-all-ribbon-clients">7.3. Customizing the Default for All Ribbon Clients</a></h3><p>可以通过使用 <code>@RibbonClients</code> 注解，注册一个默认的配置，为所有的 Ribbon 客户端提供默认配置，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonClientDefaultConfigurationTestsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BazServiceList</span> <span class="keyword">extends</span> <span class="title class_">ConfigurationBasedServerList</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">BazServiceList</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.initWithNiwsConfig(config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultRibbonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">ribbonRule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BestAvailableRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IPing <span class="title function_">ribbonPing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PingUrl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerList&lt;Server&gt; <span class="title function_">ribbonServerList</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RibbonClientDefaultConfigurationTestsConfig</span>.BazServiceList(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServerListSubsetFilter <span class="title function_">serverListFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServerListSubsetFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerListSubsetFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-Customizing-the-Ribbon-Client-by-Setting-Properties"><a href="#7-4-Customizing-the-Ribbon-Client-by-Setting-Properties" class="headerlink" title="7.4. Customizing the Ribbon Client by Setting Properties"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#customizing-the-ribbon-client-by-setting-properties">7.4. Customizing the Ribbon Client by Setting Properties</a></h3><p>从 1.2.0 开始，Spring Cloud Netflix 现在支持通过设置兼容 <a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers#components-of-load-balancer">Ribbon documentation</a> 属性来定制化 Ribbon 客户端。</p>
<p>这使你可以在不同环境中更改启动时行为。</p>
<p>下面的列表展示了支持的属性：</p>
<ul>
<li><code>&lt;clientName&gt;.ribbon.NFLoadBalancerClassName</code>：应该实现了 <code>ILoadBalancer</code></li>
<li><code>&lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName</code>：应该实现了 <code>IRule</code></li>
<li><code>&lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName</code>：应该实现了 <code>IPing</code></li>
<li><code>&lt;clientName&gt;.ribbon.NIWSServerListClassName</code>：应该实现了 <code>ServerList</code></li>
<li><code>&lt;clientName&gt;.ribbon.NIWSServerListFilterClassName</code>：应该实现了 <code>ServerListFilter</code></li>
</ul>
<blockquote>
<p>这些属性中定义的类，相较于使用 <code>@RibbonClient(configuration=MyRibbonConfig.class)</code> 定义的 Bean，以及由 Spring Cloud Netflix 提供的默认值，具有更高优先级</p>
</blockquote>
<p>要设置名为 <code>users</code> 的服务名的 <code>IRule</code></p>
<h3 id="7-6-Example-How-to-Use-Ribbon-Without-Eureka"><a href="#7-6-Example-How-to-Use-Ribbon-Without-Eureka" class="headerlink" title="7.6. Example: How to Use Ribbon Without Eureka"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#spring-cloud-ribbon-without-eureka">7.6. Example: How to Use Ribbon Without Eureka</a></h3><p>Eureka 是一种便捷的方式，它抽象化远程服务的发现，因此你不必在客户端中进行硬编码。但是，如果你不想使用 Eureka，Ribbon 和 Feign 也可以工作。假设你已经声明了 “stores” 的 <code>@RibbonClient</code>，并且 Eureka 没有使用（甚至不在类路径）。Ribbon 客户端默认到配置好的服务列表。你可以按如下方式提供配置：</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stores:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">listOfServers:</span> <span class="string">example.com,google.com</span></span><br></pre></td></tr></table></figure>

<h3 id="7-7-Example-Disable-Eureka-Use-in-Ribbon"><a href="#7-7-Example-Disable-Eureka-Use-in-Ribbon" class="headerlink" title="7.7. Example: Disable Eureka Use in Ribbon"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#example-disable-eureka-use-in-ribbon">7.7. Example: Disable Eureka Use in Ribbon</a></h3><p>将 <code>ribbon.eureka.enabled</code> 属性设置为 <code>false</code>，显式地禁用 Ribbon 中 Eureka 的使用，如下示例所示：</p>
<p><strong>application.yml</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eureka:</span></span><br><span class="line">   <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>


<h3 id="7-8-Using-the-Ribbon-API-Directly"><a href="#7-8-Using-the-Ribbon-API-Directly" class="headerlink" title="7.8. Using the Ribbon API Directly"></a><a href="https://docs.spring.io/spring-cloud-netflix/docs/2.2.9.RELEASE/reference/html/#using-the-ribbon-api-directly">7.8. Using the Ribbon API Directly</a></h3><p>你也可以直接使用 <code>LoadBalanceClient</code>，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStuff</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> loadBalancer.choose(<span class="string">&quot;stores&quot;</span>);</span><br><span class="line">        <span class="type">URI</span> <span class="variable">storesUri</span> <span class="operator">=</span> URI.create(String.format(<span class="string">&quot;https://%s:%s&quot;</span>, instance.getHost(), instance.getPort()));</span><br><span class="line">        <span class="comment">// ... do something with the URI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Netflix</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 官方文档翻译笔记</title>
    <url>/2022/07/15/MyBatis/MyBatis-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a><a href="https://mybatis.org/mybatis-3/">MyBatis</a></h1><hr>
<h2 id="1-Getting-started"><a href="#1-Getting-started" class="headerlink" title="1. Getting started"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Getting_started">1. Getting started</a></h2><h3 id="1-1-Installation"><a href="#1-1-Installation" class="headerlink" title="1.1. Installation"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Installation">1.1. Installation</a></h3><p>进行最基本的 MyBatis 应用开发需要导入的依赖，最新版本可以参考<a href="https://github.com/mybatis/mybatis-3/releases">github</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-2-Building-SqlSessionFactory-from-XML"><a href="#1-2-Building-SqlSessionFactory-from-XML" class="headerlink" title="1.2. Building SqlSessionFactory from XML"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Building_SqlSessionFactory_from_XML">1.2. Building SqlSessionFactory from XML</a></h3><p>从 XML 构建 SqlSessionFactory。所有 mybatis 应用程序围绕 <code>SqlSessionFactory</code> 实例。可以通过 <code>SqlSessionFactoryBuilder</code> 获取到 <code>SqlSessionFactory</code> 实例。<code>SqlSessionFactoryBuilder</code> 可以从以下几个来源进行构建：</p>
<ul>
<li>Mybatis configuration xml</li>
<li>Configuration object</li>
</ul>
<p>从 XML 文件构建 <code>SqlSessionFactory</code> 实例，建议使用<strong>类路径资源</strong>，但实际上也可以使用 InputStream。</p>
<p><strong>mybatis-config.xml</strong> 可以参考<a href="https://mybatis.org/mybatis-3/getting-started.html">官网</a></p>
<h3 id="1-3-Building-SqlSessionFactory-without-XML"><a href="#1-3-Building-SqlSessionFactory-without-XML" class="headerlink" title="1.3. Building SqlSessionFactory without XML"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Building_SqlSessionFactory_without_XML">1.3. Building SqlSessionFactory without XML</a></h3><p>可以参考官网的案例。但是，并不支持这种做法，因为高级映射仍然需要 XML 的支持。</p>
<h3 id="1-4-Acquiring-a-SqlSession-from-SqlSessionFactory"><a href="#1-4-Acquiring-a-SqlSession-from-SqlSessionFactory" class="headerlink" title="1.4. Acquiring a SqlSession from SqlSessionFactory"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Acquiring_a_SqlSession_from_SqlSessionFactory">1.4. Acquiring a SqlSession from SqlSessionFactory</a></h3><p>通过以下代码可以创建一个 Session（注意关闭）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>


<h3 id="1-5-Exploring-Mapped-SQL-Statements"><a href="#1-5-Exploring-Mapped-SQL-Statements" class="headerlink" title="1.5. Exploring Mapped SQL Statements"></a><a href="https://mybatis.org/mybatis-3/getting-started.html#Exploring_Mapped_SQL_Statements">1.5. Exploring Mapped SQL Statements</a></h3><p>语句可以由 XML 或者 Annotation 定义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述例子，在命名空间 <code>org.mybatis.example.BlogMapper</code> 中，定义了名为 <code>selectBlog</code> 的映射语句，允许你通过完全限定名称 <code>org.mybatis.example.BlogMapper.selectBlog</code> 来调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure>

<p>这与在完全限定的 Java 类上调用一个方法是非常类似的，这也是如此设计的原因。使用与映射的 select 语句在名称，参数，返回类型相匹配的方法，可以直接映射到与命名空间名称相同的 Mapper 类。这允许你简单地将方法调用在映射器接口上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BlogMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(BlogMapper.class);</span><br><span class="line"><span class="type">Blog</span> <span class="variable">blog</span> <span class="operator">=</span> mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure>
<p>第二种方法有很多优势。首先，它不依赖字符串，更安全。其次，如果你的 IDE 由代码补全，可以利用它跳转到你映射的 SQL 语句。</p>
<p><strong>Namespaces</strong><br>以前版本的 MyBatis 命名空间是可选的，现在强制需要命名空间，具有隔离语句的目的。</p>
<p>命名空间让接口进行绑定，并且，即使你现在并不认为你会使用，你也应该遵循这种实践，防止你改变想法。一旦使用命名空间，把它放到正确的 Java 包命名空间下能清理你的代码，并且长期内提高 MyBatis 的可用性</p>
<p>对于简单的语句，可以使用注解方式定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlogMapper</span> &#123;</span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">  Blog <span class="title function_">selectBlog</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过，对于复杂的语句，建议使用 XML 方式定义，否则显得混乱。</p>
</blockquote>
<h2 id="2-Configuration-XML"><a href="#2-Configuration-XML" class="headerlink" title="2. Configuration XML"></a><a href="https://mybatis.org/mybatis-3/configuration.html">2. Configuration XML</a></h2><h3 id="2-1-properties"><a href="#2-1-properties" class="headerlink" title="2.1. properties"></a><a href="https://mybatis.org/mybatis-3/configuration.html#properties">2.1. properties</a></h3><p><code>&lt;properties&gt;</code> 除了支持嵌入内置属性，还支持引入外部 Java 属性文件，只需通过 resource 或者 url 属性设置即可。resource 是以类路径为基础路径的相对路径，url 为标准的路径位置，如 file:&#x2F;&#x2F;&#x2F;。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong> </p>
<ul>
<li>resource 和 url 不可以同时设置，否则抛出异常。</li>
<li>如果配置了相同的属性，则后面的会覆盖前面的；如果是分散在属性文件和子元素属性中，那么由于属性文件后加载，因此属性文件会覆盖子元素属性。</li>
<li><code>&lt;properties&gt;</code> 标签必需位于 <code>configuration</code> 子元素第一个</li>
</ul>
<p>属性配置完，可以在配置文件中使用属性，以替代需要动态配置的值。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性的来源也可以是由程序传递给 SqlSessionFactoryBuilder.build() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, props);</span><br><span class="line"><span class="comment">// ... or ...</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>.build(reader, environment, props);</span><br></pre></td></tr></table></figure>



<h3 id="2-2-settings"><a href="#2-2-settings" class="headerlink" title="2.2. settings"></a><a href="https://mybatis.org/mybatis-3/configuration.html#settings">2.2. settings</a></h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cacheEnabled</td>
<td align="left">全局启用或禁用此配置下任何映射器中的任何缓存</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">lazyLoadingEnabled</td>
<td align="left">全局懒加载。该值可以被 <code>fetchType</code> 取代。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">aggressiveLazyLoading</td>
<td align="left">启用后，任何方法调用都会加载对象的延迟属性。否则，每个属性按需加载。具体见 <code>lazyLoadTriggerMethods</code></td>
<td align="left"></td>
<td align="left">false (true in ≤3.4.1)</td>
</tr>
<tr>
<td align="left">useColumnLabel</td>
<td align="left">使用列标签而不是列名。不同的驱动表现不同。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">mapUnderscoreToCamelCase</td>
<td align="left">下划线到驼峰转换</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">autoMappingBehavior</td>
<td align="left">是否自动映射，Spring MyBatis 默认为 PARTIAL，注意。</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">defaultExecutorType</td>
<td align="left">配置默认的执行器。SIMPLE REUSE BATCH</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">localCacheScope</td>
<td align="left">本地缓存的作用域</td>
<td align="left">SESSION | STATEMENT</td>
<td align="left">SESSION</td>
</tr>
<tr>
<td align="left">logImpl</td>
<td align="left">指定 MyBatis 应该使用的日志实现。如果未设置，则自动发现。</td>
<td align="left">SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</td>
<td align="left">Not set</td>
</tr>
</tbody></table>
<h3 id="2-3-typeAliases"><a href="#2-3-typeAliases" class="headerlink" title="2.3. typeAliases"></a><a href="https://mybatis.org/mybatis-3/configuration.html#typeAliases">2.3. typeAliases</a></h3><p>别名是 Java 类型的短名称，可以简单地减少完全限定类名的冗余输入。支持 <code>&lt;typeAlias&gt;</code> 和 <code>&lt;package&gt;</code> 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>指定 MyBatis 搜索 bean 的包，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在包中的<strong>所有 bean</strong>，都会使用 bean 的小写非限定类名作为别名。其中，<code>domain.blog.Author</code> 将被注册为 <code>author</code>。特殊地，如果发现 @Alias 注解，则其值将用作别名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有许多内置的 Java 类型的别名。它们都是大小写不敏感的。具体参见类 <code>TypeAliasRegistry</code></p>
<h3 id="2-4-typeHandlers"><a href="#2-4-typeHandlers" class="headerlink" title="2.4. typeHandlers"></a><a href="https://mybatis.org/mybatis-3/configuration.html#typeHandlers">2.4. typeHandlers</a></h3><p>typeHandler 用于两个地方：</p>
<ul>
<li>当 MyBatis 在 PreparedStatement 设置参数时。参见 <code>DefaultParameterHandler</code></li>
<li>从 ResultSet 检索值。参见 <code>DefaultResultSetHandler</code></li>
</ul>
<blockquote>
<p>自从  3.4.5, MyBatis 默认支持 JSR-310 (Date and Time API)</p>
</blockquote>
<p>在 MyBatis 中，存在一个 <code>TypeHandlerRegistry</code> 组件，其维护了一个 Map 结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>该 Map 的 key 是 <code>java.lang.reflect.Type</code> 类型对象，value 又是一个 Map（称为 sub map），通常用于传入一个 Class 对象，得到 Jdbc 类型支持的类型处理器，sub map 通常还会存储一个 key 为 null 的键值对，用于匹配默认的处理器。</p>
<blockquote>
<p>typeHandlers 几乎很少自己定义扩展，但少部分情况还是比较有效的，例如：不涉及查询的一对多关系、setString 的乱码问题。</p>
</blockquote>
<h3 id="2-5-Handling-Enums"><a href="#2-5-Handling-Enums" class="headerlink" title="2.5. Handling Enums"></a><a href="https://mybatis.org/mybatis-3/configuration.html#Handling_Enums">2.5. Handling Enums</a></h3><h3 id="2-6-objectFactory"><a href="#2-6-objectFactory" class="headerlink" title="2.6. objectFactory"></a><a href="https://mybatis.org/mybatis-3/configuration.html#objectFactory">2.6. objectFactory</a></h3><p>使用 ObjectFactory 进行创建结果对象的新实例。不仅支持无参构造器的创建，也支持有参构造器创建。</p>
<h3 id="2-7-plugins"><a href="#2-7-plugins" class="headerlink" title="2.7. plugins"></a><a href="https://mybatis.org/mybatis-3/configuration.html#plugins">2.7. plugins</a></h3><h3 id="2-8-environments"><a href="#2-8-environments" class="headerlink" title="2.8. environments"></a><a href="https://mybatis.org/mybatis-3/configuration.html#environments">2.8. environments</a></h3><p>MyBatis 可以配置多个环境。这有助于你以任何原因将 SQL 映射到不同的数据库。例如，你可能对于开发，测试和生产环境由不同的配置。或者，你可能有多个表结构相同的生产数据库，并且你希望为两者使用相同的 SQL 映射。</p>
<p><strong>注意</strong> 尽管你可以配置多个环境，但是你只可以为每个 SqlSessionFactory 选择一个。因此，如果要连接到多个数据库，则需要为每个数据库创建一个 SqlSessionFactory。</p>
<ul>
<li><strong>每个数据库一个 SqlSessionFactory 实例</strong></li>
</ul>
<p>传递给 build() 方法参数 environment 可以指定环境，否则使用 default 环境。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment, properties);</span><br></pre></td></tr></table></figure>


<p><strong>transactionManager</strong></p>
<p>MyBatis 包含了两种事务管理器，JDBC | MANAGED</p>
<p><strong>dataSource</strong></p>
<p>dataSource 元素使用标准 JDBC DataSource 接口配置 JDBC Connection 对象。</p>
<p>大多数 MyBatis 应用程序将根据示例中配置 dataSource。但是，它不是必需的。但是，要促进懒加载，数据源是需要的。</p>
<p>有三种内置的数据源类型，UNPOOLED | POOLED | JNDI</p>
<p><strong>UNPOOLED</strong> 每次请求时，数据源都是简单地打开和关闭一个链接。虽然它有点慢，但是对于不需要立即可用连接地简单应用来说，是个不错地选择。不同的数据库也不同，因此对于一些池化不太重要的数据库，该配置会是比较理想的。UNPOOLED 数据源具有以下属性需要配置：</p>
<ul>
<li><code>driver</code> </li>
<li><code>url</code></li>
<li><code>username</code></li>
<li><code>password</code></li>
<li><code>defaultTransactionIsolationLevel</code> 连接的默认事务隔离级别</li>
<li><code>defaultNetworkTimeout</code> 默认网络超时值，以等待数据库操作完成，单位毫秒</li>
</ul>
<p><strong>POOLED</strong> DataSource 池化 JDBC Connection 对象，以避免创建新连接实例所需要的初始化和认证时间。这是一种当前 web 应用中流行的方式，可以获得最快的响应。</p>
<p>除了上面的（UNPOOLED）属性之外，还有许多属性可用于配置 POOLED 数据源：</p>
<ul>
<li><code>poolMaximumActiveConnections</code></li>
<li><code>poolMaximumIdleConnections</code></li>
<li><code>poolMaximumCheckoutTime</code></li>
<li><code>poolTimeToWait</code></li>
<li><code>poolMaximumLocalBadConnectionTolerance</code></li>
<li><code>poolPingQuery</code> ping 查询被发送到数据库以验证连接处于良好的工作状态，并且已准备好接受请求。默认值：”NO PING QUERY SET”，这回引起大多数数据库驱动以错误信息产生失败。</li>
<li><code>poolPingEnabled</code> 开启或禁用 ping 查询。如果开启，你必须用一个有效的 SQL 语句（最好很快）设置 <code>poolPingQuery</code> 属性。默认：false</li>
<li><code>poolPingConnectionsNotUsedFor</code></li>
</ul>
<p><strong>JNDI</strong> 此 DataSource 的实现旨在与容器（如 EJB 或者应用服务器）一起使用，该数据源可以配置内部或外部数据源，并且在 JNDI 上下文中对其进行引用。该数据源配置只需要两个属性：</p>
<ul>
<li>initial_context</li>
<li>data_source</li>
</ul>
<h3 id="2-9-databaseIdProvider"><a href="#2-9-databaseIdProvider" class="headerlink" title="2.9. databaseIdProvider"></a><a href="https://mybatis.org/mybatis-3/configuration.html#databaseIdProvider">2.9. databaseIdProvider</a></h3><h3 id="2-10-mappers"><a href="#2-10-mappers" class="headerlink" title="2.10. mappers"></a><a href="https://mybatis.org/mybatis-3/configuration.html#mappers">2.10. mappers</a></h3><p>定义映射的 SQL 语句，首先，我们需要告诉 MyBatis 在哪里找到他们，你可以使用：</p>
<ul>
<li>类路径相对资源引用</li>
<li>完全限定 url 引用，包括 <code>file:///</code></li>
<li>类名</li>
<li>包名</li>
</ul>
<h4 id="方式1-类路径相对资源引用"><a href="#方式1-类路径相对资源引用" class="headerlink" title="方式1 类路径相对资源引用"></a>方式1 类路径相对资源引用</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式2-完全限定-url-引用"><a href="#方式2-完全限定-url-引用" class="headerlink" title="方式2 完全限定 url 引用"></a>方式2 完全限定 url 引用</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///var/mappers/AuthorMapper.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式3-类名"><a href="#方式3-类名" class="headerlink" title="方式3 类名"></a>方式3 类名</h4><p>注册的配置结构如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注册源码分析</strong></p>
<p>依靠组件 <code>MapperRegistry</code> 进行注册。不需要尝试配置两个一样的类，否则你会得到异常。</p>
<p>依靠 <code>MapperAnnotationBuilder</code> 解析注解。注解解析部分，通过反射 Class.getMethod() 获取到接口所有的方法。</p>
<p>MapperAnnotationBuilder 会委派内部的 MapperBuilderAssistant 进行语句添加，还会缓存到 MapperBuilderAssistant  中</p>
<h4 id="方式4-包名"><a href="#方式4-包名" class="headerlink" title="方式4 包名"></a>方式4 包名</h4><p>注册该包下所有接口为 mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>你在指定非 package 的配置时，只能配置 url，name，resource 之一的属性，否则你会得到异常。</p>
<h2 id="3-Mapper-XML-Files"><a href="#3-Mapper-XML-Files" class="headerlink" title="3. Mapper XML Files"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#">3. Mapper XML Files</a></h2><h3 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1. select"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#select">3.1. select</a></h3><p>对于形如 <code>#&#123;id&#125;</code> 这样的标记，这告诉 MyBatis 需要创建一个 PreparedStatement 的参数。使用 JDBC，这样的参数会在 SQL 中识别为 “?”，传递给 PreparedStatement。</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">在该 namesapce 下的唯一标识符，可以用于引用该语句，即 Statement ID。</td>
</tr>
<tr>
<td align="left">parameterType</td>
<td align="left">将传递到此语句的参数的完全限定类名或别名。可选，因为 MyBatis 可以通过传递给语句的实际参数得到 <code>TypeHandler</code></td>
</tr>
<tr>
<td align="left">resultType</td>
<td align="left">从此语句返回的预期类型的完全限定类名或别名。在集合的情况下，这应该是集合包含的类型，而不是集合类型。使用 <code>resultType</code> 或者 <code>resultMap</code>，不可以都用。</td>
</tr>
<tr>
<td align="left">resultMap</td>
<td align="left">外部 <code>resultMap</code> 的引用。使用 <code>resultMap</code> 或者 <code>resultType</code>，不可以都用。</td>
</tr>
<tr>
<td align="left">flushCache</td>
<td align="left">设置为 true 将导致当调用此语句时会刷新 Local 和 2 级缓存。对于 select 默认是 false</td>
</tr>
<tr>
<td align="left">useCache</td>
<td align="left">设置为 true 将导致该语句的结果缓存在 2 级缓存。对于 select 语句默认为: <code>true</code></td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">驱动等待数据库返回数据，在抛出异常之前的超时时间，默认 <code>unset</code>（驱动决定）</td>
</tr>
<tr>
<td align="left">fetchSize</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">statementType</td>
<td align="left">可选值：STATEMENT, PREPARED, CALLABLE。默认值：PREPARED</td>
</tr>
<tr>
<td align="left">resultSetType</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">databaseId</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">resultOrdered</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">resultSets</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="3-2-insert-update-and-delete"><a href="#3-2-insert-update-and-delete" class="headerlink" title="3.2. insert, update and delete"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#insert.2C_update_and_delete">3.2. insert, update and delete</a></h3><p>MyBatis 加载 Mapper 的时候会将读取到的语句信息都存储到 Configuration 的属性 <code>mappedStatements</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, MappedStatement&gt; mappedStatements;</span><br></pre></td></tr></table></figure>

<p>其中，<code>MappedStatement</code> 又能够获取 <code>BoundSql</code></p>
<h3 id="一对多关联"><a href="#一对多关联" class="headerlink" title="一对多关联"></a>一对多关联</h3><ul>
<li>collection</li>
</ul>
<p>支持分步查询和关联查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;com.cannedbread.dictionary.pojo.domain.DictionaryTypeDO&quot;</span> <span class="attr">id</span>=<span class="string">&quot;doctionaryType&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;t_type&quot;</span> <span class="attr">property</span>=<span class="string">&quot;type&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;t_description&quot;</span> <span class="attr">property</span>=<span class="string">&quot;description&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;dictionaryTypeList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.cannedbread.dictionary.pojo.domain.DictionaryValueDO&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;v_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;java.lang.String&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;v_label&quot;</span> <span class="attr">property</span>=<span class="string">&quot;label&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;v_value&quot;</span> <span class="attr">property</span>=<span class="string">&quot;value&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="3-3-Parameters"><a href="#3-3-Parameters" class="headerlink" title="3.3. Parameters"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Parameters">3.3. Parameters</a></h3><p>参数，指传递给语句的参数。参数可以认为有 2 种：</p>
<ul>
<li><p>简易（原始）数据类型。 Integer、String 等没有属性的值。</p>
</li>
<li><p>复合数据类型。可以理解为是由简易数据类型组合而成的类。</p>
</li>
</ul>
<p>通常，我们使用 <code>#&#123;id&#125;</code> 这种方式引用参数。但是，参数可以更具体地引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#&#123;property,javaType=<span class="type">int</span>,jdbcType:NUMBERIC&#125;</span><br></pre></td></tr></table></figure>
<p><code>javaType</code> 基本可以总是从参数对象中确定，除非该对象是 <code>HashMap</code>，那么需要显式指定 <code>javaType</code> 确保使用正确的 TypeHandler。</p>
<ul>
<li>传入 List</li>
</ul>
<p>引用名称必须为 <code>list</code>，获取长度：<code>list.size</code>，获取第 n 个元素：list[n]</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;list != null and list.size != 0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span>&gt;</span>#&#123;item&#125;<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>传入多个值</li>
</ul>
<p>多个参数会封装成 Map，key 为 param1, param2, …</p>
<p>引用方式：<code>#&#123;param1&#125;</code>、<code>#&#123;param2.password&#125;</code></p>
<ul>
<li>传入 Map</li>
</ul>
<p>对 XML 中映射的语句进行解析之后，能够得到一个 <code>List&lt;ParameterMapping&gt;</code>，其中收集所有 <code>#&#123;&#125;</code> 占位符。</p>
<p>这些结构之后会传递给 <code>StatementHandler</code>，通常是 <code>PreparedStatementHandler</code>，之后通过 handler 进行参数设置。</p>
<h3 id="3-4-Result-Maps"><a href="#3-4-Result-Maps" class="headerlink" title="3.4. Result Maps"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Result_Maps">3.4. Result Maps</a></h3><p>对于如下映射语句例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">  select id, username, hashedPassword</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据 <code>resultType</code> 属性所指定的，这样的语句会简单地将所有地列自动映射到 <code>HashMap</code> 的 key 上。但是，在大多数场景下，<code>HashMap</code>并不是一个好的领域模型。应用程序更有可能使用 Java Bean 或者 POJO。考虑如下的 Java Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String hashedPassword;</span><br><span class="line">  <span class="comment">// Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于 Java Bean 规范，上面的类有 3 个属性：id, username, hashedPassword。这些与 SELECT 语句中的列名<strong>完全匹配</strong>。这样，Java Bean 可以像 HashMap 一样，简单地映射到 ResultSet。</p>
<p>在这些情况下，MyBatis 自动在幕后创建 ResultMap 以将列名基于名称地自动映射到 Java Bean 的属性。</p>
<p><strong>列名与属性名不匹配的情况如何处理 ?</strong></p>
<ul>
<li>标准 SQL 语法，SELECT 语句别名</li>
<li>使用自定义 <code>&lt;Result Map&gt;</code></li>
</ul>
<h4 id="3-4-1-Advanced-Result-Maps"><a href="#3-4-1-Advanced-Result-Maps" class="headerlink" title="3.4.1. Advanced Result Maps"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Advanced_Result_Maps">3.4.1. Advanced Result Maps</a></h4><p>Result Map 是 MyBatis 强大的工具，可以自由映射结果。</p>
<h4 id="3-4-2-resultMap"><a href="#3-4-2-resultMap" class="headerlink" title="3.4.2. resultMap"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#resultMap">3.4.2. resultMap</a></h4><p><code>&lt;resultMap&gt;</code> 元素的概览：</p>
<ul>
<li><code>&lt;constructor&gt;</code> 用于在实例化时将结果注入类的构造函数<ul>
<li><code>idArg</code> ID 参数，标识 ID 将有助于提升整体性能</li>
<li><code>arg</code> 普通结果参数注入</li>
</ul>
</li>
<li><code>&lt;id&gt;</code> 一个 ID 结果，标识 ID 将会提高整体性能</li>
<li><code>&lt;result&gt;</code> 普通结果参数</li>
<li><code>&lt;association&gt;</code> 复合类型关联，许多结果会汇总到该类型<ul>
<li>嵌套结果映射 - association 本身就是 <code>resultMap</code>，或者可以引用其他的 <code>resultMap</code></li>
</ul>
</li>
<li><code>&lt;collection&gt;</code> 复合类型的集合<ul>
<li>嵌套结果映射 - collection 本身就是 <code>resultMap</code>，或者可以引用其他的 <code>resultMap</code></li>
</ul>
</li>
<li><code>&lt;discriminator&gt;</code> 使用结果的值来确定要使用的 <code>resultMap</code></li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">当前命名空间下引用此 result map 的唯一标识符</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">Java 的完全限定名，或者别名</td>
</tr>
<tr>
<td align="left">autoMapping</td>
<td align="left">如果存在该属性，MyBatis 会为该 result map 启用或禁用自动映射</td>
</tr>
</tbody></table>
<h4 id="3-4-3-id-amp-result"><a href="#3-4-3-id-amp-result" class="headerlink" title="3.4.3. id &amp; result"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#id_.26_result">3.4.3. id &amp; result</a></h4><p>id 和 result 都可以映射一个列的值到一个简单数据类型的字段（String,int,double,Date,…）</p>
<h4 id="association"><a href="#association" class="headerlink" title="association"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#association">association</a></h4><p>association 元素处理 “has-one” 类型关系。例如，一个博客有一个作者。<code>&lt;association&gt;</code> 映射像其他 <code>&lt;result&gt;</code> 一样工作。你可以指定 <code>property</code>, <code>javaType</code>, <code>jdbcType</code>, <code>typeHandler</code>。</p>
<p>association 不同之处在于，你需要告诉 MyBatis 如何加载关联数据，支持 2 种方式：</p>
<ul>
<li>Nested Select：嵌套查询，或者嵌套子查询。通过执行另一个映射 SQL 语句返回所需的<strong>复合类型</strong>。</li>
<li>Nested Results：嵌套结果。通过使用嵌套的结果映射来处理 join 结果的重复子集。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">property</td>
<td align="left">字段或属性。如果给定名称存在 Java Bean 匹配的属性，则会使用。否则，MyBatis 会寻找给定名称的字段。</td>
</tr>
<tr>
<td align="left">javaType</td>
<td align="left">完全限定的 Java 类名（或者 alias）。如果你映射到 Java Bean，MyBatis 会弄清楚类型。如果你映射到 HashMap，你需要指定 javaType 以确保所需的行为。</td>
</tr>
<tr>
<td align="left">jdbcType</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">typeHandler</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="Nested-Select-for-Association"><a href="#Nested-Select-for-Association" class="headerlink" title="Nested Select for Association"></a>Nested Select for Association</h4><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">column</td>
<td align="left">将要传递给嵌套语句的列名或者别名。<strong>可以确定唯一一条记录。</strong><br>注意：为了处理复合键，可以使用语法 <code>column=&quot;prop1=col1,prop2=col2&quot;</code> 指定多个列名传递给嵌套的 select 语句</td>
</tr>
<tr>
<td align="left">select</td>
<td align="left">映射语句的 ID，将会加载需要的复杂类型</td>
</tr>
<tr>
<td align="left">fetchType</td>
<td align="left">可选。有效值是 lazy 和 eager。如果存在，它会覆盖全局配置参数 <code>lazyLoadingEnabled</code></td>
</tr>
</tbody></table>
<blockquote>
<p>嵌套 SELECT 必须确保结果集的数量小于等于 1 个，否则你会得到异常：<br>org.apache.ibatis.executor.ExecutorException: Statement returned more than one row, where no more than one was expected.</p>
</blockquote>
<p><strong>官方提示</strong> 虽然这种方式比较简单，但是，对于大量数据集或者列表性能并不好。这种问题也被称之为 “N + 1 Select 问题”。简而言之，N + 1 Select 问题是由类似如下引起的：</p>
<ul>
<li>你执行单个 SQL 检索出一个记录列表（+1）</li>
<li>对于每个返回的记录，你执行 select 语句来加载每个的细节（N）</li>
</ul>
<p>该问题会导致大量 SQL 执行，并不是可取的。MyBatis 可以拦截在这些查询语句，因此你可能会忽略这些语句的开销。但是，如果你加载这样的列表，然后立即迭代它访问嵌套数据，则会调用所有延迟加载，因此性能可能非常糟糕。</p>
<blockquote>
<p>这也是在开发过程中比较忌讳的，在循环体中发起 SQL 查询</p>
</blockquote>
<h4 id="Nested-Results-for-Association"><a href="#Nested-Results-for-Association" class="headerlink" title="Nested Results for Association"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#Nested_Results_for_Association">Nested Results for Association</a></h4><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">resultMap</td>
<td align="left">ID</td>
</tr>
<tr>
<td align="left">columnPrefix</td>
<td align="left">当 join 多张表时，你往往会使用别名来避免结果重复列名。指定 <code>columnPrefix</code> 允许你在映射时添加统一的前缀</td>
</tr>
<tr>
<td align="left">notNullColumn</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">autoMapping</td>
<td align="left">如果该属性存在，MyBatis 在映射该属性时，将会启用或者禁用自动映射</td>
</tr>
</tbody></table>
<h4 id="Multiple-ResultSets-for-Association"><a href="#Multiple-ResultSets-for-Association" class="headerlink" title="Multiple ResultSets for Association"></a>Multiple ResultSets for Association</h4><h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><ul>
<li>嵌套 select</li>
<li>使用 join + 嵌套结果</li>
</ul>
<h4 id="Nested-Select-for-Collection"><a href="#Nested-Select-for-Collection" class="headerlink" title="Nested Select for Collection"></a>Nested Select for Collection</h4><p><code>&lt;collection&gt;</code> 元素将会使用新的属性 <code>ofType</code>，该属性适用于区分 Java Bean 属性类型和 collection 包含的类型。</p>
<h4 id="Nested-Results-for-Collection"><a href="#Nested-Results-for-Collection" class="headerlink" title="Nested Results for Collection"></a>Nested Results for Collection</h4><p>需要注意 collection 子元素 id 的重要性。</p>
<h4 id="Multiple-ResultSets-for-Collection"><a href="#Multiple-ResultSets-for-Collection" class="headerlink" title="Multiple ResultSets for Collection"></a>Multiple ResultSets for Collection</h4><h4 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h4><h3 id="Auto-mapping"><a href="#Auto-mapping" class="headerlink" title="Auto-mapping"></a>Auto-mapping</h3><p>MyBatis 可以自动映射结果，你也可以自己构建 result map，你甚至可以结合两种。</p>
<p>通常，数据库列使用大写字母且单词之间用下划线，而 Java 属性通常遵循驼峰命名约定。可以设置 <code>mapUnderscoreToCamelCase </code> 为 true 完成自动映射。</p>
<p>即使存在 <code>resultMap</code>，自动映射也会发生。对于每个结果映射，在结果集中但没有进行手工映射的列，将会被自动映射，之后进行手工映射。</p>
<p>有 3 个映射级别：</p>
<ul>
<li><code>NONE</code> 禁用自动映射。即，只会赋值手动映射属性。</li>
<li><code>PARTIAL</code> 除了其中定义的嵌套结果映射，其他都会自动映射</li>
<li><code>FULL</code> 自动映射所有</li>
</ul>
<h2 id="3-6-cache"><a href="#3-6-cache" class="headerlink" title="3.6. cache"></a><a href="https://mybatis.org/mybatis-3/sqlmap-xml.html#cache">3.6. cache</a></h2><p>默认地，只有 Local Cache 是启用的，用于缓存会话的数据。要启用全局二级缓存，你只需添加一行文字到你的 SQL Mapper 文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>二级缓存需要配置 <code>cacheEnabled</code> 为 <code>true</code> 才会开启，一般默认是开启的，但建议显式设置。另外，使用二级缓存，还需要实体类实现 <code>Serializable</code> 接口，否则将会抛出异常。</p>
</blockquote>
<p>这个简单的语句效果如下：</p>
<ul>
<li>缓存所有映射语句文件中 SELECT 语句的结果</li>
<li>所有 insert, update, delete 语句将刷新缓存</li>
<li>缓存将使用最近最少使用（LRU）算法进行驱逐</li>
<li>缓存不会以基于计划的时间顺序刷新</li>
<li>缓存将存储 1024 个列表或对象的引用（无论方法返回什么）</li>
<li>缓存会被视为读&#x2F;写缓存，这意味，被检索的对象不会被共享，可以被调用者安全的修改，不会干扰其他线程可能的修改</li>
</ul>
<h3 id="Using-a-Custom-Cache"><a href="#Using-a-Custom-Cache" class="headerlink" title="Using a Custom Cache"></a>Using a Custom Cache</h3><p>实现 Cache 接口，并在 Mapper 文件中指定 type：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;com.domain.something.MyCustomCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="cache-ref"><a href="#cache-ref" class="headerlink" title="cache-ref"></a>cache-ref</h3><p>在不同 namespace 之间共享相同的缓存配置和实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>=<span class="string">&quot;com.someone.application.data.SomeMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="5-Java-API"><a href="#5-Java-API" class="headerlink" title="5. Java API"></a><a href="https://mybatis.org/mybatis-3/java-api.html">5. Java API</a></h2><h3 id="5-2-SqlSessions"><a href="#5-2-SqlSessions" class="headerlink" title="5.2. SqlSessions"></a><a href="https://mybatis.org/mybatis-3/java-api.html#sqlSessions">5.2. SqlSessions</a></h3><p>通过 <code>SqlSession</code>，你可以执行命令，获得 Mapper，管理事务。<code>SqlSession</code> 由 <code>SqlSessionFactory</code> 创建。</p>
<h4 id="5-2-1-SqlSessionFactoryBuilder"><a href="#5-2-1-SqlSessionFactoryBuilder" class="headerlink" title="5.2.1. SqlSessionFactoryBuilder"></a>5.2.1. SqlSessionFactoryBuilder</h4><p><code>SqlSessionFactoryBuilder</code> 有 5 个 build() 方法，每个方法允许你从不同来源构建 <code>SqlSessionFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String env, Properties props)</span></span><br><span class="line">SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span></span><br></pre></td></tr></table></figure>

<p><code>environment</code> MyBatis 将会使用的环境，如果没有调用包含 environment 参数的方法，则使用默认环境。</p>
<p><code>properties</code> MyBatis 将会加载的属性，可使用 <code>$&#123;propName&#125;</code> 进行配置</p>
<p><strong>关于 properties 加载的顺序</strong> </p>
<ul>
<li>首先，读取 properties 元素主体中指定的属性</li>
<li>其次，加载于 properties 元素的 resource 类路径资源或者 url 属性指定的资源将会被读取</li>
<li>最后，作为方法参数传递的 properties 最后读取</li>
</ul>
<p>后加载的属性会覆盖前者</p>
<h4 id="5-2-2-SqlSessionFactory"><a href="#5-2-2-SqlSessionFactory" class="headerlink" title="5.2.2. SqlSessionFactory"></a>5.2.2. SqlSessionFactory</h4><p>SqlSessionFactory 有 6 种方法用于创建 SqlSession 实例。一般地，当你选择用哪个方法时，需要考虑以下事情：</p>
<ul>
<li><strong>Transaction</strong>：你是否希望为 session 使用事务范围，或者使用 auto-commit（这通常意味着数据库或 JDBC 没有事务）？</li>
<li><strong>Connection</strong>：从 MyBatis 配置好的数据源获取还是自己提供</li>
<li><strong>Execution</strong>：重用 PreparedStatement 还是批处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">()</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(Connection connection)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, <span class="type">boolean</span> autoCommit)</span></span><br><span class="line">SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span></span><br><span class="line">Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>默认地，无参的 openSession() 将会创建具有如下特征的 SqlSession：</p>
<ul>
<li>启动事务，即不会 auto commit</li>
<li>Connection 对象从 DataSource 中获取</li>
<li>事务隔离级别是驱动或者数据源使用的默认值</li>
<li>不会重用 PreparedStatements，不会批量更新</li>
</ul>
<p>ExecutorType 参数定义了 3 个可选值：</p>
<ul>
<li>ExecutorType.SIMPLE：朴素的执行器。为每个执行语句创建一个 PreparedStatement。</li>
<li>ExecutorType.REUSE：这种类型会重用 PreparedStatement。</li>
<li>ExecutorType.BATCH：批量更新，同时，如果执行语句之间有 SELECT 语句，也会在必要的地方划清。</li>
</ul>
<h4 id="5-2-3-SqlSession"><a href="#5-2-3-SqlSession" class="headerlink" title="5.2.3. SqlSession"></a><a href="https://mybatis.org/mybatis-3/java-api.html#SqlSession">5.2.3. SqlSession</a></h4><h5 id="5-2-3-1-Statement-Execution-Methods"><a href="#5-2-3-1-Statement-Execution-Methods" class="headerlink" title="5.2.3.1. Statement Execution Methods"></a><a href="https://mybatis.org/mybatis-3/java-api.html#Statement_Execution_Methods">5.2.3.1. Statement Execution Methods</a></h5><p>SqlSession 具有许多方法，用于执行 SQL 映射文件中定义的 SELECT, INSERT, UPDATE, DELETE 语句。每个方法都有一个 <code>statement</code> 参数（Statement ID），并且可以有 parameter 参数，参数可以是原始类型（自动装箱），或者 Java Bean，POJO，Map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement)</span>;</span><br><span class="line">&lt;T&gt; T <span class="title function_">selectOne</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement)</span>;</span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement)</span>;</span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line">&lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, String mapKey)</span>;</span><br><span class="line">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey)</span>;</span><br><span class="line">&lt;K, V&gt; Map&lt;K, V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowBounds)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, ResultHandler handler)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, Object parameter, ResultHandler handler)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(String statement, Object parameter)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(String statement, Object parameter)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>selectOne</code> 和 <code>selectList</code> 不同点在于， <code>selectOne</code> 必须返回一个对象或者 null（没有对象）。如果超过一个对象，则抛出异常。</li>
</ul>
</blockquote>
<p>如果你不知道有多少对象，使用 <code>selectList</code> 总是安全的。</p>
<p>如果你想检查对象是否存在，你最好返回一个计数值（0 或 1）。</p>
<p><code>selectMap</code> 是一个特殊的情况，它会基于结果中的某个属性，将结果列表转换为一个 Map。</p>
<p>因为不是所有方法都需要参数，因此这些方法都有一个无参数的重载方法。</p>
<p><code>insert</code>, <code>update</code>, <code>delete</code> 的返回值表示的是影响行数。</p>
<p>有几种高级的 <code>select</code> 方法，它们允许你限制要返回的行范围，或者提供自定义的结果处理逻辑（ResultHandler），通常用于非常大的数据集（MySQL 几乎不使用）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">selectList</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span><br><span class="line">&lt;T&gt; Cursor&lt;T&gt; <span class="title function_">selectCursor</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span></span><br><span class="line">&lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">selectMap</span><span class="params">(String statement, Object parameter, String mapKey, RowBounds rowbounds)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span> <span class="params">(String statement, Object parameter, ResultHandler&lt;T&gt; handler)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">select</span> <span class="params">(String statement, Object parameter, RowBounds rowBounds, ResultHandler&lt;T&gt; handler)</span></span><br></pre></td></tr></table></figure>
<p><code>RowBounds</code> 参数会让 MyBatis 跳过指定的记录数，同时限制要返回的记录数。</p>
<blockquote>
<ul>
<li>在这里，不同的驱动能够获得不同的效率。为了最佳性能，需要使用结果集类型为 <code>SCROLL_SENSITIVE </code> 或者 <code>SCROLL_INSENSITIVE </code></li>
</ul>
</blockquote>
<p><code>ResultHandler</code> 参数允许你按照你的方式处理每一行。你可以把它添加到 List，创建一个 Map，Set，或者抛出买个结果，而只保留计算的计算的总数。你可以使用 ResultHandler 做任何事情，这就是 MyBatis 内部使用来构造结果集列表的。</p>
<p>ResultHandler 接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResultHandler</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleResult</span><span class="params">(ResultContext&lt;? extends T&gt; context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ResultContext</code> 参数用于访问结果对象本身，这是被创建的结果对象的数量计数，以及你可以使用 <code>stop()</code> 方法停止 MyBatis 加载更多结果。</p>
<p>使用 <code>ResultHandler</code> 有两点你应该了解：</p>
<ul>
<li>使用 <code>ResultHandler</code> 调用的方法种的数据不会被缓存</li>
<li>当使用高级 <code>resultMap</code> 时，MyBatis 有可能需要多行来构建 1 个对象。如果使用 <code>ResultHandler</code>，可能会给你一个关联或者集合未被填充的对象。</li>
</ul>
<h5 id="Local-Cache"><a href="#Local-Cache" class="headerlink" title="Local Cache"></a><a href="https://mybatis.org/mybatis-3/java-api.html#Local_Cache">Local Cache</a></h5><p>MyBatis 使用了 2 个缓存，Local Cache 和 二级缓存。</p>
<p>每次 MyBatis 创建新的会话时，也会创建一个 Local Cache 附加到会话中。在<strong>本次会话</strong>中执行的任何查询都将存储在本地缓存中，因此具有相同输入参数的相同查询，以后都不会查询数据库。当 update, commit, rollback 和 close 时，Local Cache 会清除。</p>
<h6 id="1-Local-Cache-原理-👇"><a href="#1-Local-Cache-原理-👇" class="headerlink" title="1. Local Cache 原理 👇"></a>1. Local Cache 原理 👇</h6><p>一般地，执行查询方法的时候都是调用 BaseExecutor 的 query() 方法，其方法内部会先考虑是否从 Local Cache 中获取数据，如果不从缓存中获取，则调用内部的 doQuery() 方法</p>
<h6 id="Local-Cache-的-Key-🐱"><a href="#Local-Cache-的-Key-🐱" class="headerlink" title="Local Cache 的 Key 🐱"></a>Local Cache 的 Key 🐱</h6><p>org.apache.ibatis.cache.CacheKey 是 Local Cache 的 key</p>
<h6 id="何时可能会失效-Local-Cache（失效）？-🐌"><a href="#何时可能会失效-Local-Cache（失效）？-🐌" class="headerlink" title="何时可能会失效 Local Cache（失效）？ 🐌"></a>何时可能会失效 Local Cache（失效）？ 🐌</h6><ul>
<li>不同的会话</li>
</ul>
<p>不同的 Session 本身不共享 Local Cache。我并不认为这是失效的原因。这反而是一种使用错误的方式。</p>
<ul>
<li>执行 update 操作</li>
</ul>
<p>如果执行了更新操作会清空 Local Cache</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutorException</span>(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clearLocalCache();</span><br><span class="line">    <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>手动调用 DefaultSqlSession.clearCache()</li>
</ul>
<p>底层会调用 executor 的 clearLocalCache() 方法</p>
<ul>
<li><p>设置了语句属性 <code>flushCache</code> 为 <code>true</code>，缓存全清</p>
</li>
<li><p>设置 flushCacheRequired</p>
</li>
<li><p>配置 localCacheScope 为 STATEMENT</p>
</li>
<li><p>commit 和 rollback</p>
</li>
</ul>
<h5 id="Ensuring-that-SqlSession-is-Closed"><a href="#Ensuring-that-SqlSession-is-Closed" class="headerlink" title="Ensuring that SqlSession is Closed"></a>Ensuring that SqlSession is Closed</h5><p>你必须确保关闭所有你打开的会话。推荐方式是使用 try 包裹资源。</p>
<h5 id="Using-Mappers"><a href="#Using-Mappers" class="headerlink" title="Using Mappers"></a>Using Mappers</h5><h5 id="Mapper-Annotations"><a href="#Mapper-Annotations" class="headerlink" title="Mapper Annotations"></a>Mapper Annotations</h5><table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">目标</th>
<th align="left">XML 等价物</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@CacheNamespace</td>
<td align="left">Class</td>
<td align="left"><code>&lt;cache&gt;</code></td>
<td align="left">为给定的命名空间配置缓存</td>
</tr>
<tr>
<td align="left">@CacheNamespaceRef</td>
<td align="left">Class</td>
<td align="left"><code>&lt;cacheRef&gt;</code></td>
<td align="left">引用其他命名空间的缓存。注意：xml mapper 文件声明的缓存是隔离的</td>
</tr>
<tr>
<td align="left">@MapKey</td>
<td align="left">Method</td>
<td align="left"></td>
<td align="left">用于返回类型是 Map 的方法。基于对象的属性将结果 List 转换为 Map。注解的属性 <code>value</code> 作为 Map 的 key</td>
</tr>
</tbody></table>
<h1 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a><a href="https://mp.baomidou.com/">MyBatisPlus</a></h1><hr>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &#123;&quot;com.cannedbread.dictionary.mapper&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PaginationInterceptor <span class="title function_">paginationInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PaginationInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><hr>
<ul>
<li>PageHelper</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用方法：<br>(1) PageHelper.start()，传入 pageNum 当前页码，pageSize 每页显示数目。<br>(2) 调用 Mapper 方法查询<br>(3) 使用 pageInfo 构造器传入查询结果集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> PageInfo&lt;ProjectArea&gt; <span class="title function_">listPageByExample</span><span class="params">(<span class="type">int</span> pageNum, <span class="type">int</span> pageSize, ProjectArea example)</span> &#123;</span><br><span class="line">	PageHelper.startPage(pageNum, pageSize);</span><br><span class="line">	List&lt;ProjectArea&gt; result = projectAreaMapper.selectList(example);</span><br><span class="line">	PageInfo&lt;ProjectArea&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(result);</span><br><span class="line">	<span class="keyword">return</span> pageInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="各种-Logger"><a href="#各种-Logger" class="headerlink" title="各种 Logger"></a>各种 Logger</h2><ul>
<li>PreparedStatementLogger</li>
<li>ConnectionLogger</li>
</ul>
<h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><h3 id="PreparedStatementHandler"><a href="#PreparedStatementHandler" class="headerlink" title="PreparedStatementHandler"></a>PreparedStatementHandler</h3><p>执行 SQL 的时候会将 statement 强制转换为 PreparedStatement 类型，并进行执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">	<span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> (PreparedStatement) statement;</span><br><span class="line">	ps.execute();</span><br><span class="line">	<span class="keyword">return</span> resultSetHandler.handleResultSets(ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SqlSource"><a href="#SqlSource" class="headerlink" title="SqlSource"></a>SqlSource</h2><ul>
<li>RawSqlSource</li>
<li>DynamicSqlSource</li>
<li>StaticSqlSource，生成 BoundSQL</li>
</ul>
<h3 id="RawSqlSource"><a href="#RawSqlSource" class="headerlink" title="RawSqlSource"></a>RawSqlSource</h3><p>RawSqlSource 拥有一个 SqlSource 的属性，它是 StaticSqlSource：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RawSqlSource</span> <span class="keyword">implements</span> <span class="title class_">SqlSource</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SqlSource sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>如何判断一个 SqlNode 是否是动态的 ?</strong></p>
<ul>
<li>如果是纯文本节点，且存在 <code>$&#123;&#125;</code>，认为是动态</li>
<li>如果是元素节点，则一定是动态</li>
</ul>
<p>具体代码见 XMLScriptBuilder.parseDynamicTags &gt; TextSqlNode.isDynamic</p>
<p><strong>为什么 RawSqlSource、DynamicSqlSource 不直接生成 BoundSQL，反而通过   StaticSqlSource 生成?</strong></p>
<p>设计的问题</p>
<p>DynamicSqlSource 解析是对 SqlNode 的解析，其中会存储根节点 rootSqlNode，节点可以认为是类似 DOM 的节点。</p>
<p><code>rootSqlNode.apply(context);</code> 即遍历 SqlNode 树进行解析，最终生成 context。</p>
<h2 id="SqlNode"><a href="#SqlNode" class="headerlink" title="SqlNode"></a>SqlNode</h2><ul>
<li>MixedSqlNode</li>
</ul>
<p>SQL 语法树从结构来看是树形，但是 MyBatis 会将同一层的所有节点用 MixedSqlNode 包装，因此，从节点的角度看，是一个链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    contents.forEach(node -&gt; node.apply(context));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>StaticTextSqlNode 静态文本</p>
</li>
<li><p>TextSqlNode 包含了表达式的文本，如：select * from ${table}</p>
</li>
<li><p>IfSqlNode</p>
</li>
</ul>
<p>计算表达式的值，如果为 true，则继续解析，一般 if 表达式下面就是静态文本了，所以大部分情况则是直接追加 SQL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (evaluator.evaluateBoolean(test, context.getBindings())) &#123;</span><br><span class="line">        contents.apply(context);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ForEachNode</li>
</ul>
<p>解析完毕之后会生成特定的序列，其中每个每个</p>
<p>该解析一定会添加 open 与 close，所以如果在拼接 in 语句的时候没有元素，可能导致 SQL 错误</p>
<ul>
<li>TrimSqlNode</li>
</ul>
<p>从进入该节点开始，将会使用 <code>FilteredDynamicContext</code> 包装原来的 context，之后的结果会缓存在 <code>FilteredDynamicContext</code> 的 <code>sqlBuffer</code> 中，直至该节点解析完毕，最后使用 filteredDynamicContext.applyAll() 真正进行应用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(DynamicContext context)</span> &#123;</span><br><span class="line">    TrimSqlNode.<span class="type">FilteredDynamicContext</span> <span class="variable">filteredDynamicContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrimSqlNode</span>.FilteredDynamicContext(context);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> contents.apply(filteredDynamicContext);</span><br><span class="line">    filteredDynamicContext.applyAll();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么加这一个缓存 ?</strong></p>
<p>如果直接追加 SQL 到最终的结果上，最后还需要做一步 trim，此时已经不方便 trim 了。</p>
<ul>
<li>WhereSqlNode</li>
</ul>
<p>将会删除特定的前缀，并追加前缀 WHERE</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; prefixList = Arrays.asList(<span class="string">&quot;AND &quot;</span>,<span class="string">&quot;OR &quot;</span>,<span class="string">&quot;AND\n&quot;</span>, <span class="string">&quot;OR\n&quot;</span>, <span class="string">&quot;AND\r&quot;</span>, <span class="string">&quot;OR\r&quot;</span>, <span class="string">&quot;AND\t&quot;</span>, <span class="string">&quot;OR\t&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhereSqlNode</span> <span class="keyword">extends</span> <span class="title class_">TrimSqlNode</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">WhereSqlNode</span><span class="params">(Configuration configuration, SqlNode contents)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(configuration, contents, <span class="string">&quot;WHERE&quot;</span>, prefixList, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="rootSqlNode-apply-context"><a href="#rootSqlNode-apply-context" class="headerlink" title="rootSqlNode.apply(context)"></a>rootSqlNode.apply(context)</h2><h2 id="MapperProxy"><a href="#MapperProxy" class="headerlink" title="MapperProxy"></a>MapperProxy</h2><p>MapperProxy 是 MyBatis 中 InvacationHandler 的实现类。其中，包含一个 SqlSessionTemplate，SqlSessionTemplate 内部又包含一个 DefaultSqlSession </p>
<p><strong>为什么 SqlSessionTemplate 又使用代理对象 sqlSessionProxy 去执行方法？</strong></p>
<p>为了实现拦截操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; SqlSession.class &#125;, <span class="keyword">new</span> <span class="title class_">SqlSessionInterceptor</span>());</span><br></pre></td></tr></table></figure>




<h2 id="CachingExecutor-的执行"><a href="#CachingExecutor-的执行" class="headerlink" title="CachingExecutor 的执行"></a>CachingExecutor 的执行</h2><h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>(1) 获得 BoundSql</p>
<p>BoundSql </p>
<p>(2) 创建缓存 key</p>
<p>创建是由 BaseExecutor 完成的，其中影响因素有：</p>
<ul>
<li>MappedStatement.id，即方法全限定名</li>
<li>rowBounds.offset</li>
<li>rowBounds.limit</li>
<li>boundSql.sql</li>
<li>parameterMappings 的参数值</li>
<li>parameterMappings.environment.id</li>
</ul>
<p>(3) flushCacheIfRequired<br>(4) 使用代理 Executor 执行查询</p>
<h2 id="SimpleExecutor"><a href="#SimpleExecutor" class="headerlink" title="SimpleExecutor"></a>SimpleExecutor</h2><h3 id="queryFromDatabase"><a href="#queryFromDatabase" class="headerlink" title="queryFromDatabase"></a>queryFromDatabase</h3><p>(1) 获取 Configuration<br>(2) 创建 StatementHandler<br>(3) prepareStatement<br>(4) StatementHandler.query</p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot Features</title>
    <url>/2022/07/07/Spring-Boot/Spring-Boot-Features/</url>
    <content><![CDATA[<h1 id="Spring-Boot-Features"><a href="#Spring-Boot-Features" class="headerlink" title="Spring Boot Features"></a>Spring Boot Features</h1><h2 id="1-SpringApplication"><a href="#1-SpringApplication" class="headerlink" title="1. SpringApplication"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-application">1. SpringApplication</a></h2><p><code>SpringApplication</code> 类提供了一种简单的方式来引导 Spring 应用程序从 main 方法中启动。在许多情况下，你可以委托给静态的 <code>SpringApplication.run</code> 方法，就像下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(MySpringConfiguration.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你的应用启动时，你应该会看到类似的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::   v2.3.12.RELEASE</span><br><span class="line"></span><br><span class="line">2019-04-31 13:09:54.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)</span><br><span class="line">2019-04-31 13:09:54.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy</span><br><span class="line">2019-04-01 13:09:56.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080</span><br><span class="line">2019-04-01 13:09:57.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</span><br></pre></td></tr></table></figure>
<h3 id="1-1-Startup-Failure"><a href="#1-1-Startup-Failure" class="headerlink" title="1.1. Startup Failure"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-startup-failure">1.1. Startup Failure</a></h3><p>如果你的应用程序未能启动，则注册的 <code>FailureAnalyzers</code> 将有机会提供专用的错误消息以及具体操作来解决该问题。例如，如果你在端口 <code>8080</code> 启动一个 Web 项目，并且该端口已经被占用，你应该能看到类似以下消息的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that&#x27;s listening on port 8080 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot 提供了许多 <code>FailureAnalyzer</code> 实现，你可以添加自己的实现。</p>
</blockquote>
<h3 id="1-4-Customizing-SpringApplication"><a href="#1-4-Customizing-SpringApplication" class="headerlink" title="1.4. Customizing SpringApplication"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-customizing-spring-application">1.4. Customizing SpringApplication</a></h3><p>如果 <code>SpringApplication</code> 的默认值不符合你的口味，那么你可以取而代之地创建一个本地实例并自定义它。例如，关闭 banner，你可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(MySpringConfiguration.class);</span><br><span class="line">    app.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">    app.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>传递给 <code>SpringApplication</code> 地构造器参数是用于 Spring Bean 地配置源。在大多数情况下，这些是 <code>@Configuration</code> 类地引用，但它们也可以引用 XML 配置或者应该扫描的包。</p>
</blockquote>
<p>也可以使用 <code>application.properties</code> 文件来配置 <code>SpringApplication</code>。有关详细信息，参见 <a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config">Externalized Configuration</a></p>
<h3 id="1-5-Fluent-Builder-API"><a href="#1-5-Fluent-Builder-API" class="headerlink" title="1.5. Fluent Builder API"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-fluent-builder-api">1.5. Fluent Builder API</a></h3><p>如果你需要构建 <code>ApplicationContext</code> 层次结构（具有父子关系的多上下文）或者你更喜欢用 “fluent” 构造器 API，你可以使用 <code>SpringApplicationBuilder</code>。</p>
<p><code>SpringApplicationBuilder</code> 使你可以将多个方法连接在一起，并且包含 <code>parent</code> 和 <code>child</code> 方法，可以让你创建一个层次结构，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class="line">        .sources(Parent.class)</span><br><span class="line">        .child(Application.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>

<h3 id="1-7-Application-Events-and-Listeners"><a href="#1-7-Application-Events-and-Listeners" class="headerlink" title="1.7. Application Events and Listeners"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners">1.7. Application Events and Listeners</a></h3><p>除了通常的 Spring Framework 事件，例如 <code>ContextRefreshedEvent</code>，一个 <code>SpringApplication</code> 还会发送一些其他应用事件。</p>
<blockquote>
<p>实际上，在 <code>ApplicationContext</code> 创建之前一些事件就已经被触发了，因此你无法以 <code>@Bean</code>的方式在上面注册监听器。你可以用 <code>SpringApplication.addListeners(...)</code> 方法或者 <code>SpringApplicationBuilder.listeners(...)</code> 方法注册它们。<br>如果你希望这些监听器自动注册，无论应用程序的创建方式如何，你可以添加一个 <code>META-INF/spring.factories</code> 文件到你的项目中，并通过使用 <code>org.springframework.context.ApplicationListener</code> key 引用你的监听器，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">com.example.project.MyListener</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-8-Web-Environment"><a href="#1-8-Web-Environment" class="headerlink" title="1.8. Web Environment"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-web-environment">1.8. Web Environment</a></h3><p><code>SpringApplication</code> 试图在你的立场上创建正确的 <code>ApplicationContext</code> 类型。决定一个 <code>WebApplicationType</code> 的算法如下：</p>
<ul>
<li>如果 Spring MVC 存在，使用 <code>AnnotationConfigServletWebServerApplicationContext</code></li>
<li>如果 Spring MVC 不存在，Spring WebFlux 存在，使用 <code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
<li>否则，使用 <code>AnnotationConfigApplicationContext</code></li>
</ul>
<p>这意味着，如果你在同一个应用使用 Spring MVC 以及来自 Spring WebFlux 的新 <code>WebClient</code>，默认使用 Spring MVC。你可以通过调用 <code>setWebApplicationType(WebApplicationType)</code> 轻易覆盖这一点。</p>
<h3 id="1-9-Accessing-Application-Arguments"><a href="#1-9-Accessing-Application-Arguments" class="headerlink" title="1.9. Accessing Application Arguments"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-application-arguments">1.9. Accessing Application Arguments</a></h3><p>如果你需要访问传递给 <code>SpringApplication.run(...)</code> 的参数，那么你可以注入一个 <code>org.springframework.boot.ApplicationArguments</code> 的 bean。<code>ApplicationArguments</code> 接口提供了对原始 String[] 参数的访问，以及被解析的 option 和 non-option 参数，正如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(ApplicationArguments args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> args.containsOption(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class="line">        <span class="comment">// if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-11-Application-Exit"><a href="#1-11-Application-Exit" class="headerlink" title="1.11. Application Exit"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-application-exit">1.11. Application Exit</a></h3><p>每个 <code>SpringApplication</code> 都会在 JVM 上注册一个关闭钩子，以确保 <code>ApplicationContext</code> 在退出时优雅地关闭。所有标准的 Spring 生命周期回调（例如 <code>DisposableBean</code> 接口或者 <code>@PreDestroy</code> 注解）都可以使用。</p>
<p>此外，如果希望当 <code>SpringApplication.exit()</code> 调用时返回特定的结束码，Bean 可以实现 <code>org.springframework.boot.ExitCodeGenerator</code> 接口。然后可以将此退出码传递给 <code>System.exit()</code>，以一个状态码的形式返回，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExitCodeApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ExitCodeGenerator <span class="title function_">exitCodeGenerator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication.class, args)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="2-Externalized-Configuration"><a href="#2-Externalized-Configuration" class="headerlink" title="2. Externalized Configuration"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config">2. Externalized Configuration</a></h2><h3 id="2-1-Configuring-Random-Values"><a href="#2-1-Configuring-Random-Values" class="headerlink" title="2.1. Configuring Random Values"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-random-values">2.1. Configuring Random Values</a></h3><p><code>RandomValuePropertySource</code> 可用于注入随机值（例如，secret 或者测试用例）。它可以产生 integer，long，uuid，或者 string，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.secret</span>=<span class="string">$&#123;random.value&#125;</span></span><br><span class="line"><span class="attr">my.number</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="attr">my.bignumber</span>=<span class="string">$&#123;random.long&#125;</span></span><br><span class="line"><span class="attr">my.uuid</span>=<span class="string">$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="attr">my.number.less.than.ten</span>=<span class="string">$&#123;random.int(10)&#125;</span></span><br><span class="line"><span class="attr">my.number.in.range</span>=<span class="string">$&#123;random.int[1024,65536]&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-Application-Property-Files"><a href="#2-3-Application-Property-Files" class="headerlink" title="2.3. Application Property Files"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-application-property-files">2.3. Application Property Files</a></h3><p><code>SpringApplication</code> 在以下位置的 <code>application.properties</code> 文件中加载属性，并将它们添加到 Spring <code>Environment</code>：</p>
<ol>
<li>当前目录的一个 <code>/config</code> 子目录</li>
<li>当前文件夹</li>
<li>类路径 <code>/config</code> 包</li>
<li>类路径根</li>
</ol>
<h2 id="2-7-Using-YAML-Instead-of-Properties"><a href="#2-7-Using-YAML-Instead-of-Properties" class="headerlink" title="2.7. Using YAML Instead of Properties"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-yaml">2.7. Using YAML Instead of Properties</a></h2><p>YAML 是 JSON 的超集，因此，也是一种指定层次配置数据的方便格式。<code>SpringApplication</code> 类自动支持 YAML 作为 properties 的替代品，只需要在类路径添加 SnakeYAML 库支持。</p>
<p>如果你使用 “starter”，SnakeYAML 将由 <code>spring-boot-starter</code> 自动提供。</p>
<h3 id="2-7-1-Loading-YAML"><a href="#2-7-1-Loading-YAML" class="headerlink" title="2.7.1. Loading YAML"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-loading-yaml">2.7.1. Loading YAML</a></h3><p>Spring Framework 提供了两个方便的类，可以用于加载 YAML 文档。<code>YamlPropertiesFactoryBean</code> 将 YAML 加载作为 <code>Properties</code>，而 <code>YamlMapFactoryBean</code> 将 YAML 加载作为 <code>Map</code>。</p>
<p>例如，考虑如下 YAML 文档：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line">    <span class="attr">dev:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">https://dev.example.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line">    <span class="attr">prod:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">https://another.example.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>
<p>前面的示例将转换为以下属性：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">environments.dev.url</span>=<span class="string">https://dev.example.com</span></span><br><span class="line"><span class="attr">environments.dev.name</span>=<span class="string">Developer Setup</span></span><br><span class="line"><span class="attr">environments.prod.url</span>=<span class="string">https://another.example.com</span></span><br><span class="line"><span class="attr">environments.prod.name</span>=<span class="string">My Cool App</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-4-YAML-Shortcomings"><a href="#2-7-4-YAML-Shortcomings" class="headerlink" title="2.7.4. YAML Shortcomings"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-yaml-shortcomings">2.7.4. YAML Shortcomings</a></h3><p>YAML 文件不能使用 <code>@PropertySource</code> 注解加载。因此，以这种方式加载值，你需要使用 properties 文件。</p>
<p>在特定 profile 的 YAML 文件中使用多 YAML 文档语法可能导致不可预测的行为。例如，考虑如下文件配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">&quot;!test&quot;</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;secret&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你以参数 <code>--spring.profiles.active=dev</code> 运行应用，你可能期望 <code>security.user.password</code> 设置为 “secret”，但是事实并非如此。</p>
<p>嵌套文档将被过滤，因为主文件名为 <code>application-dev.yml</code>。它已经被认为是特定于配置文件的，并且嵌套的文档将会被忽略。</p>
<blockquote>
<p>我们建议你不要将特定 profile 的 YAML 文件和多 YAML 文档混合。坚持使用其一。</p>
</blockquote>
<h2 id="2-8-Type-safe-Configuration-Properties"><a href="#2-8-Type-safe-Configuration-Properties" class="headerlink" title="2.8. Type-safe Configuration Properties"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-typesafe-configuration-properties">2.8. Type-safe Configuration Properties</a></h2><h3 id="2-8-1-JavaBean-properties-binding"><a href="#2-8-1-JavaBean-properties-binding" class="headerlink" title="2.8.1. JavaBean properties binding"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-java-bean-binding">2.8.1. JavaBean properties binding</a></h3><p>如下示例所示，可以绑定声明标准 JavaBean 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AcmeProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Security</span> <span class="variable">security</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Security</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> InetAddress <span class="title function_">getRemoteAddress</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRemoteAddress</span><span class="params">(InetAddress remoteAddress)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Security <span class="title function_">getSecurity</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Security</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Collections.singleton(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getRoles</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 POJO 定义了以下属性：</p>
<ul>
<li><code>acme.enabled</code>，具有默认值 <code>false</code></li>
<li><code>acme.remote-address</code>，具有可以从 <code>String</code> 强转的类型</li>
<li><code>acme.security.username</code>，具有一个嵌套的 “security” 对象，其名称由属性名决定。特别注意，返回类型这里根本没有使用，有可能是 <code>SecurityProperties</code></li>
<li><code>acme.security.password</code></li>
<li><code>acme.security.roles</code> 带有默认为 <code>USER</code> 的 <code>String</code> 集合</li>
</ul>
<p>一般需要提供一个无参构造器，并且 getter 和 setter 是强制地，除了一些情况：</p>
<ul>
<li>Map，只要被实例化过了，只需要一个 getter 无需 setter</li>
<li>Collection 和 Array，可以使用索引或者逗号分隔来访问。后者需要 setter。始终建议添加 setter。如果自己初始化，确保它是 not immutable</li>
<li>嵌套属性无需 setter。如果希望默认构造器能够创建该嵌套属性地实例，需要 setter。</li>
</ul>
<p>有人使用 Lombok，确保其不会为属性类生成任何特定地构造函数，因为容器会自动使用它来实例化对象。</p>
<p>只考虑标准 Java Bean，不支持静态属性绑定。</p>
<h3 id="2-8-3-Enabling-ConfigurationProperties-annotated-types"><a href="#2-8-3-Enabling-ConfigurationProperties-annotated-types" class="headerlink" title="2.8.3. Enabling @ConfigurationProperties-annotated types"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-enabling">2.8.3. Enabling @ConfigurationProperties-annotated types</a></h3><p>Spring Boot 提供了绑定 <code>@ConfigurationProperties</code> 类型并将其注册为 Bean 的基础架构。你可以在一个一个的类上启用配置属性，或者启用配置属性扫描，这以类似于组件扫描的方式工作。</p>
<p>有时候，<code>@ConfigurationProperties</code> 可能不适合总是被扫描。例如，如果你正在开发自己的 auto-configuration，或者你需要有条件的启用它们。在这些情况下，使用 <code>@EnableConfiguratonProperties</code> 注解指定要处理的类列表。这可以在任何 <code>@Configuration</code> 类上完成，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AcmeProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用配置属性扫描，请将 <code>@ConfigurationPropertiesScan</code> 注解添加到你的应用。通常，会将其添加到用 <code>@SpringBootApplication</code> 注解的主应用类中，但也可以添加到任何 <code>@Configuration</code> 类。默认情况下，将从声明注解的类所在的包开始扫描。如果你想定义特定的包扫描，你可以像下面示例这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ConfigurationPropertiesScan(&#123; &quot;com.example.app&quot;, &quot;org.acme.another&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>当使用配置属性扫描或者 @EnableConfigurationProperties 注册 @ConfigurationProperties bean 时，bean 有一个约定名称：<code>&lt;prefix&gt;-&lt;fqn&gt;</code>，<code>&lt;prefix&gt;</code> 是 @ConfigurationProperties 的 prefix 属性，<code>&lt;fqn&gt;</code> 是 bean 的全限定名。如果注解没有提供任何前缀，则使用 bean 的完全限定名称。</p>
</blockquote>
<h2 id="3-Profiles"><a href="#3-Profiles" class="headerlink" title="3. Profiles"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-profiles">3. Profiles</a></h2><p>Spring 配置文件提供了一种方式，可以分离应用配置的一部分，并使其仅在某些环境中可用。任何 <code>@Component</code>，<code>@Configuration</code>，或者 <code>@ConfigurationProperties</code> 都可以用 <code>@Profile</code> 标记以限制何时加载，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductionConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以使用 <code>spring.profiles.active</code> <code>Environment</code> 属性来指定哪些配置文件处于激活状态。你可以以本章前面描述的任何方式指定属性。例如，你可以在你的 <code>application.properties</code> 中包含，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev,hsqldb</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用以下开关在命令行上指定：<code>--spring.profiles.active=dev.hsqldb</code></p>
<p>如果没有配置文件处于激活状态。则启用默认配置文件。默认配置文件的名称为 <code>default</code>，并且可以使用 <code>spring.profiles.default</code> <code>Environment</code> 属性进行调整，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.default</span>=<span class="string">none</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Logging"><a href="#4-Logging" class="headerlink" title="4. Logging"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-logging">4. Logging</a></h2><p>Spring Boot 使用 Commons Logging 用于所有内部的日志记录，但是保持底层的日志实现开放。为 Java Util Logging，Log4J2，以及 Logback 提供了默认配置。在每种情况下，日志记录器是预先配置使用控制台输出，同事可选的文件输出也是可用的。</p>
<p>默认情况下，如果你使用 “starter”，则使用 Logback 进行日志记录。适当的 Logback 路由也会被包括进来，确保使用 Java Util Logging，Commons Logging，Log4J，或者 SLF4J 的独立库都能正常工作。</p>
<blockquote>
<p>Java 有很多可供选择的日志框架。如果上面的清单似乎令人困惑，但不用担心。通常，你无需更改日志依赖项，Spring Boot 默认项工作就好。</p>
</blockquote>
<h3 id="4-1-Log-Format"><a href="#4-1-Log-Format" class="headerlink" title="4.1. Log Format"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-logging-format">4.1. Log Format</a></h3><p>Spring Boot 的默认日志输出类似于以下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class="line">2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: &#x27;dispatcherServlet&#x27; to [/]</span><br><span class="line">2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: &#x27;hiddenHttpMethodFilter&#x27; to: [/*]</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Console-Output"><a href="#4-2-Console-Output" class="headerlink" title="4.2. Console Output"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-logging-console-output">4.2. Console Output</a></h3><p>默认的日志配置在写入时会将信息回显到控制台。默认地，<code>ERROR</code> 级别，<code>WARN</code> 级别，以及 <code>INFO</code> 级别的信息会被记录。你还可以通过使用 <code>--debug</code> 标记启动应用，开启 “debug” 模式。</p>
<h3 id="4-3-File-Output"><a href="#4-3-File-Output" class="headerlink" title="4.3. File Output"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-logging-file-output">4.3. File Output</a></h3><p>默认情况下，Spring Boot 日志仅仅输出到控制台，并不会写到日志文件。如果你希望除了输出到控制台还能写到日志文件，你需要设置 <code>logging.file.name</code> 或者 <code>logging.file.path</code> 属性（例如，在你的 <code>application.properties</code>）。</p>
<p>下表一起展示了如何使用 <code>logging.*</code> 属性：</p>
<p>|<code>logging.file.name</code>|<code>logging.file.path</code>|Example|Description|<br>|(none)|(none)||仅控制台记录|<br>|特定文件|(none)|my.log|写到特定日志文件。名称可以是精确的位置或者相对于当前文件夹|<br>|(none)|Specific directory|&#x2F;var&#x2F;log|写 <code>spring.log</code> 到特定文件夹。名字可以是一个精确的位置或者相对于当前文件夹|</p>
<p>日志文件达到 10MB 时旋转，并且与控制台输出一样，默认记录了 <code>ERROR</code> 级别，<code>WARN</code> 级别，以及 <code>INFO</code> 级别的信息。可以使用 <code>logging.file.max-size</code> 属性修改大小限制。默认情况下，保留最后7天的轮转日志文件，除非设置 <code>logging.file.max-history</code>。可以使用 <code>logging.file.total-size-cap</code> 属性限制日志归档的总大小。当日志归档的总大小超过该阈值的时候，将删除备份。要在应用程序启动时强制执行日志归档清理，请使用 <code>logging.file.clean-history-on-start</code> 属性。</p>
<blockquote>
<p>日志属性与实际日志基础架构无关。结果就是，Spring Boot 不会管理特定的配置键（例如，对于 Logback 的 <code>logback.configurationFile</code>）。</p>
</blockquote>
<h3 id="4-4-Log-Levels"><a href="#4-4-Log-Levels" class="headerlink" title="4.4. Log Levels"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-custom-log-levels">4.4. Log Levels</a></h3><p>所有支持的日志系统都可以通过使用 <code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code> 在 Spring <code>Environment</code> 中（例如，在 <code>application.properties</code>）设置日志级别，其中 <code>level</code> 是 TRACE，DEBUG，INFO，WARN，ERROR，FATAL，或者 OFF 之一。可以使用 <code>logging.level.root</code> 配置 <code>root</code> 记录器。</p>
<p>以下示例展示了 <code>application.properties</code> 中的可能的日志设置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging.level.root</span>=<span class="string">warn</span></span><br><span class="line"><span class="attr">logging.level.org.springframework.web</span>=<span class="string">debug</span></span><br><span class="line"><span class="attr">logging.level.org.hibernate</span>=<span class="string">error</span></span><br></pre></td></tr></table></figure>

<p>也可以使用环境变量设置日志级别。例如，<code>LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG</code> 将设置 <code>org.springframework.web</code> 为 <code>DEBUG</code>。</p>
<h3 id="4-7-Custom-Log-Configuration"><a href="#4-7-Custom-Log-Configuration" class="headerlink" title="4.7. Custom Log Configuration"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-custom-log-configuration">4.7. Custom Log Configuration</a></h3><p>可以通过在类路径上包含适当的库来激活各种日志系统，并可以通过提供合适的配置文件进行进一步的定制化，配置文件可以在类路径的根或者由下面 Spring <code>Environment</code> 属性：<code>logging.config</code> 指定位置。</p>
<p>你可以使用 <code>org.springframework.boot.logging.LoggingSystem</code> 系统属性强制 Spring Boot 使用特定的日志系统。该值必须是 <code>LoggingSystem</code> 实现的完全限定类名。你也可以使用 <code>none</code> 值完全禁用 Spring Boot 的日志配置。</p>
<blockquote>
<p>由于 logging 是在 <code>ApplicationContext</code> 创建之前初始化的，因此不可能从 <code>@Configuration</code> 文件中的 <code>@PropertySources</code> 控制日志。更改日志系统或者完全禁用唯一的方式是通过系统属性。</p>
</blockquote>
<p>根据你的日志系统，加载下面的文件：</p>
<table>
<thead>
<tr>
<th align="left">Logging System</th>
<th align="left">Customization</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Logback</td>
<td align="left"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, 或者 <code>logback.groovy</code></td>
</tr>
<tr>
<td align="left">Log4j2</td>
<td align="left"><code>log4j2-spring.xml</code>，或者 <code>log4j2.xml</code></td>
</tr>
<tr>
<td align="left">JDK (Java Util Logging)</td>
<td align="left"><code>logging.properties</code></td>
</tr>
</tbody></table>
<h2 id="5-Internationalization"><a href="#5-Internationalization" class="headerlink" title="5. Internationalization"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-internationalization">5. Internationalization</a></h2><h2 id="6-JSON"><a href="#6-JSON" class="headerlink" title="6. JSON"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-json">6. JSON</a></h2><h2 id="7-Developing-Web-Applications"><a href="#7-Developing-Web-Applications" class="headerlink" title="7. Developing Web Applications"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-developing-web-applications">7. Developing Web Applications</a></h2><h3 id="7-1-The-“Spring-Web-MVC-Framework”"><a href="#7-1-The-“Spring-Web-MVC-Framework”" class="headerlink" title="7.1. The “Spring Web MVC Framework”"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc">7.1. The “Spring Web MVC Framework”</a></h3><h4 id="7-1-1-Spring-MVC-Auto-configuration"><a href="#7-1-1-Spring-MVC-Auto-configuration" class="headerlink" title="7.1.1. Spring MVC Auto-configuration"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-auto-configuration">7.1.1. Spring MVC Auto-configuration</a></h4><p>Spring Boot 为 Spring MVC 提供了自动配置 <code>WebMvcAutoConfiguration</code>。</p>
<ul>
<li>WebMvcAutoConfigurationAdapter</li>
</ul>
<p>如果希望保持 Spring Boot MVC 的定制，并作出更多 MVC 自定义的话，只需要添加自己的 <code>WebMvcConfigurer</code>，并添加 <code>@Configuration</code> 类，而不要使用 <code>@EnableWebMvc</code>。</p>
<p><code>@EnableWebMvc</code> 导致 Spring Boot 自动配置失效原因：<code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code></p>
<p>如果向完全控制 Spring MVC，可以添加带有 <code>@EnableWebMvc</code> 的 <code>@Configuration</code>，或者添加自己的 @Configuration 的 <code>DelegatingWebMvcConfiguration</code></p>
<h3 id="7-1-2-HttpMessageConverters"><a href="#7-1-2-HttpMessageConverters" class="headerlink" title="7.1.2. HttpMessageConverters"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters">7.1.2. HttpMessageConverters</a></h3><p>Spring MVC 使用 <code>HttpMessageConverter</code> 接口来转换 HTTP 请求和响应。开箱即用地包含一些合理的默认项。例如，可以自动地将对象转换为 JSON（通过使用 Jackson 库）或者 XML（通过使用 Jackson XML 扩展，如果可用，或者如果 Jackson XML 扩展不可用就是用 JAXB）。</p>
<p>如果需要添加 converter，可以使用 Spring Boot 的 HttpMessageConverters：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HttpMessageConverters <span class="title function_">customConverters</span><span class="params">()</span> &#123;</span><br><span class="line">        HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">        HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpMessageConverters</span>(additional, another);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-1-3-Custom-JSON-Serializers-and-Deserializers"><a href="#7-1-3-Custom-JSON-Serializers-and-Deserializers" class="headerlink" title="7.1.3. Custom JSON Serializers and Deserializers"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-json-components">7.1.3. Custom JSON Serializers and Deserializers</a></h3><p>使用 @JsonComponent 自定义序列化和反序列化</p>
<p>&amp;nbsp;</p>
<h3 id="7-1-5-Static-Content"><a href="#7-1-5-Static-Content" class="headerlink" title="7.1.5. Static Content"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content">7.1.5. Static Content</a></h3><p>默认地，Spring Boot 提供静态资源的路径（见 <code>ResourceProperties.CLASSPATH_RESOURCE_LOCATIONS</code>）：</p>
<ul>
<li>classpath:&#x2F;static</li>
<li>classpath:&#x2F;public</li>
<li>classpath:&#x2F;resources</li>
<li>classpath:&#x2F;META-INF&#x2F;resources</li>
<li>servletContext 根路径</li>
</ul>
<p>Spring Boot 使用 Spring MVC 的 <code>ResourceHttpRequestHandler</code> 处理静态资源，可以通过添加自己的 <code>WebMvcConfigurer</code> 并覆盖 <code>addResourceHandlers</code> 方法修改此行为。</p>
<p>&amp;nbsp;<br>默认地，静态资源资源映射在 &#x2F;**，可以使用如下配置调整：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加一个固定前缀 resources</span></span><br><span class="line">spring.mvc.static-path-pattern=/resources/**</span><br></pre></td></tr></table></figure>

<p>&amp;nbsp;<br>修改默认的静态资源搜寻路径，支持数组（上面描述的 4 个 classpath 路径会失效）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Servlet Context 的根路径会自动添加</span></span><br><span class="line"><span class="comment"># 注意末尾需要添加 /</span></span><br><span class="line">spring.resources.static-locations=classpath:/res/</span><br></pre></td></tr></table></figure>


<p><strong>官方提示</strong> 如果应用程序预计打包为 jar，不要使用 src&#x2F;main&#x2F;webapp 目录。虽然这是一个通用标准，但只是在 war 包上，如果生成 jar，会被大多数构建工具忽略。</p>
<h3 id="7-1-6-Welcome-Page"><a href="#7-1-6-Welcome-Page" class="headerlink" title="7.1.6. Welcome Page"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-welcome-page">7.1.6. Welcome Page</a></h3><p>Spring Boot 支持静态和模板的欢迎页面。Spring Boot 首先在配置静态内容位置中寻找 <code>index.html</code> 文件。如果一个都没找到，那么它会寻找一个 <code>index</code> 模板。如果找到了某一个模板，模板将会自动使用作为应用的欢迎页。</p>
<h3 id="7-1-7-Custom-Favicon"><a href="#7-1-7-Custom-Favicon" class="headerlink" title="7.1.7. Custom Favicon"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon">7.1.7. Custom Favicon</a></h3><p>在配置的静态内容位置寻找 favicon.ico，如果存在自动作为应用的图标（不可以增加静态资源前缀）。</p>
<h3 id="7-1-11-Error-Handling"><a href="#7-1-11-Error-Handling" class="headerlink" title="7.1.11. Error Handling"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-error-handling">7.1.11. Error Handling</a></h3><p>默认地，Spring Boot 提供一个 <code>/error</code> 的 mapping 以明智的方式来处理所有的错误，并且它被注册为一个 Servlet 容器“全局”错误页面。对于机器客户端，它会产生一个具有错误详情，HTTP 状态码，异常信息的 JSON 响应。对于浏览器客户端，有一个白页错误视图，以 HTML 的格式渲染相同的数据（要定制它，需要添加一个解析到 <code>error</code> 的视图）。</p>
<p>如果你要自定义默认的错误处理行为，则可以设置许多 <code>server.error</code> 属性。参见附录的 <a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/appendix-application-properties.html#common-application-properties-server">“Server Properties”</a></p>
<p>为了完全替换默认行为，你可以实现 <code>ErrorController</code> 并注册该类型的 Bean Definition，或者添加类型为 <code>ErrorAttributes</code> 的 Bean，以使用现存的机制，但是替换内容。</p>
<p>你还可以定义一个以 <code>@ControllerAdvice</code> 注解的类，来自定义 JSON 格式，用于特定的 Controller 或者异常类型，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(basePackageClasses = AcmeController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AcmeControllerAdvice</span> <span class="keyword">extends</span> <span class="title class_">ResponseEntityExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(YourException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">        <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> getStatus(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CustomErrorType</span>(status.value(), ex.getMessage()), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpStatus <span class="title function_">getStatus</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">statusCode</span> <span class="operator">=</span> (Integer) request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (statusCode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>&amp;nbsp;</p>
<ul>
<li>@ResponseStatus 注解的异常类</li>
</ul>
<p>通过处理过程抛出特定的异常，该异常类被 @ResponseStatus 注解</p>
<p>&amp;nbsp;<br>在 Spring 中，HandlerExceptionResolverComposite 也是一个 HandlerExceptionResolver，而且它是多个 HandlerExceptionResolver 的组合。默认地，它以如下的顺序包含多个 HandlerExceptionResolver：</p>
<p>(1) ExceptionHandlerExceptionResolver<br>(2) ResponseStatusExceptionResolver<br>(3) DefaultHandlerExceptionResolver，垫底处理，实现 Ordered 接口，并且 order &#x3D; Ordered.LOWEST_PRECEDENCE</p>
<h4 id="Custom-Error-Pages"><a href="#Custom-Error-Pages" class="headerlink" title="Custom Error Pages"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-error-handling-custom-error-pages">Custom Error Pages</a></h4><p>对于给定的 HTTP 状态码，自定义 HTML 错误页面，可以添加文件到 &#x2F;error 路径。错误页面可以是静态 HTML 或者使用模板引擎。</p>
<p>页面名称应该是精确的状态码或一系列掩码，如：404.html, 5xx.html。</p>
<h3 id="7-4-Embedded-Servlet-Container-Support"><a href="#7-4-Embedded-Servlet-Container-Support" class="headerlink" title="7.4. Embedded Servlet Container Support"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container">7.4. Embedded Servlet Container Support</a></h3><p>Spring Boot 包含对内嵌的 Tomcat，Jetty，以及 Undertow 服务器的支持。大多数开发者使用适当的 “starter” 获得完整的配置实例。默认的，内嵌的服务器在端口 8080 上监听 HTTP 请求。</p>
<h4 id="7-4-1-Servlets-Filters-and-listeners"><a href="#7-4-1-Servlets-Filters-and-listeners" class="headerlink" title="7.4.1. Servlets, Filters, and listeners"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container-servlets-filters-listeners">7.4.1. Servlets, Filters, and listeners</a></h4><p>当使用内嵌的 Servlet 容器时，你可以通过使用 Spring Bean 或者通过扫描 Servlet 组件的方式注册来自于 Servlet 规范的 Servlet，Filter，以及所有的 Listener（例如 <code>HttpSessionListener</code>）</p>
<h5 id="Registering-Servlets-Filters-and-Listeners-as-Spring-Beans"><a href="#Registering-Servlets-Filters-and-Listeners-as-Spring-Beans" class="headerlink" title="Registering Servlets, Filters, and Listeners as Spring Beans"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container-servlets-filters-listeners-beans">Registering Servlets, Filters, and Listeners as Spring Beans</a></h5><p>任何作为一个 Spring Bean 的 <code>Servlet</code>，<code>Filter</code>，或者 servlet <code>*Listener</code> 实例都会注册到内嵌的容器中。如果你想在配置期间引用一个来自于你 <code>application.properties</code> 的值，这是极其方便的。</p>
<p>默认情况下，如果上下文仅包含一个 Servlet，则将其映射到 <code>/</code>。在多 Servlet Bean 场景下，Bean Name 用于路径前缀。过滤器映射到 <code>/*</code>。</p>
<p>如果基于约定的映射不够灵活，你可以使用 <code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>，以及 <code>ServletListenerRegistrationBean</code> 类获得完全控制。</p>
<p>通常，保持 Filter Bean 无序是安全的。如果需要特定的 order，你应该用 <code>@Order</code> 注解 <code>Filter</code> 或者使其实现 <code>Ordered</code>。你无法通过用 <code>@Order</code> 注解其 bean 方法配置 <code>Filter</code> 的 order。如果你无法更改 Filter 类以添加 <code>@Order</code> 或者实现 <code>Ordered</code>，你必须定义为该 <code>Filter</code> 定义一个 <code>FilterRegistrationBean</code> 并使用 <code>setOrder(int)</code> 方法设置注册 Bean 的 order。避免配置在 <code>Ordered.HIGEST_PRECEDENCE</code> 读取请求体的过滤器，因为它可能与你应用的字符编码配置违背。如果 Servlet filter 包装请求，则应使用小于等于 <code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code> 的 order 值。</p>
<h4 id="7-4-2-Servlet-Context-Initialization"><a href="#7-4-2-Servlet-Context-Initialization" class="headerlink" title="7.4.2. Servlet Context Initialization"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container-context-initializer">7.4.2. Servlet Context Initialization</a></h4><p>嵌入式 Servlet 容器不会直接执行 Servlet 3.0+ 的 <code>javax.servlet.ServletContainerInitializer</code> 接口或者是 Spring 的 <code>org.springframework.web.WebApplicationInitializer</code> 接口。这是一个故意的设计决定，旨在降低被设计在 war 中运行的第三方包可能破坏 Spring Boot 应用的风险。</p>
<p>如果你需要在 Spring Boot 应用中执行 Servlet Context 初始化，你应该注册一个实现了 <code>org.springframework.boot.web.servlet.ServletContextInitializer</code> 接口的 Bean。单个 <code>onStartup</code> 方法提供了对 <code>ServletContext</code> 的访问，并且如果有必要，可以轻松地用作现存的 <code>WebApplicationInitializer</code> 的适配器。</p>
<h4 id="Scanning-for-Servlets-Filters-and-listeners"><a href="#Scanning-for-Servlets-Filters-and-listeners" class="headerlink" title="Scanning for Servlets, Filters, and listeners"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-container-servlets-filters-listeners-scanning">Scanning for Servlets, Filters, and listeners</a></h4><p>当使用嵌入式容器时，可以通过使用 <code>@ServletComponentScan</code> 自动注册被 <code>@WebServlet</code>，<code>@WebFilter</code>，以及 <code>@WebListener</code> 注解的类。</p>
<h2 id="8-Graceful-shutdown"><a href="#8-Graceful-shutdown" class="headerlink" title="8. Graceful shutdown"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-graceful-shutdown">8. Graceful shutdown</a></h2><h2 id="11-Working-with-SQL-Databases"><a href="#11-Working-with-SQL-Databases" class="headerlink" title="11. Working with SQL Databases"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-sql">11. Working with SQL Databases</a></h2><p>Spring Framework 为使用 SQL 数据库提供了广泛支持，从使用 <code>JdbcTemplate</code> 直接进行 JDBC 访问，到完成 “object relational mapping” 技术，例如 Hibernate。Spring Data 提供了更多功能级别：从你的接口中直接创建 <code>Repository</code> 实现，并使用约定从你的方法名称中生成查询。</p>
<h3 id="11-1-Configure-a-DataSource"><a href="#11-1-Configure-a-DataSource" class="headerlink" title="11.1. Configure a DataSource"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-configure-datasource">11.1. Configure a DataSource</a></h3><p>Java 的 <code>javax.sql.DataSource</code> 接口提供了一种使用数据库连接的标准方法。传统上，一个 ‘DataSource’ 使用 <code>URL</code> 以及一些凭证来建立数据库连接。</p>
<h4 id="11-1-1-Embedded-Database-Support"><a href="#11-1-1-Embedded-Database-Support" class="headerlink" title="11.1.1. Embedded Database Support"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-embedded-database-support">11.1.1. Embedded Database Support</a></h4><p>通常，使用一个内存嵌入式数据库开发应用很方便。显然，内存数据库不提供持久化存储。当你的应用程序启动时，你需要填充你的数据库，并在应用结束时准备好丢掉数据。</p>
<p>Spring Boot 可以自动配置嵌入式 H2，HSQL，以及 Derby 数据库。你不需要提供任何连接 URL。你只需要对要使用的嵌入式数据库包含一个构建依赖。</p>
<h4 id="11-1-2-Connection-to-a-Production-Database"><a href="#11-1-2-Connection-to-a-Production-Database" class="headerlink" title="11.1.2. Connection to a Production Database"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-connect-to-production-database">11.1.2. Connection to a Production Database</a></h4><p>生产数据库连接也可以通过池化 <code>DataSource</code> 自动配置。Spring Boot 使用下面的算法选择特定的实现：</p>
<ol>
<li>我们更喜欢 HikariCP 的性能和并发。如果 HikariCP 可用，我们始终会选择它</li>
<li>否则，如果 Tomcat 池化 <code>DataSource</code> 可用，我们将使用它</li>
<li>如果 HikariCP 和 Tomcat 池化数据源都不可用，并且 Commons DBCP2 可用，我们会使用它</li>
</ol>
<p>如果你使用 <code>spring-boot-starter-jdbc</code> 或者 <code>spring-boot-starter-data-jpa</code> “starter”，你会自动获得 <code>HikariCP</code> 的依赖。</p>
<p>DataSource 的配置由 <code>spring.datasource.*</code> 之中的外部配置属性控制。例如，你可以在 <code>application.properties</code> 中声明如下部分：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">dbuser</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">dbpass</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>你应该至少通过设置 <code>spring.datasource.url</code> 属性来指定 URL。否则，Spring Boot 将尝试自动配置嵌入式数据库。</p>
</blockquote>
<blockquote>
<p>你通常不需要指定 <code>driver-class-name</code>，因为 Spring Boot 可以从 <code>url</code> 中推导得到大多数数据库。</p>
</blockquote>
<h3 id="11-2-Using-JdbcTemplate"><a href="#11-2-Using-JdbcTemplate" class="headerlink" title="11.2. Using JdbcTemplate"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-using-jdbc-template">11.2. Using JdbcTemplate</a></h3><p>Spring 的 <code>JdbcTemplate</code> 和 <code>NamedParameterJdbcTemplate</code> 类是自动配置的，你可以将它们直接 <code>@Autowire</code> 进自己的 Bean，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 上面的例子其实不必在构造器上加 <code>@Autowired</code>，因为这是 Spring 的默认行为</p>
</blockquote>
<h3 id="11-3-JPA-and-Spring-Data-JPA"><a href="#11-3-JPA-and-Spring-Data-JPA" class="headerlink" title="11.3. JPA and Spring Data JPA"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-jpa-and-spring-data">11.3. JPA and Spring Data JPA</a></h3><p>Java Persistence API 是一种标准技术，可以让你映射对象到关系型数据库。<code>spring-boot-starter-data-jpa</code> POM 提供了一种快速入门的方法。它提供了如下几个关键依赖：</p>
<ul>
<li>Hibernate：最流行的 JPA 实现之一</li>
<li>Spring Data JPA：帮你实现基于 JPA 的存储库</li>
<li>Spring ORM：为 Spring Framework 提供核心 ORM 支持</li>
</ul>
<h4 id="11-3-1-Entity-Classes"><a href="#11-3-1-Entity-Classes" class="headerlink" title="11.3.1. Entity Classes"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-entity-classes">11.3.1. Entity Classes</a></h4><p>传统上，JPA 实体类在 <code>persistence.xml</code> 文件中指定。使用 Spring Boot，不需要此文件，而是使用 “实体扫描”。默认情况下，在你主应用类（注解了 <code>@EnableAutoConfiguration</code> 以及 <code>@SpringBootApplication</code> 的类）下的所有包都会被搜索。</p>
<p>使用 <code>@Entity</code>，<code>@Embeddable</code>，或者 <code>@MappedSuperclass</code> 注解的类都会被纳入。一个典型的实体类类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">City</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional members, often include @OneToMany mappings</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">City</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// no-args constructor required by JPA spec</span></span><br><span class="line">        <span class="comment">// this one is protected since it shouldn&#x27;t be used directly</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">City</span><span class="params">(String name, String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... etc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-3-2-Spring-Data-JPA-Repositories"><a href="#11-3-2-Spring-Data-JPA-Repositories" class="headerlink" title="11.3.2. Spring Data JPA Repositories"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-data-jpa-repositories">11.3.2. Spring Data JPA Repositories</a></h4><p>Spring Data JPA repository 是一些接口，你可以定义其用于访问数据。JPA 查询从你的方法名称自动创建。例如，一个 <code>CityRepository</code> 接口可能声明了一个 <code>findAllByState(String state)</code> 方法，用于找到给定 state 的所有 city。</p>
<p>有关更复杂的查询，你可以使用 Spring Data 的 <code>Query</code> 注解来注解你的方法。</p>
<p>通常，Spring Data repository 从 <code>Repository</code> 或者 <code>CrudRepository</code> 接口扩展。如果你使用自动配置，将会从包含主配置类（被 <code>@EnableAutoConfiguration</code> 或者 <code>@SpringBootApplication</code> 注解的类）的包下面搜索 repository。</p>
<p>以下示例展示了一个典型的 Spring Data repository 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CityRepository</span> <span class="keyword">extends</span> <span class="title class_">Repository</span>&lt;City, Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;City&gt; <span class="title function_">findAll</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">    City <span class="title function_">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Data JPA repository 支持三种不同的自我引导模式：default，deferred，以及 lazy。要启动 deferred 或者 lazy 自启，请将分别将 <code>spring.data.jpa.repositories.bootstrap-mode</code> 属性设置为 <code>deferred</code> 或者 <code>lazy</code>。当使用 deferred 或者 lazy 引导模式时，自动配置的 <code>EntityManagerFactoryBuilder</code> 将会使用上下文的 <code>AsyncTaskExecutor</code>（如果有的话）作为引导的执行器。如果存在多个，将会使用名为 <code>applicationTaskExecutor</code> 的那个。</p>
<h3 id="11-4-Spring-Data-JDBC"><a href="#11-4-Spring-Data-JDBC" class="headerlink" title="11.4. Spring Data JDBC"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-data-jdbc">11.4. Spring Data JDBC</a></h3><p>Spring Data 包含对 JDBC 支持的 repository，并将自动为 <code>CrudRepository</code> 上的方法生成 SQL。对于更高级的查询，提供了一个 <code>@Query</code> 注解。</p>
<p>当必要的依赖在类路径上时，Spring Boot 将自动配置 Spring Data 的 JDBC repository。使用仅仅一个依赖 <code>spring-boot-starter-data-jdbc</code>，就可以将它们添加到你的项目。如果有必要，你可以通过添加 <code>@EnableJdbcRepositories</code> 注解或者 <code>JdbcConfiguration</code> 子类到你的应用来控制 Spring Data JDBC 的配置。</p>
<h3 id="11-5-Using-H2’s-Web-Console"><a href="#11-5-Using-H2’s-Web-Console" class="headerlink" title="11.5. Using H2’s Web Console"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-sql-h2-console">11.5. Using H2’s Web Console</a></h3><p>H2 数据库提供了一个基于浏览器的控制台，Spring Boot 可以为你自动配置。当满足如下条件时，将自动配置控制台：</p>
<ul>
<li>你正在开发一个基于 Servlet 的 Web 应用</li>
<li><code>com.h2database:h2</code> 在类路径</li>
<li>你正在使用 Spring Boot’s developer tools</li>
</ul>
<p>如果你没有使用 Spring Boot developer tools，但仍然希望使用 H2 的控制台，你可以配置 <code>spring.h2.console.enabled</code> 属性值为 <code>true</code></p>
<h4 id="11-5-1-Changing-the-H2-Console’s-Path"><a href="#11-5-1-Changing-the-H2-Console’s-Path" class="headerlink" title="11.5.1. Changing the H2 Console’s Path"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-sql-h2-console-custom-path">11.5.1. Changing the H2 Console’s Path</a></h4><p>默认情况下，控制台在 <code>/h2-console</code> 可以获得。你可以使用 <code>spring.h2.console.path</code> 属性自定义控制台路径。</p>
<h2 id="12-Working-with-NoSQL-Technologies"><a href="#12-Working-with-NoSQL-Technologies" class="headerlink" title="12. Working with NoSQL Technologies"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-nosql">12. Working with NoSQL Technologies</a></h2><h3 id="12-5-Elasticsearch"><a href="#12-5-Elasticsearch" class="headerlink" title="12.5. Elasticsearch"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-elasticsearch">12.5. Elasticsearch</a></h3><h3 id="12-1-Redis"><a href="#12-1-Redis" class="headerlink" title="12.1. Redis"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-redis">12.1. Redis</a></h3><h2 id="21-Quartz-Scheduler"><a href="#21-Quartz-Scheduler" class="headerlink" title="21. Quartz Scheduler"></a><a href="">21. Quartz Scheduler</a></h2><h2 id="26-Testing"><a href="#26-Testing" class="headerlink" title="26. Testing"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-testing">26. Testing</a></h2><p>Spring Boot 在测试你的应用程序时提供了许多工具和注解。由两个模块提供测试支持：<code>spring-boot-test</code> 包含核心项目，<code>spring-boot-test-autoconfigure</code> 包含测试的自动配置。</p>
<p>大多数开发者使用 <code>spring-boot-starter-test</code> “starter”，该测试不仅导入了 Spring Boot 测试模块，而且还导入了 JUnit Jupiter，AssertJ，Hamcrest，以及许多其他有用的库。</p>
<blockquote>
<p>starter 还引入了 vintage 引擎，因此你既可以运行 JUnit 4 也可以运行 JUnit 5 的测试。如果你已经将测试迁移到 JUnit 5，你应该排除 JUnit 4 的支持，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/&gt; artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-vintage-engine&lt;/&gt; artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="26-1-Test-Scope-Dependencies"><a href="#26-1-Test-Scope-Dependencies" class="headerlink" title="26.1. Test Scope Dependencies"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-test-scope-dependencies">26.1. Test Scope Dependencies</a></h3><h2 id="29-Creating-Your-Own-Auto-configuration"><a href="#29-Creating-Your-Own-Auto-configuration" class="headerlink" title="29. Creating Your Own Auto-configuration"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-developing-auto-configuration">29. Creating Your Own Auto-configuration</a></h2><h3 id="29-1-Understanding-Auto-configured-Beans"><a href="#29-1-Understanding-Auto-configured-Beans" class="headerlink" title="29.1. Understanding Auto-configured Beans"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-understanding-auto-configured-beans">29.1. Understanding Auto-configured Beans</a></h3><p>表层之下 ，使用标准 <code>@Configuration</code> 类实现自动配置。当使用自动配置时，需要使用额外的 <code>@Conditional</code> 注解进行约束。通常，自动配置类使用 <code>@ConditionalOnClass</code> 以及 <code>@ConditionalOnMissingBean</code> 注解。这样可以确保仅当找到相关的类，以及未声明自己的 <code>@Configuration</code> 时才使用自动配置。</p>
<p>你可以浏览 <code>spring-boot-autoconfigure</code> 源码，查看 Spring 提供的 <code>@Configuration</code> 类（见 <code>META-INF/spring.factories</code> 文件）。</p>
<h3 id="29-2-Locating-Auto-configuration-Candidates"><a href="#29-2-Locating-Auto-configuration-Candidates" class="headerlink" title="29.2. Locating Auto-configuration Candidates"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-locating-auto-configuration-candidates">29.2. Locating Auto-configuration Candidates</a></h3><p>Spring Boot 检查你已发布的 jar 中是否存在 <code>META-INF/spring.factories</code> 文件。该文件应在 <code>EnableAutoConfiguration</code> key 下列出你的配置类，如下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span></span><br><span class="line"><span class="string">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<h2 id="29-3-Condition-Annotations"><a href="#29-3-Condition-Annotations" class="headerlink" title="29.3. Condition Annotations"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-condition-annotations">29.3. Condition Annotations</a></h2><h3 id="29-3-1-Class-Conditions"><a href="#29-3-1-Class-Conditions" class="headerlink" title="29.3.1. Class Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-class-conditions">29.3.1. Class Conditions</a></h3><ul>
<li>@ConditionalConClass</li>
<li>@ConditionalOnMissingClass</li>
</ul>
<h3 id="29-3-2-Bean-Conditions"><a href="#29-3-2-Bean-Conditions" class="headerlink" title="29.3.2. Bean Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-bean-conditions">29.3.2. Bean Conditions</a></h3><ul>
<li>@ConditionalOnBean</li>
<li>@ConditionalOnMissingBean</li>
</ul>
<h3 id="29-3-3-Property-Conditions"><a href="#29-3-3-Property-Conditions" class="headerlink" title="29.3.3. Property Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-property-conditions">29.3.3. Property Conditions</a></h3><ul>
<li>@ConditionalOnProperty</li>
</ul>
<h3 id="29-3-4-Resource-Conditions"><a href="#29-3-4-Resource-Conditions" class="headerlink" title="29.3.4. Resource Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-resource-conditions">29.3.4. Resource Conditions</a></h3><ul>
<li>@ConditionalOnResource</li>
</ul>
<h3 id="29-3-5-Web-Application-Conditions"><a href="#29-3-5-Web-Application-Conditions" class="headerlink" title="29.3.5. Web Application Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-web-application-conditions">29.3.5. Web Application Conditions</a></h3><ul>
<li>@ConditionalOnWebApplication</li>
<li>@ConditionalOnNotWebApplication</li>
</ul>
<h3 id="29-3-6-SpEL-Expression-Conditions"><a href="#29-3-6-SpEL-Expression-Conditions" class="headerlink" title="29.3.6. SpEL Expression Conditions"></a><a href="https://docs.spring.io/spring-boot/docs/2.3.12.RELEASE/reference/html/spring-boot-features.html#boot-features-spel-conditions">29.3.6. SpEL Expression Conditions</a></h3>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework Web Servlet</title>
    <url>/2022/05/09/Spring-Web-Servlet/Spring-Framework-Web-Servlet/</url>
    <content><![CDATA[<h1 id="Web-on-Servlet-Stack"><a href="#Web-on-Servlet-Stack" class="headerlink" title="Web on Servlet Stack"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html">Web on Servlet Stack</a></h1><h2 id="1-Spring-Web-MVC"><a href="#1-Spring-Web-MVC" class="headerlink" title="1. Spring Web MVC"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc">1. Spring Web MVC</a></h2><p>Spring Web MVC 是基于 Servlet API 的原始 Web 框架，从很早的时候就包含在 Spring Framework 之中。正式名称 —— Spring Web MVC，来源于它的源模块名称（<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a>），但通常称之为 “Spring MVC”。</p>
<p>与 Spring Web MVC 平行，Spring Framework 5.0 引入了一个响应式栈 web 框架，其名称为 “Spring WebFlux”，也是基于其源模块（<a href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a>）。本节涵盖 Spring Web MVC。<a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web-reactive.html#spring-web-reactive">下一节</a>涵盖 Spring WebFlux。</p>
<p>有关基线信息以及与 Servlet 容器和 Java EE 版本范围的兼容性，请参见 Spring Framework <a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">Wiki</a>。</p>
<h3 id="1-1-DispatcherServlet"><a href="#1-1-DispatcherServlet" class="headerlink" title="1.1. DispatcherServlet"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet">1.1. DispatcherServlet</a></h3><p><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web-reactive.html#webflux-dispatcher-handler">WebFlux</a></p>
<p>与许多其他 Web 框架一样，Spring MVC 围绕着前端控制器模式设计，其中首要的 <code>Servlet</code> —— <code>DispatcherServlet</code> 为请求处理提供了一组共享的算法，而实际的工作则由可配置的代理组件执行。这种模型灵活，并且支持各种工作流。</p>
<blockquote>
<p><strong>作者的话</strong> 简单来说，<code>DispatcherServlet</code> 为所有请求提供统一的处理流程（<code>doDispatch</code>），但是细节部分由各个组件实现，而且并不是每个组件在处理每个请求时都会发挥作用。</p>
</blockquote>
<p>正如任何 <code>Servlet</code> 一样，<code>DispatcherServlet</code> 也需要根据 Servlet 规范进行声明以及映射（路径），可以通过 Java 配置或者在 <code>web.xml</code> 中声明以及映射。反过来，<code>DispatcherServlet</code> 使用 Spring 配置，去发现它所需要的委托组件，比如用于请求映射，视图解析，异常处理的组件，等等。</p>
<p>下面是有关于 Java 配置注册以及初始化 <code>DispatcherServlet</code> 的示例，这会被 Servlet 容器自动检测（参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-container-config">Servlet Config</a>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext servletContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load Spring web application configuration</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        context.register(AppConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create and register the DispatcherServlet</span></span><br><span class="line">        <span class="type">DispatcherServlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(context);</span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> servletContext.addServlet(<span class="string">&quot;app&quot;</span>, servlet);</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/app/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了直接使用 ServletContext API，你还可以继承 <code>AbstractAnnotationConfigDispatcherServletInitializer</code> 并覆盖特定的方法（见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-context-hierarchy">Context Hierarchy</a> 下面的例子）。</p>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> 不必太关心这里，只有基于外部容器部署的时候才会加载 <code>WebApplicationInitializer</code></p>
</blockquote>
<p>以下示例是 <code>web.xml</code> 配置注册以及初始化 <code>DispatcherServlet</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span><span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring Boot 遵循一种不同的初始化顺序。Spring Boot 并不是直接挂载到 Servlet 容器的生命周期，而是使用 Spring 配置来引导自身以及内嵌的 Servlet 容器。<code>Filter</code> 和 <code>Servlet</code> 的声明以 Spring 配置的方式被检测到，并注册到 Servlet 容器。</p>
</blockquote>
<h4 id="1-1-1-Context-Hierarchy"><a href="#1-1-1-Context-Hierarchy" class="headerlink" title="1.1.1. Context Hierarchy"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-container-config">1.1.1. Context Hierarchy</a></h4><p><code>DispatcherServlet</code> 期望一个 <code>WebApplicationContext</code>（继承于简单 <code>ApplicationContext</code>） 用于自己的配置。<code>WebApplicationContext</code> 持有 <code>ServletContext</code> 的引用，并且持有相关的 <code>Servlet</code> 的引用。<code>WebApplicationContext</code> 也会绑定到 <code>ServletContext</code>，以便于应用程序在需要的时候可以通过 <code>RequestContextUtiles</code> 的静态方法找到 <code>WebApplicationContext</code>。</p>
<blockquote>
<p><strong>作者的话</strong> 上面这句话简单来看就是 <code>WebApplicationContext</code> 和 <code>ServletContext</code> 相互引用。<code>ServletContext</code> 绑定 <code>WebApplicationContext</code> 方式是设置为请求的属性。</p>
</blockquote>
<p>对于许多应用程序而言，具有单个的 <code>WebApplicationContext</code> 是简易且足够用了。也有可能，有一种上下文结构，其中，根 <code>WebApplicationContext</code> 被多个 <code>DispatcherServlet</code> 实例共享（或者其他 <code>Servlet</code>），每个 <code>Servlet</code> 又有自己的子 <code>WebApplicationContext</code> 配置。有关上下文层次结构功能的更多信息，请参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-introduction"> Additional Capabilities of the <code>ApplicationContext</code></a></p>
<p>root <code>WebApplicationContext</code> 通常包含基于架构 Bean，例如数据仓库和业务服务，它们需要在多个 <code>Servlet</code> 实例上共享。这些 Bean 被有效继承，并且可以在特定于 Servlet 的子 <code>WebApplicationContext</code> 中覆盖，这通常包含给定的本地 <code>Servlet</code> Bean。下图展示了这种关系：</p>
<img src="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/images/mvc-context-hierarchy.png">

<p>下面的示例配置了一个 <code>WebApplicationContext</code> 层次结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; RootConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; App1Config.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/app1/*&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不需要应用程序上下文的层次结构，应用程序可以通过 <code>getRootConfigClasses()</code> 返回所有的配置，并且在 <code>getServletConfigClasses()</code> 返回 <code>null</code>。</p>
</blockquote>
<p>下面示例展示了 <code>web.xml</code> 的等价物：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/root-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/app1-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>app1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app1/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果应用程序不需要上下文层次结构，则可以仅仅配置 “root” 上下文，并保持 <code>contextConfigLocation</code> Servlet 参数为空。</p>
</blockquote>
<h4 id="1-1-2-Special-Bean-Types"><a href="#1-1-2-Special-Bean-Types" class="headerlink" title="1.1.2. Special Bean Types"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-special-bean-types">1.1.2. Special Bean Types</a></h4><p><code>DispatcherServlet</code> 委托特殊的 bean 来处理请求并给予合适的响应。具体见官网列表。</p>
<p>下面的表格列出了由 <code>DispatcherServlet</code> 检测的特殊 bean：</p>
<table>
<thead>
<tr>
<th align="left">Bean Type</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>HandlerMapping</code></td>
<td align="left">将请求映射到 handler，以及前置处理拦截器和后置处理拦截器的列表。该映射基于某些规则，其中的细节随着 <code>HandlerMapping</code> 的实现有所不同。<br><br>两个主要的 <code>HandlerMapping</code> 的实现类：<br>(1) <code>RequestMappingHandlerMapping </code>，它支持 <code>@RequestMapping</code> 注解方法<br>(2) <code>SimpleUrlHandlerMapping</code>，它维护 URI 路径模式到 handler 的显式注册</td>
</tr>
<tr>
<td align="left"><code>HandlerAdapter</code></td>
<td align="left">帮助 <code>DispatcherServlet</code> 调用映射到请求的 handler，不管 handler 实际是如何调用。例如，调用注解式控制器需要解析注解。<code>HandlerAdapter</code> 的主要目的是防止 <code>DispatcherServlet</code> 受此类细节的影响</td>
</tr>
<tr>
<td align="left"><code>HandlerExceptionResolver</code></td>
<td align="left">解析异常的策略，可能会将它们映射到 handler，html 错误视图，或者其他目标</td>
</tr>
<tr>
<td align="left"><code>ViewResolver</code></td>
<td align="left">从 handler 返回的基于字符串的逻辑视图名称解析为要呈现给响应的实际视图</td>
</tr>
<tr>
<td align="left"><code>LocaleResolver</code>,<a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-timezone">LocaleContextResolver</a></td>
<td align="left">解析客户端正在使用的 <code>Locale</code> 以及可能的时区，以便能提供国际化的视图。参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-localeresolver">Locale</a></td>
</tr>
<tr>
<td align="left"><code>ThemeResolver</code></td>
<td align="left">解析你的 Web 应用程序可以使用的主题</td>
</tr>
<tr>
<td align="left"><code>MultipartResolver</code></td>
<td align="left">在某些 multipart 解析库的帮助下，用于解析 multi-part 请求（例如，浏览器表单文件上传）。请参阅 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-multipart">Multipart Resolver</a></td>
</tr>
<tr>
<td align="left"><code>FlashMapManager</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="1-1-3-Web-MVC-Config"><a href="#1-1-3-Web-MVC-Config" class="headerlink" title="1.1.3. Web MVC Config"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-config">1.1.3. Web MVC Config</a></h4><p>应用程序可以声明一些在 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-special-bean-types">Special Bean Types</a> 列出的基础架构的 Bean，需要这些 Bean 来处理请求。<code>DispatcherServlet</code> 会为每个特殊 Bean 检查 <code>WebApplicationContext</code>。如果没有匹配的 Bean 类型，则会回退到使用 <code>DispatcherServlet.properties</code> 列出的默认 bean。</p>
<p>大多数情况下，MVC Config 是最佳出发点。它以 Java 或者 XML 的方式声明了需要的 bean，并且提供了更高级配置回调 API 用于自定义。</p>
<blockquote>
<p><strong>作者的话</strong> MVC Config 是官方术语，代表 Spring MVC 提供的默认配置，可以是注解式启用，也可以是 XML 方式启用，具体来说就是 <code>@EnableWebMvc</code> 和 <code>&lt;mvc:annotation-driven/&gt;</code></p>
</blockquote>
<blockquote>
<p>Spring Boot 依赖于 MVC Java Config 配置 Spring MVC，以及提供了许多额外的便利选项</p>
</blockquote>
<h4 id="1-1-4-Servlet-Config"><a href="#1-1-4-Servlet-Config" class="headerlink" title="1.1.4. Servlet Config"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-container-config">1.1.4. Servlet Config</a></h4><blockquote>
<p><strong>作者的话</strong> 对于 Spring Boot 来说，<code>DispatcherServlet</code> 是自动配置的，而且 Servlet 容器也是在 <code>ApplicationContext</code> 进行 <code>refresh</code> 的过程中内嵌启动的，所以这一节可以简单了解</p>
</blockquote>
<p>在 Servlet 3.0+ 环境下，你可以选择使用编程方式作为一种替代方案进行 Servlet 容器配置，或者你也可以与 <code>web.xml</code> 方式组合使用。如下是注册一个 <code>DispatcherServlet</code> 的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebApplicationInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext container)</span> &#123;</span><br><span class="line">        <span class="type">XmlWebApplicationContext</span> <span class="variable">appContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlWebApplicationContext</span>();</span><br><span class="line">        appContext.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.<span class="type">Dynamic</span> <span class="variable">registration</span> <span class="operator">=</span> container.addServlet(<span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(appContext));</span><br><span class="line">        registration.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registration.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WebApplicationInitializer</code> 是由 Spring MVC 提供的接口，可以确保检测到你的实现类并用于初始化任何 Servlet 3 容器。<code>WebApplicationInitializer</code> 的一个实现类（抽象基类）是 <code>AbstractDispatcherServletInitializer</code>，你可以通过覆盖父类方法指定 Servlet 映射以及 <code>DispatcherServlet</code> 配置的路径使得注册 <code>DispatcherServlet</code> 更加容易。</p>
<p>应用程序使用基于 Java 的 Spring 配置如下示例所示，这也是官方建议的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; MyWebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用基于 XML 的 Spring 配置，则应该直接从 <code>AbstractDispatcherServletInitializer</code> 继承下来，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XmlWebApplicationContext</span> <span class="variable">cxt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlWebApplicationContext</span>();</span><br><span class="line">        cxt.setConfigLocation(<span class="string">&quot;/WEB-INF/spring/dispatcher-config.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;/&quot;</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractDispatcherServletInitializer</code> 还提供了一种添加 <code>Filter</code> 实例，并将其自动映射到 <code>DispatcherServlet</code> 的简便方法，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[] &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>(), <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加的每个过滤器都会基于其具体类型有一个默认名字，并自动映射到 <code>DispatcherServlet</code>。</p>
<blockquote>
<p><strong>作者的话</strong> 将 <code>Filter</code> 映射到 <code>DispatcherServlet</code> 的方式是通过 Servlet API <code>javax.servlet.FilterRegistration#addMappingForServletNames</code> 实现的</p>
</blockquote>
<p><code>AbstractDispatcherServletInitializer</code> 的 protected 方法 <code>isAsyncSupported</code> 提供了一个地方可以在 <code>DispatcherServlet</code> 上启用异步支持，并且所有过滤器都会映射到它上面。默认地，这个标志位是 <code>true</code></p>
<p>最后，如果你需要进一步自定义 <code>DispatcherServlet</code> 本身，你可以直接覆盖 <code>createDispatcherServlet</code> 方法。</p>
<h4 id="1-1-5-Processing"><a href="#1-1-5-Processing" class="headerlink" title="1.1.5. Processing"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-servlet-sequence">1.1.5. Processing</a></h4><p><code>DispatcherServlet</code> 处理过程如下：</p>
<ul>
<li><p>搜索 <code>WebApplicationContext</code> 并将其绑定到 Request 的属性上，处理过程中控制器和其他元素可能会使用到。默认绑定到 <code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> key 上。</p>
</li>
<li><p>将 locale resolver 绑定到 Request 的属性上，以便于当处理请求的过程中让其他元素解析本地化使用。如果你不需要本地化解析，你就不必使用 locale resolver。</p>
</li>
<li><p>将主题解析器绑定到请求，以使视图之类的元素确定用何种主题。如果你不使用主题，可以忽略它。</p>
</li>
<li><p>如果你指定了一个 multipart 文件解析器，将会检查请求的 multiparts。如果找到了 multiparts，请求会被包装成 <code>MultipartHttpServletRequest</code>，用于过程后期其他元素的处理。</p>
</li>
<li><p>搜索合适的 handler。如果找到了一个 handler，与该 handler 有关的执行链（前置处理器、后置处理器、控制器）将会运行，用于准备 model 的渲染。或者，对于注解式控制器，响应可以直接渲染（在 <code>HandlerAdapter</code>）而不是返回一个视图。</p>
</li>
<li><p>如果返回的是 model，视图就会被渲染。如果没有返回 model（可能由于前置处理器或者后置处理器拦截了请求，可能是因为安全问题），就不会渲染视图，因为请求已经完成了。</p>
</li>
</ul>
<p>声明在 <code>WebApplicationContext</code> 的 <code>HandlerExceptionResolver</code> bean 用于解析请求处理过程中抛出的异常。允许自定义异常处理器的逻辑用于处理异常。</p>
<p><code>DispatcherServlet</code> 还支持返回 <code>last-modification-date</code>，正如 Servlet API 指定的。确定特定请求的最后一次修改日期很简单：<code>DispatcherServlet</code> 寻找合适的 handler mapping，并检测被找到的 handler 是否实现了 <code>LastModified</code> 接口。如果是，接口 <code>LastModified</code> 的方法 <code>long getLastModified(request)</code> 的值就会返回给客户端。</p>
<blockquote>
<p><strong>作者的话</strong> 注解式 Controller 想要实现最后一次修改日期需要做一些特殊操作，因为 <code>RequestMappingHandlerAdapter</code> 的 <code>getLastModified</code> 总是返回 -1，但源码方法注解也给了我们指引，需要在 handler 中调用 <code>WebRequest#checkNotModified(long)</code>，如果返回值是 true，则返回 <code>null</code></p>
</blockquote>
<p>你可以通过在 <code>web.xml</code> 文件中添加 Servlet 初始化参数到 Servlet 声明中来自定义一个自己 <code>DispatcherServlet</code>。以下列表列出了支持的参数：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>contextClass</code></td>
<td align="left">实现了 <code>ConfigurableWebApplicationContext</code> 的类，将由此 Servlet 进行实例化与本地配置。默认地，使用 <code>XmlWebApplicationContext</code>。</td>
</tr>
<tr>
<td align="left"><code>contextConfigLocation</code></td>
<td align="left">传递给上下文实例的字符串，标识从哪里寻找上下文。</td>
</tr>
<tr>
<td align="left"><code>namespace</code></td>
<td align="left"><code>WebApplicationContext</code>的命名空间。默认是 <code>[servlet-name]-servlet</code></td>
</tr>
<tr>
<td align="left"><code>throwExceptionIfNoHandlerFound</code></td>
<td align="left">当找不到请求的 handler 时，是否抛出异常</td>
</tr>
</tbody></table>
<h4 id="1-1-6-Interception"><a href="#1-1-6-Interception" class="headerlink" title="1.1.6. Interception"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-handlermapping-interceptor">1.1.6. Interception</a></h4><p>所有的 <code>HandlerMapping</code> 实现类都支持 handler 拦截器，这很有用，比如你希望将某些特定的功能应用于某些请求，举个例子，检查 principal。</p>
<p>拦截器必须实现 <code>org.springframework.web.servlet.HandlerInterceptor</code> 接口，它提供了三个方法，应该可以足够灵活地执行各种前置处理以及后置处理操作。</p>
<ul>
<li><code>preHandle(..)</code>: 在实际的 handler 运行之前</li>
<li><code>postHandle(..)</code>: 在实际的 handler 运行之后</li>
<li><code>afterCompletion(..)</code>: 在完整的请求结束之后</li>
</ul>
<p><code>preHandle(..)</code> 方法返回一个 boolean 值。你可以使用此方法 break 或者 continue 执行链的执行。当方法返回 <code>true</code>，handler 执行链就会继续；当方法返回 <code>false</code>，<code>DispatcherServlet</code> 会认为拦截器本身已经处理了请求（例如，渲染了恰当的视图），并且不会继续执行其他拦截器以及实际的 handler。</p>
<p>请注意，当具有 <code>@ResponseBody</code> 以及 <code>ResponseEntity</code> 的时候，<code>postHandle</code> 没什么用，因为在 <code>postHandle</code> 之前响应就会在 <code>HandlerAdapter</code> 中写入并提交了。这意味着，对响应进行任何更改为时已晚，例如添加额外的 header 都是无用的。对于这种情况，你可以实现 <code>ResponseBodyAdvice</code>，并将它声明为一个 <code>Controller Advice</code> bean，或者，你也可以直接在 <code>RequestMappingHandlerAdapter</code> 上直接配置。</p>
<h4 id="1-1-7-Exceptions"><a href="#1-1-7-Exceptions" class="headerlink" title="1.1.7. Exceptions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers">1.1.7. Exceptions</a></h4><p>如果请求 mapping 期间或者请求 handler（如 @Controller）抛出异常，则 DispatcherServlet 将委托给 HandlerExceptionResolver 链解析异常，并提供可替代的处理，这是典型的错误响应。</p>
<blockquote>
<p><strong>作者的话</strong> 其实就是 try catch 模式，catch 中处理异常</p>
</blockquote>
<p>以下表格列出了可用的 <code>HandlerExceptionResolver</code> 实现类：</p>
<table>
<thead>
<tr>
<th align="left"><code>HandlerExceptionResolver</code></th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>SimpleMappingExceptionResolver</code></td>
<td align="left">异常类名于错误视图名之间的映射。</td>
</tr>
<tr>
<td align="left"><code>DefaultHandlerExceptionResolver</code></td>
<td align="left">解析 Spring MVC 的异常，并将它们映射到 HTTP 状态码</td>
</tr>
<tr>
<td align="left"><code>ResponseStatusExceptionResolver</code></td>
<td align="left">用 <code>@ResponseStatus</code> 注解解析异常，并根据注解中的值将其映射到 HTTP 状态码</td>
</tr>
<tr>
<td align="left"><code>ExceptionHandlerExceptionResolver</code></td>
<td align="left">通过调用 <code>@Controller</code> 或者 <code>@ControllerAdvice</code> 中的 <code>@ExceptionHandler</code> 方法解析异常</td>
</tr>
</tbody></table>
<p><code>HandlerExceptionResolver</code> 的约定规定它可以返回：</p>
<ul>
<li>一个指向错误视图的 <code>ModelAndView</code></li>
<li>如果在解析器处理了异常，则是一个空的 <code>ModelAndView</code></li>
<li>如果异常仍然未解析，则返回 null，后面的解析器继续尝试，如果最后仍然未解析，可以冒泡到 Servlet 容器</li>
</ul>
<p>MVC Config 自动地为默认的 Spring MVC 异常，<code>@ResponseStatus</code> 注解异常，以及 <code>@ExceptionHandler</code> 方法的支持声明了内置的解析器。你可以自定义或者替换它们。</p>
<h5 id="Chain-of-Resolvers"><a href="#Chain-of-Resolvers" class="headerlink" title="Chain of Resolvers"></a>Chain of Resolvers</h5><p>可以通过 HandlerExceptionResolver 在 Spring 配置中声明多个 bean 并根据需要设置他们的 order 属性。order 越高，异常处理器位置越靠后（越晚处理）。</p>
<p>HandlerExceptionResolver 约定可以返回如下：</p>
<ul>
<li>ModelAndView 跳转到错误页面</li>
<li>如果在解析器里处理了异常，则可以返回一个空的 ModelAndView </li>
<li>如果异常仍未处理，则返回 null，供后续解析器继续尝试，如果异常一直存在，允许冒泡到 Servlet 容器。</li>
</ul>
<h5 id="Container-Error-Page"><a href="#Container-Error-Page" class="headerlink" title="Container Error Page"></a>Container Error Page</h5><p>如果没有任何 <code>HandlerExceptionResolver</code> 处理异常，那么就会传播出去，或者如果响应状态为错误状态（即 4xx, 5xx），那么 Servlet 容器会在 HTML 中渲染默认的错误页面。要自定义容器的默认错误页面，可以在 <code>web.xml</code> 声明一个错误页面映射，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>给定之前的例子，当异常向上冒泡或者响应具有一个错误状态，Servlet 容器会将错误派发到配置的 URL（例如，<code>/error</code>）。接着，由 <code>DispatcherServlet</code> 处理，可能将其映射到一个 <code>@Controller</code>，其实现可以返回一个带有 model 的错误视图名，或者返回一个 JSON 响应，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/error&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;status&quot;</span>, request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>));</span><br><span class="line">        map.put(<span class="string">&quot;reason&quot;</span>, request.getAttribute(<span class="string">&quot;javax.servlet.error.message&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-11-Multipart-Resolver"><a href="#1-1-11-Multipart-Resolver" class="headerlink" title="1.1.11. Multipart Resolver"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-multipart">1.1.11. Multipart Resolver</a></h4><p><code>org.springframework.web.multipart.MultipartResolver</code> 是解析包含文件上传的 multipart 请求的策略接口。</p>
<ul>
<li>其中一个实现是基于 Commons FileUpload 框架</li>
<li>另一个是基于 Servlet 3.0 multipart 请求解析</li>
</ul>
<h5 id="Apache-Commons-FileUpload"><a href="#Apache-Commons-FileUpload" class="headerlink" title="Apache Commons FileUpload"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-multipart-resolver-commons">Apache Commons FileUpload</a></h5><p>为了使用 Apache 的 Commons FileUpload：</p>
<ul>
<li>配置一个 <code>CommonsMultipartResolver</code>，名称任意，如：<code>multipartResolver</code></li>
<li>添加 <code>commons-fileupload</code> 依赖</li>
</ul>
<h5 id="Servlet-3-0"><a href="#Servlet-3-0" class="headerlink" title="Servlet 3.0"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-multipart-resolver-standard">Servlet 3.0</a></h5><h3 id="1-2-Filters"><a href="#1-2-Filters" class="headerlink" title="1.2. Filters"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#filters">1.2. Filters</a></h3><h4 id="1-2-1-Form-Data"><a href="#1-2-1-Form-Data" class="headerlink" title="1.2.1. Form Data"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#filters-http-put">1.2.1. Form Data</a></h4><p>浏览器只能通过 HTTP GET 或者 HTTP POST 提交表单数据，但是，非浏览器的客户端（比如 Postman）还可以使用 HTTP PUT, PATCH, DELETE 等。Servlet API 规定：<code>ServletRequest.getParameter*()</code> 系列方法仅仅支持访问 HTTP POST 的表单字段。</p>
<p><code>spring-web</code> 模块提供了 <code>FormContentFilter</code>，拦截 Content Type 为 <code>application/x-www-form-urlencoded</code> 的 HTTP PUT, PATCH, DELETE 请求，读取请求体的表单数据，然后将 <code>ServletRequest</code> 进行一层包装，接着就可以通过 <code>ServletRequest.getParameter*()</code> 系列方法直接访问表单数据了。</p>
<h4 id="1-2-2-Forwarded-Headers"><a href="#1-2-2-Forwarded-Headers" class="headerlink" title="1.2.2. Forwarded Headers"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#filters-forwarded-headers">1.2.2. Forwarded Headers</a></h4><p>当请求通过代理（例如，负载均衡器）时，主机，端口号，以及 schema 可能会更改，这使得形成一个指向用户正确的主机，端口和 schema 的连接比较困难。</p>
<p>RFC 7239 定义了 <code>Forwarded</code> HTTP 头部，代理可以用它来提供关于原始请求的信息。还有一些其他的非标准头部，包括 <code>X-Forwarded-Host</code>, <code>X-Forwarded-Port</code>, <code>X-Forwarded-Proto</code>, <code>X-Forwared-Ssl</code>, 以及 <code>X-Forwarded-Prefix</code>。</p>
<p><code>ForwardedHeaderFilter</code> 是一个 Servlet 过滤器，它可以修改请求：a) 基于<code>Forwarded</code> 头部的主机，端口号，以及 schema；b) 删除这些头部，防止影响后期。该过滤器依赖于包装请求，因此，必须排在其他过滤器（如 <code>RequestContextFilter</code>）之前，它应该与修改后的，而不是原始请求一起使用。</p>
<p>由于应用程序并不知道 header 是否由代理（这是预期的），还是由恶意客户端添加的，因此有必要对于 <code>Forwared</code> 头部做一些安全考虑。这就是为什么在信任边界上（最外层）的代理应该做一层配置，去删除那些从外部传来的不信任的 <code>Forwarded</code> 头部。你还可以给 <code>ForwardedHeaderFilter</code> 配置 <code>removeOnly=true</code>，这种情况下，它会删除不使用这些头部。</p>
<h4 id="1-2-4-CORS"><a href="#1-2-4-CORS" class="headerlink" title="1.2.4. CORS"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#filters-cors">1.2.4. CORS</a></h4><p>Spring MVC 通过控制器的注解，为 CORS 配置提供了细粒度的支持。但是，当你和 Spring Security 一起使用时，建议依赖于内置的 <code>CorsFilter</code>，它必须排在 Spring Security 的过滤器链之前。</p>
<h3 id="1-3-Annotated-Controllers"><a href="#1-3-Annotated-Controllers" class="headerlink" title="1.3. Annotated Controllers"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-controller">1.3. Annotated Controllers</a></h3><p>Spring MVC 提供了一个基于注解的编程模型，其中 <code>@Controller</code> 和 <code>@RestController</code> 组件用注解来表示请求的映射、请求的输入、异常的处理等。</p>
<p>被注解的控制器具有灵活的方法签名（即方法名、参数个性化定制），不必扩展基类也不必实现特定接口。</p>
<p>以下例子展示了一个由注解定义的控制器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，该方法接受 <code>Model</code> 并将视图名称以 <code>String</code> 形式返回。</p>
<h4 id="1-3-1-Declaration"><a href="#1-3-1-Declaration" class="headerlink" title="1.3.1. Declaration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-controller">1.3.1. Declaration</a></h4><p>你可以在 Servlet 的 <code>WebApplicationContext</code> 中使用标准的 Spring Bean definition 来定义控制器 bean。<code>@Controller</code> 注解允许自动检测，这与 Spring 通用支持检测类路径中的 <code>@Component</code> 类并自动注册 bean definition 是一致的。<code>@Controller</code> 还充当注解类的刻板印象，表示其作为 Web 组件。</p>
<blockquote>
<p>刻板印象是译词，表示该注解具有特定语义。</p>
</blockquote>
<h4 id="1-3-2-Request-Mapping"><a href="#1-3-2-Request-Mapping" class="headerlink" title="1.3.2. Request Mapping"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping">1.3.2. Request Mapping</a></h4><p>你可以使用 <code>@RequestMapping</code> 注解将请求映射到控制器方法。该注解有各种属性去映射，如：URL、HTTP 方法、请求参数、请求头、媒体类型。你可以在类级别使用它来表示共享映射或者在特定方法级别上使用来缩小到特定的端点映射。</p>
<p>还有一些 <code>@RequestMapping</code> 的特定快捷变体：</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>快捷变体是自定义注解，因为，大多数控制器方法应该映射到特定的 HTTP 方法，而不是使用 <code>@RequestMapping</code>。在类级别，仍然需要 <code>@RequestMapping</code> 来表示共享映射。</p>
<blockquote>
<p>默认地，<code>@RequestMapping</code> 与所有 HTTP 方法适配。</p>
</blockquote>
<h5 id="URI-patterns"><a href="#URI-patterns" class="headerlink" title="URI patterns"></a>URI patterns</h5><table>
<thead>
<tr>
<th><div style="width: 120px">Pattern</div></th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>?</code></td>
<td>匹配一个字符</td>
<td><code>&quot;/pages/t?st.html&quot;</code><br>匹配 <code>&quot;/pages/test.html&quot;</code> <br> <code>&quot;/pages/t3st.html&quot;</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>匹配零个或多个字符</td>
<td><code>&quot;/resources/*.png&quot;</code><br>匹配 <code>&quot;/resources/file.png&quot;</code><br><br><code>&quot;/projects/*/versions&quot;</code><br>匹配 <code>&quot;/projects/spring/versions&quot;</code>，<br>但不匹配 <code>&quot;/projects/spring/boot/versions&quot;</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td>匹配零个或多个路径段，直到路径结束</td>
<td><code>&quot;/resources/**&quot;</code><br>匹配 <code>&quot;/resources&quot;</code> <br> <code>&quot;/resources/file.png&quot;</code> <br> <code>&quot;/resources/images/file.png&quot;</code></td>
</tr>
<tr>
<td><code>&#123;name&#125;</code></td>
<td>匹配一条路径段，并将其捕获为名为 “name” 的变量</td>
<td><code>&quot;/projects/&#123;project&#125;/versions&quot;</code><br>匹配 <code>&quot;/projects/spring/versions&quot;</code>，并捕获 <code>project=spring</code></td>
</tr>
<tr>
<td><code>&#123;name:[a-z]+&#125;</code></td>
<td>匹配正则表达式 <code>&quot;[a-z]+&quot;</code> 作为名为 “name” 的路径变量</td>
<td><code>&quot;/projects/&#123;project:[a-z]+&#125;/versions&quot;</code><br>匹配 <code>&quot;/projects/spring/versions&quot;</code>，<br>但不匹配 <code>&quot;/projects/spring1/versions&quot;</code></td>
</tr>
</tbody></table>
<h4 id="1-3-3-Handler-Methods"><a href="#1-3-3-Handler-Methods" class="headerlink" title="1.3.3. Handler Methods"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-methods">1.3.3. Handler Methods</a></h4><p><code>@RequestMapping</code> 处理器方法具有灵活的签名，可以从一系列支持的控制器方法参数和返回值中进行选择。</p>
<h5 id="Method-Arguments"><a href="#Method-Arguments" class="headerlink" title="Method Arguments"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments">Method Arguments</a></h5><table>
<thead>
<tr>
<th>Controller method argument</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>WebRequest</code>,<code>NativeWebRequest</code></td>
<td>无需直接使用 Servlet API，对请求参数、请求属性、会话属性的通用访问</td>
</tr>
<tr>
<td><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td>
<td>选择任何特定的请求或相应类型，例如，<code>ServletRequest</code>, <code>HttpServletRequest</code>, 或者 Spring 的 <code>MultipartRequest</code>, <code>MultipartHttpServletRequest</code></td>
</tr>
<tr>
<td><code>javax.servlet.http.HttpSession</code></td>
<td>强制 Session 必须存在。因此，该参数不可能是 null。注意，Session 访问不是线程安全的。如果允许多个请求可以同时访问会话，考虑设置 <code>RequestMappingHandlerAdapter</code> 实例的 <code>synchronizeOnSession</code> 标志位为 tue</td>
</tr>
<tr>
<td><code>javax.servlet.http.PushBuilder</code></td>
<td></td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td></td>
</tr>
<tr>
<td><code>HttpMethod</code></td>
<td>请求的 HTTP 方法</td>
</tr>
<tr>
<td><code>java.util.Locale</code></td>
<td>当前请求的语言环境，由可用的最准确的 <code>LocaleResolver</code> 决定（配置的 <code>LocaleResolver</code> 或者 <code>LocaleContextResolver</code></td>
</tr>
<tr>
<td><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td>
<td></td>
</tr>
<tr>
<td><code>java.io.InputStream</code>,<code>java.io.Reader</code></td>
<td>通过 Servlet API 访问暴露的原始请求体</td>
</tr>
<tr>
<td><code>java.io.OutputStream</code>,<code>java.io.Writer</code></td>
<td>通过 Servlet API 访问暴露的原始响应体</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>用于访问 URI 模板变量</td>
</tr>
<tr>
<td><code>@MatrixVariable</code></td>
<td></td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>用于访问 Servlet 请求参数，包括 multipart 文件</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>用于访问请求头</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>用于访问 cookie</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>用于访问 HTTP 请求体</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code></td>
<td></td>
</tr>
<tr>
<td><code>@RequestPart</code></td>
<td>用于访问 <code>multipart/form-data</code> 请求中的 part</td>
</tr>
<tr>
<td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td>
<td></td>
</tr>
<tr>
<td><code>RedirectAttributes</code></td>
<td></td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td></td>
</tr>
<tr>
<td><code>Errors</code>,<code>BindingResult</code></td>
<td></td>
</tr>
<tr>
<td><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td>
<td></td>
</tr>
<tr>
<td><code>UriComponentsBuilder</code></td>
<td></td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td></td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td></td>
</tr>
<tr>
<td>Any other argument</td>
<td></td>
</tr>
</tbody></table>
<h5 id="Return-Values"><a href="#Return-Values" class="headerlink" title="Return Values"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types">Return Values</a></h5><table>
<thead>
<tr>
<th>Controller method return value</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>@ResponseBody</code></td>
<td>返回值通过 <code>HttpMessageConverter</code> 实现类进行转换，并写入响应中</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code>,<code>ResponseEntity&lt;B&gt;</code></td>
<td>指定完整的响应（包括 HTTP 响应头以及响应体），将通过 <code>HttpMessageConverter</code> 实现类转换，并写入响应</td>
</tr>
<tr>
<td><code>HttpHeaders</code></td>
<td>用于返回一个只有响应头，没有响应体的 response</td>
</tr>
<tr>
<td><code>String</code></td>
<td>视图名…</td>
</tr>
<tr>
<td><code>View</code></td>
<td></td>
</tr>
</tbody></table>
<h5 id="Type-Conversion"><a href="#Type-Conversion" class="headerlink" title="Type Conversion"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-typeconversion">Type Conversion</a></h5><p>如果 Controller 方法参数声明为 String 以外的其他类型，则某些带有 <code>@RequestParam</code>、<code>@RequestHeader</code>、<code>@PathVariable</code> 等注解的参数可能需要类型转换。</p>
<p>对于上述情况，将根据配置的转换器自动进行类型转换。默认地，支持一些简单的类型，如 <code>int</code>, <code>long</code>, <code>Date</code> 等。也可由通过 <code>WebDataBinder</code> 或者通过使用 <code>FormattingConversionService</code> 注册 <code>Formatters</code> 来自定义类型转换。</p>
<h5 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-modelattrib-method-args">@ModelAttribute</a></h5><p>在方法参数上使用 @ModelAttribute 注解来访问 model 中的属性。model 属性还涵盖来自 HTTP Servlet 请求参数的值，其名称与字段名称匹配，这称为数据绑定，让你不必处理解析和转化单个 query 参数以及 form 字段。以下例子展示了如何做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute</span> Pet pet)</span> &#123;</span><br><span class="line">    <span class="comment">// method logic...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>官方提示</strong> <code>@ModelAttribute</code> 是可选的。默认地，任何非简单类型（由 <code>BeanUtils#isSimpleProperty</code> 决定），且未被任何其他参数解析器解析的参数，都会被当作使用了 <code>@ModelAttribute</code> 注解进行解析。<br><br> 这是因为 <code>HandlerMethodArgumentResolverComposite#argumentResolvers</code>（这是一个 List） 包含了两个 <code>ServletModelAttributeMethodProcessor</code>，一个在中间，一个在最后，不同点在于属性 <code>annotationNotRequired</code>，位于中间的 <code>annotationNotRequired=false</code>，即必须有 <code>@ModelAttribute</code> 注解；位于最后的 <code>annotationNotRequired=true</code>，即没有被 <code>@ModelAttribute</code> 注解，所以，在搜索 Processor 进行处理的过程中，如果一直没有参数解析器可以解析，就会使用最后的 <code>ServletModelAttributeMethodProcessor</code> 进行解析。</p>
</blockquote>
<p><strong>注意点：</strong><br>(1) 对简单参数不进行任何注解，可以认为与 <code>@RequestParam(required = false)</code> 等效，而且如果只是添加了 <code>@RequestParam</code> 注解，缺乏该参数反而会报错。</p>
<p>(2) @ModelAttribute 可以注解在方法上，先于 Controller 方法执行。</p>
<h5 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattributes">@SessionAttributes</a></h5><p><code>@SessionAttributes</code> 用于在请求之间的 HTTP Servlet 会话中存储 model 属性。</p>
<p>这是一个类级别注解，该注解声明指定控制器使用的会话属性。</p>
<p>通常列出了应该透明地存储于 session 中的 model 属性的名称或者 mode 属性的类型，以供后续请求访问。、</p>
<p>以下示例使用 <code>@SessionAttributes</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;pet&quot;)</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditPetForm</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一次请求中，当具有名称 <code>pet</code> 的 model 属性添加到 Model 时，它会自动升级并保存到 HTTP Servlet Session 中。它会一直存储在那里，直到另一个控制器方法使用 <code>SessionStatus</code> 方法参数去清除存储，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;pet&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditPetForm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/pets/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(Pet pet, BindingResult errors, SessionStatus status)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        status.setComplete(); </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-sessionattribute">@SessionAttribute</a></h5><p>如果你需要访问全局管理的预先存在的 session 属性（即，控制器之外，例如，通过过滤器产生），可能存在也可能不存在，你可以在方法参数上使用 <code>@SessionAttribute</code> 注解，正如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(<span class="meta">@SessionAttribute</span> User user)</span> &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于需要添加或者删除会话属性的案例，请考虑注入 <code>org.springframework.web.context.request.WebRequest</code> 或者 <code>javax.servlet.http.HttpSession</code> 到控制器方法。</p>
<p>对于要作为控制器工作流程的一部分在会话中临时存储 model 属性，请考虑使用 <code>@SessionAttributes</code>。</p>
<h5 id="RequestAttribute"><a href="#RequestAttribute" class="headerlink" title="@RequestAttribute"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-requestattrib">@RequestAttribute</a></h5><p>类似于 <code>@SessionAttribute</code>，你可以使用 <code>@RequestAttribute</code> 注解去访问事先已经存在的 Request 属性（例如，通过 <code>Filter</code> 或者 <code>HandlerInterceptor</code> 注入的属性）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(<span class="meta">@RequestAttribute</span> Client client)</span> &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Multipart"><a href="#Multipart" class="headerlink" title="Multipart"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-multipart-forms">Multipart</a></h5><p>启用了 <code>MultipartResolver</code> 之后，使用 <code>multipart/form-data</code> 的 POST 请求内容会被解析并且可以作为一般的请求参数访问。</p>
<blockquote>
<p>Spring Boot 会通过 <code>MultipartAutoConfiguration</code> 自动注入 <code>MultipartResolver</code></p>
</blockquote>
<p>下面的示例访问了一个一般的表单字段以及一个上传的文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/form&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleFormUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name,</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!file.isEmpty()) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            <span class="comment">// store the bytes somewhere</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:uploadSuccess&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:uploadFailure&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将参数类型声明为 <code>List&lt;MultipartFile&gt;</code> 允许解析相同参数名的多个文件。</p>
<p>当 <code>@RequestParam</code> 没有指定注解参数名，且被声明为 <code>Map&lt;String, MultipartFile&gt;</code> 或者 <code>MultiValueMap&lt;String, MultipartFile&gt;</code>，，那么对于每个给定参数名的 multipart 文件都会填充到 map 中。</p>
<blockquote>
<p><strong>作者的话</strong> 这种用法请勿设置参数名，否则会发生转化错误；而且这种用法无法收集多个相同参数名的 multipart 文件。</p>
</blockquote>
<blockquote>
<p><strong>官方</strong> 如果使用了 Servlet 3.0 multipart 解析，你还可以声明 <code>javax.servlet.http.Part</code> 作为方法参数或者集合的 Value 类型，以取代 Spring 的 <code>MultipartFile</code></p>
</blockquote>
<p>你还可以将 multipart 内容作为绑定到命令对象的数据的一部分。例如，前面示例中的表单字段和文件可以是表单对象上的字段，如下示例所示：</p>
<blockquote>
<p><strong>作者的话</strong> 命令对象：command object，可以理解为复合对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyForm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MultipartFile file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/form&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleFormUpload</span><span class="params">(MyForm form, BindingResult errors)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!form.getFile().isEmpty()) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = form.getFile().getBytes();</span><br><span class="line">            <span class="comment">// store the bytes somewhere</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:uploadSuccess&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:uploadFailure&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 RESTful 服务方案中，也可以从非浏览器的客户端提交 multipart 请求。如下示例展示了一个带有 JSON 的文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">POST /someUrl</span><br><span class="line">Content-Type: multipart/mixed</span><br><span class="line"></span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;meta-data&quot;</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;value&quot;</span><br><span class="line">&#125;</span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;file-data&quot;; filename=&quot;file.properties&quot;</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">... File Data ...</span><br></pre></td></tr></table></figure>

<p>你可以用 <code>@RequestParam</code> 以 <code>String</code>  的方式访问 “meta-data” 部分，但是有可能你想将他从 JSON 反序列化（类似于 <code>@RequestBody</code>）。使用 <code>@RequestPart</code> 注解可以访问被 <code>HttpMessageConverter</code> 转换之后的 multipart：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">handle</span><span class="params">(<span class="meta">@RequestPart(&quot;meta-data&quot;)</span> MetaData metadata,</span></span><br><span class="line"><span class="params">        <span class="meta">@RequestPart(&quot;file-data&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 这种情况下需要特殊设置某个文件的 Content-Type 为 application&#x2F;json</p>
</blockquote>
<h4 id="1-3-4-Model"><a href="#1-3-4-Model" class="headerlink" title="1.3.4. Model"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-modelattrib-methods">1.3.4. Model</a></h4><p>你可以使用 <code>@ModelAttribute</code> 注解：</p>
<ul>
<li><p><code>@RequestMapping</code> 方法上的一个方法参数上，用于创建或者访问一个来自 model 的 <code>Object</code>，并通过 <code>WebDataBinder</code> 将它绑定到请求</p>
</li>
<li><p>作为 <code>@Controller</code> 或者 <code>@ControllerAdvice</code> 类中方法级注解，帮助在任何 <code>@RequestMapping</code> 方法调用之前初始化 model</p>
</li>
<li><p>用于 <code>@RequestMapping</code> 方法，标记其返回值是 model 属性</p>
</li>
</ul>
<p>本节讨论 <code>@ModelAttribute</code> 方法，前面列表中的第 2 项。一个控制器可以有任意数量的 <code>@ModelAttribute</code> 方法。在同一个控制器的 <code>@RequestMapping</code> 方法之前，所有此类的方法都会被调用。<code>@ModelAttribute</code> 方法也可以通过 <code>@ControllerAdvice</code> 在控制器之间共享。详见…</p>
<p><code>@ModelAttribute</code> 具有灵活的方法签名。他们支持许多与 <code>@RequestMapping</code> 方法相同的参数，除了 <code>@ModelAttribute</code> 本身，或者与请求体相关的任何内容。</p>
<p>以下示例展示了 <code>@ModelAttribute</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateModel</span><span class="params">(<span class="meta">@RequestParam</span> String number, Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(accountRepository.findAccount(number));</span><br><span class="line">    <span class="comment">// add more ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例添加了仅仅 1 个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">addAccount</span><span class="params">(<span class="meta">@RequestParam</span> String number)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> accountRepository.findAccount(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看也可以在 <code>@RequestMapping</code> 方法上使用 <code>@ModelAttribute</code> 作为方法级注解，在这种情况下，<code>@RequestMapping</code> 方法的返回值会被解释为 model 属性。这通常不需要，因为这是 HTML 控制器的默认行为，除非返回值是 <code>String</code>，会被解释成视图名字。<code>@ModelAttribute</code> 也可以自定义 model 属性名，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ModelAttribute(&quot;myAccount&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Account <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-5-DataBinder"><a href="#1-3-5-DataBinder" class="headerlink" title="1.3.5. DataBinder"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-initbinder">1.3.5. DataBinder</a></h4><p><code>@Controller</code> 和 <code>@ControllerAdvice</code> 类可以具有一些 <code>@InitBinder</code> 方法，用来初始化 <code>WebDataBinder</code> 实例，而这些方法又可以：</p>
<ul>
<li>绑定请求参数（即，表单或者查询数据）到 model 对象</li>
<li>将基于字符串的请求值（例如请求参数，路径变量，头，cookie等）转换为控制器方法参数的目标类型</li>
<li>当渲染 HTML 形式时，将 model 对象值以 <code>String</code> 值格式化</li>
</ul>
<p><code>@InitBinder</code> 方法可以注册特定于控制器的 <code>java.bean.PropertyEditor</code> 或者 Spring <code>Converter</code> 以及 <code>Formatter</code> 组件。此外，你也可以使用 MVC Config 在全局共享的 <code>FormattingConversionService</code> 注册 <code>Converter</code> 以及 <code>Formatter</code>。</p>
<p><code>@InitBinder</code> 方法支持许多跟 <code>@RequestMapping</code> 一样支持的参数，除了 <code>@ModelAttribute</code> （command object）参数。通常，这些方法以一个 <code>WebDataBinder</code> 参数（用于注册）声明，并返回一个 <code>void</code>。下面展示了一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        dateFormat.setLenient(<span class="literal">false</span>);</span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> <span class="title class_">CustomDateEditor</span>(dateFormat, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，当你通过共享的 <code>FormattingConversionService</code> 使用基于 <code>Formatter</code> 的设置时，你可以再使用相同的方式注册特定于控制器的 <code>Formatter</code> 实现，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FormController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initBinder</span><span class="params">(WebDataBinder binder)</span> &#123;</span><br><span class="line">        binder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">DateFormatter</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-6-Exceptions"><a href="#1-3-6-Exceptions" class="headerlink" title="1.3.6. Exceptions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler">1.3.6. Exceptions</a></h4><p><code>@Controller</code> 和 <code>@ControllerAdvice</code> 类可以拥有 <code>@ExceptionHandler</code> 方法来处理来自控制器方法的异常，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handle</span><span class="params">(IOException ex)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中，异常可能与顶级异常（top-level）相匹配（即，直接抛出的 <code>IOException</code>），或者与在顶级包装器异常的直接 cause 相匹配（例如，<code>IOException</code> 被包裹在 <code>IllegalStateException</code>）。</p>
<blockquote>
<p><strong>作者的话</strong> 顶级异常（top-level）可以理解为最外层异常，通常是一个模糊异常，并不具体，另外异常有一个 cause，通常表示具体异常，这里也可以匹配到进行处理。</p>
</blockquote>
<p>对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根异常匹配通常比 cause 异常匹配优先级更高。更具体地，使用 <code>ExceptionDepthComparator</code> 基于异常类型的深度来对异常进行排序。</p>
<p>另外，注解声明可能会缩小匹配的异常类型范围，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handle</span><span class="params">(IOException ex)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你甚至可以使用特定的异常类型数组，以及一个非常通用的参数签名，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">handle</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根异常匹配和 cause 异常匹配可能令人觉得很惊讶。<br>在前面展示的 <code>IOException</code> 变量中，该方法通常以实际的 <code>FileSystemException</code> 或者 <code>RemoteException</code> 实例作为参数，因为它们两个都从 <code>IOException</code> 继承。但是，如果在包装器异常中的任何这样的相匹配的异常被传播出来，它们本身也是一个 <code>IOException</code>，则传递的异常实例是包装器异常。<br><strong>作者的话</strong> 也就是需要通过 <code>ex.getCause()</code> 才能拿到具体异常<br>这种行为在 <code>handle(Exception)</code> 变量中更简单。在包装方案下，总是以包装器异常调用异常处理方法，在这种情况下，通过 <code>ex.getCause()</code> 找到实际匹配的异常。仅当作为顶级异常抛出的时候，传递的异常才是实际的 <code>FileSystemException</code> 或者 <code>RemoteException</code>。<br><strong>作者的话</strong> 不过，你调用 <code>ex.getCause()</code> 拿到的也是具体异常，因为 <code>this.cause=this</code></p>
</blockquote>
<p>我们通常建议你在参数签名中尽可能具体，可以降低 root 异常类型和 cause 异常类型之间不匹配的可能性。考虑将多匹配方法分解为单个 <code>@ExceptionHandler</code> 方法，每个方法都通过其签名匹配单个特定异常类型。</p>
<blockquote>
<p><strong>作者的话</strong> 官方就是建议你将每个具体的异常都写一个 <code>@ExceptionHandler</code></p>
</blockquote>
<p>在多个 <code>@ControllerAdvice</code> 安排下，建议你在 <code>@ControllerAdvice</code> 上声明你的主要 root 异常映射，该映射使用相关的 order 优先使用。虽然 root 异常匹配优先于 cause，但是这是在给定的 <code>@Controller</code> 或者 <code>@ControllerAdvice</code> 类方法中定义。这意味着，在较高优先级 <code>@ControllerAdvice</code> bean 上的 cause 匹配优先于任何较低级的 <code>@ControllerAdvice</code> bean。</p>
<h5 id="Method-Arguments-1"><a href="#Method-Arguments-1" class="headerlink" title="Method Arguments"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler-args">Method Arguments</a></h5><p><code>@ExceptionHandler</code> 方法支持以下参数：</p>
<table>
<thead>
<tr>
<th>方法参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="Return-Values-1"><a href="#Return-Values-1" class="headerlink" title="Return Values"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-exceptionhandler-return-values">Return Values</a></h5><h4 id="1-3-7-Controller-Advice"><a href="#1-3-7-Controller-Advice" class="headerlink" title="1.3.7. Controller Advice"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-controller-advice">1.3.7. Controller Advice</a></h4><p>通常，<code>@ExceptionHandler</code>，<code>@InitBinder</code>，以及 <code>@ModelAttribute</code> 方法应用于 <code>@Controller</code> 类（或者类继承层次），将这些注解声明在里面。如果你希望这样的方法在全局范围内更多地应用（跨控制器），则可以在 <code>@ControllerAdvice</code> 或者 <code>@RestControllerAdvice</code> 注解类中声明它们。</p>
<p><code>@ControllerAdvice</code> 使用 <code>@Component</code> 注解，这意味着这样的类可以通过组件扫描（component scanning）注册为 Spring bean。<code>@RestControllerAdvice</code> 是一个由 <code>@ControllerAdvice</code> 和 <code>@ResponseBody</code> 注解的组合注解，本质上意味着，<code>@ExceptionHandler</code> 方法是通过消息转换（以及视图解析或者模板解析）渲染到响应体的。</p>
<p>在启动时，用于 <code>@RequestMapping</code> 和 <code>@ExceptionHandler</code> 方法的基础设施类会检测注解有 <code>@ControllerAdvice</code> 的 Spring bean，然后在运行时应用它们的方法。 全局的 <code>@ExceptionHandler</code> 方法（来自 <code>@ControllerAdvice</code>）应用于本地方法之后（来自 <code>@Controller</code>）。相比之下，全局的 <code>@ModelAttribute</code> 和 <code>@InitBinder</code> 方法应用于本地方法之前。</p>
<p>默认地，<code>ControllerAdvice</code> 方法应用于每个请求（即，所有控制器），但是你可以通过注解上的属性，将其缩小到控制器的子集，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Target all Controllers annotated with @RestController</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = RestController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleAdvice1</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers within specific packages</span></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;org.example.controllers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleAdvice2</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers assignable to specific classes</span></span><br><span class="line"><span class="meta">@ControllerAdvice(assignableTypes = &#123;ControllerInterface.class, AbstractController.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleAdvice3</span> &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>全局异常处理 @RestControllerAdvice</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">	<span class="meta">@ExceptionHandler(value = AuthenticationException.class)</span></span><br><span class="line">	<span class="keyword">public</span> ResponseDTO <span class="title function_">AuthenticationExceptionHandler</span><span class="params">(AuthenticationException e)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ResponseDTO.failure(e.getMessage());	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*** ControllerAdvice 处理 Filter 抛出的异常</p>
<p>类比，Sturts 拦截器组，第一个就是 exception 拦截器。本质上是借助过滤器栈，将异常处理的过滤器放在第一个位置。</p>
<p>定义 ExceptionFilter，将捕捉的异常交给异常处理的 Controller。其他的过滤器不用处理异常，直接 throw 即可。<br>请务必调用 setOrder 方法，保持 order 值最大，这样过滤就能排在第一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(Integer.MIN_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionFilter</span> <span class="keyword">extends</span> <span class="title class_">HttpFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            request.setAttribute(<span class="string">&quot;ioException&quot;</span>, e);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/error&quot;</span>).forward(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">            request.setAttribute(<span class="string">&quot;servletException&quot;</span>, e);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/error&quot;</span>).forward(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义抛出异常的 Mapping</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/error&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseVO <span class="title function_">throwException</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">throw</span> (Exception) request.getAttribute(<span class="string">&quot;exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="1-4-Functional-Endpoints"><a href="#1-4-Functional-Endpoints" class="headerlink" title="1.4. Functional Endpoints"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn">1.4. Functional Endpoints</a></h3><h4 id="1-4-1-Overview"><a href="#1-4-1-Overview" class="headerlink" title="1.4.1. Overview"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-overview">1.4.1. Overview</a></h4><p>在 WebMvc.fn 中，使用 <code>HandlerFunction</code> 处理 HTTP 请求：这是一个接受 <code>ServerRequest</code> 并返回 <code>ServerResponse</code> 的函数。请求和响应都有固定的约定，提供了 JDK8 友好的 HTTP 请求和响应访问。<code>HandlerFunction</code> 等价于基于注解的编程模型中的 <code>@RequestMapping</code> 方法体。</p>
<p>传入的请求会使用 <code>RouterFunction</code> 路由到一个 handler function：这是一个接收 <code>ServerRequest</code> 并返回 一个 Optional 包裹的 <code>HandlerFunction</code>（<code>Optional&lt;HandlerFunction&gt;</code>） 的函数。当路由器函数匹配到时，就会返回一个 handler function；否则是一个空的 Optional。<code>RouterFunction</code> 等价于 <code>@RequestMapping</code> 注解，但有一个主要的区别，路由函数不仅仅提供数据，还提供行为。</p>
<p><code>RouterFunctions.route()</code> 提供了一个路由器构建器，可以比较容易地创建路由器，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.servlet.function.RequestPredicates.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.servlet.function.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line"><span class="type">PersonRepository</span> <span class="variable">repository</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">PersonHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonHandler</span>(repository);</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .GET(<span class="string">&quot;/person/&#123;id&#125;&quot;</span>, accept(APPLICATION_JSON), handler::getPerson)</span><br><span class="line">    .GET(<span class="string">&quot;/person&quot;</span>, accept(APPLICATION_JSON), handler::listPeople)</span><br><span class="line">    .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">listPeople</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">createPerson</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">getPerson</span><span class="params">(ServerRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 上述代码不符合 Java 语法规范，只是作为一种示例参考，具体注入路由器需要使用 bean 注入</p>
</blockquote>
<p>如果将 <code>RouterFunction</code> 注册为 bean，例如在 <code>@Configuration</code> 类中暴露它，它会被 servlet 自动检测，如 Running a Server 所述。</p>
<h4 id="1-4-2-HandlerFunction"><a href="#1-4-2-HandlerFunction" class="headerlink" title="1.4.2. HandlerFunction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-handler-functions">1.4.2. HandlerFunction</a></h4><p><code>ServerRequest</code> 和 <code>ServerResponse</code> 是不可变接口，可提供 JDK8 友好访问 HTTP 请求和响应，包括 headers，body，method，status code。</p>
<h5 id="ServerRequest"><a href="#ServerRequest" class="headerlink" title="ServerRequest"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-request">ServerRequest</a></h5><p><code>ServerRequest</code> 提供了对 HTTP method，URI，Headers，Query Parameters，而通过 <code>body</code> 方法访问 Body。</p>
<p>以下示例将请求体提取为一个 <code>String</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> request.body(String.class);</span><br></pre></td></tr></table></figure>


<p>以下示例将 Body 提取为一个 <code>List&lt;Person&gt;</code>，其中 <code>Person</code> 对象是从 JSON 或者 XML 此类的序列化形式解吗得到的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; people = request.body(<span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;Person&gt;&gt;() &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>以下示例展示了如何访问参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MultiValueMap&lt;String, String&gt; params = request.params();</span><br></pre></td></tr></table></figure>

<h5 id="ServerResponse"><a href="#ServerResponse" class="headerlink" title="ServerResponse"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-response">ServerResponse</a></h5><p><code>ServerResponse</code> 提供了对 HTTP response 的访问，并且由于它是不变的，因此你可以使用一个 <code>build</code> 方法来创建它。你可以通过构建器设置响应状态，添加响应头，或者提供响应体。以下示例创建了一个具有 JSON 内容的 200（OK）响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> ...</span><br><span class="line">ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);</span><br></pre></td></tr></table></figure>

<p>以下示例展示了如何使用 <code>Location</code> 头以及无响应体构建一个 201（CREATED）响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URI</span> <span class="variable">location</span> <span class="operator">=</span> ...</span><br><span class="line">ServerResponse.created(location).build();</span><br></pre></td></tr></table></figure>

<h5 id="Handler-Classes"><a href="#Handler-Classes" class="headerlink" title="Handler Classes"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-handler-classes">Handler Classes</a></h5><p>我可以用 lambda 方式书写一个 handler 函数，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HandlerFunction&lt;ServerResponse&gt; helloWorld =</span><br><span class="line">  request -&gt; ServerResponse.ok().body(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这很方便，但是在应用程序中我们需要多个函数，并且多个内联的 lambda 可能变得混乱。因此 ，将相关的 handler 函数一起分组到一个 handler 类是很有用的，这与基于注解的应用中，具有跟 <code>@Controller</code> 相似的角色。举个例子，下面的类暴露了响应式 <code>Person</code> 仓库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.ServerResponse.ok;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PersonHandler</span><span class="params">(PersonRepository repository)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">listPeople</span><span class="params">(ServerRequest request)</span> &#123; </span><br><span class="line">        List&lt;Person&gt; people = repository.allPeople();</span><br><span class="line">        <span class="keyword">return</span> ok().contentType(APPLICATION_JSON).body(people);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">createPerson</span><span class="params">(ServerRequest request)</span> <span class="keyword">throws</span> Exception &#123; </span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> request.body(Person.class);</span><br><span class="line">        repository.savePerson(person);</span><br><span class="line">        <span class="keyword">return</span> ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServerResponse <span class="title function_">getPerson</span><span class="params">(ServerRequest request)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">personId</span> <span class="operator">=</span> Integer.parseInt(request.pathVariable(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> repository.getPerson(personId);</span><br><span class="line">        <span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ok().contentType(APPLICATION_JSON).body(person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.notFound().build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-3-RouterFunction"><a href="#1-4-3-RouterFunction" class="headerlink" title="1.4.3. RouterFunction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-router-functions">1.4.3. RouterFunction</a></h4><p>路由器函数用于将请求路由到相关的 <code>HandlerFunction</code>。通常你不用自己编写路由器函数，而是使用 <code>RouterFunctions</code> 工具类上的一个方法创建它。<code>RouterFunctions.route()</code> （无参）为你提供了一个流利的构建器用于创建路由器函数，而 <code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code> 提供了一个直接创建路由器的方法。</p>
<h4 id="1-4-4-Running-a-Server"><a href="#1-4-4-Running-a-Server" class="headerlink" title="1.4.4. Running a Server"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-running">1.4.4. Running a Server</a></h4><p>通常，你可以通过 MVC Config 在基于 <code>DispatcherHandler</code> 的设置中运行路由函数，这种设置使用 Spring Configuration 声明处理请求所需的组件。MVC Java 配置声明了以下的一些基础设施组件用以支持功能性端点：</p>
<ul>
<li>RouterFunctionMapping</li>
<li>HandlerFunctionAdapter</li>
</ul>
<p>前面的组件使功能性端点兼容到 <code>DispatcherServlet</code> 请求处理生命周期里，并且（可能）与注解控制器并行，如果有任何声明。这也是 Spring Boot Web starter 启用功能性端点的方式。</p>
<p>以下示例展示了 WebFlux Java 配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;?&gt; routerFunctionA() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;?&gt; routerFunctionB() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="comment">// configure message conversion...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// configure CORS...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// configure view resolution for HTML rendering...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-5-Filtering-Handler-Functions"><a href="#1-4-5-Filtering-Handler-Functions" class="headerlink" title="1.4.5. Filtering Handler Functions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#webmvc-fn-handler-filter-function">1.4.5. Filtering Handler Functions</a></h4><p>你可以在路由函数构建器使用 <code>before</code>，<code>after</code> 或者 <code>filter</code> 方法来过滤 handler 函数。使用注解，你可以通过使用 <code>@ControllerAdvice</code>，<code>ServletFilter</code> 或者两者都用，实现类似的功能。过滤将会应用到构建器构建的路由中。这意味着在嵌套路由中定义的过滤其不适用于顶级路由。例如，考虑如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .path(<span class="string">&quot;/person&quot;</span>, b1 -&gt; b1</span><br><span class="line">        .nest(accept(APPLICATION_JSON), b2 -&gt; b2</span><br><span class="line">            .GET(<span class="string">&quot;/&#123;id&#125;&quot;</span>, handler::getPerson)</span><br><span class="line">            .GET(<span class="string">&quot;&quot;</span>, handler::listPeople)</span><br><span class="line">            .before(request -&gt; ServerRequest.from(request) </span><br><span class="line">                .header(<span class="string">&quot;X-RequestHeader&quot;</span>, <span class="string">&quot;Value&quot;</span>)</span><br><span class="line">                .build()))</span><br><span class="line">        .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson))</span><br><span class="line">    .after((request, response) -&gt; logResponse(response)) </span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h3 id="1-5-URI-Links"><a href="#1-5-URI-Links" class="headerlink" title="1.5. URI Links"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-uri-building">1.5. URI Links</a></h3><h4 id="1-5-1-UriComponents"><a href="#1-5-1-UriComponents" class="headerlink" title="1.5.1. UriComponents"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#web-uricomponents">1.5.1. UriComponents</a></h4><p><code>UriComponentBuilder</code> 有助于从带有变量的 URI 模板中构建 URI。如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UriComponents</span> <span class="variable">uriComponents</span> <span class="operator">=</span> UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;https://example.com/hotels/&#123;hotel&#125;&quot;</span>)  </span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)  </span><br><span class="line">        .encode() </span><br><span class="line">        .build(); </span><br><span class="line"></span><br><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> uriComponents.expand(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>).toUri();  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>前面的示例可以合并到一个链中，并使用 <code>buildAndExpand</code> 缩短，如下示例所示：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;https://example.com/hotels/&#123;hotel&#125;&quot;</span>)</span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)</span><br><span class="line">        .encode()</span><br><span class="line">        .buildAndExpand(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .toUri();</span><br></pre></td></tr></table></figure>

<p>你可以直接进入 URI（表示编码）进一步缩短，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;https://example.com/hotels/&#123;hotel&#125;&quot;</span>)</span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)</span><br><span class="line">        .build(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>你可以使用完整的 URI 模板进一步缩短，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;https://example.com/hotels/&#123;hotel&#125;?q=&#123;q&#125;&quot;</span>)</span><br><span class="line">        .build(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-UriBuilder"><a href="#1-5-2-UriBuilder" class="headerlink" title="1.5.2. UriBuilder"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#web-uribuilder">1.5.2. UriBuilder</a></h4><h3 id="1-6-Asynchronous-Requests"><a href="#1-6-Asynchronous-Requests" class="headerlink" title="1.6. Asynchronous Requests"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-async">1.6. Asynchronous Requests</a></h3><p>Spring MVC 集成了 Servlet 3.0 异步请求处理：</p>
<ul>
<li>在控制器方法中，<code>DeferredResult</code> 和 <code>Callable</code> 返回值，并为单个异步返回值提供了基本支持。</li>
<li>控制器可以流传输多个值，包括 SSE 和 原始数据</li>
<li>控制器可以使用 reactive 客户端，并为响应处理返回 reactive types</li>
</ul>
<h4 id="1-6-1-DeferredResult"><a href="#1-6-1-DeferredResult" class="headerlink" title="1.6.1. DeferredResult"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-async-deferredresult">1.6.1. DeferredResult</a></h4><p>一旦在 Servlet 容器中启用了异步处理功能，控制器方法就可以用 <code>DeferredResult</code> 包装任何支持的控制器方法的返回值，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/quotes&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title function_">quotes</span><span class="params">()</span> &#123;</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> <span class="title class_">DeferredResult</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// Save the deferredResult somewhere..</span></span><br><span class="line">    <span class="keyword">return</span> deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// From some other thread...</span></span><br><span class="line">deferredResult.setResult(result);</span><br></pre></td></tr></table></figure>


<h4 id="1-6-3-Processing"><a href="#1-6-3-Processing" class="headerlink" title="1.6.3. Processing"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-ann-async-processing">1.6.3. Processing</a></h4><p>这是 Servlet 异步请求处理非常简洁的概述：</p>
<ul>
<li><p>通过调用 <code>request.startAsync()</code>，<code>ServletRequest</code> 可以放到异步模型中。这样做的主要影响就是，Servlet（以及任何过滤器）可以退出，但是响应会一直打开用于后面处理完成。</p>
</li>
<li><p>调用 <code>request.startAsync()</code> 会返回 <code>AsyncContext</code>，你可以用它来对异步处理做进一步控制。例如，它提供了 <code>dispatch</code> 方法，该方法类似于 Servlet API 的 forward，除了它可以让应用程序在 Servlet 容器线程上恢复请求处理。</p>
</li>
<li><p><code>ServletRequest</code> 提供了对当前 <code>DispatcherType</code> 的访问，你可以用它区别处理初始化请求，异步调度，forward，以及其他调度类型。</p>
</li>
</ul>
<p><code>DeferredResult</code> 处理工作如下：</p>
<ul>
<li><p>控制器返回一个 <code>DeferredResult</code>，并将其保存到一些内存中的可访问的队列或者列表中。</p>
</li>
<li><p>Spring MVC 调用 <code>request.startAsync()</code></p>
</li>
<li><p>同时，<code>DispatcherServlet</code> 以及所有配置的过滤器都退出请求处理线程，但 response 仍然保持打开</p>
</li>
<li><p>应用程序从某个线程设置 <code>DeferredResult</code>，然后 Spring MVC 将请求调度回 Servlet 容器。</p>
</li>
<li><p>再次调用 <code>DispatcherServlet</code>，并以异步产生的返回值进行处理。</p>
</li>
</ul>
<h3 id="1-7-CORS"><a href="#1-7-CORS" class="headerlink" title="1.7. CORS"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors">1.7. CORS</a></h3><p>参考链接：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></p>
<h4 id="1-7-1-Introduction"><a href="#1-7-1-Introduction" class="headerlink" title="1.7.1. Introduction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-intro">1.7.1. Introduction</a></h4><p>出于安全原因，浏览器禁止 AJAX 调用当前源之外的资源。举个例子，你可以将你的银行账户放在一个标签中，而 evil.com 在另一个标签中。来自 evil.com 的脚本不应通过你的凭据向你的银行 API 发出 AJAX 请求，例如从你的账户提取资金。</p>
<p>跨域资源共享是 W3C 的规范，大多数浏览器都实现了这种规范，可以让你指定哪种类型的跨域请求已获得授权，而不是使用基于 IFRAME 或者 JSONP 的不太安全且不太强大的解决方案。</p>
<h4 id="1-7-2-Processing"><a href="#1-7-2-Processing" class="headerlink" title="1.7.2. Processing"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-processing">1.7.2. Processing</a></h4><p>CORS 规范区分预请求、简单请求、实际请求。想要学习更多 CORS，参考<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">这篇文章</a></p>
<p>Spring MVC <code>HandlerMapping</code> 实现类提供了内置的对 CORS 的支持。在成功将请求映射到一个 handler 之后，<code>HandlerMapping</code> 实现类就会检查给定请求以及 handler 的 CORS 配置，然后采取更进一步的措施。预请求直接处理，但是，简单请求和实际的 CORS 请求会被拦截，校验，并设置需要的 CORS 响应头。</p>
<p>为了启用跨域请求，你需要有一个显式的 CORS 配置。如果找不到合适的 CORS 配置，就会拒绝预请求。如果没有添加 CORS 头部到简单请求、实际 CORS 请求响应中，那么，浏览器就会拒绝它们。</p>
<blockquote>
<p><strong>作者的话</strong> 可能有人会认为跨域是浏览器无法发起请求，其实不是，只是拒绝接收 response。</p>
</blockquote>
<p>每个 <code>HandlerMapping</code> 都可以单独地配置基于模式的 URL <code>CorsConfiguration</code> 映射。在大多数情况下，应用使用 MVC Java 配置或者 XML 命名空间去声明映射，不过这会导致一个传递给所有 <code>HandlerMapping</code> 实例的全局映射。</p>
<p>你可以将位于 <code>HandlerMapping</code> 级别的全局 CORS 配置与更加细粒度的 handler 级别的 CORS 配置相结合。举个例子，注解式 Controller 可以使用类级别或者方法级别的 <code>@CrossOrigin</code> 注解（其他 handler 可以实现 <code>CorsConfigurationSource</code>）</p>
<h4 id="1-7-3-CrossOrigin"><a href="#1-7-3-CrossOrigin" class="headerlink" title="1.7.3. @CrossOrigin"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-controller">1.7.3. @CrossOrigin</a></h4><p><code>@CrossOrigin</code> 注解在注解式控制器的方法上，可以启用跨域请求，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认地，@CrossOrigin 允许：</p>
<ul>
<li>所有 origin</li>
<li>所有 header</li>
<li>所有 HTTP 方法</li>
</ul>
<p>默认情况下，<code>allowedCredentials</code> 不启用，因为那会建立一个信任级别，会暴露敏感的用户特定的信息（例如 cookie 和 CSRF 令牌），应该只能在适当的情况下使用。</p>
<p>@CrossOrigin 可以用于：</p>
<ul>
<li>Controller 的方法，开启 Controller 方法级别的跨域请求</li>
<li>Controller 类，由所有方法继承</li>
</ul>
<p>maxAge 默认 30 分钟</p>
<p><code>@CrossOrigin</code> 也支持类级别，这会被所有方法继承，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;https://domain2.com&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在类级别和方法级别上同时使用 <code>@CrossOrigin</code>，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin(&quot;https://domain2.com&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-7-4-Global-Configuration"><a href="#1-7-4-Global-Configuration" class="headerlink" title="1.7.4. Global Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-global">1.7.4. Global Configuration</a></h4><p>除了细粒度的控制外，也可以通过实现 <code>WebMvcConfigurer.addCorsMappings</code> 定义全局 CORS 配置，参考代码见官网。</p>
<p>具体原理可见 <code>DefaultCorsProcessor</code>。</p>
<h4 id="1-7-5-CORS-Filter"><a href="#1-7-5-CORS-Filter" class="headerlink" title="1.7.5. CORS Filter"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-cors-filter">1.7.5. CORS Filter</a></h4><p>可以通过内置的 CorsFilter 增加 CORS 支持。</p>
<h3 id="1-8-Web-Security"><a href="#1-8-Web-Security" class="headerlink" title="1.8. Web Security"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-web-security">1.8. Web Security</a></h3><p>Spring Security 工程为保护 web 应用免受恶意漏洞提供了支持。清参阅 Spring Security 参考文档，包括：</p>
<ul>
<li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc">Spring MVC Security</a></li>
<li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-mockmvc">Spring MVC Test Support</a></li>
<li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#csrf">CSRF protection</a></li>
<li><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#headers">Security Response Headers</a></li>
</ul>
<h3 id="1-9-HTTP-Caching"><a href="#1-9-HTTP-Caching" class="headerlink" title="1.9. HTTP Caching"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-caching">1.9. HTTP Caching</a></h3><h3 id="1-11-MVC-Config"><a href="#1-11-MVC-Config" class="headerlink" title="1.11. MVC Config"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config">1.11. MVC Config</a></h3><p>MVC Java 配置和 MVC XML 命名空间配置提供了默认的配置，这适合大多数应用程序，如果你觉得不够，也提供了配置 API 供你自定义。</p>
<h4 id="1-11-1-Enable-MVC-Configuration"><a href="#1-11-1-Enable-MVC-Configuration" class="headerlink" title="1.11.1. Enable MVC Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-enable">1.11.1. Enable MVC Configuration</a></h4><p>在 Java 配置中，你可以使用 <code>@EnableMvc</code> 注解来启用 MVC 配置，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> Spring Boot 无需且尽量不要使用 <code>@EnableWebMvc</code>，这会覆盖 Spring Boot 的默认配置。</p>
</blockquote>
<p>在 XML 配置中，你可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素，以启用 MVC 配置，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的示例会注册许多 Spring MVC 的基础 bean，并且适配类路径上的可用依赖（例如，载体转换器，JSON，XML，以及其他什么）</p>
<h4 id="1-11-2-MVC-Config-API"><a href="#1-11-2-MVC-Config-API" class="headerlink" title="1.11.2. MVC Config API"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-customize">1.11.2. MVC Config API</a></h4><p>在 Java 配置中，你可以实现 <code>WebMvcConfigurer</code> 示例，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implement configuration methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 XML 下，你可以检查属性，以及 <code>&lt;mvc:annotation-driven/&gt;</code> 的子元素。你可以浏览 <a href="https://schema.spring.io/mvc/spring-mvc.xsd">Spring MVC XML schema</a> 或者使用 IDE 的代码编译功能，找到那些可用的属性以及子元素。</p>
<h4 id="1-11-3-Type-Conversion"><a href="#1-11-3-Type-Conversion" class="headerlink" title="1.11.3. Type Conversion"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-conversion">1.11.3. Type Conversion</a></h4><p>默认地，Spring MVC 安装了各种数字和日期的格式化器（formatter），并且支持 <code>@NumberFormat</code> 和 <code>@DateTimeFormat</code> 对字段进行自定义。</p>
<p>如果要在 Java 配置中注册自定义的格式化器和转换器，使用以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFormatters</span><span class="params">(FormatterRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 其实就是实现 <code>WebMvcConfigurer</code> 的 <code>addFormatters</code> 方法</p>
</blockquote>
<h4 id="1-11-4-Validation"><a href="#1-11-4-Validation" class="headerlink" title="1.11.4. Validation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-validation">1.11.4. Validation</a></h4><p>默认地，如果 Bean Validation 存在于类路径（例如，Hibernate Validator），就会注册一个 <code>LocalValidatorFactoryBean</code> 作为全局的 Validator，供控制器方法参数上的 <code>@Valid</code> 以及 <code>Validated</code> 使用</p>
<blockquote>
<p> <strong>作者的话</strong> 判断是否存在 Bean Validation 框架的方法是注解查找是否存在 <code>javax.validation.Validator</code></p>
</blockquote>
<p>在 Java 配置中，你可以自定义全局 <code>Validator</code> 示例，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Validator <span class="title function_">getValidator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-11-5-Interceptors"><a href="#1-11-5-Interceptors" class="headerlink" title="1.11.5. Interceptors"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-interceptors">1.11.5. Interceptors</a></h4><p>在 Java 配置中，你可以注册拦截器，以应用于收到的请求，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LocaleChangeInterceptor</span>());</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">ThemeChangeInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>).excludePathPatterns(<span class="string">&quot;/admin/**&quot;</span>);</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">SecurityInterceptor</span>()).addPathPatterns(<span class="string">&quot;/secure/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-11-6-Content-Types"><a href="#1-11-6-Content-Types" class="headerlink" title="1.11.6. Content Types"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-content-negotiation">1.11.6. Content Types</a></h4><h4 id="1-11-7-Message-Converters"><a href="#1-11-7-Message-Converters" class="headerlink" title="1.11.7. Message Converters"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-message-converters">1.11.7. Message Converters</a></h4><p>你可以通过覆盖 <code>configureMessageConverters()</code>，以 Java 配置的方式自定义 <code>HttpMessageConverter</code>（这会取代 Spring MVC 创建的默认转换器），或者通过覆盖 <code>extendMessageConverters()</code>（这可以自定义默认的转换器或者添加额外的转换器）</p>
<p>以下示例使用自定义的 <code>ObjectMapper</code> 添加了 XML 和 Jackson JSON 转换器，取代默认的转换器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">        <span class="type">Jackson2ObjectMapperBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2ObjectMapperBuilder</span>()</span><br><span class="line">                .indentOutput(<span class="literal">true</span>)</span><br><span class="line">                .dateFormat(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>))</span><br><span class="line">                .modulesToInstall(<span class="keyword">new</span> <span class="title class_">ParameterNamesModule</span>());</span><br><span class="line">        converters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(builder.build()));</span><br><span class="line">        converters.add(<span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>(builder.createXmlMapper(<span class="literal">true</span>).build()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-11-10-Static-Resources"><a href="#1-11-10-Static-Resources" class="headerlink" title="1.11.10. Static Resources"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources">1.11.10. Static Resources</a></h4><p>这里提供了一种简便的方法用于提供静态资源服务，是基于 <code>Resource</code> 的位置列表的。</p>
<p>在以下示例中，给定一个以 <code>/resources</code> 开头的请求，相对路径用于查找和提供位于 web 应用的根目录下的 <code>/public</code> 或者类路径 <code>/static</code> 下的静态资源</p>
<p>如果需要以 &#x2F;resources 为前缀，根据其后的相对路径寻找 Web 应用程序根目录下的 &#x2F;public 资源或 类路径 &#x2F;static 下的静态资源，资源设置一年到期，还会评估 Last-Modified 头部，如果存在，返回 304，则可以按如下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>)</span><br><span class="line">            .addResourceLocations(<span class="string">&quot;/public&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>)</span><br><span class="line">            .setCachePeriod(<span class="number">31556926</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>(1) 配置类路径静态资源时，末尾必须有 &#x2F;，不可缺省，否则 404</p>
<h4 id="1-11-11-Default-Servlet"><a href="#1-11-11-Default-Servlet" class="headerlink" title="1.11.11. Default Servlet"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-default-servlet-handler">1.11.11. Default Servlet</a></h4><p>Spring MVC 允许将 DispatcherServlet 映射到 <code>/</code>（因此，这覆盖了容器默认的 Servlet 映射），但是，Spring MVC 仍然允许容器默认的 Servlet 处理静态资源请求。Spring MVC 配置有一个 <code>DefaultServletHttpRequestHandler</code>，使用 <code>/**</code> 的 URL 映射，相对于其他 URL 映射的具有最低优先级（Integer.MAX_VALUE）。</p>
<blockquote>
<p><strong>作者的话</strong> 在 Spring Boot 中，你不启用，是不会将此 <code>HandlerMapping</code> 添加的。并且，启用了也不会发生作用，因为请求会被 <code>SimpleUrlHandlerMapping</code> 中的 <code>/**</code> 匹配到。</p>
</blockquote>
<p>该 handler 将所有请求转发到默认的 Servlet。因此，它必须保持在所有其他 URL <code>HandlerMapping</code> 的最后。如果你使用 <code>mvc:annotation-driven</code>，就是这种情况。另外，如果你设置了自定义的 <code>HandlerMapping</code> 实例，请确保将其 <code>order</code> 属性设置低于 <code>DefaultServletHttpRequestHandler</code>（Integer.MAX_VALUE）</p>
<p>如下示例显示了如何通过使用默认设置启用该功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-11-12-Path-Matching"><a href="#1-11-12-Path-Matching" class="headerlink" title="1.11.12. Path Matching"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/web.html#mvc-config-path-matching">1.11.12. Path Matching</a></h4><p>你可以自定义与 URL 的路径匹配和处理有关的可选项。有关各个选项的详细信息，参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html"><code>PathMatchConfigurer</code></a> javadoc。</p>
<p>以下示例显示了如何在 Java 配置中自定义路径匹配：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer</span><br><span class="line">            .setUseTrailingSlashMatch(<span class="literal">false</span>)</span><br><span class="line">            .setUseRegisteredSuffixPatternMatch(<span class="literal">true</span>)</span><br><span class="line">            .setPathMatcher(antPathMatcher())</span><br><span class="line">            .setUrlPathHelper(urlPathHelper())</span><br><span class="line">            .addPathPrefix(<span class="string">&quot;/api&quot;</span>, HandlerTypePredicate.forAnnotation(RestController.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UrlPathHelper <span class="title function_">urlPathHelper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PathMatcher <span class="title function_">antPathMatcher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Framework Core</title>
    <url>/2022/05/09/Spring-Core/Spring-Framework-Core/</url>
    <content><![CDATA[<h1 id="Core"><a href="#Core" class="headerlink" title="Core"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#spring-core">Core</a></h1><h2 id="1-The-IoC-Container"><a href="#1-The-IoC-Container" class="headerlink" title="1. The IoC Container"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans">1. The IoC Container</a></h2><p>这一章主要讲述 Spring 的 IoC 容器，也就是 Inversion of Control container。</p>
<h3 id="1-1-Introduction-to-the-Spring-IoC-Container-and-Beans"><a href="#1-1-Introduction-to-the-Spring-IoC-Container-and-Beans" class="headerlink" title="1.1. Introduction to the Spring IoC Container and Beans"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-introduction">1.1. Introduction to the Spring IoC Container and Beans</a></h3><p>本章涵盖了控制反转（IoC）原理的 Spring Framework 实现。IoC 也被称为依赖注入（DI）。依赖注入是这样一个过程，对象定义它们的依赖仅通过构造器参数，工厂方法参数，在对象实例构造完毕或者从工厂方法返回之后设置属性。然后，容器在创建 bean 时注入这些依赖。这个过程通过使用类的直接构造或者例如服务定位器模式的机制，从根本上反转（因此得名控制反转）了 bean 本身控制其依赖的初始化或者定位。</p>
<blockquote>
<p><strong>作者的话</strong> IoC 是 Inversion of Control 的缩写；DI 是 Dependency Injection 的缩写</p>
</blockquote>
<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 是 Spring IoC 容器的基础包。<code>BeanFactory</code> 接口提供了管理任意类型对象的高级配置机制。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口，添加了：</p>
<ul>
<li>与 Spring AOP 功能更容易集成</li>
<li>消息资源处理（用于国际化）</li>
<li>事件发布</li>
<li>应用程序层特定上下文，例如用于 Web 应用程序中的 <code>WebApplicationContext</code></li>
</ul>
<p>简而言之，<code>BeanFactory</code> 提供了配置框架和基础功能，并且 <code>ApplicationContext</code> 添加了更多企业特定的功能。<code>ApplicationContext</code> 是 <code>BeanFactory</code> 的完整超集，仅仅用于本章 Spring IoC 容器的描述。有关使用 <code>BeanFactory</code> 而不是 <code>ApplicationContext</code> 的更多信息，参见 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beanfactory">The <code>BeanFactory</code></a></p>
<blockquote>
<p>官网中，主要描述的也是 <code>ApplicationContext</code>。</p>
</blockquote>
<p>在 Spring 中，构成应用骨架并由 Spring IoC 容器管理的对象称之为 bean。bean 是由 Spring IoC 容器实例化，组装和管理的对象。一个 bean 只是你应用程序中的众多对象之一。bean 以及其中的依赖项反映在供容器使用的配置元数据中。</p>
<h3 id="1-2-Container-Overview"><a href="#1-2-Container-Overview" class="headerlink" title="1.2. Container Overview"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-basics">1.2. Container Overview</a></h3><p><code>org.springframework.context.ApplicationContext</code> 代表 Spring IoC 容器，负责实例化、配置、组装 bean。通过读取配置元数据，容器获取那些需要实例化、配置、组装的对象的说明。配置元数据表现为 XML，Java 注解，Java 代码。它让你表达出组成你应用的对象，以及这些对象之间丰富的相互依赖性。</p>
<p>Spring 提供了一些 <code>ApplicationContext</code> 接口的实现。在独立应用程序中，通常创建 <code>ClassPathXmlApplicationContext</code> 或者 <code>FileSystemXmlApplicationContext</code> 实例。虽然 XML 一直是一种定义元数据的传统格式，但可以通过提供少量 XML 配置来声明启用其他元数据格式（Java 注解，Java 代码）的支持。它使你可以表达构成你应用程序的对象，以及这些对象之间丰富的相互依赖关系。</p>
<p>Spring 提供了 <code>ApplicationContext	</code> 接口的几种实现。在独立应用程序中，通常创建一个 <code>ClassPathXmlApplicationContext</code> 或者 <code>FileSystemXmlApplicationContext</code>。虽然 XML 是定义配置元数据的传统格式，但是你可以通过提供少量的 XML 配置来声明开启对于这些传统元数据格式的支持，指示容器使用 Java 配置或者代码作为元数据格式。</p>
<p>在大多数应用程序方案中，无需明确的用户代码即可实例化一个或多个 Spring IoC 容器的实例。例如，在 Web 应用程序方案中，应用程序的 <code>web.xml</code> 文件中的样例 web 描述符 XML 简单八行就足够了。如果你使用 Spring Tools for Eclipse，你可以轻松地点几下鼠标或者敲键盘来创建此样板配置。</p>
<p>下图展示了 Spring 工作方式的高级视图。你的应用程序类与配置元数据结合起来，以便于在 <code>ApplicationContext</code> 创建并初始化之后，你可以拥有一个完全配置化的可执行的系统或应用程序。<br><img src="https://img-blog.csdnimg.cn/054c1b5f95d04370b549bd566f4891c7.png" alt="请添加图片描述"></p>
<h4 id="1-2-1-Configuration-Metadata"><a href="#1-2-1-Configuration-Metadata" class="headerlink" title="1.2.1. Configuration Metadata"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-metadata">1.2.1. Configuration Metadata</a></h4><p>如前面图所示，Spring IoC 容器消耗某种形式的配置元数据。配置元数据表现出你如何告诉 Spring 容器去实例化，配置，组装你应用程序中的对象。</p>
<blockquote>
<ul>
<li>组装可以认为是一种依赖注入。</li>
</ul>
</blockquote>
<p>传统上，配置元数据以简单而直观的 XML 格式提供，这是本章用于传达 Spring IoC 容器关键概念和特色的大多数方式。</p>
<blockquote>
<p>基于 XML 的元数据并不是唯一的配置元数据格式。Spring IoC 容器本身与配置元数据实际编写的格式完全分离。如今，许多开发人员选择为他们的 Spring 应用使用基础 Java 的配置</p>
</blockquote>
<p>有关与 Spring 容器一起使用的其他形式的元数据信息，参见：</p>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-annotation-config">Annotation-based configuration</a>: Spring 2.5 引入了基于注解的配置元数据支持</li>
<li><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java">Java-based configuration</a>: 从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多功能称为 Core Spring Framework 的一部分。因此，你可以使用 Java 而不是 XML 文件来定义你应用程序类之外的 bean。要使用这些新功能，见 <code>@Configuration</code>，<code>@Bean</code>，<code>@Import</code>，以及 <code>@DependsOn</code> 注解</li>
</ul>
<p>Spring 配置包含至少一个，且通常不止一个容器必须管理的 bean 定义。基于 XML 的配置元数据将这些 bean 以 <code>&lt;bean/&gt;</code> 元素配置在顶级 <code>&lt;beans/&gt;</code> 元素中。Java 配置通常使用 <code>@Configuration</code> 类中的 <code>@Bean</code> 注解的方法。</p>
<p>以下示例展示了基于 XML 的配置元数据的基本结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>id</code> 属性是标识单个 bean 定义的字符串<br><code>class</code> 属性定义了 bean 的类型，并且使用完全限定类名。</p>
<h4 id="1-2-2-Instantiating-a-Container"><a href="#1-2-2-Instantiating-a-Container" class="headerlink" title="1.2.2. Instantiating a Container"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-instantiation">1.2.2. Instantiating a Container</a></h4><p>提供给 <code>ApplicationContext</code> 构造器的一个或多个位置路径是资源字符串，它使得容器能够从各种外部资源加载配置元数据，例如本地文件系统，Java <code>CLASSPATH</code> 等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Composing-XML-based-Configuration-Metadata"><a href="#Composing-XML-based-Configuration-Metadata" class="headerlink" title="Composing XML-based Configuration Metadata"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-xml-import">Composing XML-based Configuration Metadata</a></h5><p>让 bean 定义涵盖多个 XML 文件可能很有用。通常，每个单独的 XML 配置文件代表你的架构中的一个逻辑层或者模块。</p>
<p>你可以使用 <code>ApplicationContext</code> 构造器从所有这些 XML 片段中加载 bean 定义。该构造器接收多个 <code>Resource</code> 路径，如前一节所示。另外，请使用一个或多个 <code>&lt;import/&gt;</code> 元素从另一个（些）文件中加载 bean 定义。以下示例显示了如何做：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;services.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;resources/messageSource.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;/resources/themeSource.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在前面的例子中，外部 bean 定义是从这三个文件加载的：<code>services.xml</code>，<code>messageSource.xml</code> 以及 <code>themeSource.xml</code>。所有路径均相对于执行 import 的定义文件，因此 <code>services.xml</code> 必须执行 import 的文件在相同的目录或者类路径位置，而 <code>messageSource.xml</code> 和 <code>themesource.xml</code> 必须位于 import 文件位置下的 <code>resources</code> 位置中。如你所见，前导的斜杠被忽略了。但是，鉴于这些路径是相对的，最好不要使用斜杠。依据 Spring Schema，所导入的文件内容，包括顶级 <code>&lt;beans/&gt;</code> 元素，必须是有效的 XML bean 定义。</p>
<blockquote>
<p>使用一个 “..&#x2F;“ 相对路径引用父目录的文件是可以的，但是并不推荐。这样做会产生对当前应用程序之外的文件的依赖。特别地，这种引用对于 <code>classpath:</code> URL（例如，<code>classpath:../services.xml</code>）也不建议，其中运行时解析过程选择 “最近” 的类路径根，然后查看其父目录。类路径配置更改可能导致选择其他的错误的路径。<br>你可以始终使用完全限定资源地址，而不是相对路径：例如，<code>file:C:/config/services.xml</code> 或者 <code>classpath:/config/services.xml</code>。但是，请注意，你将应用程序的配置耦合到特定的绝对路径。通常，最好对这种绝对路径持有一个间接取值 —— 例如，通过在运行时根据 JVM 系统属性解析的占位符 “${…}”</p>
</blockquote>
<p>命名空间本身提供了 import 指令功能。除了普通 bean 定义之外，还可以在 Spring 提供的 XML 命名空间的选择中获得更多配置功能 —— 例如，<code>context</code> 和 <code>util</code> 命名空间。</p>
<h5 id="The-Groovy-Bean-Definition-DSL"><a href="#The-Groovy-Bean-Definition-DSL" class="headerlink" title="The Groovy Bean Definition DSL"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#groovy-bean-definition-dsl">The Groovy Bean Definition DSL</a></h5><p>先省略</p>
<h4 id="1-2-3-Using-the-Container"><a href="#1-2-3-Using-the-Container" class="headerlink" title="1.2.3. Using the Container"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-client">1.2.3. Using the Container</a></h4><p><code>ApplicationContext</code> 是一个高级工厂接口，能够维护各种各样 bean 及其依赖的注册表 。通过使用 <code>T getBean(String name, Class&lt;T&gt; requiredType)</code> 方法，你可以检索 你的 bean 实例。</p>
<p><code>ApplicationContext</code> 使你可以读取 bean 定义并访问它们，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve configured instance</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// use configured instance</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure>

<p>最灵活的变体形式是 <code>GenericApplicationContext</code> 组合 Reader 委托，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 这种方式避免配置加载与 ApplicationContext 耦合</p>
</blockquote>
<p>然后，你可以使用 <code>getBean</code> 来检索 bean 实例。<code>ApplicationContext</code> 接口还有一些其他的方法用于检索 bean，但是理想情况下，你的应用程序代码绝不应该使用它们。实际上，你的应用程序代码一点都不应该调用 <code>getBean()</code> 方法，因此一点都不依赖于 Spring API。例如，Spring 和 Web 框架的集成，通过元数据声明对 bean 的依赖，进而通过 Web 框架来获取 bean。</p>
<h3 id="1-3-Bean-Overview"><a href="#1-3-Bean-Overview" class="headerlink" title="1.3. Bean Overview"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition">1.3. Bean Overview</a></h3><p>Spring IoC 容器管理一个或多个 bean。这些 bean 是用你提供给容器的配置元数据所创建的（例如，以 XML <code>&lt;bean/&gt;</code> 定义形式）。</p>
<p>在容器之中，这些 Bean Definition 都会以 <code>BeanDefinition</code> 对象形式表现，其中包含（除其他信息）以下元数据：</p>
<ul>
<li>完全限定类名，实际上也就是需要实例化的类</li>
<li>bean 行为配置元素，指示 bean 在容器的行为，例如：scope，生命周期回调 initMethodName、destroyMethodName 等</li>
<li>依赖项（DependsOn）。</li>
<li>设置在新建对象的其他设置（<code>PropertyValues</code>）。比如，池的大小, 连接的数量。</li>
</ul>
<p>该元数据转化为构成每个 Bean Definition 的一组属性。下表描述了这些属性：</p>
<table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">Explained in…​</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Class</td>
<td align="left">Instantiating Beans</td>
</tr>
<tr>
<td align="left">Name</td>
<td align="left">Naming Beans</td>
</tr>
<tr>
<td align="left">Scope</td>
<td align="left">Bean Scopes</td>
</tr>
<tr>
<td align="left">Constructor arguments</td>
<td align="left">Dependency Injection</td>
</tr>
<tr>
<td align="left">Properties</td>
<td align="left">Dependency Injection</td>
</tr>
<tr>
<td align="left">Autowiring mode</td>
<td align="left">Autowiring Collaborators</td>
</tr>
<tr>
<td align="left">Lazy initialization mode</td>
<td align="left">Lazy-initialized Beans</td>
</tr>
<tr>
<td align="left">Initialization method</td>
<td align="left">Initialization Callbacks</td>
</tr>
<tr>
<td align="left">Destruction method</td>
<td align="left">Destruction Callbacks</td>
</tr>
</tbody></table>
<h4 id="1-3-1-Naming-Beans"><a href="#1-3-1-Naming-Beans" class="headerlink" title="1.3.1. Naming Beans"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beanname">1.3.1. Naming Beans</a></h4><p>每个 Bean 可以有一个或多个标识符。这些标识符必须在托管 Bean 的容器中是唯一的。通常，一个 Bean 只有一个标识符。但是，如果需要多个，其余视为别名。</p>
<p>在基于 XML 的配置元数据，你可以使用 <code>id</code> 属性，<code>name</code> 属性，或者两个一起来指定 bean 的标识符。<code>id</code> 属性允许你指定一个标识。按照约定，这些名字是字母或数字组合，例如：myBean, someService 等。</p>
<p>如果你想引入其他别名，你也可以指定 <code>name</code> 属性，使用 <code>,</code> 或者 <code>;</code> 或者空格进行分割。</p>
<blockquote>
<p>在 Spring 3.1 之前 <code>id</code> 属性被定义为 <code>xsd:ID</code> 类型，可能受制于一定的字符。Spring 3.1 之后，它被定义为 <code>xsd:string</code> 类型。注意，尽管不再由 XML 解析器强制执行 bean <code>id</code> 唯一性，但仍然由容器强制执行。</p>
</blockquote>
<p>你不必为 bean 即提供 <code>id</code> 又提供 <code>name</code>。如果你有其中一个没有明确提供，容器会生成一个唯一的名字。但是，如果你想使用名称引用 bean，通过 <code>ref</code> 元素，或者服务定位器风格查找，你必须提供一个 name。</p>
<blockquote>
<center><strong>Bean Naming Conventions</strong></center>
该约定是，当命名 Bean 时，使用用于实例字段名称的标准 Java 约定。即，Bean 的名字以小写字母开头，并从那里开始以驼峰格式。此类名称的示例包括 `accountManager`，`accountService`，`userDao`，`loginController` 等。
</blockquote>
<h5 id="Aliasing-a-Bean-outside-the-Bean-Definition"><a href="#Aliasing-a-Bean-outside-the-Bean-Definition" class="headerlink" title="Aliasing a Bean outside the Bean Definition"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beanname-alias">Aliasing a Bean outside the Bean Definition</a></h5><p>在一个 bean 定义本身中，你可以通过 <code>id</code> 属性指定最多 1 个名称，以及在 <code>name</code> 属性中任意数量的其他名称，为 bean 提供不止一个名称。这些名称可以等效的 bean 别名，并且对于某些场景很有用，例如，让应用程序中的每个组件通过使用特定于该组件本身的 bean name 来引用通用的依赖。</p>
<blockquote>
<p>如果你使用 Java 配置，可以使用 <code>@Bean</code> 注解提供别名。</p>
</blockquote>
<h4 id="1-3-2-Instantiating-Beans"><a href="#1-3-2-Instantiating-Beans" class="headerlink" title="1.3.2. Instantiating Beans"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-class">1.3.2. Instantiating Beans</a></h4><p>Bean Definition 本质上可以认为是创建一个或多个对象的配方。当需要时，容器会查找有名 bean 的配方，并使用该 Bean Definition 封装的配置元数据来创建（或者是获取）一个实际的对象。</p>
<p>如果你使用的是基于 XML 配置元数据，指定 <code>&lt;bean/&gt;</code> 元素的 <code>class</code> 属性作为对象的类型。<code>class</code> 属性（<code>BeanDefinition</code> 实例中的 <code>Class</code> 属性）通常是必需的。</p>
<h5 id="Instantiation-with-a-Constructor"><a href="#Instantiation-with-a-Constructor" class="headerlink" title="Instantiation with a Constructor"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-class-ctor">Instantiation with a Constructor</a></h5><p>当你通过构造器方式创建 bean 时，所有一般的类都可以为 Spring 所用，并与 Spring 兼容。也就是说，开发的类无需实现特定的接口或者以特定方式进行编码。简单地指定 bean 的 class 就足够了。但是，根据你用于该特定 bean 的 IoC 类型，你可能需要一个默认（空）构造器。</p>
<p>Spring IoC 容器几乎可以管理你想要管理的任何类。它不仅仅局限于管理真正的 Java Bean。大多数 Spring 用户更愿意在容器中使用实际的 Java Bean，具有一个默认（无参）构造器，以及适当的属性 Setter 和 Getter。你也可以在容器中有更多特别的非 bean 风格的类。例如，如果你需要使用绝对不符合 Java Bean 规范的旧连接池，Spring 也可以管理它。</p>
<p>使用基于 XML 的配置元数据，你可以按照如下方式指定 bean 的 class：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;anotherExample&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBeanTwo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>有关向构造函数提供参数的机制的详细信息（如果需要），并在对象构造后设置对象实例属性，请参见 Injecting Dependencies。</p>
<h5 id="Instantiation-with-a-Static-Factory-Method"><a href="#Instantiation-with-a-Static-Factory-Method" class="headerlink" title="Instantiation with a Static Factory Method"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-class-static-factory-method">Instantiation with a Static Factory Method</a></h5><p>使用静态工厂方法创建 bean 时，class 属性指定静态工厂方法的类，factory-method 属性指定静态方法名。主要用于遗留代码中的静态工厂方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="Instantiation-by-Using-an-Instance-Factory-Method"><a href="#Instantiation-by-Using-an-Instance-Factory-Method" class="headerlink" title="Instantiation by Using an Instance Factory Method"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-class-instance-factory-method">Instantiation by Using an Instance Factory Method</a></h5><p>实例工厂创建 bean 方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个工厂方法可以包含多个工厂方法。</p>
<h5 id="Determining-a-Bean’s-Runtime-Type"><a href="#Determining-a-Bean’s-Runtime-Type" class="headerlink" title="Determining a Bean’s Runtime Type"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-type-determination">Determining a Bean’s Runtime Type</a></h5><h3 id="1-4-Dependencies"><a href="#1-4-Dependencies" class="headerlink" title="1.4. Dependencies"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-dependencies">1.4. Dependencies</a></h3><p>典型的企业应用程序并不会只包含一个对象（就是 Spring 里的 Bean）。即使是最简单的应用，也会有一些对象共同协作，以一个连贯的应用呈现给终端用户他们所看到的东西。下一节说明你如何从定义许多单独的 Bean Definition 到一个完整实现的应用程序，其中对象相互合作达到目的。</p>
<h4 id="1-4-1-Dependency-Injection"><a href="#1-4-1-Dependency-Injection" class="headerlink" title="1.4.1. Dependency Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators">1.4.1. Dependency Injection</a></h4><p>依赖注入，对象通过构造函数参数、工厂方法的参数，或者在对象构造完毕之后设置到对象实例上的属性，或者工厂方法的返回值。</p>
<p>依赖注入存在两种主要的变体：</p>
<ul>
<li>基于构造函数的依赖注入</li>
<li>基于 Setter 的依赖注入</li>
</ul>
<h5 id="Constructor-based-Dependency-Injection"><a href="#Constructor-based-Dependency-Injection" class="headerlink" title="Constructor-based Dependency Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-constructor-injection">Constructor-based Dependency Injection</a></h5><p>基于构造函数的依赖注入是通过容器调用具有多个参数的构造函数来完成，每个参数代表一个依赖项。</p>
<h6 id="Constructor-Argument-Resolution"><a href="#Constructor-Argument-Resolution" class="headerlink" title="Constructor Argument Resolution"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-constructor-injection">Constructor Argument Resolution</a></h6><p>构造函数参数解析通过参数类型匹配。如果 bean 定义的构造函数参数中不存在潜在的歧义，那么在 bean 定义中定义的构造函数参数的顺序就是当 bean 实例化时提供给构造器的参数的顺序。</p>
<p><strong>Constructor argument type matching</strong><br>如果使用 <code>type</code> 属性显式指定构造函数参数类型，则容器可以使用简单类型的类型匹配。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>&amp;nbsp;<br><strong>Constructor argument index</strong><br>解决构造函数参数歧义：可以通过 index 属性指定构造函数参数的索引（从 0 开始）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>Constructor argument name</strong><br>可以使用 <code>name</code> 属性消除构造器参数歧义。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;years&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;ultimateAnswer&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>类似 MyBats 的 <code>@Param</code>，你需要将启用代码的 debug 编译，否则 Spring 无法找到参数名。</p>
</blockquote>
<p>如果不希望使用 debug 编译，则使用 <code>@ConstructorProperties</code> 指定构造器参数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ExampleBean</span><span class="params">(<span class="type">int</span> years, String ultimateAnswer)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.years = years;</span><br><span class="line">    <span class="built_in">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Setter-based-Dependency-Injection"><a href="#Setter-based-Dependency-Injection" class="headerlink" title="Setter-based Dependency Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-setter-injection">Setter-based Dependency Injection</a></h5><p>理论上来说，基于 Setter 的依赖注入是容器在调用无参构造函数或者无参静态工厂方法实例化 bean 之后，再调用 bean 的 setter 方法完成。</p>
<p><code>ApplicationContext</code> 对于它管理的 bean，支持基于构造器的依赖注入，也支持基于 setter 的依赖注入。它还支持，在已经通过构造器注入了一些依赖之后，继续用 setter 注入依赖。</p>
<p>可以用 BeanDefinition 的形式配置依赖项，将其与 PropertyEditior 实例结合使用以将属性从一种格式转换为另一种格式。但是，一般不这样使用编程方式工作，而是用 XML 的 bean 定义，注解，或者 @Configuration + @Bean 方式。然后这些源转换成 BeanDefinition 的实例，用于加载 Spring IoC 容器。</p>
<h5 id="Dependency-Resolution-Process"><a href="#Dependency-Resolution-Process" class="headerlink" title="Dependency Resolution Process"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-dependency-resolution">Dependency Resolution Process</a></h5><p>容器执行 Bean 依赖解析如下：</p>
<ul>
<li>创建 <code>ApplicationContext</code> 并使用描述所有 Bean 的配置元数据初始化。配置元数据可以以 XML，Java 代码，或者注解方式指定。</li>
<li>对于每个 Bean，它的依赖项以属性，构造器参数，或者静态工厂方法（如果你使用它而不是普通构造器）参数的形式表示。实际创建 Bean 时，这些依赖项将提供给 Bean。</li>
<li>每个属性或者构造器参数是要设置的值的实际定义，或者是对容器中另一个 Bean 的引用</li>
<li>每个属性或者构造器参数从指定格式转换为该属性或者构造器参数的实际类型。默认地，Spring 可以将字符串格式转换为所有内置类型，如 <code>int</code>，<code>long</code>，<code>String</code>，<code>boolean</code> 等。</li>
</ul>
<h4 id="1-4-2-Dependencies-and-Configuration-in-Detail"><a href="#1-4-2-Dependencies-and-Configuration-in-Detail" class="headerlink" title="1.4.2. Dependencies and Configuration in Detail"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-properties-detailed">1.4.2. Dependencies and Configuration in Detail</a></h4><p>你可以定义 bean 属性，构造器参数作为引用其他被管理的 bean，或者作为内联值。Spring 的基于 XML 配置元数据支持在 <code>&lt;property/&gt;</code> 以及 <code>&lt;constructor-arg/&gt;</code> 之中的子元素类型。</p>
<h5 id="Straight-Values-Primitives-Strings-and-so-on"><a href="#Straight-Values-Primitives-Strings-and-so-on" class="headerlink" title="Straight Values (Primitives, Strings, and so on)"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-value-element">Straight Values (Primitives, Strings, and so on)</a></h5><p><code>&lt;property/&gt;</code> 元素的属性 <code>value</code> 将一个属性或者构造器参数指定为一个人可读的表现形式。Spring 的 conversion service 用于将这些值从 <code>String</code> 转换为属性或者参数的实际类型。以下示例展示了各种值的设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;misterkaoli&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你还可以配置 <code>java.util.Properties</code> 示例，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mappings&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.PropertySourcesPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="The-idref-element"><a href="#The-idref-element" class="headerlink" title="The idref element"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-idref-element">The idref element</a></h5><p><code>ideref</code> 元素是一种错误校验方式，将容器中另一个 bean 的 <code>id</code> 传递给 <code>&lt;constructor-arg/&gt;</code> 或者 <code>&lt;property/&gt;</code> 元素。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theClientBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的 bean 定义片段等价于下面的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;theTargetBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;client&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;targetName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;theTargetBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第一个形式比第二个更好，因为使用 <code>idref</code> 标记允许容器在部署期间验证所引用的有名 bean 是否实际存在。</p>
<h4 id="1-4-3-Using-depends-on"><a href="#1-4-3-Using-depends-on" class="headerlink" title="1.4.3. Using depends-on"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-dependson">1.4.3. Using <code>depends-on</code></a></h4><p>如果一个 Bean 是另一个 Bean 的依赖项，那通常意味着该 Bean 被设置为另一个 Bean 的属性。通常，你可以在基于 XML 的配置元数据中使用 <code>&lt;ref/&gt;</code> 元素来完成此操作。但是，有时候 Bean 之间的依赖不太直接。一个例子是，需要触发类中的静态初始化器，例如数据库驱动程序注册。<code>depends-on</code> 属性可以显式强制在使用该元素（<code>depends-on</code>）的 Bean 初始化之前，初始化一个或多个 bean。下面的示例使用 <code>depends-on</code> 属性来表达对单个 bean 的依赖性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>要表达对多个 bean 的依赖性，请提供 Bean 名称的列表作为依赖性属性的值（逗号，空格，分号是有效的分隔符）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;beanOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ExampleBean&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;manager,accountDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;manager&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;manager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ManagerBean&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.jdbc.JdbcAccountDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-4-Lazy-initialized-Beans"><a href="#1-4-4-Lazy-initialized-Beans" class="headerlink" title="1.4.4. Lazy-initialized Beans"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lazy-init">1.4.4. Lazy-initialized Beans</a></h4><p>默认地，<code>ApplicationContext</code> 实现类会迅速创建并配置所有的单例 bean，这作为初始化过程的一部分。通常，这种预启动是可取的，因为可以立即发现配置或者环境中的错误，而不是几个小时，甚至几天之后才发现。当这种行为不可取时，你可以通过将 Bean Definition 标记为懒初始化来防止对单例 bean 的预实例化。懒初始化 bean 告诉 IoC 容器首次请求时要创建一个 bean 实例，而不是在启动时创建一个 bean 实例。</p>
<p>在 XML 中，此行为由 <code>&lt;bean/&gt;</code> 元素上的 <code>lazy-init</code> 属性控制，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.ExpensiveToCreateBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;not.lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当前面的配置被 <code>ApplicationContext</code> 消费时，在 <code>ApplicationContext</code> 启动时，<code>lazy</code> bean 不会迅速地预启动，然而 <code>not.lazy</code> bean 会迅速地预实例化。</p>
<p>但是，当一个懒初始化 bean 是一个非懒初始化的单例 bean 的依赖时，<code>ApplicationContext</code> 在启动时会创建初始化 bean，因为它必须满足单例的依赖性。懒初始化 bean 被注入到别的非懒初始化的单例 bean 中。</p>
<p>你还可以通过使用 <code>&lt;beans/&gt;</code> 元素上的 <code>default-lazy-init</code> 属性来控制容器级别的懒初始化，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-5-Autowiring-Collaborators"><a href="#1-4-5-Autowiring-Collaborators" class="headerlink" title="1.4.5. Autowiring Collaborators"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-autowire">1.4.5. Autowiring Collaborators</a></h4><p>Spring 容器可以自动绑定协作 Bean 之间的关系。你可以让 Spring 自动地通过审查 <code>ApplicationContext</code> 的内容为你的 Bean 解析协作者的话（其他 Bean）。自动绑定有如下优势：</p>
<ul>
<li>自动绑定可以大大减少指定属性或者构造器参数的需求。</li>
<li>自动绑定可以随着对象的进化更新配置。</li>
</ul>
<h5 id="Limitations-and-Disadvantages-of-Autowiring"><a href="#Limitations-and-Disadvantages-of-Autowiring" class="headerlink" title="Limitations and Disadvantages of Autowiring"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-autowired-exceptions">Limitations and Disadvantages of Autowiring</a></h5><p>考虑自动绑定的局限性和劣势：</p>
<ul>
<li>在 <code>property</code> 和 <code>constructor-arg</code> 设置上的显式依赖总是会覆盖自动绑定。你不能自动绑定简单属性，例如原生类型，<code>Strings</code>，以及 <code>Classes</code>。这种限制是设计如此的。</li>
<li>自动绑定不如显式绑定精确。虽然，如前面表格所述，Spring 在可能有产生无法预测结果的歧义情况下，小心地避免猜测。你由 Spring 管理的对象之间的关系不再明确记录。</li>
<li>那些能够从 Spring 容器中生成文档的工具可能无法获得自动绑定信息</li>
<li>可能容器中多个 Bean Definition 都可以匹配待绑定的 Setter 方法或者构造器参数指定的类型。对于数字，集合，或者 <code>Map</code> 实例，这未必是个问题。但是，对于期望单个值得依赖，这种歧义无法解决。如果没有唯一得 Bean Definition，则会抛出异常。<h4 id="1-4-6-Method-Injection"><a href="#1-4-6-Method-Injection" class="headerlink" title="1.4.6. Method Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-method-injection">1.4.6. Method Injection</a></h4>在大多数应用场景中，多数的 bean 都是单例。当一个单例 bean 需要与另一个单例 bean 协作，或者一个非单例 bean 需要与另一个非单例 bean 协作，你通常会定义其中一个 bean 为另一个的属性来处理依赖关系。当 bean 的生命周期不同时，就会出现问题。假设单例 bean A 需要使用非单例（prototype）bean B，也许是在 A 的每个方法调用上。容器只会创建单例 bean A 一次，因此，只有一个机会可以设置属性 。不可能每次需要时容器都为 bean A 提供一个新的 bean B 实例。</li>
</ul>
<blockquote>
<p><strong>作者的话</strong> 官方的意思应该是 bean A 的方法调用都需要一个全新的 bean B，而不是复用同一个，但是在遵循控制反转的规则下，又无法每次需要时从容器中得到一个全新的 bean B。</p>
</blockquote>
<p>解决方案是放弃一些控制反转。你可以让 bean A 实现 <code>ApplicationContextAware</code> 接口来感知容器，并且，每当 bean A 需要的时候，通过调用容器的 <code>getBean(&quot;B&quot;)</code> 请求（通常是新的）一个 bean B 实例。</p>
<h3 id="1-5-Bean-Scopes"><a href="#1-5-Bean-Scopes" class="headerlink" title="1.5. Bean Scopes"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-scopes">1.5. Bean Scopes</a></h3><p>Spring Framework 支持 6 个范围，其中四个仅在使用 web-aware <code>ApplicationContext</code></p>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>（默认值）对于每个 Spring IoC 容器，将单个 Bean Definition 范围示为单个对象实例</td>
</tr>
<tr>
<td>prototype</td>
<td>将单个 Bean Definition 范围示为任意数量的对象实例</td>
</tr>
</tbody></table>
<h3 id="1-6-Customizing-the-Nature-of-a-Bean"><a href="#1-6-Customizing-the-Nature-of-a-Bean" class="headerlink" title="1.6. Customizing the Nature of a Bean"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-nature">1.6. Customizing the Nature of a Bean</a></h3><p>Spring Framework 提供了许多可用的接口来自定义 bean 的性质。本节将它们分组为如下：</p>
<ul>
<li>Lifecycle Callbacks</li>
<li><code>ApplicationContextAware</code> and <code>BeanNameAware</code></li>
<li>Other <code>Aware</code> Interfaces</li>
</ul>
<h4 id="1-6-1-Lifecycle-Callbacks"><a href="#1-6-1-Lifecycle-Callbacks" class="headerlink" title="1.6.1. Lifecycle Callbacks"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle">1.6.1. Lifecycle Callbacks</a></h4><p>要与 Bean 生命周期的容器管理交互，你可以实现 Spring 的 <code>InitializingBean</code> 和 <code>DisposableBean</code> 接口。该容器为前者调用 <code>afterPropertiesSet()</code>，为后者调用调用 <code>destroy()</code>，这使得在 bean 的初始化和销毁时执行某些操作。</p>
<blockquote>
<p><strong>作者的话</strong> <code>InitializingBean</code> 方法的调用是通过创建 bean 的过程中由 <code>AbstractAutowireCapableBeanFactory</code> 调用 <code>invokeInitMethods</code> 方法实现的，该方法除了调用接口实现的方法，还可以触发自定义 init 方法的调用</p>
</blockquote>
<p>在内部，Spring Framework 使用 <code>BeanPostProcessor</code> 实现类来处理任何它能找到的回调接口，并调用适当的方法。如果你需要自定义功能或者其他 Spring 默认没有提供的生命周期行为，则可以自己实现一个 <code>BeanPostProcessor</code>。更多信息，参见 Container Extension Points。</p>
<blockquote>
<p><strong>作者的话</strong> 准确来说，是由 <code>CommonAnnotationBeanPostProcessor</code> 来调用生命周期方法的，而 <code>CommonAnnotationBeanPostProcessor</code> 又是 <code>InitDestroyAnnotationBeanPostProcessor</code> 的子类，后者实现了调用逻辑。</p>
</blockquote>
<p>除了初始化和销毁的回调外，被 Spring 管理的对象还可以实现 <code>Lifecycle</code> 接口，以便于这些对象能够参与由容器自己的生命周期驱动的启动和关闭过程。</p>
<p><code>Lifecycle</code> 回调接口在本节中有描述。</p>
<p>减少与 Spring 的耦合，JSR-250 最佳实践：</p>
<ul>
<li><code>@PostConstruct</code></li>
<li><code>@PreDestroy</code></li>
</ul>
<p>不想使用 JSR-250，可以考虑：</p>
<ul>
<li>init-method</li>
<li>destroy-method</li>
</ul>
<p>Spring 使用 BeanPostProcessor 实现来处理找到的任何回调接口并调用适当的方法。可以自定义功能。</p>
<h5 id="Initialization-Callbacks"><a href="#Initialization-Callbacks" class="headerlink" title="Initialization Callbacks"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-initializingbean">Initialization Callbacks</a></h5><p><code>org.springframework.beans.factory.InitializingBean</code> 接口让 bean 可以在容器设置所有必要的属性之后执行初始化工作。<code>InitializingBean</code> 接口指定了一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>

<p>我们建议你不要使用 <code>InitializingBean</code> 接口，因为它不必要地将代码耦合到 Spring。另外，我们建议使用 <code>@PostConstruct</code> 注解或者指定一个 POJO 初始化方法。对于基于 XML 的配置元数据，你可以使用 <code>init-method</code> 属性来指定一个返回值为 void，没有参数签名的方法。对于 Java 配置，你可以使用 <code>@Bean</code> 的 <code>initMethod</code> 属性。考虑如下示例：</p>
<blockquote>
<p><strong>作者的话</strong> 如果你没有指定返回值为 void 的无参方法，那么就会启动抛出异常。</p>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> 如果你对调用初始化回调方法顺序并没有严格的需求，那么你完全可以用 <code>@PostConstruct</code> 注解来完成，从而忽视 init 方法或者 <code>InitializingBean</code> 接口。而且，<code>@PostConstruct</code> 注解方法可以配置多个，init 方法或者 <code>InitializingBean</code> 只能指定一个。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例的效果几乎与下面示例效果完全相同：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleInitBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.AnotherExampleBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，前面两个示例中的第一个不会将代码与 Spring 耦合。</p>
<h5 id="Destruction-Callbacks"><a href="#Destruction-Callbacks" class="headerlink" title="Destruction Callbacks"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-disposablebean">Destruction Callbacks</a></h5><p>实现 DisposableBean 接口可以让 bean 在容器销毁它时执行回调。</p>
<p>给 <code>destroy-method</code> 或者 <code>default-destroy-method</code> 赋予特殊值 <code>(inferred)</code> 会进行方法推断，如：java.io.Closeable，java.lang.AutoCloseable 的实现方法。</p>
<p>&amp;nbsp;</p>
<h5 id="Default-Initialization-and-Destroy-Methods"><a href="#Default-Initialization-and-Destroy-Methods" class="headerlink" title="Default Initialization and Destroy Methods"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-default-init-destroy-methods">Default Initialization and Destroy Methods</a></h5><p>在 <code>&lt;beans&gt;</code> 指定属性：</p>
<ul>
<li>default-init-method</li>
<li>default-destroy-method</li>
</ul>
<p>此属性可以被 <code>&lt;bean&gt;</code> 的属性 init-method 和 destroy-method 覆盖</p>
<h5 id="Combining-Lifecycle-Mechanisms"><a href="#Combining-Lifecycle-Mechanisms" class="headerlink" title="Combining Lifecycle Mechanisms"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-combined-effects">Combining Lifecycle Mechanisms</a></h5><p>为同一个 bean 配置多个生命周期机制，具有不同的初始化方法，调用如下：</p>
<ol>
<li>@PostConstruct 方法</li>
<li>InitializingBean.afterPropertiesSet() 方法</li>
<li>自定义配置的 init() 方法</li>
</ol>
<p>销毁方法类似：</p>
<ol>
<li>@PreDestroy</li>
<li>DisposableBean.destroy()</li>
<li>自定义配置的 destroy()</li>
</ol>
<h5 id="Startup-and-Shutdown-Callbacks"><a href="#Startup-and-Shutdown-Callbacks" class="headerlink" title="Startup and Shutdown Callbacks"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-lifecycle-processor">Startup and Shutdown Callbacks</a></h5><p><code>Lifecycle</code> 接口为那些有自己生命周期需求的对象定义了必要的方法（例如启动或停止某些后台处理过程）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何被 Spring 管理的对象都可以实现 <code>Lifecycle</code> 接口。然后，当 <code>ApplicationContext</code> 本身接收启动和停止信号时，它会汇总定义在该上下文中的所有 <code>Lifecycle</code> 实现类的调用。它通过委托给 <code>LifecycleProcessor</code> 做到这一点，如下列表所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>LifecycleProcessor</code> 本身就是 <code>Lifecycle</code> 接口的扩展。它还添加了两个其他的方法，用于响应上下文的刷新和关闭。</p>
<blockquote>
<p>注意，常规的 <code>org.springframework.context.Lifecycle</code> 接口明确的启动和停止通知的简单合同，并不意味着在上下文刷新事件内自动启动。要对特定 bean 的自动启动（包括启动阶段）进行细粒度的控制，考虑实现 <code>org.springframework.context.SmartLifecycle</code>。</p>
</blockquote>
<p>启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在”依赖”关系，则依赖侧在其依赖之后启动，并且在其依赖之前停止。但是，有时候直接依赖性是未知的。你可能只知道某种类型的对象应该在其他类型对象之前开始。在这种情况下，<code>SmartLifecycle</code> 接口定义了另一个选项，即在父接口上定义的 <code>getPhase()</code> 方法。如下几列展示了 <code>Phased</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Phased</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPhase</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下几行展示了 <code>SmartLifecycle</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span>, Phased &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAutoStartup</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">(Runnable callback)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动时，最低阶段的对象首先启动。停止时，遵循反向顺序。因此，实现 <code>SmartLifecycle</code> 及其 <code>getPhase()</code> 方法返回 <code>Integer.MIN_VALUE</code> 将是第一个启动，最后一个停止的对象。</p>
<h5 id="Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications"><a href="#Shutting-Down-the-Spring-IoC-Container-Gracefully-in-Non-Web-Applications" class="headerlink" title="Shutting Down the Spring IoC Container Gracefully in Non-Web Applications"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-shutdown">Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</a></h5><blockquote>
<p>本节仅适用于非 Web 应用。当关闭相关的 Web 应用时，Spring 基于 Web 的 <code>ApplicationContext</code> 实现已经有了适当的代码，可以优雅地关闭 Spring IoC 容器。</p>
</blockquote>
<h4 id="1-6-2-ApplicationContextAware-and-BeanNameAware"><a href="#1-6-2-ApplicationContextAware-and-BeanNameAware" class="headerlink" title="1.6.2. ApplicationContextAware and BeanNameAware"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-aware">1.6.2. <code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></h4><p>当 <code>ApplicationContextAware</code> 创建一个实现了 <code>org.springframework.context.ApplicationContextAware</code> 接口的对象实例时，会提供一个 <code>ApplicationContext</code> 的引用给该实例。下面几行展示了 <code>ApplicationContextAware</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，bean 可以通过 <code>ApplicationContext</code> 接口或者通过将引用转换到该接口的已知子类（例如 <code>ConfigurableApplicationContext</code>，其暴露了额外的功能），从而程序化地操纵创建它们的 <code>ApplicationContext</code>。一种用法是对其他 bean 的程序化检索。有时候这种功能很有用。但是，总的来说你应该避免它，因为它将代码耦合到 Spring，并且不遵循 IoC 风格，此时将合作者的话作为属性提供给 bean。<code>ApplicationContext</code> 的其他方法提供了对文件资源的访问，发布应用事件，以及访问 <code>MessageSource</code>。这些附加功能在 Additional Capabilities of the <code>ApplicationContext</code> 中进行了描述。</p>
<p>自动绑定时对获得 <code>ApplicationContext</code> 的引用的另一种替代方式。传统的 <code>constructor</code> 以及 <code>byType</code> 自动绑定模式可以分别为构造函数参数或者 setter 方法参数提供 <code>ApplicationContext</code> 类型的依赖。为了获得更多灵活性，包括自动绑定字段以及多参数方法的能力，请使用基于注解的自动绑定特性。如果你这样做了，并且字段，构造器，或者方法携带了@Autowired 注解，那么<code>ApplicationContext</code> 将自动绑定到一个字段，构造器参数，或者期望 <code>ApplicationContext</code> 类型的方法参数。更多信息，参见 Using @Autowired。</p>
<blockquote>
<p>使用 @Autowired 获得 ApplicationContext</p>
</blockquote>
<p>当 <code>ApplicationContext</code> 创建了一个实现 <code>org.springframework.beans.factory.BeanNameAware</code> 接口的类时，它会给该类提供定义在其关联对象定义中的名称引用。下面几行展示了 <code>BeanNameAware</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanNameAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在普通 bean 属性填充之后，但是在例如 <code>InitializingBean</code>，<code>afterPropertiesSet</code>，或者自定义的 init-method 初始化回调之前调用该回调。</p>
<blockquote>
<p><strong>作者的话</strong> 所以，顺序应该是填充属性（populate），Aware 回调，init 回调。</p>
</blockquote>
<h4 id="1-6-3-Other-Aware-Interfaces"><a href="#1-6-3-Other-Aware-Interfaces" class="headerlink" title="1.6.3. Other Aware Interfaces"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aware-list">1.6.3. Other Aware Interfaces</a></h4><p>除了 <code>ApplicationContextAware</code> 和 <code>BeanNameAware</code>（前面讨论过）之外，Spring 还提供了广泛的 <code>Aware</code> 回调接口，使得 bean 向容器指示它们需要一定的基础架构依赖。正如一般规则，名称表示依赖类型。下表总结了最重要的几个 <code>Aware</code> 接口：</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th>Injected Dependency</th>
<th>Explained in…​</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ApplicationContextAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">ApplicationEventPublisherAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">BeanClassLoaderAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">BeanFactoryAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">BeanNameAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">BootstrapContextAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">LoadTimeWeaverAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">MessageSourceAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">NotificationPublisherAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">ResourceLoaderAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">ServletConfigAware</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="left">ServletContextAware</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-7-Bean-Definition-Inheritance"><a href="#1-7-Bean-Definition-Inheritance" class="headerlink" title="1.7. Bean Definition Inheritance"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-child-bean-definitions">1.7. Bean Definition Inheritance</a></h3><p>Bean Definition 可以包含许多配置信息，包括构造器参数，属性值，特定于容器的信息，例如初始化方法，静态工厂方法名等。子 Bean Definition 从父 Definition 继承配置数据。子 Definition 可以覆盖一些值，或者根据需要添加其他值。使用父子 Bean Definition 可以节约大量键入。有效地，这是一种模板。</p>
<p>如果你以编程的方式使用 <code>ApplicationContext</code> 接口，那么子 Bean Definition 以 <code>ChildBeanDefinition</code> 类标表示。大多数用户在这一层不与它们合作。相反，它们在类中声明式配置 Bean Definition，例如 <code>ClassPathXmlApplicationContext</code>。当你使用基于 XML 的配置元数据时，你可以通过使用 <code>parent</code> 属性来指示子 Bean Definition，将父 bean 指定为该属性的值。下面的示例展示了怎么做：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">abstract</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.TestBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;parent&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;inheritsWithDifferentClass&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.DerivedTestBean&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">&quot;inheritedTestBean&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initialize&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;override&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="1-8-Container-Extension-Points"><a href="#1-8-Container-Extension-Points" class="headerlink" title="1.8. Container Extension Points"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension">1.8. Container Extension Points</a></h3><p>通常，应用程序开发者不必子类化 <code>ApplicationContext</code> 实现类。取而代之的是，可以通过插入特殊集成接口实现来扩展 Spring IoC 容器。接下来几节描述了这些集成接口。</p>
<h4 id="1-8-1-Customizing-Beans-by-Using-a-BeanPostProcessor"><a href="#1-8-1-Customizing-Beans-by-Using-a-BeanPostProcessor" class="headerlink" title="1.8.1. Customizing Beans by Using a BeanPostProcessor"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp">1.8.1. Customizing Beans by Using a <code>BeanPostProcessor</code></a></h4><p><code>BeanPostProcessor</code> 接口定义了一些回调方法，你可以实现它们来提供自己的实例化逻辑（或者覆盖容器默认的），依赖解析逻辑等。如果你要在 Spring 容器完成实例化，配置，初始化 bean 之后，实现一些自己的逻辑，则可以插入一个或多个自定义的 <code>BeanPostProcessor</code> 实现。</p>
<p>你可以配置多个 <code>BeanPostProcessor</code> 实例，并且通过设置 <code>order</code> 属性控制这些 <code>BeanPostProcessor</code> 实例执行顺序。你只有在 <code>BeanPostProcessor</code> 实现 <code>Ordered</code> 接口时才能设置此属性。如果你编写自己的 <code>BeanPostProcessor</code>，则也应该考虑实现 <code>Ordered</code> 接口。有关更多信息，请参阅 <code>BeanPostProcessor</code> 和 <code>Ordered</code> 接口的 javadoc。另请参见 programmatic registration of BeanPostProcessor instances.</p>
<blockquote>
<p>如果要更改实际的 bean 实例，则需要使用 BeanPostProcessor。虽然，技术上可以通过 BeanFactoryPostProcessor 实现（如：<code>beanFactory.get()</code>），但是这样会导致 bean 过早实例化，违反了标准的容器生命周期。而且，这会产生副作用，如：绕过 bean 的后置处理。</p>
</blockquote>
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code> 接口刚好由 2 个回调方法组成。当这样的类以 post-processor 注册到容器中时，post-processor 在容器初始化方法调用之前，且在任何 bean 初始化回调之后，都会从容器中获得回调。Post Processor 可以对 bean 实例进行任何操作，包括完全忽略回调。一个 Bean Post Processor 通常检查回调接口，或者可能包装带有代理的 bean。一些 Spring AOP 基础架构类以 Bean Post Processor 进行实现，以提供代理包装逻辑</p>
<p><code>ApplicationContext</code> 自动检测实现了 <code>BeanPostProcessor</code> 接口的定义在配置元数据中的任何 bean。<code>ApplicationContext</code> 将这些 bean 注册为后置处理器，以便以后再 bean 创建时可被调用。Bean Post Processor 可以与其他任何 bean 以相同的方式部署到容器中。</p>
<p>请注意，当通过在 Configuration 类上使用 <code>@Bean</code> 工厂方法声明 <code>BeanPostProcessor</code> 时，工厂方法的返回类型应该时实现类本身，或者至少是 <code>org.springframework.beans.factory.config.BeanPostProcessor</code> 接口，清晰表明该 bean 的后置处理性质。否则，<code>ApplicationContext</code> 在完全创建它之前将无法通过类型自动检测到。由于需要尽早实例化 <code>BeanPostProcessor</code> 才能应用于上下文中其他 bean 的初始化，因此这种早期类型检测至关重要。</p>
<blockquote>
<p><strong>作者的话</strong> 如果你的 <code>BeanPostProcessor</code> 不仅实现了 <code>BeanPostProcessor</code> 还实现了其他接口或者继承了其他类，那么 @Bean 返回类型必须使用 <code>BeanPostProcessor</code> 否则 Spring 无法识别到</p>
</blockquote>
<p>具体的底层代码可以阅读 <code>AbstractAutowireCapableBeanFactory#initializeBean()</code>，其中在调用 <code>invokeInitMethods()</code> 方法的前后分别调用了 <code>applyBeanPostProcessorsBeforeInitialization()</code> 和 <code>applyBeanPostProcessorsAfterInitialization()</code>。</p>
<table>
<thead>
<tr>
<th align="left">常见的 BeanPostProcessor</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CommonAnnotationBeanPostProcessor</td>
<td align="left">用于执行 @PostConstruct @PreDestroy 注解的方法</td>
</tr>
<tr>
<td align="left">AutowiredAnnotationBeanPostProcessor</td>
<td align="left">用于自动注入 @Autowired @Value @Inject</td>
</tr>
</tbody></table>
<h5 id="Example-Hello-World-BeanPostProcessor-style"><a href="#Example-Hello-World-BeanPostProcessor-style" class="headerlink" title="Example: Hello World, BeanPostProcessor-style"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-hw">Example: Hello World, BeanPostProcessor-style</a></h5><h5 id="Example-The-AutowiredAnnotationBeanPostProcessor"><a href="#Example-The-AutowiredAnnotationBeanPostProcessor" class="headerlink" title="Example: The AutowiredAnnotationBeanPostProcessor"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-aabpp">Example: The AutowiredAnnotationBeanPostProcessor</a></h5><p>使用回调接口或者注解，配合自定义的 <code>BeanPostProcessor</code> 实现是扩展 Spring IoC 容器的常见手段。一个例子是 Spring <code>AutowiredAnnotationBeanPostProcessor</code> —— 这是 <code>BeanPostProcessor</code> 的一个实现类，其与 Spring 分布和 <code>@Autowired</code> 注解字段，Setter 方法，以及任意配置方法一起</p>
<h4 id="1-8-2-Customizing-Configuration-Metadata-with-a-BeanFactoryPostProcessor"><a href="#1-8-2-Customizing-Configuration-Metadata-with-a-BeanFactoryPostProcessor" class="headerlink" title="1.8.2. Customizing Configuration Metadata with a BeanFactoryPostProcessor"></a><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-extension-factory-postprocessors">1.8.2. Customizing Configuration Metadata with a BeanFactoryPostProcessor</a></h4><p><code>BeanFactoryPostProcessor</code> 是一个扩展点。<code>BeanFactoryPostProcessor</code> 与 <code>BeanPostProcessor</code> 语义类似，但有一个主要区别：<code>BeanFactoryPostProcessor</code> 对 bean 配置元数据进行操作。Spring Ioc 容器允许 <code>BeanFactoryPostProcessor</code> 读取配置元数据，并且可以在实例化除了 <code>BeanFactoryPostProcessor</code> 任何 bean 之前修改这些配置元数据。</p>
<blockquote>
<p><code>BeanDefinitionRegistryPostProcessor</code> 是 <code>BeanFactoryPostProcessor</code> 的子接口。</p>
</blockquote>
<p>可以配置多个 BeanFactoryPostProcessor 实例，并通过 order 属性来控制这些实例的运行顺序。如果编写自己的 BeanFactoryPostProcessor，也应该考虑实现 Ordered 接口。</p>
<p>为了应用这些改变到容器中的配置元数据，当 bean factory 后置处理器声明在 <code>ApplicationContext</code> 中时，它会自动执行。Spring 包含了许多预定义的 bean factory 后置处理器，比如 <code>PropertyOverrideConfigurer</code> 以及 <code>PropertySourcesPlaceholderConfigurer</code>。</p>
<h3 id="1-9-Annotation-based-Container-Configuration"><a href="#1-9-Annotation-based-Container-Configuration" class="headerlink" title="1.9. Annotation-based Container Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-annotation-config">1.9. Annotation-based Container Configuration</a></h3><blockquote>
<center><strong>配置 Spring 注解比 XML 更好吗？</strong></center>
引入基于注解的配置出现了一个问题，即这种方式是否比 XML 更好。简短的答案是：看情况。具体就是，每种方法都有其优点和缺点，通常，开发人员决定哪种测策略更适合他们。由于他们的定义方式，注解在声明的时候提供许多上下文，使得配置更短，更简洁。但是，XML 擅于在不触及源代码以及重新编译的情况下，将组件关联起来。一些开发者更喜欢让关联接近源代码，而另一个开发者人为注解类不再是 POJO，此外，配置变得分散且难以控制。
</blockquote>
<ul>
<li>Spring 2.0 引入 <code>@Required</code> 强化需要的属性</li>
</ul>
<p>基于注解得配置提供了 XML 设置的可替代方案，该方案依赖于字节码元数据来绑定组件而不是声明。无需使用 XML 去描述 Bean 的绑定，开发者只需将配置移动到组件类本身，在相关的类，方法，或者字段声明上面使用注解。如 <a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factory-extension-bpp-examples-aabpp">Example: The AutowiredAnnotationBeanPostProcessor</a> 所述，结合注解使用 <code>BeanPostProcessor</code> 是扩展 Spring IoC 容器的通用方式。</p>
<h4 id="1-9-1-Required"><a href="#1-9-1-Required" class="headerlink" title="1.9.1. @Required"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-required-annotation">1.9.1. @Required</a></h4><p><code>@Required</code> 注解用于 bean 的 Setter 方法，如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>作者的话</strong> 该注解只能使用在方法上</p>
</blockquote>
<p>该注解表示，受影响的 Bean 属性必须在配置期间填充属性，无论是通过 Bean Definition 中明确的属性值，还是自动绑定。如果受影响的属性并没有填充，则容器会抛出一个异常。这是考虑到尽早且明确的故障，以免以后 <code>NullPointerException</code> 实例或者此类的问题。我们依然建议你将断言放到 bean 类本身（例如，放入 init 方法）。这样做甚至可以当你在容器之外使用类时，也能强制需要的引用和值。</p>
<blockquote>
<p><code>RequiredAnnotationBeanPostProcessor</code> 必须注册为一个 bean，以支持 <code>@Required</code> 注解</p>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> Spring Boot 默认是不注册 <code>RequiredAnnotationBeanPostProcessor</code> 的，因此需要手动导入，譬如使用 <code>@Import</code></p>
</blockquote>
<blockquote>
<p><code>@Required</code> 注解和 <code>RequiredAnnotationBeanPostProcessor</code> 在 Spring 框架 5.1 正式弃用，这是为了支持对必需的配置使用构造器注入（或者一个 <code>InitializingBean.afterPropertiesSet()</code> 自定义的实现，或者随着 Bean 属性 Setter 方法自定义的 <code>@PostConstruct</code> 方法。</p>
</blockquote>
<h4 id="1-9-2-Using-Autowired"><a href="#1-9-2-Using-Autowired" class="headerlink" title="1.9.2. Using @Autowired"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation">1.9.2. Using <code>@Autowired</code></a></h4><blockquote>
<p>在本节包含的示例中，你可以使用 JSR 330 的 <code>@Inject</code> 注解代替 Spring 的 <code>@Autowired</code> 注解。有关更多详情，参见<a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-standard-annotations">此处</a>。</p>
</blockquote>
<p>你可以将 <code>@Autowired</code> 注解应用在构造器上，如下实例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从 Spring Framework 4.3 开始，如果目标 Bean 仅定义了一个构造器，则不再需要在该构造器上使用 <code>@Autowired</code> 注解。但是，如果有几个构造器可用，并且没有 primary 或者默认构造器，至少用 <code>@Autowired</code> 注解一个构造器，以便于指示容器用哪一个。</p>
</blockquote>
<p>你也可以将 <code>@Autowired</code> 注解应用于传统的 Setter 方法，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以将注解应用于具有任意名称和多个参数的方法，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span><br><span class="line"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你还可以将 <code>@Autowird</code> 应用在字段上，甚至混合构造器一起使用，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过将 <code>@Autowired</code> 注解添加到字段或者期望数组类型的方法上，你可以指示 Spring 从 <code>ApplicationContext</code> 中提供所有特定类型的 Bean，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同的也可以用在集合类型上，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至类型 <code>Map</code> 示例也可以自动绑定，只要期望的 Key 类型是 <code>String</code>。<code>Map</code> 的 value 包含所有期望类型的 Bean，kay 包含相关的 Bean 名称，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovieRecommender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieCatalogs = movieCatalogs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况，当对于给定的注入点没有匹配的候选 Bean 可用时，自动绑定就会失败。在声明了数组，集合，或者 Map 情况下，期望至少有一个匹配的元素。</p>
<p>默认的行为是将注解的方法和字段视为必需的依赖。你可以如下示例所示，更改此行为，通过将其标记为非必需的（即，通过设置 <code>@Autowired</code> 属性 <code>required</code> 为 <code>false</code>），让框架跳过不满足的注入点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个非必需的方法依赖（或者在多参数情况下，有一个依赖）不可获得，那么该方法根本不会调用。在这种情况下，非必需的字段将根本不会被填充，保持默认值。</p>
<p>另外，你可以通过 Java 8 的 <code>java.util.Optional</code> 表达特定以来的非必需特性，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(Optional&lt;MovieFinder&gt; movieFinder)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>@Autowired 用法</strong>：<br>(1) 构造函数。若 bean 只有一个构造函数，则可不必。<br>(2) setter 方法<br>(3) 任意的方法<br>(4) 字段<br>(5) 数组、Collection、Map<br>(6) java.util.Optional<br>(7) BeanFactory，ApplicationContext，Environment，ResourceLoader，ApplicationEventPublisher，MessageSource 这些接口以及它们的扩展接口</p>
<p><strong>指定类型数组、集合的顺序</strong><br>(1) org.springframework.core.Ordered<br>(2) @Order 或者 @Priority </p>
<p>@Autowired，@Inject、@Value、@Resource 会由 Spring 的 BeanPostProcessor 处理。因此，不能在自己的 BeanPostProcessor 或者 BeanFactoryPostProcessor 中使用这些注解（否则循环了）。</p>
<p>注入见：<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessProperties</code></p>
<h4 id="1-9-3-Fine-tuning-Annotation-based-Autowiring-with-Primary"><a href="#1-9-3-Fine-tuning-Annotation-based-Autowiring-with-Primary" class="headerlink" title="1.9.3. Fine-tuning Annotation-based Autowiring with @Primary"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation-primary">1.9.3. Fine-tuning Annotation-based Autowiring with @Primary</a></h4><p>按照<strong>类型</strong>的自动绑定可能产生多个候选者，因此有必要使用更多的控制进行选择。其中一种方式就是使用 <code>@Primary</code> 注解。<code>@Primary</code> 注解表示，当多个 bean 候选者需要自动绑定到一个单值依赖上时，特定的 bean 应该给予优先权。如果多个候选者中存在一个主要的 bean，那么它将会自动绑定到值上。</p>
<blockquote>
<ul>
<li><code>BeanDefinition</code> 接口方法 <code>isPrimary()</code> 正是描述了该 bean 是否具有优先权。</li>
<li>如果你注入了两个类型相同，且都标注了 <code>@Primary</code> 的 bean，而且通过类型获取单个 bean，那么将会抛出异常。具体逻辑见：DefaultListableBeanFactory#determinePrimaryCandidate</li>
</ul>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> 该注解完全可以忽视，一般并不希望自动绑定出现歧义，或者直接使用 <code>@Resource</code> 进行准确绑定。</p>
</blockquote>
<h4 id="1-9-4-Fine-tuning-Annotation-based-Autowiring-with-Qualifiers"><a href="#1-9-4-Fine-tuning-Annotation-based-Autowiring-with-Qualifiers" class="headerlink" title="1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation-qualifiers">1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers</a></h4><p>当你需要在选择过程上有更多控制时，可以使用 <code>@Qualifier</code> 注解。你可以将 qualifier 的值与特定参数绑定，缩小类型匹配的集合，以便于能选出特定的那个 bean。</p>
<p>可以用于：字段、方法参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;main&quot;)</span></span><br><span class="line"><span class="keyword">private</span> MovieCatalog movieCatalog;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">(<span class="meta">@Qualifier(&quot;main&quot;)</span> MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.movieCatalog = movieCatalog;</span><br><span class="line">    <span class="built_in">this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>作为备用匹配，bean 的名称被当作默认的限定值。但是，即使你使用这个约定，通过名称引用一个 bean，@Autowired 本质上也是类型驱动注解，只是附带一个可选的语义限定符（在匹配类型的集合中缩小范围），并不能表示唯一一个 bean 的 <code>id</code>。</li>
<li>好的限定符应该表达一个与 bean ID 无关的特定组件的特征。</li>
</ul>
</blockquote>
<p>Qualifier 也可以适用于类型集合，比如 <code>Set&lt;Object&gt;</code>，这意味着限定者并不是唯一的，而是一个筛选条件。</p>
<blockquote>
<ul>
<li>如果你希望通过名称进行注解驱动注入，但不想使用 <code>@Autowired</code>，即使这是可以在类型匹配的候选者中选择对应名称的 bean，你可以使用 JSR-250 注解 <code>@Resource</code>，这是一个语义上定义为通过使用唯一名称标识特定组件的注解，与声明类型无关。</li>
</ul>
</blockquote>
<h4 id="1-9-5-Using-Generics-as-Autowiring-Qualifiers"><a href="#1-9-5-Using-Generics-as-Autowiring-Qualifiers" class="headerlink" title="1.9.5. Using Generics as Autowiring Qualifiers"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-generics-as-qualifiers">1.9.5. Using Generics as Autowiring Qualifiers</a></h4><p>除了显式使用 <code>@Qualifier</code> 注解，你可以使用 Java 泛型作为隐式的限定。</p>
<h4 id="1-9-6-Using-CustomAutowireConfigurerl"><a href="#1-9-6-Using-CustomAutowireConfigurerl" class="headerlink" title="1.9.6. Using CustomAutowireConfigurerl"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-custom-autowire-configurer">1.9.6. Using CustomAutowireConfigurer</a>l</h4><h4 id="1-9-7-Injection-with-Resource"><a href="#1-9-7-Injection-with-Resource" class="headerlink" title="1.9.7. Injection with @Resource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-resource-annotation">1.9.7. Injection with @Resource</a></h4><p>Spring 也支持 JSR-250 注解 <code>@Resource</code>，用于字段或者 bean 属性的 setter 方法。</p>
<p><code>@Resource</code> 具有一个 <code>name</code> 属性。默认地，Spring 将该值当作被注入的 bean 的名字。</p>
<blockquote>
<ul>
<li><code>@Resource</code> 注解不支持 static 字段。</li>
</ul>
</blockquote>
<p>如果没有指定 name，默认的名称将会从字段名或者 setter 方法中解析出来。没有显式地指定名称，类似于 @Autowired，@Resource 将查找主要地类型匹配而不是特定 名称，并且解析熟知的 BeanFactory, ApplicationContext, ResourceLoader, ApplicationEvenetPublisher, MessageSource 接口。</p>
<h4 id="1-9-8-Using-Value"><a href="#1-9-8-Using-Value" class="headerlink" title="1.9.8. Using @Value"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-value-annotations">1.9.8. Using @Value</a></h4><p><code>@Value</code> 典型的用法是注入外部的属性</p>
<p>使用位置：字段、方法参数</p>
<ul>
<li><code>@Value(&quot;$&#123;catalog.name:defaultCatalog&#125;&quot;)</code>，defaultCatalog 为默认值，用冒号隔开</li>
<li><code>@Value(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</code>，嵌套使用</li>
</ul>
<p>Spring 默认是宽松解析，如果要严格解析，配置 <code>PropertySourcesPlaceholderConfigurer</code>，Spring Boot 是默认配置的（见 <code>PropertyPlaceholderAutoConfiguration</code>）。</p>
<h4 id="1-9-9-Using-PostConstruct-and-PreDestroy"><a href="#1-9-9-Using-PostConstruct-and-PreDestroy" class="headerlink" title="1.9.9. Using @PostConstruct and @PreDestroy"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-postconstruct-and-predestroy-annotations">1.9.9. Using @PostConstruct and @PreDestroy</a></h4><p><code>CommonAnnotationBeanPostProcessor</code> 不仅能识别 <code>@Resource</code> 注解，还可以识别 JSR-250 生命周期注解：<code>javax.annotation.PostConstruct</code> 和 <code>javax.annotation.PreDestroy</code>。</p>
<blockquote>
<p>在标准 JDK 6 到 JDK 8 中，<code>@Resource</code>, <code>@PostConstruct</code>, <code>@PreDestroy</code> 注解是其中的一部分。但是，整个 <code>javax.annotation</code> 包在 JDK 9 中与核心模块分开，并最终在 JDK 11 移除。如果需要，则应该通过 maven 中心获取 <code>javax.annotation-api</code> 组件，简单地添加到类路径中。</p>
</blockquote>
<h3 id="1-10-Classpath-Scanning-and-Managed-Components"><a href="#1-10-Classpath-Scanning-and-Managed-Components" class="headerlink" title="1.10. Classpath Scanning and Managed Components"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-classpath-scanning">1.10. Classpath Scanning and Managed Components</a></h3><p>通过隐式地类路径扫描找到候选组件。候选组件是那些与过滤器标准相匹配的类，并且会有一个相关的 bean 定义被注册到容器中。这会消除使用 XML 执行 bean 定义的需求。取而代之的，你可以使用注解，AspectJ 类型表达式，或者你自己自定义的过滤器原则来挑选出注册到容器中的 bean 定义。</p>
<h4 id="1-10-1-Component-and-Further-Stereotype-Annotations"><a href="#1-10-1-Component-and-Further-Stereotype-Annotations" class="headerlink" title="1.10.1. @Component and Further Stereotype Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-stereotype-annotations">1.10.1. @Component and Further Stereotype Annotations</a></h4><p><code>@Repository</code> 是那些具有仓库（也可以认为是 Data Access Object）作用的类的标记。</p>
<p>Spring 提供了更多注解：<code>@Component</code>, <code>@Service</code>, <code>@Controller</code>。<code>@Component</code> 对于任何 Spring 管理的组件来说，是一个通用注解。<code>@Repository</code>, <code>@Service</code>, <code>@Controller</code> 是 <code>@Component</code> 的特例。因此，你可以用 <code>@Component</code> 注解你的组件类，但是，通过用 <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code> 注解，你的类可以更好地通过工具处理，或者与切面关联。</p>
<h4 id="1-10-2-Using-Meta-annotations-and-Composed-Annotations"><a href="#1-10-2-Using-Meta-annotations-and-Composed-Annotations" class="headerlink" title="1.10.2. Using Meta-annotations and Composed Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-meta-annotations">1.10.2. Using Meta-annotations and Composed Annotations</a></h4><p>Spring 提供的许多注解可以作为你自己代码的元注解，以供其他注解使用。</p>
<p>你可以组合元注解创建组合型注解。例如，<code>@RestController</code> 注解就是 Spring MVC 框架中，由 <code>@Controller</code> 和 <code>@ResponseBody</code> 组合而成。</p>
<h4 id="1-10-3-Automatically-Detecting-Classes-and-Registering-Bean-Definitions"><a href="#1-10-3-Automatically-Detecting-Classes-and-Registering-Bean-Definitions" class="headerlink" title="1.10.3. Automatically Detecting Classes and Registering Bean Definitions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-scanning-autodetection">1.10.3. Automatically Detecting Classes and Registering Bean Definitions</a></h4><p>Spring 可以自动检测刻板印象类，并注册相关的 <code>BeanDefinition</code> 实例到 <code>ApplicationContext</code>。例如，以下两个类有资格被自动检测到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title class_">MovieFinder</span> &#123;</span><br><span class="line">    <span class="comment">// implementation elided for clarity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了自动检测类并注册相关的 bean，需要将 <code>@ComponentScan</code> 添加到 <code>@Configuraion</code> 类上，其中，<code>@ComponentScan</code> 的 <code>basePackages</code> 属性是这些的共有父包。</p>
<blockquote>
<ul>
<li>你可以指定多个父包，以逗号（<code>,</code>）或者分号（<code>;</code>）或者空格分隔。</li>
</ul>
</blockquote>
<p>如果你使用 XML，则可以以如下代码替代：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;org.example&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当你使用 <code>&lt;component-scan/&gt;</code> 元素时 ，<code>AutowiredAnnotationBeanPostProcessor </code> 和 <code>CommonAnnotationBeanPostProcessor </code> 两者会隐式地包含进来。</p>
<blockquote>
<ul>
<li>你可以通过包含 <code>annotation-config</code>，设置其值为 <code>false</code> 来禁用 <code>AutowiredAnnotationBeanPostProcessor </code> 和 <code>CommonAnnotationBeanPostProcessor </code> 的注册。</li>
</ul>
</blockquote>
<h4 id="1-10-4-Using-Filters-to-Customize-Scanning"><a href="#1-10-4-Using-Filters-to-Customize-Scanning" class="headerlink" title="1.10.4. Using Filters to Customize Scanning"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-scanning-filters">1.10.4. Using Filters to Customize Scanning</a></h4><p>默认地，本身是用 @Component 注解的类，会被检测作为候选组件。但是也可以配置过滤器。</p>
<h4 id="1-10-5-Defining-Bean-Metadata-within-Components"><a href="#1-10-5-Defining-Bean-Metadata-within-Components" class="headerlink" title="1.10.5. Defining Bean Metadata within Components"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-factorybeans-annotations">1.10.5. Defining Bean Metadata within Components</a></h4><h4 id="1-10-8-Providing-Qualifier-Metadata-with-Annotations"><a href="#1-10-8-Providing-Qualifier-Metadata-with-Annotations" class="headerlink" title="1.10.8. Providing Qualifier Metadata with Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-scanning-qualifiers">1.10.8. Providing Qualifier Metadata with Annotations</a></h4><h3 id="1-11-Using-JSR-330-Standard-Annotations"><a href="#1-11-Using-JSR-330-Standard-Annotations" class="headerlink" title="1.11. Using JSR 330 Standard Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-standard-annotations">1.11. Using JSR 330 Standard Annotations</a></h3><p>从 Spring 3.0 开始，Spring 为 JSR-330 标准注解（依赖注入）提供了支持。这些注解与 Spring 注解一样以相同的方式被扫描。要使用他们，你必须在类路径中持有相关的 jar 包。</p>
<blockquote>
<p>如果你使用 maven，<code>javax.inject</code> 的 artifact 可以在标准 maven 仓库（<a href="https://repo1.maven.org/maven2/javax/inject/javax.inject/1/%EF%BC%89%E7%9B%B4%E6%8E%A5%E8%8E%B7%E5%BE%97%E3%80%82%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B7%BB%E5%8A%A0%E5%88%B0">https://repo1.maven.org/maven2/javax/inject/javax.inject/1/）直接获得。你可以将下面的依赖添加到</a> pom.xml：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;<span class="number">1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="1-11-1-Dependency-Injection-with-Inject-and-Named"><a href="#1-11-1-Dependency-Injection-with-Inject-and-Named" class="headerlink" title="1.11.1. Dependency Injection with @Inject and @Named"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-inject-named">1.11.1. Dependency Injection with @Inject and @Named</a></h4><p>为了代替 <code>@Autowired</code>，你可以使用 <code>@javax.inject.Inject</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listMovies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder.findMovies(...);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 <code>@Autowired</code> 一样，你可以在字段级别，方法级别，构造函数级别内使用 <code>@Inject</code>。此外，你可以将注入点声明为一个 <code>Provider</code>，从而可以按需访问较短的范围或者通过调用 <code>Provider.get()</code> 来懒惰地访问其他 Bean。以下的示例提供了前面示例的变体：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Provider&lt;MovieFinder&gt; movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(Provider&lt;MovieFinder&gt; movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listMovies</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder.get().findMovies(...);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想使用注入依赖的限定名称，可以使用 <code>@Named</code> 注解，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(<span class="meta">@Named(&quot;main&quot;)</span> MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 <code>@Autowired</code> 一样，<code>@Inject</code> 也可以与 <code>java.util.Optional</code> 或者 <code>@Nullable</code> 一起使用。在这里甚至更合适，因为 <code>@Inject</code> 没有 <code>require</code> 属性。以下一对示例展示了如何使用 <code>@Inject</code> 和 <code>@Nullable</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(Optional&lt;MovieFinder&gt; movieFinder)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-11-2-Named-and-ManagedBean-Standard-Equivalents-to-the-Component-Annotation"><a href="#1-11-2-Named-and-ManagedBean-Standard-Equivalents-to-the-Component-Annotation" class="headerlink" title="1.11.2. @Named and @ManagedBean: Standard Equivalents to the @Component Annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-named">1.11.2. @Named and @ManagedBean: Standard Equivalents to the @Component Annotation</a></h4><p>你可以使用 <code>@javax.inject.Named</code> 或者 <code>@javax.annotation.ManagedBean</code> 代替 <code>@Component</code>，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named(&quot;movieListener&quot;)</span>  <span class="comment">// @ManagedBean(&quot;movieListener&quot;) could be used as well</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@Component</code> 而不为组件指定名称非常常见。<code>@Named</code> 可以以类似的方式使用，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> javax.inject.Named;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Named</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你使用 <code>@Named</code> 或者 <code>@ManagedBean</code> 时，你可以以与使用 Spring 注解时完全相同方式进行组件扫描，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;org.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>与 <code>@Component</code> 相反，JSR-330 <code>@Named</code> 和 JSR-250 <code>@ManagedBean</code> 注解是不可组合的。你应该使用 Spring 的刻板印象模型来构建自定义的注解。</p>
</blockquote>
<blockquote>
<p><strong>作者的话</strong> 之所以无法构建自定义的组合注解，是因为 Spring 不会去检查你的自定义注解。见 <code>ClassPathScanningCandidateComponentProvider</code> 的 <code>includeFilters</code>。</p>
</blockquote>
<h4 id="1-11-3-Limitations-of-JSR-330-Standard-Annotations"><a href="#1-11-3-Limitations-of-JSR-330-Standard-Annotations" class="headerlink" title="1.11.3. Limitations of JSR-330 Standard Annotations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-standard-annotations-limitations">1.11.3. Limitations of JSR-330 Standard Annotations</a></h4><p>当你使用标准注解时，你应该知道，有一些重要功能是不可用的，如下表所示：</p>
<table>
<thead>
<tr>
<th align="left">Spring</th>
<th align="left">java.inject.*</th>
<th align="left">javax.inject restrictions &#x2F; comments</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Autowired</td>
<td align="left">@Inject</td>
<td align="left"><code>@Inject</code> 没有 required 属性。可以用 Java 8 的 <code>Optional</code> 替代</td>
</tr>
<tr>
<td align="left">@Component</td>
<td align="left">@Named &#x2F; @ManagedBean</td>
<td align="left">JSR-330 未提供组合的模型，只是一种识别命名组件的方式</td>
</tr>
<tr>
<td align="left">@Scope(“singleton”)</td>
<td align="left">@Singleton</td>
<td align="left">JSR-330 默认范围就像 Spring 的 <code>prototype</code>。但是，为了使其与 Spring 的一般默认值保持一致，声明在 容器中的 JSR-330 Bean 默认是 <code>singleton</code>。为了使用 <code>singleton</code> 意外的范围，你应该使用 Spring 的 <code>@Scope</code> 注解。<code>javax.inject</code> 也提供了一个 <code>@Scope</code> 注解。然而，这仅仅用于创建你自己的注解。</td>
</tr>
<tr>
<td align="left">@Qualifier</td>
<td align="left">@Qualifier &#x2F; @Named</td>
<td align="left"><code>javax.inject.Qualifier</code> 仅仅是一个用于构建自定义 qualifier 的元注解。可以通过 <code>javax.inject.Named</code> 关联具体的 <code>String</code> 限定词（就像 Spring 带有一个值的 <code>@Qualifier</code>）</td>
</tr>
<tr>
<td align="left">@Value</td>
<td align="left">-</td>
<td align="left">没有对等体</td>
</tr>
<tr>
<td align="left">@Required</td>
<td align="left">-</td>
<td align="left">没有对等体</td>
</tr>
<tr>
<td align="left">@Lazy</td>
<td align="left">-</td>
<td align="left">没有对等体</td>
</tr>
<tr>
<td align="left">ObjectFactory</td>
<td align="left">Provider</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="1-12-Java-based-Container-Configuration"><a href="#1-12-Java-based-Container-Configuration" class="headerlink" title="1.12. Java-based Container Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java">1.12. Java-based Container Configuration</a></h3><h4 id="1-12-1-Basic-Concepts-Bean-and-Configuration"><a href="#1-12-1-Basic-Concepts-Bean-and-Configuration" class="headerlink" title="1.12.1. Basic Concepts: @Bean and @Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-basic-concepts">1.12.1. Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></a></h4><p>在 Spring 新的 Java 注解支持中的中央工件是 <code>@Configuration</code> 注解类以及 <code>@Bean</code> 注解方法。</p>
<p><code>@Bean</code> 注解用于表明方法是实例化，配置和初始化一个由 Spring IoC 容器管理的新对象。对于那些熟悉 Spring <code>&lt;bean/&gt;</code> XML 配置的人，<code>@Bean</code> 注解扮演着与 <code>&lt;bean/&gt;</code> 元素相同的角色。</p>
<h4 id="1-12-2-Instantiating-the-Spring-Container-by-Using-AnnotationConfigApplicationContext"><a href="#1-12-2-Instantiating-the-Spring-Container-by-Using-AnnotationConfigApplicationContext" class="headerlink" title="1.12.2. Instantiating the Spring Container by Using AnnotationConfigApplicationContext"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container">1.12.2. Instantiating the Spring Container by Using <code>AnnotationConfigApplicationContext</code></a></h4><p><code>AnnotationConfigApplicationContext</code> 在<br>以下各节记录了 Spring 的 <code>AnnotationConfigApplicationContext</code>，在 Spring 3.0 引入。这种万能的 <code>ApplicationContext</code> 实现不仅能接收 <code>@Configuration</code> 类作为输入，而且能够接受 <code>@Component</code> 类以及 JSR-330 元数据注解的类。</p>
<p>当提供 <code>@Configuration</code> 类作为输入时，<code>@Configuration</code> 类本身被注册为 Bean Definition，并且在类中声明的所有 <code>@Bean</code> 方法也都会注册为 Bean Definition。</p>
<p>当 <code>@Component</code> 或者 JSR-330 注解的类作为输入时，它们会注册为 Bean Definition，并且在必要时，这些类中的依赖元数据，例如 <code>@Autowired</code> 或者 <code>@Inject</code> 都会被使用。</p>
<h5 id="Simple-Construction"><a href="#Simple-Construction" class="headerlink" title="Simple Construction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-constructor">Simple Construction</a></h5><p>与实例化 <code>ClassPathXmlApplicationContext</code> 时使用 Spring XML 文件作为输入的方式相同，当你实例化一个 <code>AnnotationConfigApplicationContext</code> 时，你可以使用 <code>@Configuration</code> 类作为输入。这是考虑到完全无 XML 的 Spring 容器的使用，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前面说的，<code>AnnotationConfigApplicationContext</code> 不仅限于与 <code>@Configuration</code> 类一起使用。任意 <code>@Component</code> 或者 JSR-330 注解类都可以作为输入提供给构造器，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的示例假定 <code>MyServiceImpl</code>，<code>Dependency1</code>，以及 <code>Dependency2</code> 使用了 Spring 依赖注入注解，例如 <code>@Autowired</code>。</p>
<h5 id="Building-the-Container-Programmatically-by-Using-register-Class-lt-gt-…​"><a href="#Building-the-Container-Programmatically-by-Using-register-Class-lt-gt-…​" class="headerlink" title="Building the Container Programmatically by Using register(Class&lt;?&gt;…​)"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-register">Building the Container Programmatically by Using <code>register(Class&lt;?&gt;…​)</code></a></h5><p>你可以通过使用无参构造器实例化一个 <code>AnnotationConfigApplicationContext</code>，然后使用 <code>register()</code> 对其进行配置。当程序化地构建了一个 <code>AnnotationConfigApplicationContext</code> 这种方式特别有用。以下示例显示了如何做到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">    ctx.register(AdditionalConfig.class);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">    myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Enabling-Component-Scanning-with-scan-String…​"><a href="#Enabling-Component-Scanning-with-scan-String…​" class="headerlink" title="Enabling Component Scanning with scan(String…​)"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-scan">Enabling Component Scanning with <code>scan(String…​)</code></a></h5><p>要启用组件扫描，你可以按以下方式注解 <code>@Configuration</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.acme&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span>  &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，扫描 <code>com.acme</code> 包查找 <code>@Component</code> 注解的类，并且这些类以 Spring Bean Definition 的形式注册在容器中。<code>AnnotationConfigApplicationContext</code> 暴露了 <code>scan(String...)</code> 方法，以允许相同组件扫描功能，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    ctx.scan(<span class="string">&quot;com.acme&quot;</span>);</span><br><span class="line">    ctx.refresh();</span><br><span class="line">    <span class="type">MyService</span> <span class="variable">myService</span> <span class="operator">=</span> ctx.getBean(MyService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Support-for-Web-Applications-with-AnnotationConfigWebApplicationContext"><a href="#Support-for-Web-Applications-with-AnnotationConfigWebApplicationContext" class="headerlink" title="Support for Web Applications with AnnotationConfigWebApplicationContext"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-instantiating-container-web">Support for Web Applications with <code>AnnotationConfigWebApplicationContext</code></a></h5><p><code>AnnotationConfigApplicationContext</code> 的 <code>WebApplicationContext</code> 变体可用 <code>AnnotationConfigWebApplicationContext</code>。你在在配置 Spring <code>ContextLoaderListener</code> Servlet Listener，Spring MVC <code>DispatcherServlet</code> 等时候，使用此实现。下面的 <code>web.xml</code> 摘要配置了一个典型的 Spring MVC Web 应用（请注意 <code>contextClass</code> context-param 和 init-param 的使用）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext</span></span><br><span class="line"><span class="comment">        instead of the default XmlWebApplicationContext --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Configuration locations must consist of one or more comma- or space-delimited</span></span><br><span class="line"><span class="comment">        fully-qualified @Configuration classes. Fully-qualified packages may also be</span></span><br><span class="line"><span class="comment">        specified for component-scanning --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext</span></span><br><span class="line"><span class="comment">            instead of the default XmlWebApplicationContext --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Again, config locations must consist of one or more comma- or space-delimited</span></span><br><span class="line"><span class="comment">            and fully-qualified @Configuration classes --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.acme.web.MvcConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/app/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h4 id="1-12-3-Using-the-Bean-Annotation"><a href="#1-12-3-Using-the-Bean-Annotation" class="headerlink" title="1.12.3. Using the @Bean Annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-bean-annotation">1.12.3. Using the <code>@Bean</code> Annotation</a></h4><p><code>@Bean</code> 是一种方法级注解，是 <code>&lt;bean/&gt;</code> 元素的等价。注解支持一些 <code>&lt;bean/&gt;</code> 提供的属性，例如：*init-method destroy-method autowiring name.</p>
<p>你可以在 <code>@Configuration</code> 注解类或者 <code>@Component</code> 注解类中使用 <code>@Bean</code> 注解。</p>
<h5 id="Declaring-a-Bean"><a href="#Declaring-a-Bean" class="headerlink" title="Declaring a Bean"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-declaring-a-bean">Declaring a Bean</a></h5><p>要声明一个 Bean，你可以用使用 <code>@Bean</code> 注解一个方法。你可以使用此方法在 <code>ApplicationContext</code> 中注册一个 Bean Definition，其类型由方法返回值指定。默认地，Bean 名称与方法名称相同。以下示例展示了 <code>@Bean</code> 方法声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferServiceImpl <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的配置完全等同于以下 Spring XML：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;transferService&quot;</span> class=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>这两种声明都使一个名为 <code>transferService</code> 的 bean 在 <code>ApplicationContext</code> 中可获得，绑定到类型为 <code>TransferServiceImpl</code> 的对象实例上，如下文本图形所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">transferService -&gt; com.acme.TransferServiceImpl</span><br></pre></td></tr></table></figure>

<p>你也可以用接口（或者基类）返回值声明你的 <code>@Bean</code> 方法，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这将预先类型预测的可见性限制为指定的接口类型（<code>TransferService</code>）。然后，只有一次容器知道完全类型，被影响的单例已经被实例化。非懒惰单例 bean 根据其声明 order 初始化。因此，你可能看到不同类型的匹配结果，具体取决于其他组件试图通过非声明类型（例如 @Autowired TransferServiceImple，只有在实例化了 <code>TransferService</code> bean 之后才能解析）匹配。</p>
<h5 id="Bean-Aliasing"><a href="#Bean-Aliasing" class="headerlink" title="Bean Aliasing"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-bean-aliasing">Bean Aliasing</a></h5><p>正如 Naming Beans 讨论的，有时候希望给一个 bean 多个名字，也成为 bean 别名。</p>
<p>如果希望给 bean 赋予多个名称，或者称之为别名，你可以向 <code>@Bean</code> 的 <code>name</code> 属性传递一个字符串数组。为此，<code>@Bean</code> 注解的 <code>name</code> 属性接受一个字符串数组。以下示例显示了如何为一个 bean 设置许多别名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&#123;&quot;dataSource&quot;, &quot;subsystemA-dataSource&quot;, &quot;subsystemB-dataSource&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// instantiate, configure and return DataSource bean...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="1-12-4-Using-the-Configuration-annotation"><a href="#1-12-4-Using-the-Configuration-annotation" class="headerlink" title="1.12.4. Using the @Configuration annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-configuration-annotation">1.12.4. Using the <code>@Configuration</code> annotation</a></h4><p><code>@Configuration</code> 是一个类级别的注解，表明一个对象是 Bean Definition 的来源。<code>@Configuration</code> 类通过 public <code>@Bean</code> 注解方法声明 Bean。<code>@Configuration</code> 类上的 <code>@Bean</code> 方法的调用也可以用于定义 Bean 之间的依赖。</p>
<h5 id="Injecting-Inter-bean-Dependencies"><a href="#Injecting-Inter-bean-Dependencies" class="headerlink" title="Injecting Inter-bean Dependencies"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-injecting-dependencies">Injecting Inter-bean Dependencies</a></h5><p>当 Bean 依赖于另一个 Bean 时，表现为依赖让一个 Bean 方法调用另一个一样简单，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanOne <span class="title function_">beanOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanOne</span>(beanTwo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanTwo <span class="title function_">beanTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanTwo</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，<code>beanOne</code> 通过构造器注入接收一个对 <code>beanTwo</code> 的引用。</p>
<blockquote>
<p>仅当 <code>@Bean</code> 方法声明在 <code>@Configuration</code> 类中时，这种声明 Bean 间依赖的方法才生效。你无法通过使用普通 <code>@Component</code> 类声明 Bean 间依赖。</p>
</blockquote>
<h5 id="Lookup-Method-Injection"><a href="#Lookup-Method-Injection" class="headerlink" title="Lookup Method Injection"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-method-injection">Lookup Method Injection</a></h5><p>如前所述，lookup method injection 是你比较少用的高级功能。在单例 Bean 依赖于原型 Bean 时这很有用。使用 Java 进行此类配置提供了一种天然的方式用于实现这种模式。下面的例子展示了如何查找方法注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CommandManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">process</span><span class="params">(Object commandState)</span> &#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title function_">createCommand</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 Java 配置，你可以创建一个 <code>CommandManager</code> 子类，其中抽象方法 <code>createCommand()</code> 被覆盖以查找一个新的（prototype）Command 对象。下面的示例展示了如何做到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> AsyncCommand <span class="title function_">asyncCommand</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AsyncCommand</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AsyncCommand</span>();</span><br><span class="line">    <span class="comment">// inject dependencies here as required</span></span><br><span class="line">    <span class="keyword">return</span> command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandManager <span class="title function_">commandManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// return new anonymous implementation of CommandManager with createCommand()</span></span><br><span class="line">    <span class="comment">// overridden to return a new prototype Command object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommandManager</span>() &#123;</span><br><span class="line">        <span class="keyword">protected</span> Command <span class="title function_">createCommand</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> asyncCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-12-5-Composing-Java-based-Configurations"><a href="#1-12-5-Composing-Java-based-Configurations" class="headerlink" title="1.12.5. Composing Java-based Configurations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-composing-configuration-classes">1.12.5. Composing Java-based Configurations</a></h4><p>Spring 的基于 Java 的配置特色让你可以组合注解，从而降低配置的复杂度。</p>
<h5 id="Using-the-Import-Annotation"><a href="#Using-the-Import-Annotation" class="headerlink" title="Using the @Import Annotation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-using-import">Using the @Import Annotation</a></h5><p>就像在 Spring XML 文件中使用 <code>&lt;import/&gt;</code> 元素以帮助模块化配置，<code>@Import</code> 注解也允许你从另一个配置类加载 <code>@Bean</code> 定义，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> A <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(ConfigA.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">b</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种功能的引入旨在简化容器实例化，只用准备一个你需要的类，而不是记住所有的 <code>@Configuration</code></p>
<blockquote>
<p>自从 Spring Framework 4.2，<code>@Import</code> 也支持引用普通 Component 类。当你不希望组件扫描时，这是比较有用的，通过少数几个配置类作为入口点，从而定义你需要的组件。</p>
</blockquote>
<p>&amp;nbsp;<br><code>@Import</code> 支持以下几种用法：</p>
<ul>
<li>导入普通 Bean</li>
<li>导入 ImportSelector 实现类</li>
<li>导入 ImportBeanDefinitionRegistrar 实现类</li>
</ul>
<p>更多 <code>@Import</code> 用法参见 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html">API</a></p>
<p><strong>框架案例</strong> MyBatis 的自动扫描 @Mapper 注入，@Import(AutoConfiguredMapperScannerRegistrar.class)</p>
<p>&amp;nbsp;</p>
<h5 id="Conditionally-Include-Configuration-Classes-or-Bean-Methods"><a href="#Conditionally-Include-Configuration-Classes-or-Bean-Methods" class="headerlink" title="Conditionally Include @Configuration Classes or @Bean Methods"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-conditional">Conditionally Include @Configuration Classes or @Bean Methods</a></h5><p>有条件地启用或禁用完整的 @Configuration 类，甚至单个 @Bean 方法。最常用的是使用 <code>@Profile</code>。</p>
<p><code>@Profile</code> 注解实际上是通过更灵活的称之为 <code>@Conditional</code> 的注解实现。<code>@Conditional</code> 注解表示：特定的 <code>org.springframework.context.annotation.Condition</code> 实现应该在 @Bean 注册之前作为参考。</p>
<p><code>Condition</code> 的接口实现提供了一个 <code>matches(...)</code> 方法，它返回 true 或者 false。</p>
<h5 id="Combining-Java-and-XML-Configuration"><a href="#Combining-Java-and-XML-Configuration" class="headerlink" title="Combining Java and XML Configuration"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-combining">Combining Java and XML Configuration</a></h5><p>Spring 的 @Configuration 类支持并不是为了完全取代 XML 配置。某些情况下，Spring XML 仍然是一种配置容器的理想方式。在 XML 比较方便或者必须使用的情况下，你可以选择：通过使用例如 <code>ClassPathXmlApplicationContext</code> 以 “XML为中心” 的方式实例化容器；或者以 “Java 为中心” 的方式实例化容器，使用 <code>AnnotationConfigApplicationContext</code> 以及 <code>@ImportResource</code> 注解导入所需的 XML</p>
<h6 id="XML-centric-Use-of-Configuration-Classes"><a href="#XML-centric-Use-of-Configuration-Classes" class="headerlink" title="XML-centric Use of @Configuration Classes"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-java-combining-xml-centric">XML-centric Use of <code>@Configuration</code> Classes</a></h6><p>也许最好的方式是从 XML 中引导 Spring 容器，并以点对点的方式包含 <code>@Configuration</code> 类。例如，在一个使用 Spring XML 的大型的现有代码库中，很容易在需要的基础上创建 <code>@Configuration</code> 类，并将他们从现存的 XML 文件中包含进去。稍后在本节中，我们会介绍这种 “以 XML 为中心” 情况下使用 <code>@Configuration</code> 类的选项。</p>
<p><strong>Declaring <code>@Configuration</code> classes as plain Spring <code>&lt;bean/&gt;</code> elements</strong></p>
<p>记住，<code>@Configuration</code> 类最终是容器中的 Bean Definition。在本系列示例中，我们创建了一个名为 <code>AppConfig</code> 的 <code>@Configuration</code>，并以一个 <code>&lt;bean/&gt;</code> 定义将其包含进 <code>system-test-config.xml</code> 中。因为 <code>&lt;context:annotaion-config/&gt;</code> 已经开启，容器会识别 <code>@Configuration</code> 注解并正确处理 <code>AppConfig</code> 中声明的 <code>@Bean</code> 方法。</p>
<p>以下示例展示了 Java 中一个普通的配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccountRepository <span class="title function_">accountRepository</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferService</span>(accountRepository());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下示例展示了案例 <code>system-test-config.xml</code> 文件的部分：<br>&#96;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;!-- enable processing of annotations such as <span class="meta">@Autowired</span> and <span class="meta">@Configuration</span> --&gt;</span><br><span class="line">    &lt;context:annotation-config/&gt;</span><br><span class="line">    &lt;context:property-placeholder location=<span class="string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=<span class="string">&quot;com.acme.AppConfig&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>以下示例展示了可能的 <code>jdbc.properties</code> 文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:hsqldb:hsql://localhost/xdb</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:/com/acme/system-test-config.xml&quot;</span>);</span><br><span class="line">    <span class="type">TransferService</span> <span class="variable">transferService</span> <span class="operator">=</span> ctx.getBean(TransferService.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Using &lt;context:component-scan&#x2F;&gt; to pick up <code>@Configuration</code> classes</strong></p>
<h6 id="Configuration-Class-centric-Use-of-XML-with-ImportResource"><a href="#Configuration-Class-centric-Use-of-XML-with-ImportResource" class="headerlink" title="[@Configuration Class-centric Use of XML with @ImportResource]"></a>[<code>@Configuration</code> Class-centric Use of XML with <code>@ImportResource</code>]</h6><p>在一些 <code>@Configuration</code> 类是配置容器的主要机制的应用中，仍然很可能有必要至少使用一些 XML。在这些情况下，你可以使用 <code>@ImportResource</code>，并按你所需定义 XML。这样做可以实现一种 “以 Java 为中心” 的方式配置容器，并将 XML 保持在最低限度。以下示例展示了如何使用 <code>@ImportSource</code> 注解来实现按需使用 XML 的 “以 Java 为中心” 的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>(url, username, password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">properties-config.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:/com/acme/jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.properties</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:hsqldb:hsql://localhost/xdb</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">    <span class="type">TransferService</span> <span class="variable">transferService</span> <span class="operator">=</span> ctx.getBean(TransferService.class);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-13-Environment-Abstraction"><a href="#1-13-Environment-Abstraction" class="headerlink" title="1.13. Environment Abstraction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-environment">1.13. Environment Abstraction</a></h3><p><code>Environment</code> 接口是一个集成在容器中的抽象，它模型化了两个关键的应用程序环境方面：profiles 和 properties。</p>
<p>一个 profile 是一个有名的 Bean Definition 逻辑组，仅在给定的 profile 处于激活状态时，Bean Definition 才能注册到容器中。无论是以 XML 方式还是注解方式，bean 都可以分配给一个 profile。<code>Environment</code> 关于 profiles 的作用就是决定哪个 profile 当前是激活的，哪个 profiles 应该默认被激活。</p>
<p>属性在几乎所有应用程序都发挥着重要作用，并且可能来自各种源：属性文件，JVM 系统属性，系统环境变量，JNDI，Servlet 上下文参数，ad-hoc <code>Properties</code> 对象，<code>Map</code> 对象等。<code>Environment</code> 对象对于属性的作用就是提供用户一个方便的服务接口，用于配置属性源以及从中解析属性。</p>
<h4 id="1-13-1-Bean-Definition-Profiles"><a href="#1-13-1-Bean-Definition-Profiles" class="headerlink" title="1.13.1. Bean Definition Profiles"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles">1.13.1. Bean Definition Profiles</a></h4><p>Bean Definition profile 在核心容器中提供了一种机制，可以在不同环境中注册不同的 bean。”environment” 一词对于不同用户来说可能意味着不同的事物，该功能有助于许多用例，例如：</p>
<p>考虑在实际需要 <code>DataSource</code> 的应用的第一个用例。在测试环境中，配置可能类似于下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class="line">        .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">        .addScript(<span class="string">&quot;my-schema.sql&quot;</span>)</span><br><span class="line">        .addScript(<span class="string">&quot;my-test-data.sql&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Using-Profile"><a href="#Using-Profile" class="headerlink" title="Using @Profile"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java">Using <code>@Profile</code></a></h5><p><code>@Profile</code> 注解允许你指示当一个或多个指定 profile 激活时，一个组件才有资格注册。</p>
<p><code>@Profile</code> 也可以在方法级别声明，这样仅包括了配置类的一个特定 bean。</p>
<h5 id="XML-Bean-Definition-Profiles"><a href="#XML-Bean-Definition-Profiles" class="headerlink" title="XML Bean Definition Profiles"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-xml">XML Bean Definition Profiles</a></h5><p>XML 对应的是 <code>&lt;bean/&gt;</code> 元素的 <code>profile</code> 属性。我们前面的示例配置可以以两个 XML 文件的方式重写，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;development&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以避免拆分，并在同一个文件中嵌套 <code>&lt;beans/&gt;</code> 元素，如下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- other bean definitions --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 嵌套 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="Activating-a-Profile"><a href="#Activating-a-Profile" class="headerlink" title="Activating a Profile"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-enable">Activating a Profile</a></h5><p>可以以多种方式激活 profile：</p>
<ul>
<li>Environment API 方式</li>
<li>spring.profiles.active</li>
</ul>
<p>最简单的是使用 <code>ApplicationContext</code> 的 <code>Environment</code> API 以编程方式激活：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;development&quot;</span>);</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">&quot;profile1&quot;</span>, <span class="string">&quot;profile2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>还可以通过 <code>spring.profiles.active</code> 属性激活配置文件，可以通过系统环境变量，JVM 系统属性，web.xml 中的 servlet 上下文参数，甚至是在 JNDI 中的条目指定。<code>spring.profiles.active</code> 可以接受以逗号（<code>,</code>）分割的 profile 名称列表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dspring.profiles.active=<span class="string">&quot;profile1,profile2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="Default-Profile"><a href="#Default-Profile" class="headerlink" title="Default Profile"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-default">Default Profile</a></h5><p>默认的 profile 表示默认启用的 profile。考虑如下示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultDataConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有激活任何 profile，<code>dataSource</code> 会被创建。你可以将其视为为一个或多个 Bean 提供默认定义的一种方式。如果启用了任意 profile，默认的 profile 不再使用。</p>
<p>你可以通过在 <code>Environment</code> 上使用 <code>setDefaultPrfiles()</code> 或者声明式地使用 <code>spring.profiles.default</code> 来修改默认 profile 的名称。</p>
<h4 id="1-13-2-PropertySource-Abstraction"><a href="#1-13-2-PropertySource-Abstraction" class="headerlink" title="1.13.2. PropertySource Abstraction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-property-source-abstraction">1.13.2. <code>PropertySource</code> Abstraction</a></h4><p>Spring 的 <code>Environment</code> 抽象在属性源的可配置层次结构上提供了搜索操作。考虑下面的代码清单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="type">Environment</span> <span class="variable">env</span> <span class="operator">=</span> ctx.getEnvironment();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">containsMyProperty</span> <span class="operator">=</span> env.containsProperty(<span class="string">&quot;my-property&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Does my environment contain the &#x27;my-property&#x27; property? &quot;</span> + containsMyProperty);</span><br></pre></td></tr></table></figure>

<p>在前面的片段中，我们看到了一种高级方法，其询问 Spring 是否为当前环境定义了 <code>my-property</code> 属性。为了回答这个问题，<code>Environment</code> 对象会对一组 <code>PropertySource</code> 对象执行搜索。<code>PropertySource</code> 是任何键值对源的简单抽象，并且 Spring 的 <code>StandardEnvironment</code> 配置了两个 <code>PropertySource</code> 对象 —— 一个代表 JVM 系统属性集（<code>System.getProperties()</code>），一个代表系统环境变量集（<code>System.getenv()</code>）。</p>
<blockquote>
<p>这些默认的属性源存在于 <code>StandardEnvironment</code>，用于独立应用。<code>StandardServletEnvironment</code> 填充了其他默认的属性源，包括 Servlet Config 以及 Servlet Context 参数。它可以选择性的启用 <code>JndiPropertySource</code>。详细信息参见 javadoc。</p>
</blockquote>
<p>具体而言，当你使用 <code>StandardEnvironment</code> 时，如果在运行时具有 <code>my-property</code> 系统属性或者 <code>my-property</code> 环境变量，调用 <code>env.containsProperty(&quot;my-property&quot;)</code> 就会返回 true。</p>
<blockquote>
<p>执行搜索是分层次的。默认地，系统属性优先于环境变量。因此，如果在调用 <code>env.getProperty(&quot;my-property&quot;)</code> 期间 <code>my-property</code> 属性在两个地方都发生了赋值，系统属性值会”胜利”并返回。请注意，属性值并不会合并，而是完全被前面的条目覆盖。<br>对于通用的 <code>StandardServletEnvironment</code>，完整的层次结构如下，优先级最高的在最顶端：</p>
<ol>
<li>ServletConfig 参数（如果适用，例如，在 <code>DispatcherServlet</code> 上下文的情况下）</li>
<li>ServletContext 参数（web.xml 上下文参数条目）</li>
<li>JNDI 环境变量（<code>java:comp/env/</code> 条目）</li>
<li>JVM 系统属性（<code>-D</code> 命令行参数）</li>
<li>JVM 系统环境（操作系统环境变量）</li>
</ol>
</blockquote>
<p>最重要的是，整个机制都是可配置的。也许你有一个自定义的属性源，要将其继承到此搜索中。为此，实现并实例化你自己的 <code>PropertySource</code> 并将其添加到当前 <code>Environment</code> 的 <code>PropertySources</code> 集合中。下面示例展示了怎么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="type">MutablePropertySources</span> <span class="variable">sources</span> <span class="operator">=</span> ctx.getEnvironment().getPropertySources();</span><br><span class="line">sources.addFirst(<span class="keyword">new</span> <span class="title class_">MyPropertySource</span>());</span><br></pre></td></tr></table></figure>

<p>在前面的代码中，在搜索中以高优先级添加了 <code>MyPropertySource</code>。如果它包含 <code>my-property</code> 属性，属性会被检测并返回，支持其他任何 <code>PropertySource</code> 中的任何 <code>my-property</code> 属性。<code>MutablePropertySources</code> API 暴露了许多方法，这些方法允许精确地操纵属性源集合。</p>
<h4 id="1-13-3-Using-PropertySource"><a href="#1-13-3-Using-PropertySource" class="headerlink" title="1.13.3. Using @PropertySource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-using-propertysource">1.13.3. Using <code>@PropertySource</code></a></h4><p><code>@PropertySource</code> 注解提供了一种便捷的声明式机制，用于将 <code>PropertySource</code> 添加到 Spring 的 <code>Environment</code> 中。</p>
<p>给定一个名为 <code>app.properties</code> 的文件，包含键值对 <code>testbean.name=myTestBean</code>，下面的 <code>@Configuration</code> 类使用 <code>@PropertySource</code>，以这种方式调用 <code>testBean.getName()</code> 返回 <code>myTestBean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/com/myco/app.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">testBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TestBean</span> <span class="variable">testBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>();</span><br><span class="line">        testBean.setName(env.getProperty(<span class="string">&quot;testbean.name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> testBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出现在 <code>@PropertySource</code> 中的任何 <code>$&#123;...&#125;</code> 占位符都会用已经注册到 Environment 中的属性源集合进行解析，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:/com/$&#123;my.placeholder:default/path&#125;/app.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TestBean <span class="title function_">testBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TestBean</span> <span class="variable">testBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestBean</span>();</span><br><span class="line">        testBean.setName(env.getProperty(<span class="string">&quot;testbean.name&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> testBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假定 <code>my.placeholder</code> 存在于已经注册的属性源之一（例如，系统属性或者环境变量）中，占位符会被解析为相关值。如果不存在，那么 <code>default/path</code> 会被作为默认值。如果未指定默认值，且属性无法解析，将会抛出 <code>IllegalArgumentException</code>。</p>
<h4 id="1-13-4-Placeholder-Resolution-in-Statements"><a href="#1-13-4-Placeholder-Resolution-in-Statements" class="headerlink" title="1.13.4. Placeholder Resolution in Statements"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-placeholder-resolution-in-statements">1.13.4. Placeholder Resolution in Statements</a></h4><p>过去，只针对 JVM 系统属性或者环境变量，元素上的占位符可以被解析。现在已不再这样。因为 <code>Environment</code> 抽象是集成在容器中的，因此很容易通过它来路由占位符的解析。这意味着你可以以任何你喜欢的方式配置解析流程。你可以通过系统属性或者环境变量更改搜索优先级，或者完全移除它们。你还可以适当地添加自己的属性资源。</p>
<p>具体而言，无论 <code>customer</code> 属性定义在哪儿，只要在 <code>Environment</code> 中可获得，下面的语句就可以工作：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;com/bank/service/$&#123;customer&#125;-config.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-14-Registering-a-LoadTimeWeaver"><a href="#1-14-Registering-a-LoadTimeWeaver" class="headerlink" title="1.14. Registering a LoadTimeWeaver"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-load-time-weaver">1.14. Registering a <code>LoadTimeWeaver</code></a></h3><p>Spring 使用 <code>LoadTimeWeaver</code> 当类加载到 Java 虚拟机时，动态转换这些类。</p>
<p>要启动加载时编织，你可以将 <code>@EnableLoadTimeWeaving</code> 添加到你的 <code>@Configuration</code> 类，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableLoadTimeWeaving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，对于 XML 配置，你可以使用 <code>context:load-time-weaver</code> 元素：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:load-time-weaver</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一旦配置为 <code>ApplicationContext</code>，任何在该 <code>ApplicationContext</code> 中的 bean 都可以实现 <code>LoadTimeWeaverAware</code>，从而接收到加载时 weaver 示例的引用。</p>
<h3 id="1-15-Additional-Capabilities-of-the-ApplicationContext"><a href="#1-15-Additional-Capabilities-of-the-ApplicationContext" class="headerlink" title="1.15. Additional Capabilities of the ApplicationContext"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-introduction">1.15. Additional Capabilities of the <code>ApplicationContext</code></a></h3><h4 id="1-15-1-Internationalization-using-MessageSource"><a href="#1-15-1-Internationalization-using-MessageSource" class="headerlink" title="1.15.1. Internationalization using MessageSource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-messagesource">1.15.1. Internationalization using <code>MessageSource</code></a></h4><h4 id="1-15-2-Standard-and-Custom-Events"><a href="#1-15-2-Standard-and-Custom-Events" class="headerlink" title="1.15.2. Standard and Custom Events"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events">1.15.2. Standard and Custom Events</a></h4><p><code>ApplicationContext</code> 中的事件处理功能通过 <code>ApplicationEvent</code> 类以及 <code>ApplicationListener</code> 接口提供。如果一个实现了 <code>ApplicationListener</code> 接口的 bean 部署到上下文中，那么每次 <code>ApplicationEvent</code> 发布到 <code>ApplicationContext</code> 时，该 bean 会被通知。本质上，这是一种标准的观察者模式。</p>
<p>Spring 提供的标准事件：</p>
<ul>
<li><code>ContextRefreshedEvent</code></li>
<li><code>ContextStartedEvent</code></li>
<li><code>ContextStoppedEvent</code></li>
<li><code>ContextClosedEvent</code></li>
<li><code>RequestHandledEvent</code></li>
<li><code>ServletRequestHandledEvent</code></li>
</ul>
<h5 id="Annotation-based-Event-Listeners"><a href="#Annotation-based-Event-Listeners" class="headerlink" title="Annotation-based Event Listeners"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events-annotation">Annotation-based Event Listeners</a></h5><p>在一个 bean 的方法上通过使用 <code>@EventListener</code> 注解注册一个事件监听器。</p>
<p>方法签名声明事件监听的类型。事件的类型可以通过泛型参数缩小范围，只要实际事件类型在其实现架构中解析你的泛型参数。</p>
<p>如果方法应该监听多个事件，或者你不想定义参数，那么可以在注解上指定事件类型。</p>
<p>可以通过 <code>condition</code> 属性定义一个 SpEL 表达式来添加更多的运行时过滤效果。</p>
<h5 id="Asynchronous-Listeners"><a href="#Asynchronous-Listeners" class="headerlink" title="Asynchronous Listeners"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events-async">Asynchronous Listeners</a></h5><p>如果你希望异步地处理某个事件，那你可以使用常规的 <code>@Async</code> 注解。</p>
<h5 id="Ordering-Listeners"><a href="#Ordering-Listeners" class="headerlink" title="Ordering Listeners"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events-order">Ordering Listeners</a></h5><p>如果你需要在另一个监听器之前调用某个监听器，则你可以添加 <code>@Order</code> 注解至方法声明，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="meta">@Order(42)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBlockedListEvent</span><span class="params">(BlockedListEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// notify appropriate parties via notificationAddress...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="Generic-Events"><a href="#Generic-Events" class="headerlink" title="Generic Events"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-functionality-events-generics">Generic Events</a></h5><p>你可以使用泛型来进一步定义事件的架构。例如，使用 <code>EntityCreatedEvent&lt;T&gt;</code>，其中 <code>T</code> 表示创建的实际实体类型。</p>
<h3 id="1-16-The-BeanFactory"><a href="#1-16-The-BeanFactory" class="headerlink" title="1.16. The BeanFactory"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beanfactory">1.16. The BeanFactory</a></h3><p><code>BeanFactory</code> API 为 Spring IoC 功能提供了基础。它的特定约定主要用于与 Spring 的其他部分以及第三方框架集成，并且它的 <code>DefaultListableBeanFactory</code> 实现是更高级别的 <code>GenericApplicationContext</code> 容器的委托。</p>
<p><code>BeanFactory</code> 和相关接口（如 <code>BeanFactoryAware</code>, <code>InitializingBean</code>, <code>DisposableBean</code>）是其他框架的重要集成点。不需要任何注解或者反射，它们可以非常高效地在容器和组件之间通信。应用程序级别的 bean 可以使用相同的回调接口，但是通常会通过注解或者程序配置的方式进行声明式的依赖注入。</p>
<p>请注意，核心 <code>BeanFactory</code> API 级别和它的 <code>DefaultLisableBeanFactory</code> 实现都没有对配置格式或者任何待使用的组件注解做出规定。所有的风格都通过扩展（如：<code>XmlBeanDefinitionReader</code> 和 <code>AutowiredAnnotationBeanPostProcessor</code>）进行，并在共享的作为核心元数据表现形式的 <code>BeanDefinition</code> 对象上操作。这就是使 Spring 容器如此灵活且可扩展的本质。</p>
<h4 id="1-16-1-BeanFactory-or-ApplicationContext"><a href="#1-16-1-BeanFactory-or-ApplicationContext" class="headerlink" title="1.16.1. BeanFactory or ApplicationContext?"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#context-introduction-ctx-vs-beanfactory">1.16.1. <code>BeanFactory</code> or <code>ApplicationContext</code>?</a></h4><p>在 ApplicationContext 中（如 GenericApplicationContext 实现），可以根据 bean name 或者 bean type（特别是后置处理器） 找到 bean，然而，普通的 DefaultListableBeanFactory 与任何特殊 bean 无关。</p>
<blockquote>
<p>自从 SpringFramework 4.3，如果目标 bean 只定义了一个构造器，那么不再需要指定 @Autowired 注解，见<a href="https://docs.spring.io/spring-framework/docs/4.3.29.RELEASE/spring-framework-reference/htmlsingle/#new-in-4.3">4.3更新日志</a></p>
</blockquote>
<h2 id="2-Resources"><a href="#2-Resources" class="headerlink" title="2. Resources"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources">2. Resources</a></h2><h3 id="2-1-Introduction"><a href="#2-1-Introduction" class="headerlink" title="2.1. Introduction"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-introduction">2.1. Introduction</a></h3><p>不幸地是，Java 标准的 <code>java.net.URL</code> 类和用于各种各样 URL 前缀的标准处理器不足以访问所有的低级资源。例如，没有标准化的 <code>URL</code> 实现可以用于访问需要从类路径或者相对于 <code>ServletContext</code> 的资源。虽然可以为特定的 	<code>URL</code> 前缀注册新的处理器（类似于目前用于注入 <code>http:</code> 前缀的处理器），但这通常非常复杂，并且 <code>URL</code> 接口仍然缺乏一些理想的功能，例如检查被指向的资源存在性。</p>
<h3 id="2-2-The-Resource-Interface"><a href="#2-2-The-Resource-Interface" class="headerlink" title="2.2. The Resource Interface"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-resource">2.2. The Resource Interface</a></h3><p>Spring 的 <code>Resource</code> 接口旨在成为一个用于抽象访问低级资源的更强大的接口。以下列举了 <code>Resource</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Resource</span> <span class="keyword">extends</span> <span class="title class_">InputStreamSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isOpen</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    URL <span class="title function_">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    File <span class="title function_">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    Resource <span class="title function_">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getFilename</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如 <code>Resource</code> 接口所示的定义，它扩展了 <code>InputStreamSource</code> 接口。以下列出了 <code>InputStreamSource</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InputStreamSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    InputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Resource</code> 接口中一些最重要的方法是：</p>
<ul>
<li><code>getInputStream()</code>: 定位并打开资源，返回一个输入流以从资源中读取。预计每次调用都会返回新的输入流。调用者的职责就是关闭流。</li>
<li><code>exists()</code>: 返回一个 <code>boolean</code> 指示该资源是否真正以物理形式存在。</li>
<li><code>isOpen()</code>: 返回一个 <code>boolean</code> 标识该资源是否标识一个打开流的句柄。如果是 <code>true</code>，则不能多次读取 <code>InputStream</code>，并且必须仅读取一次，然后关闭避免资源泄露。除了 <code>InputStreamResource</code>，所有常规资源实现都会返回 <code>false</code>。</li>
<li><code>getDescription()</code>: 返回此资源的描述，用于使用资源时的错误输出。这通常是完全限定文件名或者资源的实际 URL。</li>
</ul>
<p>其他方法可以让你获得代表资源的实际 <code>URL</code> 或者 <code>File</code> 对象（如果基础实现兼容且支持该功能）。</p>
<h3 id="2-3-Built-in-Resource-Implementations"><a href="#2-3-Built-in-Resource-Implementations" class="headerlink" title="2.3. Built-in Resource Implementations"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations">2.3. Built-in Resource Implementations</a></h3><h4 id="2-3-1-UrlResource"><a href="#2-3-1-UrlResource" class="headerlink" title="2.3.1. UrlResource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations-urlresource">2.3.1. UrlResource</a></h4><p><code>UrlResource</code> 包装了 <code>java.net.URL</code>。可以用于访问通常用 <code>URL</code> 访问的任何对象，例如文件、HTTP 目标、FTP 目标等。所有 URL 都有标准化的字符串表现形式，因此使用适当的标准化前缀来指示一种 URL 类型。这包括 <code>file:</code> 用于访问文件系统路径, <code>http:</code> 用于访问通过 HTTP 协议的资源, <code>ftp:</code> 用于访问通过 FTP 的资源等。</p>
<p><code>UrlResource</code> 由 Java 代码通过显式地使用 <code>UrlResource</code> 构造器创建，但是当你调用持有一个 <code>String</code> 参数标识路径的 API 方法时，通常会隐式地创建。对于后一种情况，Java Bean <code>PropertyEditor</code> 最终决定要创建哪种类型的资源。</p>
<h4 id="2-3-2-ClassPathResource"><a href="#2-3-2-ClassPathResource" class="headerlink" title="2.3.2. ClassPathResource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations-classpathresource">2.3.2. ClassPathResource</a></h4><h4 id="2-3-3-FileSystemResource"><a href="#2-3-3-FileSystemResource" class="headerlink" title="2.3.3. FileSystemResource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations-filesystemresource">2.3.3. FileSystemResource</a></h4><p>这是用于 <code>java.io.File</code> 和 <code>java.nio.file.Path</code> 处理的 <code>Resource</code> 实现。它支持以 <code>File</code> 和 <code>URL</code> 方式解析。</p>
<h4 id="2-3-5-InputStreamResource"><a href="#2-3-5-InputStreamResource" class="headerlink" title="2.3.5. InputStreamResource"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-implementations-inputstreamresource">2.3.5. InputStreamResource</a></h4><h3 id="2-4-The-ResourceLoader"><a href="#2-4-The-ResourceLoader" class="headerlink" title="2.4. The ResourceLoader"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-resourceloader">2.4. The <code>ResourceLoader</code></a></h3><p><code>ResourceLoader</code> 接口意味着由那些可以返回 <code>Resource</code> 实例的对象实现。下面的清单展示了 <code>ResourceLoader</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    Resource <span class="title function_">getResource</span><span class="params">(String location)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有 Application Context 都实现了 <code>ResourceLoader</code> 接口。因此，所有 Application Context 可以被用于获取 <code>Resource</code> 实例。</p>
<p>当你在特定应用上下文调用 <code>getResource()</code>，并且指定的位置路径没有特定前缀时，你将会获得适合特定 Application Context 的 <code>Resource</code> 类型。例如，假设以下代码段是针对 <code>ClassPathXmlApplicationContext</code> 实例运行的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="variable">template</span> <span class="operator">=</span> ctx.getResource(<span class="string">&quot;some/resource/path/myTemplate.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于 <code>ClassPathXmlApplicationContext</code>，该代码返回 <code>ClassPathResource</code>。如果相同的方法运行在 <code>FileSystemXmlApplicationContext</code> 实例上，将会返回 <code>FileSystemResource</code>。对于 <code>WebApplicationContext</code>，将会返回 <code>ServletContextResource</code>。类似地，将会返回适合于每个上下文的对象。</p>
<p>结果，你可以以适合于特定 Application Context 的方式加载资源。</p>
<p>下表总结了讲 <code>String</code> 对象转换为 <code>Resource</code> 对象的策略。</p>
<table>
<thead>
<tr>
<th align="left">Prefix</th>
<th align="left">Example</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left">classpath:</td>
<td align="left"><code>classpath:com/myapp/config.xml</code></td>
<td align="left">从类路径加载</td>
</tr>
<tr>
<td align="left">file:</td>
<td align="left"><code>file:///data/config.xml</code></td>
<td align="left">从文件系统以 <code>URL</code> 加载</td>
</tr>
<tr>
<td align="left">http:</td>
<td align="left"><code>https://myserver/logo.png</code></td>
<td align="left">以 <code>URL</code> 加载</td>
</tr>
<tr>
<td align="left">(none)</td>
<td align="left"><code>/data/config.xml</code></td>
<td align="left">依赖于底层 <code>ApplicationContext</code></td>
</tr>
</tbody></table>
<h4 id="2-5-The-ResourceLoaderAware-interface"><a href="#2-5-The-ResourceLoaderAware-interface" class="headerlink" title="2.5. The ResourceLoaderAware interface"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-resourceloaderaware">2.5. The <code>ResourceLoaderAware</code> interface</a></h4><p><code>ResourceLoaderAware</code> 接口是一个特殊的回调接口，它标识了那些期望提供以 <code>ResourceLoader</code> 接口的组件。下面的清单展示了 <code>ResourceLoaderAware</code> 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoaderAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-7-Application-Contexts-and-Resource-Paths"><a href="#2-7-Application-Contexts-and-Resource-Paths" class="headerlink" title="2.7. Application Contexts and Resource Paths"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-app-ctx">2.7. Application Contexts and Resource Paths</a></h3><p>本节涵盖了如何使用资源创建应用上下文，包括与 XML 工作的快捷方式，如何使用通配符，以及其他细节。</p>
<h4 id="2-7-1-Constructing-Application-Contexts"><a href="#2-7-1-Constructing-Application-Contexts" class="headerlink" title="2.7.1. Constructing Application Contexts"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-app-ctx-construction">2.7.1. Constructing Application Contexts</a></h4><p><code>ApplicationContext</code> 的构造器通常将一个字符串或者字符串数组作为资源路径，例如构成上下文定义的 XML 文件。</p>
<p>当这样的路径没有前缀时，将会从该路径构建特定的 <code>Resource</code> 类型，并用于加载依赖及适配于特定 Application Context 的 Bean Definition。例如，考虑以下示例，该示例创建 <code>ClassPathXmlApplicationContext</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;conf/appContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>bean 定义将会从类路径加载，因为使用了 <code>ClassPathResource</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;conf/appContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果在路径上使用特殊的 classpath 前缀，或者标准的 URL 前缀，将会覆盖默认的 <code>Resource</code> 类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;classpath:conf/appContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Constructing-ClassPathXmlApplicationContext-Instances-—-Shortcuts"><a href="#Constructing-ClassPathXmlApplicationContext-Instances-—-Shortcuts" class="headerlink" title="Constructing ClassPathXmlApplicationContext Instances — Shortcuts"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#resources-app-ctx-classpathxml">Constructing ClassPathXmlApplicationContext Instances — Shortcuts</a></h5><p><code>ClassPathXmlApplicationContext</code> 暴露出许多构造器，以便于实例化应用上下文。基本思想是：你可以只提供一个字符串数组，该数组包含 XML 文件名（无前导路径信息），并提供一个 <code>Class</code>。然后，<code>ClassPathXmlApplicationContext</code> 就能从提供的 <code>Class</code> 中推断出路径信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String path, Class&lt;?&gt; clazz)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;path&#125;, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述描述也就是根据当前类进行相对路径查找。</p>
</blockquote>
<h2 id="3-Validation-Data-Binding-and-Type-Conversion"><a href="#3-Validation-Data-Binding-and-Type-Conversion" class="headerlink" title="3. Validation, Data Binding, and Type Conversion"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation">3. Validation, Data Binding, and Type Conversion</a></h2><p>Spring Boot 2.3 不再包含 validation，见 <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.3-Release-Notes#validation-starter-no-longer-included-in-web-starters">github</a></p>
<p>将校验视为业务逻辑有利也有弊，Spring 提供了一种用于校验（以及数据绑定）的设计，这并不会排除其中任何一个。具体而言，验证不应该与 Web 层绑定，并且应该容易本地化，且应该有可能插入任何可用的验证器。考虑到这些问题，Spring 提供了一个 <code>Validator</code> 约定，它在每个应用层都是即基础又高度可用。</p>
<p>数据绑定对于让用户的输入动态绑定到应用程序的域模型（或者是任何拟用于处理用户输入的对象）非常有用。Spring 提供了恰当的名为 <code>DataBinder</code> 来做到这一点。<code>Validator</code> 和 <code>DataBinder</code> 组成了 <code>validation</code> 包，该包主要用于但不局限于 web 层。</p>
<p><code>BeanWrapper</code> 是 Spring 框架中的一个基本概念，在许多地方都有使用。但是，你可能无需直接使用 <code>BeanWrapper</code>。但是，由于这是一个参考文档，所以我们认为需要进行一些解释。我们在本章解释 <code>BeanWrapper</code>，因为如果你要使用它，你很可能在尝试将数据绑定到对象上时这样做。</p>
<p>Spring 的 <code>DataBinder</code> 和低级 <code>BeanWrapper</code> 都使用 <code>PropertyEditorSupport</code> 实现类去解析和格式化属性值。<code>PropertyEditor</code> 和 <code>PropertyEditorSupport</code> 类型是 Java Bean 规范的一部分，也会在本章解释。</p>
<p>*** JavaBean 的校验<br>Java Bean 增加 @Valid 注解，或者 @Validated 注解。 @Validated 支持分组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> HttpBody <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> LoginVO loginVO)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>*** 普通参数校验<br>增加 @Valid 注解以及校验规则，同时 Controller 增加 @Validated 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> HttpBody <span class="title function_">sendVerificationCode</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@Email(message = &quot;邮箱格式错误&quot;)</span> <span class="meta">@PathVariable</span> String to)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-Validation-by-Using-Spring’s-Validator-Interface"><a href="#3-1-Validation-by-Using-Spring’s-Validator-Interface" class="headerlink" title="3.1. Validation by Using Spring’s Validator Interface"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validator">3.1. Validation by Using Spring’s Validator Interface</a></h3><p>Spring 提供了一个 <code>Validator</code> 接口，你可以用它来校验对象。<code>Validator</code> 接口通过使用 <code>Errors</code> 对象工作，以便在验证时，验证器可以将校验的失败报告给 <code>Errors</code> 对象。</p>
<p>考虑如下的一个小型数据对象示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the usual getters and setters...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来的示例通过实现 <code>org.springframework.validation.Validator</code> 接口的两个方法来为 <code>Person</code> 类提供验证行为：</p>
<ul>
<li><code>supports(Class)</code>: 该 <code>Validator</code> 可以验证 <code>Class</code> 的实例吗？</li>
<li><code>validate(Object, org.springframework.validation.Errors)</code>: 验证给定的对象，如果发生验证错误，使用给定的 <code>Errors</code> 对象进行注册。</li>
</ul>
<p>实现 <code>Validator</code> 非常简单，尤其当你了解 Spring Framework 提供的 <code>ValidationUtils</code> 帮助类。以下示例为 <code>Persion</code> 示例实现了 <code>Validator</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This Validator validates only Person instances</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.class.equals(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object obj, Errors e)</span> &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmpty(e, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;name.empty&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">        <span class="keyword">if</span> (p.getAge() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.rejectValue(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;negativevalue&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getAge() &gt; <span class="number">110</span>) &#123;</span><br><span class="line">            e.rejectValue(<span class="string">&quot;age&quot;</span>, <span class="string">&quot;too.darn.old&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ValidationUtils</code> 类上的静态方法 <code>rejectIfEmpty(..)</code> 用于当 <code>name</code> 属性为 <code>null</code> 或者空字符串时进行拒绝。</p>
<p>虽然可以实现单个 <code>Validator</code> 类来验证复合对象中的每个嵌套对象，但最好将每个嵌套对象类的验证逻辑封装在其自己的 <code>Validator</code> 实现中。一个复合对象的简单例子是 <code>Customer</code>，其由两个 <code>String</code> 属性（first 和 second name）以及一个复杂对象 <code>Address</code> 组成。<code>Address</code> 对象可以独立于 <code>Customer</code> 对象使用，因此实现了一个独立的 <code>AddressValidator</code>。如果你希望你的 <code>CustomerValidator</code> 重用 <code>AddressValidator</code> 类中包含的逻辑，无需求助于复制粘贴，你可以在 <code>CustomerValidator</code> 中依赖注入或者实例化一个 <code>AddressValidator</code>，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerValidator</span> <span class="keyword">implements</span> <span class="title class_">Validator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Validator addressValidator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerValidator</span><span class="params">(Validator addressValidator)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (addressValidator == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The supplied [Validator] is &quot;</span> +</span><br><span class="line">                <span class="string">&quot;required and must not be null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!addressValidator.supports(Address.class)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The supplied [Validator] must &quot;</span> +</span><br><span class="line">                <span class="string">&quot;support the validation of [Address] instances.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.addressValidator = addressValidator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This Validator validates Customer instances, and any subclasses of Customer too</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Customer.class.isAssignableFrom(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">validate</span><span class="params">(Object target, Errors errors)</span> &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;firstName&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, <span class="string">&quot;surname&quot;</span>, <span class="string">&quot;field.required&quot;</span>);</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> (Customer) target;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            errors.pushNestedPath(<span class="string">&quot;address&quot;</span>);</span><br><span class="line">            ValidationUtils.invokeValidator(<span class="built_in">this</span>.addressValidator, customer.getAddress(), errors);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            errors.popNestedPath();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-Resolving-Codes-to-Error-Messages"><a href="#3-2-Resolving-Codes-to-Error-Messages" class="headerlink" title="3.2. Resolving Codes to Error Messages"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-conversion">3.2. Resolving Codes to Error Messages</a></h3><p>我们讨论了数据绑定和验证。本节涵盖了于验证错误相关的输出消息。在上一章节的示例中，我们拒绝 <code>name</code> 和 <code>age</code> 字段。如果我们想使用 <code>MessageSource</code> 输出错误消息，则我们可以使用拒绝字段时提供的错误码来完成。当你调用 <code>rejectValue</code> 或者来自 <code>Errors</code> 接口的其他  <code>reject</code> 方法之一时，底层实现不仅仅会注册你传递的错误码，而且会注册许多额外的错误码。<code>MessageCodesResolver</code> 决定了 <code>Errors</code> 接口注册哪些错误码。默认地，使用 <code>DefaultMessageCodesResolver</code>，它不仅仅注册你赋予的错误码的消息，而且还会注册包含你传递给拒绝方法的字段名的消息。因此，如果你通过使用 <code>rejectValue(&quot;age&quot;, &quot;too.darn.old&quot;)</code></p>
<h3 id="3-3-Bean-Manipulation-and-the-BeanWrapper"><a href="#3-3-Bean-Manipulation-and-the-BeanWrapper" class="headerlink" title="3.3. Bean Manipulation and the BeanWrapper"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beans">3.3. Bean Manipulation and the BeanWrapper</a></h3><p><code>org.springframework.beans</code> 包遵循 Java Bean 标准。一个 Java Bean 是一个具有默认无参构造器，并且遵循命名约定的类，其中（举个例子）一个属性名为 <code>bingoMadness</code> 有一个 Setter 方法 <code>setBingoMadness(..)</code> 以及一个 Getter 方法 <code>getBingoMadness()</code>。有关 Java Bean 和规范的更多信息，参见 <a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">javabeans</a></p>
<p>在 bean 包中非常重要的类是 <code>BeanWrapper</code> 接口及其相应的实现（<code>BeanWrapperImpl</code>）。正如 Javadoc 引用的那样，<code>BeanWrapper</code> 提供了 set 和 get 属性值（单个或者批量）的功能，获取属性描述符和查询属性，以确定它们是可读还是可写的。此外，<code>BeanWrapper</code> 提供了对嵌套属性的支持，使子属性的属性设置为无限的深度。<code>BeanWrapper</code> 还提供了添加标准 Java Bean <code>PropertyChangeListeners</code> 以及 <code>VetoableChangeListeners</code> 的能力，无需在目标类中的代码支持。最后的但同样重要的是，<code>BeanWrapper</code> 提供了设置索引属性的支持。<code>BeanWrapper</code> 通常不直接使用应用程序代码，而是由 <code>DataBinder</code> 以及 <code>BeanFactory</code> 使用。</p>
<p><code>BeanWrapper</code> 的工作方式见名知意：它包装 Bean 在该 Bean 上执行操作，例如设置和检索属性。</p>
<h4 id="3-3-1-Setting-and-Getting-Basic-and-Nested-Properties"><a href="#3-3-1-Setting-and-Getting-Basic-and-Nested-Properties" class="headerlink" title="3.3.1. Setting and Getting Basic and Nested Properties"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#beans-beans-conventions">3.3.1. Setting and Getting Basic and Nested Properties</a></h4><p>Set 和 Get 属性是通过 <code>BeanWrapper</code> 的重载方法变体 <code>setPropertyValue</code> 和 <code>getPropertyValue</code> 完成的。详细信息参见它们的 Javadoc。下表展示了这些约定的一些例子：</p>
<table>
<thead>
<tr>
<th align="left">Expression</th>
<th align="left">Explanation</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>name</code></td>
<td align="left">表示关联着 <code>getName()</code> 或者 <code>isName()</code> 以及 <code>setName(..)</code> 方法的属性 <code>name</code></td>
</tr>
<tr>
<td align="left"><code>account.name</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>account[2]</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>account[COMPANYNAME]</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>以下两个示例类使用 <code>BeanWrapper</code> 去 Get 和 Set 属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Employee managingDirector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">getManagingDirector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.managingDirector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setManagingDirector</span><span class="params">(Employee managingDirector)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.managingDirector = managingDirector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">float</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码片段展示了一些，关于如何检索和操纵实例化的 <code>Companies</code> 和 <code>Employees</code> 某些属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanWrapper</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(<span class="keyword">new</span> <span class="title class_">Company</span>());</span><br><span class="line"><span class="comment">// setting the company name..</span></span><br><span class="line">company.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Some Company Inc.&quot;</span>);</span><br><span class="line"><span class="comment">// ... can also be done like this:</span></span><br><span class="line"><span class="type">PropertyValue</span> <span class="variable">value</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Some Company Inc.&quot;</span>);</span><br><span class="line">company.setPropertyValue(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok, let&#x27;s create the director and tie it to the company:</span></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">jim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(<span class="keyword">new</span> <span class="title class_">Employee</span>());</span><br><span class="line">jim.setPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jim Stravinsky&quot;</span>);</span><br><span class="line">company.setPropertyValue(<span class="string">&quot;managingDirector&quot;</span>, jim.getWrappedInstance());</span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieving the salary of the managingDirector through the company</span></span><br><span class="line"><span class="type">Float</span> <span class="variable">salary</span> <span class="operator">=</span> (Float) company.getPropertyValue(<span class="string">&quot;managingDirector.salary&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-Spring-Type-Conversion"><a href="#3-4-Spring-Type-Conversion" class="headerlink" title="3.4. Spring Type Conversion"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#core-convert">3.4. Spring Type Conversion</a></h3><h3 id="3-7-Java-Bean-Validation"><a href="#3-7-Java-Bean-Validation" class="headerlink" title="3.7. Java Bean Validation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation">3.7. Java Bean Validation</a></h3><p>Spring Framework 为 Java Bean Validation API 提供了支持。</p>
<h4 id="3-7-1-Overview-of-Bean-Validation"><a href="#3-7-1-Overview-of-Bean-Validation" class="headerlink" title="3.7.1. Overview of Bean Validation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-overview">3.7.1. Overview of Bean Validation</a></h4><p>Bean Validation 通过约束声明和 Java 应用的元数据提供了一种通用的验证方式。要使用它，你可以用声明式验证约束注解域模型，之后这些约束在运行时会被强制执行。有内置的约束，你也可以定义你自己的自定义约束。</p>
<p>考虑以下示例，该实例展示了一个具有两个属性的简单 <code>PersonForm</code> 模型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonForm</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean Validation 让你可以声明约束，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonForm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size(max=64)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min(0)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，Bean Validation validator 基于声明的约束验证该类实例。</p>
<h4 id="3-7-2-Configuring-a-Bean-Validation-Provider"><a href="#3-7-2-Configuring-a-Bean-Validation-Provider" class="headerlink" title="3.7.2. Configuring a Bean Validation Provider"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring">3.7.2. Configuring a Bean Validation Provider</a></h4><p>Spring 为 Bean Validation API 提供了完全的支持，包括 Bean Validation provider 作为一个 Spring bean 的引导。这让你可以在你的应用任何需要验证的地方注入 <code>javax.validation.ValidatorFactory</code> 或者 <code>javax.validation.Validator</code>。</p>
<p>你可以使用 <code>LocalValidatorFactoryBean</code> 配置一个默认 Validator 作为 Spring Bean，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LocalValidatorFactoryBean <span class="title function_">validator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalValidatorFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Injecting-a-Validator"><a href="#Injecting-a-Validator" class="headerlink" title="Injecting a Validator"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring-inject">Injecting a Validator</a></h5><p><code>LocalValidatorFactoryBean</code> 实现了 <code>javax.validation.ValidatorFactory</code> 和 <code>javax.validation.Validator</code> 以及 Spring 的 <code>org.springframework.validation.Validator</code>。你可以注入这些接口中的任何一个到你需要调用校验逻辑的 Bean 中。</p>
<p>如果你更喜欢直接使用 Bean Validation API，你可以注入 <code>javax.validation.Validator</code> 的引用，如下示例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.Validator;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Configuring-Custom-Constraints"><a href="#Configuring-Custom-Constraints" class="headerlink" title="Configuring Custom Constraints"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring-constraints">Configuring Custom Constraints</a></h5><p>每个 Bean 验证约束由两部分组成：</p>
<ul>
<li><code>@Constraint</code> 注解，声明了约束及其可配置的属性</li>
<li><code>javax.validation.ConstraintValidator</code> 接口的实现类，实现了约束的行为</li>
</ul>
<h5 id="Spring-driven-Method-Validation"><a href="#Spring-driven-Method-Validation" class="headerlink" title="Spring-driven Method Validation"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring-method">Spring-driven Method Validation</a></h5><h5 id="Additional-Configuration-Options"><a href="#Additional-Configuration-Options" class="headerlink" title="Additional Configuration Options"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-beanvalidation-spring-other">Additional Configuration Options</a></h5><h4 id="3-7-3-Configuring-a-DataBinder"><a href="#3-7-3-Configuring-a-DataBinder" class="headerlink" title="3.7.3. Configuring a DataBinder"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#validation-binder">3.7.3. Configuring a <code>DataBinder</code></a></h4><h2 id="4-Spring-Expression-Language-SpEL"><a href="#4-Spring-Expression-Language-SpEL" class="headerlink" title="4. Spring Expression Language (SpEL)"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#expressions">4. Spring Expression Language (SpEL)</a></h2><h2 id="5-Aspect-Oriented-Programming-with-Spring"><a href="#5-Aspect-Oriented-Programming-with-Spring" class="headerlink" title="5. Aspect Oriented Programming with Spring"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop">5. Aspect Oriented Programming with Spring</a></h2><p>面向切面编程（AOP）提供了另一种关于编程结构的思考方式，以对面向对象编程（OOP）进行补充。OOP 中模块化的关键单元是类，而 AOP 中，模块化的单位是切面。</p>
<p>Spring 的关键组件之一是 AOP 框架。Spring IoC 容器不依赖于 AOP（意味着你不必须使用 AOP），AOP 补充了 Spring IoC，提供了一个非常有用的中间件解决方案。</p>
<p>AOP 在 Spring Framework 中能做什么：</p>
<ul>
<li>提供声明式企业服务。最重要的此类服务是声明式事务管理</li>
<li>让用户实现自定义切面，用 AOP 补充他们的 OOP</li>
</ul>
<h3 id="5-1-AOP-Concepts"><a href="#5-1-AOP-Concepts" class="headerlink" title="5.1. AOP Concepts"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-introduction-defn">5.1. AOP Concepts</a></h3><ul>
<li><strong>Aspect</strong>：切面，一个横跨多个类的模块化。事务管理是企业 Java 应用程序中横切问题很好的例子。在 Spring AOP 中，切面是通过使用常规类或者基于 @Aspect 注解的常规类。</li>
<li><strong>Join point</strong>：连接点，执行程序期间的一个点，可以是一个方法的执行或者一个异常的处理。在 Spring AOP 中，连接点就是代表一个方法的执行。</li>
<li><strong>Advice</strong>：通知，一个切面在特定连接点采取的行动。不同类似的通知包括 around，before，after。许多 AOP 框架，包括 Spring，将 advice 模型为一个拦截器，并在连接点周围维护一系列拦截器。</li>
<li><strong>Pointcut</strong>：切入点，匹配连接点的谓词。advice 与 pointcut 表达式关联，并且在切点匹配的任何 join point 执行。由 pointcut 表达式匹配的 join point 的概念是 AOP 的重点。默认，Spring 使用 AspectJ pointcut 表达式语言。</li>
<li><strong>Introduction</strong>：声明额外的方法或字段。</li>
<li><strong>Target object</strong>：由一个或多个切面通知的对象。</li>
<li><strong>AOP proxy</strong>：由 AOP 框架创建的对象，以实现切面约定（通知方法执行等）。在 Spring 框架中，AOP 代理可以是 JDK 动态代理或者是 CGLIB 代理。</li>
<li><strong>Weaving</strong>：将切面与其他应用类型或对象链接，以创建一个通知对象。</li>
</ul>
<p>Spring AOP 包括下面通知类型：</p>
<ul>
<li>Before advice</li>
<li>After returning advice</li>
<li>After throwing advice</li>
<li>After (finally) advice</li>
<li>Around advice</li>
</ul>
<p>&amp;nbsp;</p>
<h3 id="5-3-AOP-Proxies"><a href="#5-3-AOP-Proxies" class="headerlink" title="5.3. AOP Proxies"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-introduction-proxies">5.3. AOP Proxies</a></h3><h3 id="5-4-AspectJ-support"><a href="#5-4-AspectJ-support" class="headerlink" title="5.4. @AspectJ support"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-ataspectj">5.4. @AspectJ support</a></h3><h4 id="5-4-1-Enabling-AspectJ-Support"><a href="#5-4-1-Enabling-AspectJ-Support" class="headerlink" title="5.4.1. Enabling @AspectJ Support"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-aspectj-support">5.4.1. Enabling @AspectJ Support</a></h4><h4 id="5-4-2-Declaring-an-Aspect"><a href="#5-4-2-Declaring-an-Aspect" class="headerlink" title="5.4.2. Declaring an Aspect"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-at-aspectj">5.4.2. Declaring an Aspect</a></h4><p>启用 <code>@AspectJ</code> 支持之后，应用上下文定义的任何 bean 与 @Aspect 注解的类是由 Spring 自动检测，并用于配置 Spring AOP。</p>
<p>与其他任何类相同，切面（使用 @Aspect 注解的类）可以拥有方法和字段。他们也可以包含切入点，通知，和介绍声明。</p>
<p>&amp;nbsp;</p>
<h4 id="5-4-3-Declaring-a-Pointcut"><a href="#5-4-3-Declaring-a-Pointcut" class="headerlink" title="5.4.3. Declaring a Pointcut"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-pointcuts">5.4.3. Declaring a Pointcut</a></h4><p>切入点可以确定感兴趣的连接点，从而让我们控制通知的运行时机。Spring AOP 仅仅支持方法 Spring bean 的方法执行连接点，因此你可以考虑 Spring bean 上的方法执行匹配的切入点。</p>
<p>切入点的声明有两个部分：</p>
<ul>
<li>签名，包括名称和任何参数</li>
<li>切点表达式，精确指定哪些方法的执行是我们所感兴趣的</li>
</ul>
<p>在 <code>@AspectJ</code> 注解风格的 AOP 中，切入点的签名由常规的方法定义提供，切入表达式由 <code>@Pointcut</code> 注解表示。</p>
<p>构成 <code>@Pointcut</code> 注解值的切入点表达式时常规的 AspectJ 5 切入点表达式。</p>
<p>&amp;nbsp;</p>
<h5 id="Supported-Pointcut-Designators"><a href="#Supported-Pointcut-Designators" class="headerlink" title="Supported Pointcut Designators"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-pointcuts-designators">Supported Pointcut Designators</a></h5><p>Spring AOP 支持以下 AspectJ 切入点指示符用于切入点表达式：</p>
<ul>
<li><code>execution</code>：用于匹配方法执行连接点。</li>
<li><code>within</code>：</li>
<li><code>this</code></li>
<li><code>target</code></li>
<li><code>args</code></li>
<li><code>@target</code></li>
<li><code>@args</code></li>
<li><code>@within</code></li>
<li><code>@annotation</code></li>
</ul>
<p>Spring AOP 还支持一个名为 bean 的 PCD。该 PCD 允许你将连接点的匹配限定为特定名称的 Spring bean 或者一组名称的 Spring bean（使用通配符）。</p>
<p>&amp;nbsp;</p>
<h5 id="Combining-Pointcut-Expressions"><a href="#Combining-Pointcut-Expressions" class="headerlink" title="Combining Pointcut Expressions"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-pointcuts-combining">Combining Pointcut Expressions</a></h5><p>你可以通过 <code>&amp;&amp;</code>, <code>||</code>, <code>!</code> 来组合切入点表达式。你也可以按名称引用切入点表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">anyPublicOperation</span><span class="params">()</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;within(com.xyz.myapp.trading..*)&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inTrading</span><span class="params">()</span> &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tradingOperation</span><span class="params">()</span> &#123;&#125; </span><br></pre></td></tr></table></figure>


<p>&amp;nbsp;</p>
<h4 id="5-4-4-Declaring-Advice"><a href="#5-4-4-Declaring-Advice" class="headerlink" title="5.4.4. Declaring Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice">5.4.4. Declaring Advice</a></h4><p>通知和切入点表达式有关，然后在切入点匹配的方法 before，after 或者 around 执行。</p>
<h5 id="Before-Advice"><a href="#Before-Advice" class="headerlink" title="Before Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice-before">Before Advice</a></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeforeExample</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&amp;nbsp;</p>
<h5 id="After-Returning-Advice"><a href="#After-Returning-Advice" class="headerlink" title="After Returning Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice-after-returning">After Returning Advice</a></h5><p>当匹配的方法执行正常返回时，After returning advice 将会执行。</p>
<p>有时候，你需要在通知体里面访问实际的返回值。你可以使用 <code>@AfterReturning</code> 绑定返回值，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterReturningExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        pointcut=&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;,</span></span><br><span class="line"><span class="meta">        returning=&quot;retVal&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">(Object retVal)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性 <code>returning</code> 中的名称必须与通知方法的参数名称相匹配。当方法执行返回时，返回值会传递给通知方法中相关的参数。<code>returning</code> 还限制只能匹配那些特定类型的返回值（本例中，<code>Object</code> 匹配任何返回值）</p>
<p>&amp;nbsp;</p>
<h5 id="After-Throwing-Advice"><a href="#After-Throwing-Advice" class="headerlink" title="After Throwing Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice-after-throwing">After Throwing Advice</a></h5><p>当匹配的方法以抛出异常的方式结束时，after throwing advice 会运行。</p>
<p>通常，你希望仅当给定类型的异常抛出时，运行某个通知，而且你也需要在通知体中访问该异常。你可以使用 <code>throwing</code> 属性进行限制匹配，并且绑定抛出的异常到通知参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterThrowingExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        pointcut=&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;,</span></span><br><span class="line"><span class="meta">        throwing=&quot;ex&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRecoveryActions</span><span class="params">(DataAccessException ex)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性 throwing 中的名称必须与通知方法的参数名称相匹配。当方法是因为抛出异常而结束时，异常会传递给通知方法中相关的参数。throwing 也可以限制仅仅匹配方法执行过程中特定的异常（比如这里的 DataAccessException）。</p>
<p>&amp;nbsp;</p>
<h5 id="After-Finally-Advice"><a href="#After-Finally-Advice" class="headerlink" title="After (Finally) Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-advice-after-finally">After (Finally) Advice</a></h5><p>当匹配的方法执行退出时，After(finally) advice 会运行。通过 @After 注解声明。必须准备号 After 通知以处理正常和异常的返回条件。通常，它用于释放资源等。</p>
<blockquote>
<p><strong>注意</strong> @AfterThrowing 并不表示通用的异常处理。@AfterThrowing 通知方法仅仅应该从连接点接收异常，而不是从伴随的 <code>@After</code> &#x2F; <code>@AfterReturning</code> 方法。</p>
</blockquote>
<p>&amp;nbsp;</p>
<h5 id="Around-Advice"><a href="#Around-Advice" class="headerlink" title="Around Advice"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-ataspectj-around-advice">Around Advice</a></h5><p>环绕通知围绕着被匹配方法的执行。在方法执行前后，它均有机会工作，并确定何时，如何，甚至是否方法实际上是否要运行。如果你需要以线程安全的方式（例如，启动和停止计时器）在方法执行前后共享状态，通常需要时候 Around 通知。</p>
<p><strong>官方建议</strong> 总是使用功能最小的通知形式来满足需求，即，如果需要前置通知，那么就不用使用环绕通知。</p>
<p>环绕通知使用 <code>@Around</code> 注解声明。通知方法的第一个参数必须是 <code>ProceedingJoinPoint</code>。在通知体里，调用 <code>ProceedingJoinPoint.proceed()</code> 方法会引起底层方法的运行。<code>proceed</code> 方法还可以传递一个 <code>Object[]</code>。数组中的值将作为执行方法时的参数。</p>
<blockquote>
<p>用 <code>Object[]</code> 调用 <code>proceed()</code> 的行为与被 AspectJ 编译器编译的环绕通知的 <code>proceed()</code> 行为有点不同。对于使用传统 AspectJ 语言编写的环绕通知，传递给 <code>proceed</code> 的参数数量必须与传递给环绕通知的参数数量匹配，并且，在给定参数位置传递给 <code>proceed</code> 的值会取代在连接点处绑定到实体上的原始值。Spring 采取的方法更简单，更好地匹配基于代理的，仅仅执行语义。如果你编译为 Spring 所写的 @AspectJ 切面，并且与 AspectJ 编译器和 Weaver 一起使用 <code>preceed</code> 携带的参数，你只需要意识到这种差异。</p>
</blockquote>
<p>环绕通知的返回值就是方法调用者可见的返回值，其他调用者并不会感知。例如，实现一个简单的缓存切面，如果存在缓存那么就从缓存中得到并返回值，如果不存在就调用 proceed()。</p>
<p><strong>注意</strong> 可以在 Around 通知体中调用一次，多次，或者不调用 <code>proceed()</code> 方法。这些都是合法的。</p>
<p>&amp;nbsp;</p>
<h5 id="Access-to-the-Current-JoinPoint"><a href="#Access-to-the-Current-JoinPoint" class="headerlink" title="Access to the Current JoinPoint"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.17.RELEASE/spring-framework-reference/core.html#aop-ataspectj-advice-params-the-joinpoint">Access to the Current JoinPoint</a></h5><p>任何的通知方法都可以声明 org.aspectj.lang.JoinPoint 类型参数，作为它的第一个参数。</p>
<p><strong>注意</strong> Around 通知需要声明第一个参数为 <code>ProceedingJoinPoint</code>，它时 <code>JoinPoint</code> 的子类。</p>
<p>JoinPoint 接口提供了许多有用的方法：</p>
<ul>
<li><code>getArgs():Object[]</code>：返回方法参数</li>
<li><code>getThis():Object</code>：返回代理对象</li>
<li><code>getTarget():Object</code>：返回目标对象</li>
<li><code>getSignature():Signature</code>：返回被通知方法的描述</li>
<li><code>toString():String</code>：打印被通知方法的有用描述</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring Framework</tag>
      </tags>
  </entry>
</search>
